{"filename":"nowcoder-month-85","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛85\ncategory: 算法\ndate: 2024-04-18\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本场比赛做下来大多都是思维题，就当是锻炼思维了\n\n### ACCEPT\n\n签到题，一开始想复杂了，想依次循环遍历来计算每个字母出现的次数，再取出最小的次数。在对于C的次数的取值上费了很长一段时间，后面灵光一线，几行代码搞定\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\nint check(unordered_map<char, int> ump){\n\treturn min(ump['A'], min(ump['C'] / 2, min(ump['E'], min(ump['P'], ump['T']))));\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tstring str;\n\t\tcin >> str;\n\t\tint res = INT_MAX, cot = 0;\n\t\tchar minc;\n\t\tunordered_map<char, int> ump; \n\t\tfor(int i = 0; i < b; i++){\n\t\t\tump[str[i]] ++;\n//\t\t\tif(ump[str[i]] == 1) cot ++;\n//\t\t\tif(ump[str[i]] == 2 && str[i] == 'C') cot ++;\n//\t\t\tif(ump[str[i]] > res){\n//\t\t\t\t\n//\t\t\t\tif(str[i] == 'C'){\n//\t\t\t\t\tif(str[i] == minc && ump[str[i]] % 2 == 0) res ++;\n//\t\t\t\t} else{\n//\t\t\t\t\tif(str[i] == minc) res ++; \n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t} else if(res > ump[str[i]]){\n//\t\t\t\tminc = str[i];\n//\t\t\t\tif(str[i] == 'C') res = 0;\n//\t\t\t\telse res = ump[str[i]];\t\n//\t\t\t}\n//\t\t\tif(str[i] == 'C'){\n//\t\t\t\tif(minc == 'C' && ump[str[i]] % 2 == 0) res ++;\n//\t\t\t\telse res = min(res, ump[str[i]] / 2);\n//\t\t\t} else {\n//\t\t\t\tres = min(ump[str[i]], res);\n//\t\t\t}\n//\t\t\tcout << res << \" \"<< ump[str[i]]<<\" \"<<minc << endl;\n\t\t}\n\t\tcout << check(ump) << endl;\n//\t\tif(cot < 6) cout << 0 << endl;\n//\t\telse cout << res << endl;\n\t}\n \n\treturn 0;\n}\t\n```\n\n### 咕呱蛙\n\n这题就是看思维了，从前几个满足条件的数中找出规律，只有 4i + 2 和 4i + 3的数满足条件，于是考虑这两个数出现位置\n\n对于 4i + 2，直接就是 2n，对于4i + 3，也是很快知道为 2n + 1\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n   \tll x;\n   \tcin >> x;\n\tif(x % 2 == 0) cout << 2 * x << endl;\n\telse cout << 2 * x  + 1 << endl; \n}\n```\n\n### 得分显示\n\n这题题意很简单，但是很难想到一点就是，因为是递增的，所以后面出现的数x对于前面出现n个数满足，每次增加都不能超过x/n。 \n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  \tcin >> a;\n  \tint num;\n  \tdouble res = 1e9 + 1;\n  \tfor(int i = 1; i <= a; i++){\n  \t\tcin >> num;\t\n  \t\tres = min(res, (num + 0.9999999999999) / i);\n\t}\n\tprintf(\"%.10lf\", res);\n}\n```\n\n### 阿里马马与四十大盗\n\n这题用了贪心的思想，对于某个0补充到最大值后，若后面的数之和都小于这个最大值，则后面的0就不用管了无需补充；于是这个某个0之前的0都需要补充到最大值\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\nint v[N];\nll m[N];\nll fun(int x){\n\treturn m[a] - m[x];\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tll res = 0, is = 0, cot = b, flag = 0;\n\tfor(int i = 1; i <= a; i ++){\n\t\tcin >> v[i]; \t\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tm[i] = m[i - 1] + v[i];\n\t}\n\tfor(int i = 1; i <= a - 1; i ++){ \n\t\tif(v[i] == 0){\n\t\t\tres += b - cot;\n\t\t\tcot = b; \t\n\t\t\tif(cot > fun(i)){\n\t\t\t\tcout << res + a - 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcot -= v[i];\n\t\t\tif(cot <= 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tcout << res + a - 1 << endl;\n\t\n    return 0;\n}\n```\n\n","title":" 牛客小白月赛85\n","category":[" 算法\n"],"date":" 2024-04-18\n","author":" Jixer\n","source":" 原创\n\n"}}