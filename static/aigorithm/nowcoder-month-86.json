{"filename":"nowcoder-month-86","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛86\ncategory: 算法\ndate: 2024-04-23\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\nABC题能够轻松通过，后面的题就卡了\n\n### 水盐平衡\n\n简单模拟题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num;\n\tcin >> num;\n\twhile(num --){\n\t\tcin >> a >> b >> x >> y;\n\t\tdouble _1 = a * 1.0 / b, _2 = x * 1.0 / y;\n\t\tif(_1 > _2) cout << \"S\" << endl;\n\t\telse cout << \"Y\" << endl; \n\t} \n\t\t\n\treturn 0;\n}\n```\n\n### 水平考试\n\n这题有个巧妙的地方在于多选题不会出现得分为5的情况，因为不可能出现部分正确，只要有部分正确小灰灰就会把他修改为全部正确\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num;\n\tcin >> num;\n\twhile(num --){\n\t\tstring s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tint len1 = s1.size(), len2 = s2.size();\n\t\tif(len1 > len2){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(len2 == 1){\n\t\t\tif(s1[0] == s2[0]) cout << \"10\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tunordered_map<char, int> ump;\n\t\tfor(int i = 0; i < len2; i++){\n\t\t\tump[s2[i]] ++;\n\t\t}\n\t\tint flag = 0, flag2 = 1;\n\t\tfor(int i = 0; i < len1; i++){\n\t\t\tif(!ump[s1[i]]){\n\t\t\t\tflag2 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag2){\n\t\t\tcout << 10 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n//\t\tflag = 0, flag2 = 1;\n//\t\tfor(int i = 0; i < len1; i++){\n//\t\t\tif(ump[s1[i]]){\n//\t\t\t\tflag = 1;\t\n//\t\t\t} else {\n//\t\t\t\tflag2 = 0;\n//\t\t\t}\n//\t\t}\n//\t\tif(flag && !flag2){\n//\t\t\tcout << 0 << endl;\n//\t\t} else if(flag && flag2){\n//\t\t\tcout << 5 << endl;\n//\t\t} else cout << 0 << endl;\n\t} \n\t\n\t\t\n\treturn 0;\n}\n```\n\n### 数组段数 \n\n模拟题，需要注意的点是若是出现当前下标的和和上一位数的和一致的时候，就说明这段是相同，需要向前找到不一致的和\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<int> v(a + 1), m(a + 1);\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tif(i == 1){\n\t\t\tm[i] = 1;\n\t\t} else {\n\t\t\tif(v[i] == v[i - 1]){\n\t\t\t\tm[i] = m[i - 1];\t\n\t\t\t} else {\n\t\t\t\tm[i] = m[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i = 1; i <= a; i++) cout << m[i] << \" \";\n//\tcout << endl;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\twhile(v[x] == v[x - 1]){\n\t\t\tx --;\n\t\t}\n//\t\tcout << x << \" \" << y << \" \" << m[x] << \" \" << m[y] << endl;\n\t\tcout << m[y] - m[x - 1] << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 剪纸游戏\n\n这题我的思路是默认当前点位最小x和最小y的值，然后BFS遍历，找出最大x和最大y，然后计算这块区间的所有坐标是否都标记过了。但是后面看题解发现这样是不对的。若是出现 `_|` 这种的图形就会统计出错，我的思路会将其算成一个长方形，但显然不是。\n\n正解：BFS同时算出最小x，最小y，最大x，最大y，并统计标记过了的数量，通过计算这块区间数量是否等于BFS遍历标记的数量，若相同就说明是长方形，否则就不是。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nchar v[1010][1010];\nint st[1010][1010];\nint mmx, mmy, iix, iiy;\n\nint dfs(int x, int y){\n\tmmx = max(mmx, x);\n\tmmy = max(mmy, y);\n\tiix = min(iix, x);\n\tiiy = min(iiy, y);\n\tint cot = 0;\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = x + ix[i], yy = y + iy[i];\n\t\tif(xx >= 1 && xx <= a && yy >= 1 && yy <= b && !st[xx][yy] && v[xx][yy] == '.'){\n\t\t\tst[xx][yy] = 1;\n\t\t\tcot += dfs(xx, yy) + 1;\n\t\t}\n\t}\n\treturn cot;\n}\n\nint check(int x, int y, int ex, int ey){\n\tfor(int i = x; i <= ex; i++){\n\t\tfor(int j = y; j <= ey; j++){\n\t\t\tif(!st[i][j]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\t for(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tif(v[i][j] == '.' && !st[i][j]){\n\t\t\t\tmmx = 0, mmy = 0, iix = i, iiy = j;\n\t\t\t\tst[i][j] = 1;\n\t\t\t\tint cot = dfs(i, j) + 1;\n\t\t\t\tif(cot == (mmx - iix + 1) * (mmy - iiy + 1)){\n\t\t\t\t\tres ++; \n\t\t\t\t}\n//\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << \" \" << iix << \" \" << iiy << \" \" << cot << endl;\n//\t\t\t\tif(check(i, j, mmx, mmy)){\n//\t\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << endl;\n//\t\t\t\t\tres ++;\n//\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n```\n\n### 可口蛋糕\n\n前缀和+双指针+小贪心题\n\n用l，r代表两个双指针，先找出r（第一个出现大于W的下标），不断维护 v[r] - v[l] 大于等于W的区间，找出最小可口值的前缀和（贪心），用前缀和算出区间的饱腹值，得出最大的一个。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<ll> v(a + 1), m(a + 1);\n\tv[0] = 0, m[0] = 0;\n\tfor(int i = 1; i <= a; i++) cin >> v[i], v[i] += v[i - 1];\n\tfor(int i = 1; i <= a; i++) cin >> m[i], m[i] += m[i - 1];\n\tll l = 0, r = 0, minn = 1e18, res = -1e18;\n\tfor(int i = 1; i <= a; i++){\n\t\tif(v[i] >= b){\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(r <= a){\n//\t\tcout << v[r] << \" \" << v[l] << endl;\n\t\twhile(v[r] - v[l] >= b){\n\t\t\tminn = min(minn, m[l]); \n\t\t\tl ++;\n\t\t}\n//\t\tcout << minn << \" \" << m[r] << \" \" << m[r] - minn << endl;\n\t\tres = max(res, m[r] - minn);\n\t\tr ++;\n\t}\n\t\n\tcout << res << endl;\n\t\n\t\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛86\n","category":[" 算法\n"],"date":" 2024-04-23\n","author":" Jixer\n","source":" 原创\n\n"}}