{"filename":"nowcoder-month-91","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛91\ncategory: 算法\ndate: 2024-04-29\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### Bingbong的化学世界\n\n找出几个图形不同的点，根据不同的点来输出就很简单了\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tchar n[7][7];\n\tfor(int i = 0; i < 6; i++){\n\t\tfor(int j = 0; j < 7; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\t\n\tif(n[0][3] == '.') cout << \"o\" << endl;\n\telse if(n[5][3] == '.') cout << \"m\" << endl;\n\telse cout << \"p\" << endl;\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的数数世界\n\n思维题，需要我们找出最终的胜利者\n\n只要这个数是奇数并且这个数除以2的结果也是偶数的话就是`Bing`，否则就是`Bong`\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tif(b / 2 % 2 == 1 || b % 2 == 1){\n\t\t\tcout << \"Bing\" << endl;\n\t\t} else {\n\t\t\tcout << \"Bong\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的蛋仔世界\n\n这题一看到需要向四个方位移动，我立马就想到了DFS，可是仔细读题后发现后并不需要。\n\n只需要判断某个点是否能在边界消失完到达中心点即可；该点到中心点的距离 = 横坐标之差 + 纵坐标之差\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b >> x;\n\tint midx = a / 2, midy = b / 2;\n\tint mcot = max(midx, midy);\n\twhile(x --){\n\t\tint n1, n2;\n\t\tcin >> n1 >> n2;\n\t\tn1 --, n2 --;\n\t\tint cot = fabs(n1 - midx) + fabs(n2 - midy);\n\t\tif(cot <= mcot) res ++;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的奇偶世界\n\n~~每次到差不多第三，四个题的位置总是会卡~~，这题我赛时的思路和题解的思路大差不差，估计某处细节没考虑不到导致一直卡。\n\n思路：比如当前点为`i`，那么这点之前的所有满足条件的个数有`pow(i - 1, 2) + 1 - 含有前导0的数` ，每次循环遍历的时候都需要判断是否是0、奇数、偶数。并且在每次循环的时候就需要维护`pow`和`前导0的数`这两个值，不能直接通过`pow`来计算因为会超时，我感觉我g应该就出在这里。\n\n我的代码\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot = 1, cc = 1;\n\tchar c;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> c;\n\t\tif((c - '0') % 2 == 0){\n\t\t\tn[i] = (n[i - 1] + cc + 1 - cot) % mod;\n\t\t\tif(c == '0'){\n\t\t\t\tcot = cot * 2 % mod;\n\t\t\t}\n\t\t} else {\n\t\t\tn[i] = n[i - 1];\n\t\t}\n\t\tcc = cc * 2 % mod;\n\t}\n\n\tcout << n[a] << endl; \n\treturn 0;\n}\n```\n\n正解\n\n思路是每次循环的时候就去掉了0的前导数的值，当不是0的时候就直接相加，不需要想我的思路那样单独来减，容易出错。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot = 0, cc = 0;\n\tchar c;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> c;\n\t\tif(c == '0'){\n\t\t\tcot = (cot + cc + 1) % mod;\n\t\t\tcc = cc * 2 % mod; \n\t\t} else if((c - '0') % 2 == 0){\n\t\t\tcot = (cot + cc + 1) % mod;;\n\t\t\tcc = (cc * 2 + 1) % mod; \n\t\t} else {\n\t\t\tcc = (cc * 2 + 1) % mod;\n\t\t}\n\n\t}\n\n\tcout << cot << endl; \n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛91\n","category":[" 算法\n"],"date":" 2024-04-29\n","author":" Jixer\n","source":" 原创\n\n"}}