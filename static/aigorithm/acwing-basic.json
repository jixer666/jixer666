{"filename":"acwing-basic","category":"aigorithm","md":{"topSummary":"\ntitle: Acwing基础课\ncategory: 算法\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 基础算法\n\n### 快速排序\n\n#### AcWing 785. 快速排序\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> v;\n    int a;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    for(int i = 0; i < a; i++){\n        cout << v[i] << \" \";\n    }\n\n  return 0;\n}\n```\n\n#### 第k个数\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    vector<int> v;\n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    cout << v[b-1];\n\n  return 0;\n}\n```\n\n### 归并排序\n\n#### AcWing 787. 归并排序\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> v;\n    int a;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    for(int i = 0; i < a; i++){\n        cout << v[i] << \" \";\n    }\n\n  return 0;\n}\n```\n\n### 二分\n\n可以直接用STL中的lower\\_bound和upper\\_bound\n\n- lower\\_bound(n, n+a, target)\n- upper\\_bound(n, n+a, target)\n\n**举例**（转载：[博客链接](https://blog.csdn.net/qq_40160605/article/details/80150252)）\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100000+10;\nconst int INF=2*int(1e9)+10;\n#define LL long long\nint cmd(int a,int b){\n\treturn a>b;\n}\nint main(){\n\tint num[6]={1,2,4,7,15,34}; \n\tsort(num,num+6);                           //按从小到大排序 \n\tint pos1=lower_bound(num,num+6,7)-num;    //返回数组中第一个大于或等于被查数的值 \n\tint pos2=upper_bound(num,num+6,7)-num;    //返回数组中第一个大于被查数的值\n\tcout<<pos1<<\" \"<<num[pos1]<<endl;\n\tcout<<pos2<<\" \"<<num[pos2]<<endl;\n\tsort(num,num+6,cmd);                      //按从大到小排序\n\tint pos3=lower_bound(num,num+6,7,greater<int>())-num;  //返回数组中第一个小于或等于被查数的值 \n\tint pos4=upper_bound(num,num+6,7,greater<int>())-num;  //返回数组中第一个小于被查数的值 \n\tcout<<pos3<<\" \"<<num[pos3]<<endl;\n\tcout<<pos4<<\" \"<<num[pos4]<<endl;\n\treturn 0;\t\n} \n```\n\n#### AcWing 789. 数的范围\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint n[100010];\nint a, b;\n\n// 左边距\nint get_l(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n        int mid = (l + r ) / 2;\n        if(n[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\n int get_r(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n    \tint mid = (l + r + 1) / 2;\n        if(n[mid] <= x) l = mid;\n        else r = mid - 1;\n    }\n    return r;\n }\n\nint main(){\n    \n    cin >> a >> b;\n    for(int i = 0; i < a; i++) cin >> n[i];\n    for(int i = 0; i < b; i++){\n        int m;\n        cin >> m;\n        int l = get_l(m);\n        if(n[l] != m) cout << -1 << \" \" << -1 << endl;\n\t\telse {\n\t\t\tint r = get_r(m);\n\t\t\tif(n[r] != m) cout << -1 << \" \" << -1 << endl;\n\t\t\telse cout << l << \" \" << r << endl; \n\t\t} \n    }\n\t\n    return 0;\n}\n```\n\n#### AcWing 790. 数的三次方根  \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\ndouble getS(double x){\n    return x * x * x;\n}\n\ndouble fun(double x){\n    double l = -10000, r = 10000;\n    while(l < r){\n        double mid = (l + r) / 2;\n        double res = getS(mid);\n        if(fabs(res - x) < 0.0000000001){\n        \treturn mid;\n\t\t}\n        if(res <= x) l = mid;\n        else r = mid;\n    }\n}\n\nint main(){\n    double a;\n    cin >> a;\n\tprintf(\"%.6lf\", fun(a));\n    \n    return 0;\n}\n```\n\n### 高精度\n\n#### AcWing 791. 高精度加法\n\n```\na = int(input())\nb = int(input())\nprint(a + b)\n```\n\n#### AcWing 792. 高精度减法\n\n```\na = int(input())\nb = int(input())\nprint(a - b)\n```\n\n#### AcWing 793. 高精度乘法\n\n```\na = int(input())\nb = int(input())\nprint(a * b)\n```\n\n#### AcWing 794. 高精度除法\n\n```\na = int(input())\nb = int(input())\nprint(a // b)\nprint(a % b)\n```\n\n### 前缀和与差分\n\n#### AcWing 795. 前缀和\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\n\nint main(){\n    \n    int a, b;\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++){\n       cin >> n[i];\n       m[i] = n[i] + m[i - 1];\n    }\n    \n    while(b--){\n        int x, y;\n        cin >> x >> y;\n        cout << m[y] - m[x - 1] << endl;\n    }\n    \n    return 0;\n}\n```\n\n#### AcWing 796. 子矩阵的和 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[1001][1001], m[1001][1001];\n\nint main(){\n    \n    int a, b, c;\n    cin >> a >> b >> c;\n    for(int i = 1; i <= a; i++){\n        for(int j = 1; j <= b; j++){\n            cin >> n[i][j];\n            m[i][j] = n[i][j] + m[i-1][j] + m[i][j-1] - m[i-1][j-1];\n        }\n    }\n    while(c--){\n        int q, w, e, r;\n        cin >> q >> w >> e >> r;\n        cout << m[e][r] + m[q-1][w-1] - m[q-1][r] - m[e][w-1] << endl;\n    }\n    \n\n    return 0;\n}\n```\n\n#### AcWing 797. 差分 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\n\nint main(){\n   int a, b;\n   cin >> a >> b;\n   for(int i = 1; i <= a; i++){\n       cin >> n[i];\n       m[i] = n[i] - n[i-1];\n   }\n   while(b--){\n       int x, y ,z;\n       cin >> x >> y >> z;\n       m[x] += z;\n       m[y+1] -= z;\n   }\n   for(int i = 1; i <= a; i++){\n       n[i] = m[i] + n[i-1];\n       cout << n[i] << \" \";\n   }\n   \n   return 0;\n}\n```\n\n#### AcWing 798. 差分矩阵\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[1010][1010], m[1010][1010];\n\nint main(){\n  \n   int a, b, c;\n   cin >> a >> b >> c;\n   for(int i = 1; i <= a; i++){\n       for(int j = 1; j <= b; j++){\n           cin >> n[i][j];\n           m[i][j] = n[i][j] - n[i-1][j] - n[i][j-1] + n[i-1][j-1];\n       }\n   }\n   while(c--){\n       int q, w, e, r, t;\n       cin >> q >> w >> e >> r >> t;\n       m[q][w] += t;\n       m[e+1][r+1] += t;\n       m[e+1][w] -= t;\n       m[q][r+1] -= t;\n   }\n  for(int i = 1; i <= a; i++){\n      for(int j = 1; j <= b; j++){\n          n[i][j] = n[i-1][j] + n[i][j-1] - n[i-1][j-1] + m[i][j];\n          cout << n[i][j] << \" \";\n      }\n      cout << endl;\n  }\n   \n   return 0;\n}\n```\n\n### 双指针算法\n\n#### AcWing 799. 最长连续不重复子序列 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N];\n\nint main(){\n    \n    int a, l, r, res = 0;\n    map<int, int> is;\n    cin >> a;\n    for(int i = 0, j = 0; i < a; i++){\n        cin >> n[i];\n        is[n[i]] ++;\n        while(is[n[i]] > 1){\n            is[n[j]] --;\n            j ++;\n        }\n        res = max(res, i - j + 1);\n    }\n    cout << res << endl;\n  \n    return 0;\n}\n```\n\n#### AcWing 800. 数组元素的目标和\n\n哈希方法\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\nunordered_map<int, int> ump;\n\nint main(){\n    \n    int a, b, c, r1 = 0, r2 = 0;\n    cin >> a >> b >> c;\n    for(int i = 0; i < a; i++) {\n        cin >> n[i];\n        ump[n[i]] = i;\n    }\n    for(int j = 0; j < b; j++) {\n        cin >> m[j];\n        if(ump.count(c - m[j])){\n            r1 = ump[c - m[j]], r2 = j;\n        }\n    }\n\n    cout << r1 << \" \" << r2 << endl;\n  \n    return 0;\n}\n```\n\n#### AcWing 2816. 判断子序列\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\nunordered_map<int, int> ump;\n\nint main(){\n    \n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++) cin >> n[i];\n    for(int j = 0; j < b; j++) cin >> m[j];\n   \n    int x = 0, y = 0;\n    while(x < a && y < b){\n        if(n[x] == m[y]) x ++;\n        y ++;\n    }\n    \n    if(x == a) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  \n    return 0;\n}\n```\n\n### 位运算\n\n#### AcWing 801. 二进制中1的个数\n\n> 小知识：n的二进制表示中第k位是几？  \n> 答案：n >> k & 1  \n> n右移k位&1后得出二进制数的最后一位\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// 返回x的最后一位1\n// 比如10010的最后一位就是10\nint lowbit(int x){\n    return x & -x;    \n}\n\nint main(){\n        \n    int a, b, res;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        cin >> b;\n        res = 0;\n        while(b){\n            b -= lowbit(b);\n            res ++;\n        }\n        cout << res << \" \";\n    }\n        \n    return 0;\n}\n```\n\n### 离散化\n\n#### AcWing 802. 区间和  \n\n> 小知识  \n> 离散化：将100，2000，30000，4000000映射为1，2，3，4的过程\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n// 此处不是1e5+10\n// 极端情况下第一排输入会有1e5的数据，第二排会有2e5的数据\nconst int N = 3e5 + 10 ;\n\nint s[N], f[N];\n\nvector<int> v;\nvector<pair<int, int> > q, w;\n// 二分查找元素下标\nint find(int x){\n    int l = 0, r = v.size() - 1;\n    while(l < r){\n        int mid = l + r >> 1;\n        if(v[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l + 1;\n}\n\nint main(){\n    \n    int a, b, m, n;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++){\n        cin >> m >> n;\n        q.push_back({m, n});\n        v.push_back(m);\n    }\n    for(int j = 0; j < b; j++){\n        cin >> m >> n;\n        w.push_back({m, n});\n        v.push_back(m);\n        v.push_back(n);\n    }\n    sort(v.begin(), v.end());\n    // 去重\n    v.erase(unique(v.begin(), v.end()), v.end());\n    // 离散化处理\n    for(auto i: q){\n        int x = find(i.first);\n        s[x] += i.second;\n    }\n    // 预处理前缀和\n    for(int i = 1; i <= v.size(); i++){\n        f[i] = f[i-1] + s[i];\n    }\n    // 查询结果\n    for(auto i: w){\n        int l = find(i.first), r = find(i.second);\n        cout << f[r] - f[l-1] << endl;\n    }\n    \n    return 0;\n}\n```\n\n![图片描述](http://www.lijunxi.site:4000/api/file/download/6261dfbb-afd5-42b9-bcdf-46091f5b8e0f.jpg)\n\n数据范围分析\n\n### 区间合并\n\n#### AcWing 803. 区间合并\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ; \n\nstruct point{\n    int x, y;\n} n[N];\n\nbool cmp(point a, point b){\n    if(a.x == b.x) return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main(){\n    \n    int a, idx = 0;\n    cin >> a;\n    for(int i = 0; i < a; i++) cin >> n[i].x >> n[i].y;\n    sort(n, n+a, cmp);\n    int langm = n[0].y;\n    for(int i = 1; i < a; i++){\n        langm = max(langm, n[i-1].y);\n        if(langm < n[i].x) idx++;\n    }\n    cout << idx + 1 << endl;\n  \n    return 0;\n}\n```\n\n## 数据结构\n\n### 单链表\n\n#### AcWing 826. 单链表\n\n数组模拟单链表\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\n// 头指针（用下表指针辅助），下标指针\nint hidx = -1, idx = 0;\n// 元素值，元素下表\nint n[N], ne[N];\n\nvoid insert(int k, int x){\n    // 新节点值赋值\n    n[idx] = x;\n    // 将新结点下一个结点赋值为插入位置的下一个结点\n    ne[idx] = ne[k];\n    // 将插入位置的一下个节点指向新节点\n    ne[k] = idx;\n    idx++;\n}\n\nvoid addHead(int x){\n    // 头节点赋值\n    n[idx] = x;\n    // 指向头指针\n    ne[idx] = hidx;\n    // 更改头指针为当前下表\n    hidx = idx;\n    idx++;\n}\n\nvoid del(int idx){\n    ne[idx] = ne[ne[idx]];   \n}\n\nint main(){\n    \n    int x, k, num; \n    char s;\n    cin >> x;\n    while(x--){\n        cin >> s;\n        if(s == 'H'){\n            cin >> num;\n            addHead(num);\n        }\n        else if(s == 'D'){\n            cin >> k;\n            //判断是否删除的为头节点\n            if(!k) hidx = ne[hidx];  \n            del(k-1);\n        }\n        else{\n            cin >> k >> num;\n            insert(k-1, num);\n        }\n    }\n    while(hidx != -1){\n        cout << n[hidx] << \" \";\n        hidx = ne[hidx];\n    }\n    \n    return 0;\n}\n```\n\n### 双链表\n\n### 栈\n\n#### AcAcWing 3302. 表达式求值\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nstack<int> s;\nstack<char> f;\nunordered_map<char, int> ump;\n\nvoid init_map(){\n\tump['*'] = 2;\n\tump['/'] = 2;\n\tump['+'] = 1;\n\tump['-'] = 1;\n}\n\nvoid eval(){\n\tint num = 0;\n\tint x = s.top(); s.pop();\n\tint y = s.top(); s.pop();\n\tchar op = f.top(); f.pop();\n\tif(op == '+') num = x + y;\n\telse if(op == '-') num = y - x;\n\telse if(op == '*') num = x * y;\n\telse num = y / x;\n\ts.push(num);\n}\n\nint main(){\n    init_map();\n    string str;\n    int num, idx = 0;\n    char c;\n    cin >> str;\n    int len = str.size();\n    for(int i = 0; i < len; i++){\n        if(str[i] >= '0' && str[i] <= '9'){\n            idx = i;\n            num = 0;\n            while(str[idx] >= '0' && str[idx] <= '9' && idx < len){\n                num = num * 10 + str[idx] - '0';\n                idx++; \n            }\n            s.push(num);\n            i = idx - 1;\n        }\n        else if(str[i] == '(') f.push(str[i]);\n        else if(str[i] == ')'){\n       \t\twhile(f.size() && s.size() >= 2 && ump[str[i]] <= ump[f.top()] && f.top() != '(') eval();\n       \t\tf.pop();\n        }\n        else{\n        \twhile(f.size() && s.size() >= 2 && ump[str[i]] <= ump[f.top()]) eval();\n            f.push(str[i]);\n        }\n    }\n    while(f.size()) eval();\n\tcout << s.top() << endl; \n    \n    return 0;\n}\n```\n\n### 队列\n\n#### AcWing 829. 模拟队列\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nqueue<int> q;\n\nint main(){\n    int a, num;\n    string s;\n    cin >> a;\n    while(a--){\n        cin >> s;\n        if(s == \"push\"){\n            cin >> num;\n            q.push(num);\n        }\n        else if(s == \"pop\"){\n            q.pop();\n        }\n        else if(s == \"empty\"){\n            if(q.empty()) cout <<\"YES\"<<endl;\n            else cout <<\"NO\" << endl;\n        }\n        else{\n            cout << q.front() << endl;\n        }\n    }\n   \n    return 0;\n}\n```\n\n### 单调栈\n\n#### AcWing 830. 单调栈\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nstack<int> s;\n\nint main(){\n    \n    int a, num;\n    cin >> a;\n    for(int i = 0; i < a; i++) {\n        cin >> num;\n        while(s.size() && s.top() >= num) s.pop();\n        if(!s.size()) cout << -1 << \" \";\n        else cout << s.top() << \" \";\n        s.push(num);\n    }\n    \n    return 0;\n}\n```\n\n### 单调队列\n\n#### AcWing 154. 滑动窗口\n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10 ;\n\n// deque没法直接获取下表的元素值，所以需要用一个数组来维护 \nint n[N];\ndeque<int> dq; \n\nint main(){\n  \n    int a, b, num;\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++) cin >> n[i];\n    for(int i = 1; i <= a; i++){\n    \t// 当尾元素比n[i]大时，需要弹出 \n    \twhile(dq.size() && n[dq.back()] > n[i]) dq.pop_back();\n    \tdq.push_back(i);\n    \t// 当队列的个数满足b时们需要弹出首元素\n\t\t// 这里不能用dq.size()来判断是否满足个数，因为可能出现首元素到i之间有些元素已经弹出了但size总数任然小于b情况 \n    \tif(dq.size() && i - dq.front() >= b) dq.pop_front();\n    \t// 当i大于b时候就能开始输出了，这里也不能用dq.size()来判断，因为存在整个过程都小于b的情况，这样就没有输出了 \n\t\tif(i >= b) cout << n[dq.front()] << \" \";\n\t}\n\tdq.clear();\n\tputs(\"\");\n      for(int i = 1; i <= a; i++){\n    \twhile(dq.size() && n[dq.back()] < n[i]) dq.pop_back();\n    \tdq.push_back(i);\n    \tif(dq.size() && i - dq.front() >= b) dq.pop_front();\n\t\tif(i >= b) cout << n[dq.front()] << \" \";\n\t}\n    \n    return 0;\n}\n```\n\n### KMP\n\n### Tire\n\n#### AcWing 835. Trie字符串统计\n\n> Trie树（字典树）：高效存储和查找字符串集合的数据结合\n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// son[][]存储子节点的位置，分支最多26条\n// cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）\n// idx表示当前要插入的节点是第几个,每创建一个节点值+1\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(string str){\n\t// 类似指针，指向当前节点\n\tint p = 0;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tint s = str[i] - 'a';\n\t\t// 该字符不存在就创建一个 \n\t\tif(!son[p][s]) son[p][s] = ++idx;\n\t\t// \tp指向下一个节点\n\t\tp = son[p][s];\n\t}\n\t// 统计字符串个数 \n\tcnt[p] ++;\n} \n\nint query(string str){\n\tint p = 0;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tint s = str[i] - 'a';\n\t\tif(!son[p][s]) return 0;\n\t\tp = son[p][s]; \n\t}\n\treturn cnt[p];\n}\n\n\nint main(){\n \n\tint a;\n\tchar c;\n\tstring str;\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> c;\n\t\tcin >> str;\n\t\tif(c == 'I') insert(str);\n\t\telse cout << query(str) << endl;\n\t}\n    \n    return 0;\n}\n```\n\n#### AcWing 143. 最大异或对  \n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n// 最多有1e5个数，每个数的二进制数有31位，极限情况下就1e5 * 31\nconst int N = 31e5 + 10 ;\n\nint son[N][2], n[N], idx = 0;\n\n// 将数字插入trie树中 \nvoid insert(int x){\n\tint p = 0;\n\t// 数的范围为小于2e31次方 \n\tfor(int i = 30; i >= 0; i --){\n\t\tint s = x >> i & 1;\n\t\tif(!son[p][s]) son[p][s] = ++idx;\n\t\tp = son[p][s];\n\t}\n}\n\nint query(int x){\n\tint p = 0, res = 0;\n\tfor(int i = 30; i >= 0; i--){\n\t\t// x二进制第i位上的数 \n\t\tint s = x >> i & 1;\n\t\t// 若存在相反的数 \n\t\tif(son[p][!s]){\n\t\t\tp = son[p][!s];\n\t\t\t// 1左移i位就是2^(30-i)次方 \n\t\t\tres += 1 << i;\n\t\t}\n\t\telse{\n\t\t\tp = son[p][s];\n\t\t\tres += 0 << i;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint a, res = 0;\n\tcin >> a;\n\tfor(int i = 0; i < a; i++) {\n\t\tcin >> n[i];\n\t\tinsert(n[i]);\n\t}\n\tfor(int i = 0; i < a; i++) res = max(res, query(n[i]));\n\tcout << res << endl;\n\t\n    return 0;\n}\n```\n\n### 并查集\n\n#### AcWing 836. 合并集合\n\n```\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\nint n[N];\n\n// 找到祖宗结点\nint find(int x){\n    // 修改结点，避免重复查找\n   if(n[x] != x) n[x] = find(n[x]);\n   return n[x];\n}\n\nint main(){\n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++) n[i] = i;\n    for(int i = 0; i < b; i++){\n        char x;\n        int o, p;\n        cin >> x >> o >> p;\n        if(x == 'M'){\n            n[find(o)] = find(p);\n        }\n        else{\n            if(find(o) == find(p)) cout << \"Yes\" << endl;\n            else cout << \"No\" << endl;\n        }\n    }\n     \n    return 0;\n}\n```\n\n### 堆\n\n> 堆：优先队列\n\n#### AcWing 838. 堆排序\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint n[N];\n// 从小到大排序，从大到小就为less<int>，与sort相反\npriority_queue<int, vector<int>, greater<int>> pq;\nint main(){\n    \n    int a, b, num;\n    cin>> a >> b;\n    for(int i = 0; i < a; i++){\n        cin >> num;\n        pq.push(num);\n    }\n    int idx = 0;\n    while(idx != b){\n        idx ++;\n        cout << pq.top() << \" \";\n        pq.pop();\n    }\n    \n    return 0;\n}\n```\n\n### 哈希表\n\n## 搜索与图论\n\n### DFS\n\n#### AcWing 842. 排列数字 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nint is[N];\nvector<int> v;\n\nvoid dfs(int x){\n    if(x == 0) return; \n    if(v.size() == a){\n    \tfor(int i = 0; i < a; i++) cout << v[i] << \" \";\n    \tcout << endl;\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tif(!is[i]){\n\t\t\tis[i] = 1;\n\t\t\tv.push_back(i);\n\t\t\tdfs(i);\n\t\t\tv.pop_back();\n\t\t\tis[i] = 0;\n\t\t}\n\t}\n}\n\nint main(){\n    cin >> a;\n    dfs(a);\n    return 0;\n}\n```\n\n#### AcWing 843. n-皇后问题\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nchar n[11][11];\nint l[11], xie[11], fx[11];\n\nvoid print(){\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= a; j++){\n\t\t\tcout << n[i][j];\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n} \n\nvoid dfs(int x){\n\tif(x == a + 1){\n\t\tprint();\n\t\treturn;\n\t}\n    for(int i = 1; i <= a; i++){\n    \t// \ti - x + a是为了避免出现下标是负数的情况 \n    \tif(!l[i] && !xie[i - x + a] && !fx[i + x]){\n    \t\tn[x][i] = 'Q';\n    \t\txie[i - x + a] = 1;\n    \t\tfx[i + x] = 1;\n    \t\tl[i] = 1;\n    \t\tdfs(x + 1);\n    \t\tn[x][i] = '.';\n    \t\txie[i - x + a] = 0;\n    \t\tfx[i + x] = 0;\n    \t\tl[i] = 0;\n\t\t}\n\t\n\t}\n\n}\n\nint main(){\n  \t\n\tcin >> a;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= a; j++){\n\t\t\tn[i][j] = '.';\n\t\t}\n\t}\n    dfs(1);\n    \n    return 0;\n}\n```\n\n### BFS\n\n#### AcWing 844. 走迷宫 \n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint a, b;\nint n[1010][1010], is[1001][1001];\nint ix[4] = {1, -1, 0 ,0}, iy[4] = {0, 0, 1, -1};\n\nvoid bfs(int x, int y){\n    queue<pair<int, int>> q;\n    map<pair<int, int>, int> mp;\n    q.push({0, 0});\n    mp[{0, 0}] = 0;\n    while(!q.empty()){\n    \tauto top = q.front();\n    \tq.pop();\n    \tint xx = top.first, yy = top.second;\n    \tif(xx == a - 1 && yy == b - 1){\n    \t\tcout << mp[{xx, yy}] << endl;\n    \t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint x = xx + ix[i], y = yy + iy[i];\n\t\t\tif(!n[x][y] && !is[x][y] && x >= 0 && x < a && y >= 0 && y < b){\n\t\t\t\tis[x][y] = 1;\n\t\t\t\tq.push({x, y});\n\t\t\t\tmp[{x, y}] = mp[{xx, yy}] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n  \t\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++){\n\t    for(int j = 0; j < b; j++){\n\t        cin >> n[i][j];\n\t    }\n\t}\n\tbfs(0, 0);\n    \n    return 0;\n}\n```\n\n### 树与图的深度优先遍历\n\n#### AcWing 846. 树的重心\n\n图的存储采用数组模拟邻接表\n\n思路：邻接表dfs\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint h[N];\n// 存储元素 \nint e[N];\n// 下个节点值\nint ne[N];\n// 结点是否访问过\nint st[N]; \n// 单链表指针 \nint idx = 0; \nint a, ans = N; \n\nvoid add(int x, int y){\n\te[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nint dfs(int x){\n\tint res = 0, sum = 1;\n\tst[x] = 1;\t\n\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\tint j = e[i];\n\t\tif(!st[j]){\n\t\t\tint s = dfs(j);\n\t\t\t// 子图最大结点数 \n\t\t\tres = max(res, s);\n\t\t\t// j为根的节点总数 \n\t\t\tsum += s;\t\t\n\t\t}\n\t}\n\t// a - sum：另一部分的节点总数 \n\tres = max(res, a - sum);\n\t// 选取最小的最大结点数 \n\tans = min(ans, res);\n\treturn sum;\n}\n\n\nint main(){\n  \t//初始化h数组 -1表示尾节\n\tmemset(h, -1, sizeof h); \n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n    cin >> a;\n    // 创建邻接表 \n    for(int i = 0; i < a - 1; i++){\n    \tint m, n;\n    \tcin >> m >> n;\n    \tadd(m, n);\n    \tadd(n, m);\n\t}\n    dfs(1);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n### 树与图的广度优先遍历\n\n#### AcWing 847. 图中点的层次\n\n思路：邻接表bfs\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint h[N];\n// 存储元素 \nint e[N];\n// 下个节点值\nint ne[N];\n// 结点是否访问过\nint st[N]; \n// 单链表指针 \nint idx = 0; \nint a, b, ans = N; \n\nvoid add(int x, int y){\n\te[idx] = y, ne[idx] = h[x], h[x] = idx, idx ++;\n}\n\nvoid dfs(int x){\n    queue<pair<int, int>> q;\n    map<pair<int, int>, int> ump;\n    q.push({1, 1});\n    ump[{1, 1}] = 0;\n    while(!q.empty()){\n        auto top = q.front();\n        q.pop();\n        int xx = top.first, yy = top.second;\n        if(yy == a){\n        \tcout << ump[{xx, yy}] << endl;\n        \treturn;\n\t\t}\n\t\tfor(int i = h[yy]; i != -1; i = ne[i]){\n\t\t\tif(ump.find({yy, e[i]}) == ump.end()){\n\t\t\t\tq.push({yy, e[i]});\n\t\t\t\tump[{yy, e[i]}] = ump[{xx, yy}] + 1;\n\t\t\t}\n\t\t}\n    }   \n\tcout << -1 << endl; \n \n}\n\nint main(){\n  \t//初始化h数组 -1表示尾节\n\tmemset(h, -1, sizeof h); \n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n    cin >> a >> b;\n    // 创建邻接表 \n    for(int i = 0; i < b; i++){\n    \tint m, n;\n    \tcin >> m >> n;\n    \tadd(m, n);\n\t}\n    dfs(1);\n\n    return 0;\n}\n```\n\n### 拓扑排序\n\n#### AcWing 848. 有向图的拓扑序列\n\n思路：邻接表找入度为0的结点\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint h[N], e[N], ne[N], idx, a, b;\nqueue<int> q;\n// 保存各个点的入度\nint d[N]; \n// v存放答案\nvector<int> v;\n\nvoid add(int x, int y){\n    e[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nbool topsort(){\n    // 找出入读为0的点\n    for(int i = 1; i <= a; i++){\n    \tif(!d[i]) q.push(i); \n\t}\t\n\twhile(q.size()){\n\t\tint top = q.front();\n\t\tq.pop();\n\t\tv.push_back(top);\n\t\t// 每次循环减去一条边\n\t\tfor(int i = h[top]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\td[j] --;\n\t\t\t// 当减去后的入读为0则入队列\n\t\t\tif(!d[j]) q.push(j);\n\t\t}\n\t}\n\treturn v.size() == a;\n}\n\nint main(){\n  \t\n  \tmemset(h, -1, sizeof h);\n  \tcin >> a >> b;\n  \twhile(b--){\n  \t    int x, y;\n  \t    cin >> x >> y;\n  \t    add(x, y);\n  \t    d[y] ++;\n  \t}\n  \tif(topsort()){\n  \t\tfor(int i = 0; i < v.size(); i++) cout << v[i] << \" \";\n\t}\n\telse puts(\"-1\");\n  \t\n    return 0;\n}\n```\n\n### Dijkstra\n\n稠密图：临界矩阵（点较少）  \n稀疏图：邻接表（点较多）\n\n#### AcWing 849. Dijkstra求最短路 I\n\n**朴素版（暴力）**\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint m, n;\n// 为稠密阵所以用邻接矩阵存储\nint num[501][501];\n// 用于记录每一个点距离第一个点的距离\nint dis[N];\n// 用于记录该点的最短距离是否已经确定\nint st[N];\n\nint dijkstra(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tdis[1] = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tint t = -1;\n\t\t// 找到没有确定最短路径的节点中距离源点最近的点t \n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tif(!st[j] && (t == -1 || dis[t] > dis[j])){\n\t\t\t\tt = j;\n\t\t\t}\n\t\t}\n\t\tst[t] = 1;\n\t\t// 更新到其他点的距离 \n\t\tfor(int k = 1; k <= m; k++){\n\t\t\tdis[k] = min(dis[k], dis[t] + num[t][k]);\n\t\t}\n\t}\n\tif(dis[m]==0x3f3f3f3f) return -1;\n    return dis[m];\n}\n\nint main(){\n\tmemset(num, 0x3f3f3f3f, sizeof num);\n\tcin >> m >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tnum[x][y] = min(num[x][y], z);\n\t}\n  \tcout << dijkstra() << endl;\n    return 0;\n}\n```\n\n#### AcWing 850. Dijkstra求最短路 II \n\n**临界表法**\n\n```\n#include<bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\ntypedef pair<int, int> PII;\n\nint e[N], ne[N], idx, h[N], dis[N], st[N];\nint w[N]; // 存放权重 \nint a, b;\n\nvoid add(int x, int y, int z){\n\tw[idx] = z, e[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nint dj(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tpriority_queue<PII, vector<PII>, greater<PII>> heap;\n\t// 插入距离和结点编号 \n\theap.push({0, 1});\n\twhile(!heap.empty()){\n\t\tauto top = heap.top();\n\t\theap.pop();\n\t\tint x = top.second, y = top.first;\n\t\tif(st[x]) continue;\n\t\tst[x] = 1;\n\t\t// 遍历该节点的每个临界结点，给每个选出最短距离 \n\t\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\tif(dis[j] > dis[x] + w[i]){\n\t\t\t\tdis[j] = dis[x] + w[i];\n\t\t\t\theap.push({dis[j], j});\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[a] == 0x3f3f3f3f) return -1;\n\treturn dis[a];\n}\n\nint main(){\n\tmemset(h, -1, sizeof h);\n\tcin >> a >> b;\n\twhile(b--){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t}\n\tcout << dj() << endl;\n\n    return 0;\n}\n```\n\n### Floyd\n\n与迪杰斯特拉的区别：\n\n- 迪杰斯特拉算法适用于非负权，用于查找1到n 的最短距离，数据范围大\n- 弗洛伊德算法适用于含有负权，用于查找每个点之间的最短距离，数据范围较少\n\n#### AcWing 854. Floyd求最短路\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int> PII;\n\nint n, m, k;\nint e[201][201];\n\nvoid floyd(){\n\t//  f[i, j, k]表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]。\n    // 因此在计算第k层的f[i, j]的时候必须先将第k - 1层的所有状态计算出来，所以需要把k放在最外层。 \n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\te[i][j] = min(e[i][j], e[i][k] + e[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> n >> m >> k; \n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i == j) e[i][j] = 0;\n\t\t\telse e[i][j] = INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\te[x][y] = min(e[x][y], z);\n\t}\n\tfloyd();\n\twhile(k--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t// 不能e[x][y] == INF，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可 \n\t\tif(e[x][y] > INF / 2) cout << \"impossible\"<<endl;\n\t\telse cout << e[x][y] <<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 数学知识\n\n### 质数\n\n#### AcWing 867. 分解质因数\n\n主要需要开方来避免超时\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main(){\n\t\n\tint n, m;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> m;\n\t\tint mm = m, flag = 0;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\tint idx = 0;\n\t\t\twhile(mm % i == 0){\n\t\t\t\tidx ++;\n\t\t\t\tmm /= i;\n\t\t\t}\n\t\t\tif(idx != 0){\n\t\t\t    flag = 1;\n\t\t\t    cout << i << \" \" << idx << endl;\n\t\t\t} \n\t\t}\n\t\tif(flag){\n\t        if(mm != 1) cout << mm << \" \" << 1 << endl;\n\t        cout << endl;\n\t\t}\n\t\telse {\n\t\t    cout << m << \" \" << 1 << endl;\n\t\t    cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n#### AcWing 868. 筛质数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nint n[N], st[N], idx;\n\nvoid init(){\n\tfor(int i = 2; i <= N; i++){\n\t\tif(!st[i]) n[idx++] = i;\n\t\tfor(int j = 0; n[j] <= N / i; j++){\n\t\t\tst[n[j] * i] = 1;\n\t\t\tif(i % n[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nint main(){\n\tinit();\n\tint a, res = 0;\n\tcin >> a;\n\tfor(int i = 2; i <= a; i++){\n\t\tif(!st[i]){\n\t\t\tres ++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 约数\n\n![图片描述](http://www.lijunxi.site:4000/api/file/download/bd17a18c-0c3c-475c-87f2-30830d333ee3.png)\n\n#### AcWing 870. 约数个数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\tset<int> s;\n\tmap<int, int> mp;\n\tll a, b, res = 1;\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> b;\n\t\tint xx = b;\n\t\tfor(int i = 2; i <= b / i; i++){\n\t\t\twhile(xx % i == 0){\n\t\t\t\txx /= i; \n\t\t\t\tmp[i] ++;\n\t\t\t}\n\t\t}\n                // x的最大公约数可能大于sqrt(x);\n\t\tif(xx > 1) mp[xx] ++;\n\t}\n\tfor(auto i: mp){\n\t\tres = (res * (i.second + 1)) % M; \n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n```\n\n#### AcWing 871. 约数之和\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\tmap<ll, ll> mp;\n\tint a;\n\tll res = 1;\n\tcin >> a;\n\twhile(a--){\n\t\tint m;\n\t\tcin >> m;\n\t\tint c = m;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\tll cot = 0;\n\t\t\twhile(c % i == 0){\n\t\t\t\tc /= i;\n\t\t\t\tmp[i] ++;\n\t\t\t}\n\t\t}\n\t\tif(c > 1) mp[c] ++;\t\n\t}\n\tfor(auto i: mp){\n\t\tll x = i.first, y = i.second, cot1 = 1, cot2 = 1;\n\t\twhile(y--){ \n\t\t\tcot2 = cot2 * x % M;\n\t\t\tcot1 = (cot1 + cot2) % M;\n\t\t}\n\t\tres = (res * cot1) % M;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n#### AcWing 872. 最大公约数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n// 最大公约数\nll fun1(int x, int y){\n\treturn y ? fun1(y, x % y) : x;\n}\n// 最小公倍数\nll fun2(int x, int y){\n\treturn x * fun1(x, y) / y;\n}\n\nint main(){\n\t\n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tcout << fun1(m, n) << endl;\n\t}\n\n\n\treturn 0;\n}\n```\n\n### 欧拉函数\n\n> 1∼N 中与 N 互质的数的个数被称为欧拉函数，称为O(n)  \n> 若N = p1^a\\*p2^b\\*p3^c\\*.....  \n> 则O(N) = N \\* (p1-1)/p1 \\* (p2-1)/p2 \\* (p3-1)/p3 \\*.....\n\n#### AcWing 873. 欧拉函数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\t\n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m;\n\t\tcin >> m;\n\t\tll res = m; \n\t\tmap<int, ll> mp;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\twhile(m % i == 0){\n\t\t\t\tm /= i;\n\t\t\t\tmp[i] ++;\n\t\t\t} \n\t\t}\n\t\tif(m > 1) mp[m] ++;\n\t\tfor(auto i: mp){\n\t\t\tint x = i.first;\n\t\t\tres = res * (x - 1) / x;\n\t\t} \n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n### 组合数\n\n#### AcWing 885. 求组合数 I\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10, M = 1e9 + 7;\n\nint e[2010][2010];\n\nvoid init(){\n    // 类似于DP\n    // e[i][j]就代表的是Cij\n\tfor(int i = 0; i < 2010; i++){\n\t\tfor(int j = 0; j <= i; j++){\n\t\t    // Ci0为1\n\t\t\tif(!j) e[i][j] = 1;\n\t\t\telse e[i][j] = (e[i-1][j-1] + e[i-1][j]) % M;\n\t\t}\n\t}\n} \n\nint main(){\n\t\n\tinit(); \n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tcout << e[m][n] << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n### 容斥原理\n\n#### AcWing 890. 能被整除的数\n\n若给出的待求的数组都是互质\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint v[20];\nint main(){\n\n    int a, b, res = 0;\n    cin >> a >> b;\n    for(int i = 0; i < b; i ++){\n        cin >> v[i];\n    }\n    for(int i = 1; i < 1 << b; i ++){\n        int cot = 0, t = 1;\n        for(int j = 0; j < b; j ++){\n            if(i >> j & 1){\n                cot ++;\n                if((ll) t * v[j] > a){\n                    t = -1;\n                    break;\n                }\n                t *= v[j];\n            }\n        }\n        if(t != -1){\n            if(cot % 2 == 0){\n                res -= a / t;\n            } else {\n                res += a / t;\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n```\n\n否则，修改乘积为求最小公倍数\n\n参考Leetcode：[单面值组合的第 K 小金额](https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/)\n\n```c++\nclass Solution {\npublic:\n    int len;\n    long long fun(long long x, vector<int>& v){\n        long long res = 0;\n        for(int i = 1; i < 1 << len; i++){\n            long long cot = 0, t = 1;\n            for(int j = 0; j < len; j++){\n                if(i >> j & 1){\n                    long long ccc = t / gcd(t, v[j]) * v[j]; //《-------------修改这里\n                    if(ccc > x){\n                        t = -1;\n                        break;\n                    }\n                    cot ++;\n                    t = ccc;\n                }\n            }\n            if(t != -1){\n                if(cot % 2 == 1) res += x / t;\n                else res -= x / t;\n            }\n        }\n        return res;\n    }\n    long long findKthSmallest(vector<int>& coins, int k) {\n        len = coins.size();\n        long long l = 1, r = 1e12;\n        while(l < r){\n            long long mid = (l + r) >> 1;\n            if(fun(mid, coins) >= k) r = mid;\n            else l = mid + 1;\n        }\n\n        return l;\n\n    }\n};\n```\n\n\n\n## 动态规划\n\n### 记忆化搜索\n\n#### AcWing 901. 滑雪\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint a, b;\nint n[310][310], cot[310][310];\nint ix[4] = {-1,0,1,0};\nint iy[4] = {0,1,0,-1};\n\nint dfs(int x, int y){\n\tif(cot[x][y] != -1) return cot[x][y];\n\tcot[x][y] = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = ix[i] + x, yy = iy[i] + y;\n\t\tif(xx >= 1 && xx <= a && yy >= 1 && yy <= b && n[x][y] > n[xx][yy]){\n\t\t\tcot[x][y] = max(cot[x][y], dfs(xx, yy) + 1);\n\t\t}\n\t}\n\treturn cot[x][y];\n}\n\n\nint main(){\n    memset(cot, -1, sizeof cot);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tans = max(ans, dfs(i, j));\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n```\n\n### 线性DP\n\n#### AcWing 898. 数字三角形\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 510, M = 1e5 + 10;\t\nint n[N][N]; \nint cot[N][N];\nint a;\n\nint dfs(int x, int y){\n\tif(x < 1 || x > a || y < 1 || y > a) return 0;\n\tif(cot[x][y] != -1) return cot[x][y];\n\tint _1 = dfs(x + 1, y), _2 = dfs(x + 1, y + 1);\n\tcot[x][y] = max(_1, _2) + n[x][y]; \n\treturn cot[x][y]; \n}\n\nint main(){\n\tmemset(cot, -1, sizeof cot);\n\tcin >> a;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= i; j++){\n\t\t\tcin >> n[i][j];\t\n\t\t}\n\t}\n\tcout << dfs(1, 1) << endl;\n\t\n\treturn 0;\n}\n```\n\n#### AcWing 896. 最长上升子序列\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\nint n[N];\nint a;\nvector<int> v; \n\nint main(){\n\n\tint a;\n\tcin >> a;\n\tfor(int i = 0; i < a; i++) cin >> n[i];\n\tfor(int i = 0; i < a; i++){\n\t\tif(v.empty() || n[i] > v.back()){\n\t\t\tv.push_back(n[i]);\n\t\t}\n\t\telse{\n\t\t\t*lower_bound(v.begin(), v.end(), n[i]) = n[i];\n\t\t}\n\t}\n\tcout << v.size() << endl;\n\t\n\treturn 0;\n}\n```\n\n#### AcWing 897. 最长公共子序列\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\n\nchar n1[N], n2[N];\n// n[i][j]记录前i个n1和前j个n2的公共子串的最大长度\nint n[1010][1010];\n \nint main(){\n\t\n\tint a, b;\n\tcin >> a >> b >> n1 + 1 >> n2 + 1;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tif(n1[i] == n2[j]){\n\t\t\t\tn[i][j] = n[i-1][j-1] + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tn[i][j] = max(n[i-1][j], n[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcout << n[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << n[a][b] << endl;\n\t\n\treturn 0;\n}\n```","title":" Acwing基础课\n","category":[" 算法\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"}}