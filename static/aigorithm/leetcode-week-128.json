{"filename":"leetcode-week-128","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第128场双周赛\ncategory: 算法\ndate: 2024-05-01\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n今日刷哔哩哔哩小羊肖恩大神10分钟都没到就AK了本场比赛，于是就想来试着做下\n\n### 字符串的分数\n\n求相邻字母的ASCALL码值之和\n\n```c++\nclass Solution {\npublic:\n    int scoreOfString(string s) {\n        int res = 0;\n        for(int i = 1; i < s.size(); i++){\n            res += fabs(s[i] - s[i - 1]);\n        }\n        return res;\n    }\n};\n```\n\n### 覆盖所有点的最少矩形数目\n\n一眼贪心，只用考虑横坐标\n\n```c++\\\nclass Solution {\npublic:\n    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        int cot = 0, res = 0;\n        vector<int> v;\n        for(int i = 0; i < points.size(); i++){\n            v.push_back(points[i][0]);\n        }\n        int len = v.size();\n        sort(v.begin(), v.end());\n        cot = -1e9 - 10;\n        for(int i = 0; i < len; i++){\n            if(v[i] - cot > w){\n                cot = v[i];\n                res ++;\n            }\n        }\n        return res;\n\n    }\n};\n```\n\n### 访问消失节点的最少时间\n\nDjakarta模板题，这里提供两种做法，一种参考灵神的，一种是yxc模板的。\n\n参考灵神做法\n\n```c++\nclass Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        vector<vector<pair<int, int>>> g(n);\n        for(int i = 0; i < edges.size(); i++){\n            g[edges[i][0]].push_back({edges[i][1], edges[i][2]});\n            g[edges[i][1]].push_back({edges[i][0], edges[i][2]});\n        }\n\n        vector<int> dis(n, 0x3f3f3f3f);\n        vector<bool> st(n ,false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dis[0] = 0;\n        pq.push({0, 0});\n        while(!pq.empty()){\n            auto [len, xx] = pq.top();\n            pq.pop();\n            if(st[xx]) continue;\n            st[xx] = 1;\n            for(auto [_ne, _w] : g[xx]){\n                if(dis[_ne] > len + _w  && len + _w < disappear[_ne]){\n                    dis[_ne] = len + _w;\n                    pq.push({dis[_ne], _ne});\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(dis[i] == 0x3f3f3f3f) dis[i] = -1;\n        }\n       \n        return dis;\n    }\n};\n```\n\nyxc模板做法\n\n```c++\nconst int N = 1e6 + 10;\nclass Solution {\npublic:\n    int n[N], ne[N], w[N], h[N], dis[N], st[N], idx;\n    void dj(vector<int>& disappear){\n        memset(dis, 0x3f3f3f3f, sizeof dis);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dis[0] = 0;\n        pq.push({0, 0});\n        while(pq.size()){\n            auto top = pq.top();\n            pq.pop();\n            int yy = top.first, xx = top.second;\n            if(st[xx]) continue;\n            st[xx] = 1;\n            for(int i = h[xx]; i != -1; i = ne[i]){\n                int j = n[i];\n                if(dis[j] > yy + w[i] && yy + w[i] < disappear[j]){\n                    dis[j] = yy + w[i];\n                    pq.push({dis[j], j});\n                }\n            }\n        }\n    }\n    void add(int x, int y, int z){\n        n[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++;\n    }\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        memset(h, -1, sizeof h);\n        for(int i = 0; i < edges.size(); i++){\n            add(edges[i][0], edges[i][1], edges[i][2]);\n            add(edges[i][1], edges[i][0], edges[i][2]);\n        }\n        dj(disappear);\n        vector<int> res;\n        for(int i = 0; i < n; i ++){\n            res.push_back((dis[i] ==  0x3f3f3f3f ? -1 : dis[i]));\n        }\n       \n        return res;\n    }\n};\n```\n\n### 边界元素是最大值的子数组数目\n\n这题只要想到单调栈就很好做啦\n\n```c++\nclass Solution {\npublic:\n    long long numberOfSubarrays(vector<int>& nums) {\n        long long res = 0;\n        int len = nums.size();\n        stack<int> s;\n        vector<int> v(len, 0);\n        for(int i = 0; i < len; i++){\n            v[i] ++;\n            while(!s.empty() && nums[s.top()] < nums[i]){\n                s.pop();\n            }\n            if(!s.empty() && nums[s.top()] == nums[i]){\n                v[i] = v[s.top()] + 1;\n            }\n            res += v[i];\n            s.push(i);\n        }\n        return res;\n    }\n};\n```\n\n","title":" Leetcode第128场双周赛\n","category":[" 算法\n"],"date":" 2024-05-01\n","author":" Jixer\n","source":" 原创\n\n"}}