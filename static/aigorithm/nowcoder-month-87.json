{"filename":"nowcoder-month-87","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛87\ncategory: 算法\ndate: 2024-04-25\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 小苯的石子游戏\n\n模拟两者选石头，判断最终结果\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b + 1);\n\t\tint l = 0, r = 0;\n\t\tfor(int i = 1; i <= b; i++) {\n\t\t\tcin >> v[i];\n\t\t} \n\t\tint idx = 1;\n\t\tfor(int i = b; i >= 1; i --){\n\t\t\tif(idx % 2 == 1) l += v[i];\n\t\t\telse r += v[i];\n\t\t\tidx ++;\n\t\t}\n\t\tcout << (l > r ? \"Alice\" : \"Bob\") << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的排序疑惑\n\n思维题，只需对数组的两边值进行考虑\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b);\n\t\tint minn = INT_MAX, maxx = 0; \n\t\tfor(int i = 0; i < b; i++) {\n\t\t\tcin >> v[i];\n\t\t\tif(i != 0){\n\t\t\t\tminn = min(minn, v[i]);\n\t\t\t}\n\t\t\tif(i != b - 1){\n\t\t\t\tmaxx = max(maxx, v[i]);\n\t\t\t}\n\t\t} \n\t\tcout << (v[0] <= minn || v[b - 1] >= maxx ? \"YES\" : \"NO\") << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的IDE括号问题（easy）\n\n使用两字符数组分别模拟 `I` 前后两个字符串的操作\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\nstring str, s;\nchar v[N], m[N]; \nint len1, len2, c1, c2;\n\nvoid fun1(){\n\tif(len1 >= 0 && len2 < c2){\n\t\tif(v[len1] == '(' && m[len2] == ')'){\n\t\t\tlen1 --;\n\t\t\tlen2 ++;\n\t\t} else {\n\t\t\tlen1 --;\n\t\t}\t\n\t} else {\n\t\tlen1 --;\n\t}\n\t\n}\n\nvoid fun2(){\n\tlen2 ++;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tcin >> str;\n\tint idx = 0, len = str.size();\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == 'I'){\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\tv[i] = str[i];\n\t\tc1 ++;\n\t}\n\tfor(int i = idx + 1; i < len; i++){\n\t\tm[i - idx - 1] = str[i];\n\t\tc2 ++;\n\t}\n\tlen1 = c1 - 1, len2 = 0;\n\twhile(b --){\n\t\tcin >> s;\n\t\tif(s[0] == 'b'){\n\t\t\tfun1();\n\t\t} else {\n\t\t\tfun2();\n\t\t}\n\t} \n\n\tfor(int i = 0; i <= len1; i++) cout << v[i];\n\tcout << \"I\";\n\tfor(int i = len2; i < c2; i++) cout << m[i]; \n\t\n\t\n\treturn 0;\n}\n```\n\n### 小苯的IDE括号问题（hard）\n\n这题与前一题的区别在于操作数增加了两个左移和右移，若再次使用数组的话不好模拟（需要遍历），于是采用两个双端队列进模拟（上一题也可以使用双端队列进行模拟）\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\nstring str, s;\ndeque<char> d1, d2;\n\nvoid fun1(){\n\tint len1 = d1.size(), len2 = d2.size();\n\tif(len1 && len2){\n\t\tif(d1.back() == '(' && d2.front() == ')'){\n\t\t\td1.pop_back();\n\t\t\td2.pop_front();\n\t\t} else {\n\t\t\td1.pop_back();\n\t\t}\n\t} else if(len1) {\n\t\td1.pop_back();\n\t}\n\t\n}\n\nvoid fun2(){\n\tif(d2.size()){\n\t\td2.pop_front();\n\t}\n}\n\nvoid fun3(){\n\tif(d1.size()){\n\t\tchar c = d1.back();\n\t\td1.pop_back(); \n\t\td2.push_front(c);\n\t}\n}\n\nvoid fun4(){\n\tif(d2.size()){\n\t\tchar c = d2.front();\n\t\td2.pop_front();\n\t\td1.push_back(c);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tcin >> str;\n\tint idx = 0, len = a;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == 'I'){\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\td1.push_back(str[i]); \n\t}\n\tfor(int i = idx + 1; i < len; i++){\n\t\td2.push_back(str[i]);\n\t}\n\t\n\twhile(b --){\n\t\tcin >> s;\n\t\tif(s[0] == 'b'){\n\t\t\tfun1();\n\t\t} else if(s[0] == 'd'){\n\t\t\tfun2();\n\t\t} else if(s[0] == '<'){\n\t\t\tfun3();\n\t\t} else{\n\t\t\tfun4();\n\t\t}\n\t} \n\n\twhile(d1.size()){\n\t\tcout << d1.front();\n\t\td1.pop_front();\n\t}\n\tcout << \"I\";\n\twhile(d2.size()){\n\t\tcout << d2.front();\n\t\td2.pop_front();\n\t}\n\t\t\n\treturn 0;\n}\n```\n\n### 小苯的数组构造\n\n遍历每个数，找出每个数前的各个最大值（不断维护），相减即可\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<ll> v(a + 1);\n\tv[0] = -10e9 - 10;\n\tint flag = 1; \n\tfor(int i = 1; i <= a; i++) {\n\t\tcin >> v[i];\n\t\tif(i != 0 && v[i] < v[i - 1]){\n\t\t\tflag = 0;\n\t\t} \t\n\t}\n\tif(flag) {\n\t\tfor(int i = 1; i <= a; i++){\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tif(v[i] >= v[i - 1]) cout << 0 << \" \";\n\t\telse {\n\t\t\tcout << v[i - 1] - v[i] << \" \";\n\t\t\tv[i] = v[i - 1];\n\t\t}\n\t}\t\n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的数组切分\n\n思维题，分别考虑 & ^ | 这三种运算符\n\n- 对于 &，无论有多少个数相互 & 操作，结果都是越来越小\n- 对于 ^，若有两个相同的数进行 ^，则结果为0\n\n只要知道上面这两个，那么就可以确定右端点这一个数进行 &，剩下的 0, a - 1区间就用维护出 ^ 和 | 这两种操作的最大之和，加上右端点的值就是结果\n\n> 对于维护 0, a - 1这个区间，可以考虑先遍历 0 , a - 1，对每个数进行取 ^ 运算得到一个结果l，再反向遍历 a - 1, 0 若想不让这个数取 ^，可以对 l 对这个数进行取 ^ ，因为开始已经取过一边了，再取一边就是0相当于没取。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll res = 0;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++) cin >> v[i]; \n\tll l = v[0], r = v[a - 2];\n\tfor(int i = 1; i < a - 1; i++) l ^= v[i];\n\tfor(int i = a - 2; i >= 0; i--){\n\t\tl ^= v[i];\n\t\tr |= v[i];\n\t\tres = max(res, l + r);\n\t}\n\t\n\tcout << res + v[a - 1] << endl;\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛87\n","category":[" 算法\n"],"date":" 2024-04-25\n","author":" Jixer\n","source":" 原创\n\n"}}