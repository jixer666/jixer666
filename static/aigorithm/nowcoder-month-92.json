{"filename":"nowcoder-month-92","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛92\ncategory: 算法\ndate: 2024-05-04\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本次算法赛主题是MC，一下就来兴趣了\n\n## 获得木头\n\n签到题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tcout << a * 8 << endl;\t\n   \n\treturn 0;\n}\n```\n\n## 采矿时间到！\n\nwa了一次，这题坑点在于会有一种这样的情况\n\n```\n#################*##\n#########*##########\n....................\n#####*######**######\n#*##########*#######\n```\n\n最外层和最内层都有矿石，此时就只需要消耗2体力就能够挖到两个矿石\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n char v[1010][1010];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint idx = 0;\n\tcin >> a >> b;\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> v[i][j];\n\t\t\tif(v[i][j] == '*') idx ++;\n\t\t}\n\t}\n\tint cot = 0, res = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tif(v[1][i] == '*') cot ++;\n\t\tif(v[3][i] == '*') cot ++; \n\t} \n\tif(cot > b){\n\t\tcout << b << endl;\n\t\treturn 0; \n\t}\n\tint cc = (b - cot) / 2;\n\tcout << min(cc, idx - cot) + cot << endl;\n\treturn 0;\n}\n```\n\n## 耕种时间到！\n\n这题是个模拟题，很容易想到模拟的过程\n\n我在赛时把分解的过程直接化了，简单的想成了小麦种子的数量为`收割次数总次数 * 2`，正解是`pow(2, 收割次数总次数 )`\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint idx = 0;\n\tcin >> a;\n\tvector<int> v(a);\n\tunordered_map<int, ll> m; \n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v[i];\n\t}\n\tcin >> b;\n\tfor(int i = 0; i < a; i++){\n\t\tll idx = 0, cnt = 1;\n\t\twhile(v[i] > b){\n\t\t\tv[i] = ceil(v[i] * 1.0 / 3);\n\t\t\tidx ++;\n\t\t\tcnt *= 2;\n\t\t}\n\t\tif(v[i] == b){\n\t\t\tm[idx] += cnt;\n\t\t}\n\t}\n\tll res = 0;\n\tfor(auto i: m){\n\t\tres = max(res, i.second);\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n## 探索的时光\n\n这题我想了很多思考思路：\n\n- 前缀和\n\n- dp\n- 推公式，找规律\n\n但是都没法实现，问题就出在了推公式，吃了没文化的亏。正解也是推公式，我遇到求和符合就卡了，不知道怎么化简\n\n最终推出来的结论：（@为+号）\n\n![](https://img2.imgtp.com/2024/05/04/ycrX8KeI.png)\n\n你以为这就结束了？这题还需要注意坑点是数据范围！！！\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a + 1);\n\tll all = 0, all2 = 0, all3 = 0, res = 0x3f3f3f3f3f3f3f3f;\n\tfor(ll i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tall += v[i];\n\t\tall2 += i * v[i];\n\t\tall3 += i * i * v[i];\n\t}\n\tfor(ll i = 1; i <= a; i++){\n\t\tres = min(res, i * i * all + all3 - 2 * i * all2);\n\t}\n\n\tcout << res << endl; \n\t\n\t\n\treturn 0;\n}\n```\n\n## 来硬的\n\n背包问题\n\n首先从数据范围上很容易看出是DP问题，需要双循环更新\n\n~~其次我知道它是DP，但我设计不出来状态转移方程，淦~~\n\n设计状态：`dp[i][j][0/1]` 表示前i个煤炭，获得j个矿石的最短时间，0/1表示是否使用过魔法\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nstruct p{\n\tint x, y;\n}n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<vector<vector<ll>>> dp(a + 1, vector<vector<ll>>(b + 1, vector<ll>(2, 0x3f3f3f3f3f3f3f3f)));\n\tdp[0][0][0] = 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> n[i].x >> n[i].y;\n\t}\n\tfor(int i = 1;  i <= a; i++){\n\t\tfor(int j = 0; j <= b; j++){\n\t\t\tdp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][max(j - n[i].x, 0)][0] + n[i].y);\n\t\t\tdp[i][j][1] = min({dp[i - 1][j][1], dp[i - 1][max(j - n[i].x * 2, 0)][0] + n[i].y / 2, dp[i - 1][max(j - n[i].x, 0)][1] + n[i].y});\n\t\t} \n\t}\n\t\n\tcout << min(dp[a][b][1], dp[a][b][0]) << endl;\t\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛92\n","category":[" 算法\n"],"date":" 2024-05-04\n","author":" Jixer\n","source":" 原创\n\n"}}