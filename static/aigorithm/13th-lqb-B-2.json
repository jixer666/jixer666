{"filename":"13th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十三届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-04-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 九进制转十进制\n\n进制转换题\n\n2 + 2 * 9 + 2 * 9 * 9 + 2 * 9 *9 * 9\n\n### 顺子日期\n\n模拟、枚举题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \nint n[13] = {0, 31, 28, 31,30,31,30,31,31,30,31,30,31};\n\nbool fun(string kk){\n\tbool flag = 0;\n\tint idx = 1;\n\t\tfor(int j = 1; j < kk.size(); j++){\n\t\t\tif(kk[j] - '0' == kk[j - 1] - '0' + 1 ){\n\t\t\t\tidx ++;\n\t\t\t}else {\n\t\t\t\tif(idx == 3) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidx = 1;\n\t\t\t}\n\t\t}\n    \t// 注意没遍历完的也需要确认idx是否大于等于3\n\t\treturn idx >= 3 ? true : flag;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tfor(int i = 1; i <= 12; i++){\n\t\tint num = 20220000 + i * 100, idx = 0, flag = 0;\n\t\tfor(int j = 1; j <= n[i]; j++){\n\t\t\tint cot = num + j;\n\t\t\tstring kk = to_string(cot);\n\t\t\tif(fun(kk)){\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n```\n\n### 刷题统计\n\n模拟题，这题唯一需要注意的就是数据范围，需要long long类型\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll m, a, b;\n\tcin >> a >> b >> m;\n\tll kk = a * 5 + 2 * b; \n\tll kk3 = m % kk;\n\tll res = m / kk * 7;\n\tif(kk3 <= a * 5){\n\t\tres += (ll) ceil(kk3 * 1.0 / a);\n\t} else {\n\t\tres += 5 + (ll)ceil((kk3 - a * 5) * 1.0 / b);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 修剪灌木\n\n思维题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\tfor(int i = 1; i <= x; i++){\n\t\tcout << max(2 * (x - i), 2 * (i - 1)) << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 统计子矩阵\n\n前缀和、双指针题\n\n思路：先求出二维数组的前缀和，用双循环遍历每个数，此时我们需要用另一个数来比较出当前范围的和。\n\n我们可以发现若另一个数和遍历的数的范围和小于k，那么这个数的左边的数的范围和也是小于k的。于是就可以将另一个数设置在最右边，不断让这个数的列减少行增加来算出满足条件的个数，此时时间复杂度优化至O(n^3)，能过。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res = N;\nint v[501][501], n[501][501];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll k, res = 0;\n\tcin >> a >> b >> k;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> v[i][j];\t\n\t\t\tv[i][j] = v[i-1][j] + v[i][j-1] - v[i-1][j-1] + v[i][j];\n\t\t}\n\t} \n\t\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tint r = b;\n\t\t\tfor(int l = i; l <= a; l++){\n\t\t\t\twhile(r >= j && v[l][r] - v[i - 1][r] - v[l][j - 1] + v[i - 1][j - 1] > k){\n\t\t\t\t\tr --;\n\t\t\t\t}\n\t\t\t\tif(j > r){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += r - j + 1;\n\t\t\t}\n\t\t}\n\t} \n\tcout << res << endl;\t\n}\t\n```\n\n### 积木画\n\n动态规划题\n\n这题很难推出状态的转移方程\n\n假设当前点为i，用v[i]表示当前满足的个数\n\n- 若i-1全部铺满，则v[i] = v[i-1]\n- 若i-1一个都没有铺，则v[i] = v[i - 2]\n- 若i-1只铺满了一半，则v[i] = v[i - 3] * 2，同理也可以推出 v[i] = v[i - 4] * 2\n\n于是：\n\nv[i] = v[i - 1] + v[i - 2] + v[i - 3] * 2 + v[i - 4] * 2 + ... + 2 * v[1]\n\nv[i - 1] = v[i - 2] + v[i - 3] + v[i - 4] * 2 + ... + 2 * v[1]\n\n两式相减得出：**v[i] = v[i - 1] * 2 + v[i - 3]** \n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res = N;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a);\n\tv[1] = 1, v[2] = 2, v[3] = 5;  \n\tfor(int i = 4; i <= a; i++){\n\t\tv[i] = (2 * v[i - 1] % 1000000007  + v[i - 3] % 1000000007) % 1000000007;\n\t}\n\n\tcout << v[a] << endl;\n\t\n\treturn 0;\n}\t\n```\n\n### 扫雷\n\nBFS 暴力法能过 40% 的样例\n\n优化是在队列遍历的进行二分查找，~~我就不会了~~\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res;\nstruct p{\n\tint x, y, num;\n}n[N],v[N];\nint flag[N];\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    scanf(\"%d%d\",&a, &b);\n    queue<pair<int, int>> q;\n    for(int i = 0; i < a; i++){\n    \tscanf(\"%lld%lld%lld\",&n[i].x, &n[i].y, &n[i].num);\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tscanf(\"%lld%lld%lld\",&v[i].x, &v[i].y, &v[i].num);\n\t\tq.push({i, 1});\t\n\t}\n\twhile(!q.empty()){\n\t\tauto top = q.front();\n\t\tq.pop();\n\t\tint f = top.first, s = top.second;\n\t\tint xx, yy, rr;\n\t\tif(s == 1){\n\t\t\txx = v[f].x, yy = v[f].y, rr = v[f].num;\n\t\t} else {\n\t\t\txx = n[f].x, yy = n[f].y, rr = n[f].num;\n\t\t}\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tif(!flag[i] && (ll)(n[i].x - xx)*(n[i].x - xx) + (ll)(n[i].y - yy) * (n[i].y - yy) <= (ll)rr*rr){\n\t\t\t\tflag[i] = 1;\n\t\t\t\tq.push({i, 2});\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\tprintf(\"%d\", res);\n\t\t\n    return 0;\n}\n```\n\n\n\n### 李白打酒加强版\n\n记忆化搜索 + 剪枝\n\n此题不难想到用DFS，可是只用用DFS的话注意题干条件：**由于答案很大，输出模1000000007**，这时候就需要用其他条件辅助\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\nlong long res = 0;\nll n[101][101][101];\nint mod = 1000000007;\n\nint dfs(int x, int y, int num){\n    // num + a - x >  b - y 剪枝，满足当前剩余的数加上需要相乘的数必须小于需要相减的数\n    if(x > a || y > b || num < 0 || num + a - x > b - y){\n        return 0;\n    }\n    if(x == a && y == b - 1 && num == 1){\n        return 1;\n    }\n    if(n[x][y][num]){\n    \treturn n[x][y][num];\n\t}\n\tif(num > 0){\n\t\tn[x][y][num] = (dfs(x + 1, y, num * 2) % mod + dfs(x, y + 1, num - 1) % mod) % mod;\n\t} else {\n\t\tn[x][y][num] = dfs(x + 1, y, num * 2) % mod;\n\t}\n\treturn n[x][y][num];\n}\n\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> a >> b;\n    cout << dfs(0, 0, 2) << endl;\n    \n    return 0;\n}\n```\n\n","title":" 第十三届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-04-08\n","author":" Jixer\n","source":" 原创\n\n"}}