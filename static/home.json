[{"filename":"xuecheng-plus","category":"project","md":{"topSummary":"\r\ntitle: 学成在线项目笔记\r\ncategory: SpringBoot,SpringCloud,实战项目\r\ndate: 2024-08-18\r\nauthor: Jixer\r\nsource: 原创\r\n","mainContent":"\r\n\r\n此文章记录笔者在学成在线的过程中，所遇到的技术点和难点\r\n\r\n感谢黑马提供的课程和资源\r\n\r\n项目地址：[https://gitee.com/lijunxi666/xuecheng-plus-project](https://gitee.com/lijunxi666/xuecheng-plus-project)\r\n\r\n## 大文件上传\r\n\r\n此处的文件上传方法用于视频文件等大文件，若是图片这些，选用普通的上传即可\r\n\r\n本项目选用的是 minio 进行文件存储，当然其他的 oss 存储都是可以的，原理不变\r\n\r\nminio 项目地址：[https://github.com/minio/minio](https://github.com/minio/minio)\r\n\r\n### 流程\r\n\r\n1、前端通过一定手段，将一个大型的文件拆分成几个小的分片，依次上传\r\n\r\n2、在上传文件前，前端会对文件进行分片，并计算文件的 md5 值\r\n\r\n3、在初次上传前会对文件进行检查，检查该文件是否已经上传了，后端根据文件 md5 值这个唯一标识来查询数据库，若数据库存在，就说明该文件已经上传过了，无需上传，只需在数据库里添加一个记录就行；否则就没上传\r\n\r\n4、接着就是分片依次上传，同样的上传也是需要先检查该分片是否已经上传了（**断点续传作用**），若没上传就调用接口进行上传，已经上传了就检查下一个接口\r\n\r\n5、等所有分片全部上传完成，前端调用合并请求，将分片合并成一个整体并校验文件是否与上传一致，若校验通过就清理分片碎片文件，若没通过就抛错\r\n\r\n## 分布式任务调度\r\n\r\n本项目用的是 xxl-job 进行任务调度\r\n\r\nxxl-job 项目地址：[https://github.com/xuxueli/xxl-job](https://github.com/xuxueli/xxl-job)\r\n\r\n本项目采用分片广播的形式来处理视频转码、转码过程中服务宕机补偿、视频分片清理等任务\r\n\r\n分布式任务调度存在的问题：\r\n\r\n- 如何保证多个执行器不会查询到重复的任务呢？\r\n- 如果一个执行器在处理一个视频还没有完成，此时调度中心又一次请求调度，为了不重复处理同一个视频该怎么办？\r\n\r\n解决办法：\r\n\r\n- 采用分片广播，采用 `id % 分片总数 == 分片编号` 的方式来决定是哪一个执行器执行\r\n- 采用丢弃后续调度 + 乐观锁的方式\r\n\r\n### 视频转码\r\n\r\n对视频转码之前，采用乐观锁（更新转码字段状态）来判断当前任务是否已经执行了，防止多实例重复进行任务\r\n\r\n```sql\r\nupdate media_process set status = '4', execute_date = #{now} where id = #{taskId} and status in ('1', '3')\r\n```\r\n\r\n视频转码采用 ffmpeg 工具对 avi 视频转码为 mp4 文件，执行命令：\r\n\r\n```java\r\nffmpeg.exe -i lucene.avi -c:v libx264 -s 1280x720 -pix_fmt yuv420p -b:a 63k -b:v 753k -r 18 .\\lucene.mp4\r\n```\r\n\r\n先清除已经生成的转码文件，然后通过构建 ProcessBuilder 来执行命令\r\n\r\n```java\r\n// 清除以前已经生成的\r\nclearFile(savePath);\r\n// 获取执行命令\r\nList<String> commands = getCommands(filePath, savePath);\r\nString outString = \"error\";\r\ntry {\r\n    ProcessBuilder processBuilder = new ProcessBuilder();\r\n    processBuilder.command(commands);\r\n    Process process = processBuilder.start();\r\n} catch (Exception e){\r\n    log.error(\"执行视频转码命令出错，原因：{}\", e.getMessage());\r\n}\r\n```\r\n\r\n转码成功后，将文件保存到 minio 中，同时标记转码状态为已完成\r\n\r\n存在的问题：\r\n\r\n- 当一个任务调度在处理视频转码的时候，这个服务突然挂了，那么这个转码任务就一直处于转码中这个状态（已解决）\r\n- **任务失败一次次数就会加一，当达到最大失败次数的时候就说明这个视频有问题，需要人工处理（待解决）**\r\n- 上传一个文件进行分块上传，上传一半不传了，之前上传到 minio 的分块文件是否需要清理（已解决）\r\n\r\n### 视频转码补偿\r\n\r\n解决的问题：当一个任务调度在处理视频转码的时候，这个服务突然挂了，那么这个转码任务就一直处于转码中这个状态\r\n\r\n实现方法：通过分片广播的方式，对需要处理的视频文件进行重新执行视频转码\r\n\r\n如何找到需要处理的视频文件呢？项目通过查询数据库，根据状态为转码中和当前时间与执行时间比较超过2个小时这两个条件来筛选出需要重新执行的文件列表\r\n\r\n\r\n\r\n### 视频分片清理\r\n\r\n\r\n\r\n","title":" 学成在线项目笔记\r\n","category":[" SpringBoot","SpringCloud","实战项目\r\n"],"date":" 2024-08-18\r\n","author":" Jixer\r\n","source":" 原创\r\n"},"simpleMd":"\r\n\r\n此文章记录笔者在学成在线的过程中，所遇到的技术点和难点\r\n\r\n感谢黑马提供的课程和资源\r\n\r\n项目地址：https://gitee.com/lijunxi666/xuechengplusprojecthttps://gitee.com/lijunxi666/xuechengplusproject\r\n\r\n 大文件上传\r\n\r\n此处的文件上传方法用于视频文件等大文件，若是图片这些，选用普通的上传即可\r\n\r\n本项目选用的是 minio 进行文件存储，当然其他的 oss 存储都是可以的，原理不变\r\n\r\nminio 项目地址：https://github.com/minio/miniohttps://github.com/minio/minio\r\n\r\n 流程\r\n\r\n1、前端通过一定手段，将一个大型的文件拆分成几个小的分片，依次上传\r\n\r\n2、在上传文件前，前端会对文件进行分片，并计算文件的 md5 值\r\n\r\n3、在初次上传前会对文件进行检查，检查该文件是否已经上传了，后端根据文件 md5 值这个唯一标识来查询数据库，若数据库存在，就说明该文件已经上传过了，无需上传，只需在数据库里添加一个记录就行；否则就没上传\r\n\r\n4、接着就是分片依次上传，同样的上传也是需要先检查该分片是否已经上传了（断点续传作用），若没上传就调用接口进行上传，已经上传了就检查下一个接口\r\n\r\n5、等所有分片全部上传完成，前端调用合并请求，将分片合并成一个整体并校验文件是否与上传一致，若校验通过就清理分片碎片文件，若没通过就抛错\r\n\r\n 分布式任务调度\r\n\r\n本项目用的是 xxljob 进行任务调度\r\n\r\nxxljob 项目地址：https://github.com/xuxueli/xxljobhttps://github.com/xuxueli/xxljob\r\n\r\n本项目采用分片广播的形式来处理视频转码、转码过程中服务宕机补偿、视频分片清理等任务\r\n\r\n分布式任务调度存在的问题：\r\n\r\n 如何保证多个执行器不会查询到重复的任务呢？\r\n 如果一个执行器在处理一个视频还没有完成，此时调度中心又一次请求调度，为了不重复处理同一个视频该怎么办？\r\n\r\n解决办法：\r\n\r\n 采用分片广播，采用 id % 分片总数 == 分片编号 的方式来决定是哪一个执行器执行\r\n 采用丢弃后续调度 + 乐观锁的方式\r\n\r\n 视频转码\r\n\r\n对视频转码之前，采用乐观锁（更新转码字段状态）来判断当前任务是否已经执行了，防止多实例重复进行任务\r\n\r\nsql\r\nupdate mediaprocess set status = '4', executedate = {now} where id = {taskId} and status in '1', '3'\r\n\r\n\r\n视频转码采用 ffmpeg 工具对 avi 视频转码为 mp4 文件，执行命令：\r\n\r\njava\r\nffmpeg.exe i lucene.avi c:v libx264 s 1280x720 pixfmt yuv420p b:a 63k b:v 753k r 18 .\\lucene.mp4\r\n\r\n\r\n先清除已经生成的转码文件，然后通过构建 ProcessBuilder 来执行命令\r\n\r\njava\r\n// 清除以前已经生成的\r\nclearFilesavePath;\r\n// 获取执行命令\r\nList<String commands = getCommandsfilePath, savePath;\r\nString outString = \"error\";\r\ntry {\r\n    ProcessBuilder processBuilder = new ProcessBuilder;\r\n    processBuilder.commandcommands;\r\n    Process process = processBuilder.start;\r\n} catch Exception e{\r\n    log.error\"执行视频转码命令出错，原因：{}\", e.getMessage;\r\n}\r\n\r\n\r\n转码成功后，将文件保存到 minio 中，同时标记转码状态为已完成\r\n\r\n存在的问题：\r\n\r\n 当一个任务调度在处理视频转码的时候，这个服务突然挂了，那么这个转码任务就一直处于转码中这个状态（已解决）\r\n 任务失败一次次数就会加一，当达到最大失败次数的时候就说明这个视频有问题，需要人工处理（待解决）\r\n 上传一个文件进行分块上传，上传一半不传了，之前上传到 minio 的分块文件是否需要清理（已解决）\r\n\r\n 视频转码补偿\r\n\r\n解决的问题：当一个任务调度在处理视频转码的时候，这个服务突然挂了，那么这个转码任务就一直处于转码中这个状态\r\n\r\n实现方法：通过分片广播的方式，对需要处理的视频文件进行重新执行视频转码\r\n\r\n如何找到需要处理的视频文件呢？项目通过查询数据库，根据状态为转码中和当前时间与执行时间比较超过2个小时这两个条件来筛选出需要重新执行的文件列表\r\n\r\n\r\n\r\n 视频分片清理\r\n\r\n\r\n\r\n"},{"filename":"work-week-target","category":"life","md":{"topSummary":"\r\ntitle: 实习周目标\r\ncategory: 生活,实习\r\ndate: 2024-08-04\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n**写在之前的话：** 做事之前先思考，清楚需求的怎么来的，需要怎么解决，有没有更优的解决方法；思想最重要，技术是次要的；代码注重代码风格\r\n\r\n## 第一周\r\n\r\n日期：2024.7.29 ~ 2024.8.3\r\n\r\n本周是实习的第一周，没有制订周计划，所以就写下这周的总结\r\n\r\n第一天：参与入职培训，获取了公司的相关账号，配置了后端所用到的环境\r\n\r\n第二天：从 mt 得知项目需要用到 es，这天学了下 es 的用法\r\n\r\n第三天：看了雅典娜的知识库，大致了解了 v4 项目的架构，看了本地电脑上的 SaaS 项目代码的架构\r\n\r\n第四天：获得了 git 权限，拉取了本组代码，前后端联调启动（莫名其妙的问题太多了）\r\n\r\n第五天：学习了 DDD 领域架构设计，参与一下午的 OD 集训会（大型社死现场）\r\n\r\n总的来说这一周体验还是很棒的，mt 对我是放养的，公司有专门的考核机制，mt 对我设置的考核很低，非常友好\r\n\r\n## 第二周\r\n\r\n日期：2024.8.5 ~ 2024.8.9\r\n\r\n目标：\r\n\r\n- 进一步学习 DDD 领域架构，熟悉项目代码结构\r\n- 空余时间学习微服务项目\r\n- 若有安排任务，积极响应并认真做好，并确保 Bug 率不要超过10%\r\n- 学习 jira 的使用\r\n- 请教 mt，了解并熟悉项目组的业务\r\n\r\n总结：\r\n\r\n第一天：学习了 Jira 的使用，调试并熟悉了登录接口\r\n\r\n第二天：熟悉了 v3 项目的模块和开发规范，微服务项目的分片上传和合并\r\n\r\n第三天：保险单导出 PDF 的功能，实现了 HEALTH 模板的数据的渲染\r\n\r\n第四天：继续实现了其他 HEALTH、VO 的模板渲染，卡在了 EDU 模板。在 Jira 上进行了第一次提交\r\n\r\n第五天：实现了 EDU 模板的渲染\r\n\r\n这周接到了第一个需求，对保险单导出 PDF 这个功能，对项目的结构进一步熟悉了，知道了启动的流程，对一些脚本文件是怎么使用的，很多地方都需要启动的时候执行脚本文件。除了业务上，我对 IDEA 工具的调试也更加熟练了。\r\n\r\n## 第三周\r\n\r\n日期：2024.8.12 ~ 2024.8.17\r\n\r\n目标：\r\n\r\n- 制作基于 md 文件的静态博客生成器\r\n- 完善 mt 给的导出 PDF 任务\r\n- 继续学成在线微服务项目跟进\r\n- Dubbo RPC 框架的了解\r\n- 主动向上级承担任务\r\n- 认识团队的成员\r\n\r\n总结：\r\n\r\n第一天：拉取了另一个项目组的代码，根据他的 prime 代码进行迁移到我的项目组来；开展了保密安全的会议\r\n\r\n第二天：完成 prime 项目最后一个模板的渲染，调试项目 bug，理解流程\r\n\r\n第三天：开了实习期交流会，要求向领导承担任务；根据 excel 表格内容，对 json 数据进行重构；对 dashboard 的多级菜单进行排序（递归解决）\r\n\r\n第四天：参与代码重构知识分享会议；继续对 output 模块导出 pdf 代码编写；逆天领导让我干前端\r\n\r\n第五天：完成 output 模块导出 pdf 代码；学习 MySQL 索引知识点\r\n\r\n这周是在上周基础上对 output 保单打印进行收尾工作，总的来说很枯燥无味。唯一感兴趣的是每周都知识分享会【有八股可以学习】；自己也对导出模块流程进行了总结，大致对过程有了一定的了解；这周被领导安排做前端，有点不想做，看看下周能不能找个理由推掉；RPC 框架自己也是了解一知半解；团队成员以及全部认识；md 博客生成器大致已经制作完成\r\n\r\n## 第四周\r\n\r\n日期：2024.8.19 ~ 2024.8.23\r\n\r\n目标\r\n\r\n- 完成安排的任务\r\n- 学成在线项目\r\n\r\n第一天：mt 帮我 review 导出 pdf 代码，更改提出的问题；提交 jira 作业\r\n\r\n第二天：\r\n","title":" 实习周目标\r\n","category":[" 生活","实习\r\n"],"date":" 2024-08-04\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n写在之前的话： 做事之前先思考，清楚需求的怎么来的，需要怎么解决，有没有更优的解决方法；思想最重要，技术是次要的；代码注重代码风格\r\n\r\n 第一周\r\n\r\n日期：2024.7.29  2024.8.3\r\n\r\n本周是实习的第一周，没有制订周计划，所以就写下这周的总结\r\n\r\n第一天：参与入职培训，获取了公司的相关账号，配置了后端所用到的环境\r\n\r\n第二天：从 mt 得知项目需要用到 es，这天学了下 es 的用法\r\n\r\n第三天：看了雅典娜的知识库，大致了解了 v4 项目的架构，看了本地电脑上的 SaaS 项目代码的架构\r\n\r\n第四天：获得了 git 权限，拉取了本组代码，前后端联调启动（莫名其妙的问题太多了）\r\n\r\n第五天：学习了 DDD 领域架构设计，参与一下午的 OD 集训会（大型社死现场）\r\n\r\n总的来说这一周体验还是很棒的，mt 对我是放养的，公司有专门的考核机制，mt 对我设置的考核很低，非常友好\r\n\r\n 第二周\r\n\r\n日期：2024.8.5  2024.8.9\r\n\r\n目标：\r\n\r\n 进一步学习 DDD 领域架构，熟悉项目代码结构\r\n 空余时间学习微服务项目\r\n 若有安排任务，积极响应并认真做好，并确保 Bug 率不要超过10%\r\n 学习 jira 的使用\r\n 请教 mt，了解并熟悉项目组的业务\r\n\r\n总结：\r\n\r\n第一天：学习了 Jira 的使用，调试并熟悉了登录接口\r\n\r\n第二天：熟悉了 v3 项目的模块和开发规范，微服务项目的分片上传和合并\r\n\r\n第三天：保险单导出 PDF 的功能，实现了 HEALTH 模板的数据的渲染\r\n\r\n第四天：继续实现了其他 HEALTH、VO 的模板渲染，卡在了 EDU 模板。在 Jira 上进行了第一次提交\r\n\r\n第五天：实现了 EDU 模板的渲染\r\n\r\n这周接到了第一个需求，对保险单导出 PDF 这个功能，对项目的结构进一步熟悉了，知道了启动的流程，对一些脚本文件是怎么使用的，很多地方都需要启动的时候执行脚本文件。除了业务上，我对 IDEA 工具的调试也更加熟练了。\r\n\r\n 第三周\r\n\r\n日期：2024.8.12  2024.8.17\r\n\r\n目标：\r\n\r\n 制作基于 md 文件的静态博客生成器\r\n 完善 mt 给的导出 PDF 任务\r\n 继续学成在线微服务项目跟进\r\n Dubbo RPC 框架的了解\r\n 主动向上级承担任务\r\n 认识团队的成员\r\n\r\n总结：\r\n\r\n第一天：拉取了另一个项目组的代码，根据他的 prime 代码进行迁移到我的项目组来；开展了保密安全的会议\r\n\r\n第二天：完成 prime 项目最后一个模板的渲染，调试项目 bug，理解流程\r\n\r\n第三天：开了实习期交流会，要求向领导承担任务；根据 excel 表格内容，对 json 数据进行重构；对 dashboard 的多级菜单进行排序（递归解决）\r\n\r\n第四天：参与代码重构知识分享会议；继续对 output 模块导出 pdf 代码编写；逆天领导让我干前端\r\n\r\n第五天：完成 output 模块导出 pdf 代码；学习 MySQL 索引知识点\r\n\r\n这周是在上周基础上对 output 保单打印进行收尾工作，总的来说很枯燥无味。唯一感兴趣的是每周都知识分享会【有八股可以学习】；自己也对导出模块流程进行了总结，大致对过程有了一定的了解；这周被领导安排做前端，有点不想做，看看下周能不能找个理由推掉；RPC 框架自己也是了解一知半解；团队成员以及全部认识；md 博客生成器大致已经制作完成\r\n\r\n 第四周\r\n\r\n日期：2024.8.19  2024.8.23\r\n\r\n目标\r\n\r\n 完成安排的任务\r\n 学成在线项目\r\n\r\n第一天：mt 帮我 review 导出 pdf 代码，更改提出的问题；提交 jira 作业\r\n\r\n第二天：\r\n"},{"filename":"java-more","category":"java","md":{"topSummary":"\r\ntitle: Java的深入理解\r\ncategory: Java\r\ndate: 2024-07-05\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## ArryList 扩容机制\r\n\r\n下面是 ArryList 的 `add` 方法\r\n\r\n```java\r\n/**\r\n* 将指定的元素追加到此列表的末尾。\r\n*/\r\npublic boolean add(E e) {\r\n    // 加元素之前，先调用ensureCapacityInternal方法\r\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n    elementData[size++] = e;\r\n    return true;\r\n}\r\n```\r\n\r\n`ensureCapacityInternal` 方法代码如下：\r\n\r\n```java\r\n// 根据给定的最小容量和当前数组元素来计算所需容量。\r\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\r\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\r\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\r\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\r\n    }\r\n    // 否则直接返回最小容量\r\n    return minCapacity;\r\n}\r\n\r\n// 确保内部容量达到指定的最小容量。\r\nprivate void ensureCapacityInternal(int minCapacity) {\r\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\r\n}\r\n```\r\n\r\n`ensureExplicitCapacity` 代码如下：\r\n\r\n```java\r\n//判断是否需要扩容\r\nprivate void ensureExplicitCapacity(int minCapacity) {\r\n    modCount++;\r\n    //判断当前数组容量是否足以存储minCapacity个元素\r\n    if (minCapacity - elementData.length > 0)\r\n        //调用grow方法进行扩容\r\n        grow(minCapacity);\r\n}\r\n```\r\n\r\n`gorw` 扩容代码如下：\r\n\r\n```java\r\n/**\r\n * 要分配的最大数组大小\r\n */\r\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\r\n\r\n/**\r\n * ArrayList扩容的核心方法。\r\n */\r\nprivate void grow(int minCapacity) {\r\n    // oldCapacity为旧容量，newCapacity为新容量\r\n    int oldCapacity = elementData.length;\r\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n\r\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n\r\n    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\r\n    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\r\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n        newCapacity = hugeCapacity(minCapacity);\r\n\r\n    // minCapacity is usually close to size, so this is a win:\r\n    elementData = Arrays.copyOf(elementData, newCapacity);\r\n}\r\n```\r\n\r\n分析：\r\n\r\n1、当传入第1个元素的时候\r\n\r\n- 因为当前数组为空，所以 `if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)` 条件成立，返回默认值10\r\n- 此时的 `elementData.length` 长度为0，所以 ` if (minCapacity - elementData.length > 0)` 条件成立，会执行扩容\r\n- `newCapacity` 大小为0，`minCapacity` 大小为10，所以 `if (newCapacity - minCapacity < 0)` 条件成立，最后执行 `Arrays.copyOf` 对数组进行增加容量\r\n\r\n2、当传入到第11个元素的时候\r\n\r\n- `calculateCapacity` 返回的是 size + 1，也就是 10 + 1 = 11\r\n- 此时的 `elementData.length` 长度为10，所以 ` if (minCapacity - elementData.length > 0)` 条件成立，会执行扩容\r\n- `newCapacity` 大小为15，`minCapacity` 大小为10，所以方法的两个 if 语句都不会执行，最后执行 `Arrays.copyOf` 对数组进行增加容量\r\n\r\n扩容方法会对长度为0或者长度超 `int` 类型范围的时候进行特判，其他的长度都是扩大1.5倍\r\n\r\n ## HashMap\r\n\r\n### 扩容机制\r\n\r\n1、若没有自定义容量大小，会默认初始化大小为16。每次扩容都会变为原来的2倍\r\n\r\n2、若自定义了容量大小，会用给定的容量作为初始化大小。每次扩容都会变为原来的2的幂次方【为什么？**因为获取元素下标的方法是应该是`hash % length`，为了让 `hash % length == hash & (length - 1)` 的前提是 length 是 2 的 n 次方**】\r\n\r\n### 数据结构\r\n\r\n1、在 JDK 1.8之前，底层数据结构选用的是**数组 + 链表**。当加入键值对的时候，会先对键进行扰动函数处理得到 hash 值，然后通过 `(n - 1) & hash` 获取得到当前需要存放的位置，若元素以及存在，就覆盖，否则就拉链法解决冲突\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是**数组 + 链表/红黑树**。当加入键值对的时候，为了解决哈希冲突，当链表的长度8的时候，会将链表转为红黑树（在转红黑树之前，先会对数组长度进行判断，若长度小于64，会先将数组进行扩容）\r\n\r\n## ConcurrentHashMap\r\n\r\n### 容量\r\n\r\n1、在 JDK 1.7之前，若没指定大小，默认为16，且一旦确定就不可变\r\n\r\n2、在 JDK 1.18之后，若没指定大小，默认为16，可以进行扩容\r\n\r\n### 数据结构\r\n\r\n1、在JDK1.7之前，底层数据结构选用的是**分段数组 + 链表**，分段数组每段里都有一把锁（分段锁），每一把锁只锁当前的一段数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是**node 数组 + 链表/红黑树**，并发控制通过 `synchronized` 和 CAS 来操作，`synchronized` 只锁定当前链表或红黑二叉树的首节点，锁粒度更细","title":" Java的深入理解\r\n","category":[" Java\r\n"],"date":" 2024-07-05\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n ArryList 扩容机制\r\n\r\n下面是 ArryList 的 add 方法\r\n\r\njava\r\n/\r\n 将指定的元素追加到此列表的末尾。\r\n/\r\npublic boolean addE e {\r\n    // 加元素之前，先调用ensureCapacityInternal方法\r\n    ensureCapacityInternalsize + 1;  // Increments modCount\r\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n    elementDatasize++ = e;\r\n    return true;\r\n}\r\n\r\n\r\nensureCapacityInternal 方法代码如下：\r\n\r\njava\r\n// 根据给定的最小容量和当前数组元素来计算所需容量。\r\nprivate static int calculateCapacityObject elementData, int minCapacity {\r\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\r\n    if elementData == DEFAULTCAPACITYEMPTYELEMENTDATA {\r\n        return Math.maxDEFAULTCAPACITY, minCapacity;\r\n    }\r\n    // 否则直接返回最小容量\r\n    return minCapacity;\r\n}\r\n\r\n// 确保内部容量达到指定的最小容量。\r\nprivate void ensureCapacityInternalint minCapacity {\r\n    ensureExplicitCapacitycalculateCapacityelementData, minCapacity;\r\n}\r\n\r\n\r\nensureExplicitCapacity 代码如下：\r\n\r\njava\r\n//判断是否需要扩容\r\nprivate void ensureExplicitCapacityint minCapacity {\r\n    modCount++;\r\n    //判断当前数组容量是否足以存储minCapacity个元素\r\n    if minCapacity  elementData.length  0\r\n        //调用grow方法进行扩容\r\n        growminCapacity;\r\n}\r\n\r\n\r\ngorw 扩容代码如下：\r\n\r\njava\r\n/\r\n  要分配的最大数组大小\r\n /\r\nprivate static final int MAXARRAYSIZE = Integer.MAXVALUE  8;\r\n\r\n/\r\n  ArrayList扩容的核心方法。\r\n /\r\nprivate void growint minCapacity {\r\n    // oldCapacity为旧容量，newCapacity为新容量\r\n    int oldCapacity = elementData.length;\r\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n    int newCapacity = oldCapacity + oldCapacity  1;\r\n\r\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n    if newCapacity  minCapacity < 0\r\n        newCapacity = minCapacity;\r\n\r\n    // 如果新容量大于 MAXARRAYSIZE,进入执行 hugeCapacity 方法来比较 minCapacity 和 MAXARRAYSIZE，\r\n    // 如果minCapacity大于最大容量，则新容量则为Integer.MAXVALUE，否则，新容量大小则为 MAXARRAYSIZE 即为 Integer.MAXVALUE  8。\r\n    if newCapacity  MAXARRAYSIZE  0\r\n        newCapacity = hugeCapacityminCapacity;\r\n\r\n    // minCapacity is usually close to size, so this is a win:\r\n    elementData = Arrays.copyOfelementData, newCapacity;\r\n}\r\n\r\n\r\n分析：\r\n\r\n1、当传入第1个元素的时候\r\n\r\n 因为当前数组为空，所以 if elementData == DEFAULTCAPACITYEMPTYELEMENTDATA 条件成立，返回默认值10\r\n 此时的 elementData.length 长度为0，所以  if minCapacity  elementData.length  0 条件成立，会执行扩容\r\n newCapacity 大小为0，minCapacity 大小为10，所以 if newCapacity  minCapacity < 0 条件成立，最后执行 Arrays.copyOf 对数组进行增加容量\r\n\r\n2、当传入到第11个元素的时候\r\n\r\n calculateCapacity 返回的是 size + 1，也就是 10 + 1 = 11\r\n 此时的 elementData.length 长度为10，所以  if minCapacity  elementData.length  0 条件成立，会执行扩容\r\n newCapacity 大小为15，minCapacity 大小为10，所以方法的两个 if 语句都不会执行，最后执行 Arrays.copyOf 对数组进行增加容量\r\n\r\n扩容方法会对长度为0或者长度超 int 类型范围的时候进行特判，其他的长度都是扩大1.5倍\r\n\r\n  HashMap\r\n\r\n 扩容机制\r\n\r\n1、若没有自定义容量大小，会默认初始化大小为16。每次扩容都会变为原来的2倍\r\n\r\n2、若自定义了容量大小，会用给定的容量作为初始化大小。每次扩容都会变为原来的2的幂次方【为什么？因为获取元素下标的方法是应该是hash % length，为了让 hash % length == hash & length  1 的前提是 length 是 2 的 n 次方】\r\n\r\n 数据结构\r\n\r\n1、在 JDK 1.8之前，底层数据结构选用的是数组 + 链表。当加入键值对的时候，会先对键进行扰动函数处理得到 hash 值，然后通过 n  1 & hash 获取得到当前需要存放的位置，若元素以及存在，就覆盖，否则就拉链法解决冲突\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是数组 + 链表/红黑树。当加入键值对的时候，为了解决哈希冲突，当链表的长度8的时候，会将链表转为红黑树（在转红黑树之前，先会对数组长度进行判断，若长度小于64，会先将数组进行扩容）\r\n\r\n ConcurrentHashMap\r\n\r\n 容量\r\n\r\n1、在 JDK 1.7之前，若没指定大小，默认为16，且一旦确定就不可变\r\n\r\n2、在 JDK 1.18之后，若没指定大小，默认为16，可以进行扩容\r\n\r\n 数据结构\r\n\r\n1、在JDK1.7之前，底层数据结构选用的是分段数组 + 链表，分段数组每段里都有一把锁（分段锁），每一把锁只锁当前的一段数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是node 数组 + 链表/红黑树，并发控制通过 synchronized 和 CAS 来操作，synchronized 只锁定当前链表或红黑二叉树的首节点，锁粒度更细"},{"filename":"first-interview","category":"life","md":{"topSummary":"\r\ntitle: 双非菜鸟的第一次面试\r\ncategory: 生活,面试\r\ndate: 2024-07-02\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## 开篇\r\n\r\n职位：Java 开发实习生\r\n\r\n起因是经过学长介绍一家成都的小公司，我想的是既然是学长介绍的，那么我还是有可能面上的（虽然是第一次面试）。但因为是线下面试，距离较远（需要来回做火车和住宿），所以我得思考下才能答复学长是否能够去\r\n\r\n后面我询问了父母和朋友的意见，决定还是去面试，毕竟机会是留给有准备的人的，而且现在大环境也不好，难得有面试\r\n\r\n## 准备\r\n\r\n在牛客上我找到了一篇关于该公司的笔试题目，后面会给出笔试题\r\n\r\n> PS：这与我当时的笔试是一样的，算是一个小意外吧\r\n\r\n然后我根据我写的简历又重新背一遍八股，讲项目的那些技术都看了一下，不是说很熟悉，至少能够说个大概\r\n\r\n接着每天就在牛客上看面经，遇到不会的都会记录下来\r\n\r\n## 出发去成都\r\n\r\n我是提前一天的去的，当天坐智轨到了高铁站，花了一将近一个小时，然后根据身份证进站，坐车到成都，又花了一个半小时\r\n\r\n到了成都，因为我是第一次到成都，所以我的第一反应就是成都真大啊，我这种土狗难得看到这种高楼建筑\r\n\r\n接着我就在腾讯地图上找附近的酒店，打算住一晚上，第二天是10点面试，所以怕来不及。最后反反复复查找，最终选了一个便宜的民宿，20多块一晚上，还要啥自信车，哈哈哈\r\n\r\n在民宿我也复习了一遍八股，把面试官可能问我的问题猜了个遍\r\n\r\n## 面试\r\n\r\n当天我很早就起床了，大概7点左右，然后坐地铁，公交车，到达了公司门口，这时候大概8点半左右，因为是9点开始上班的，所以我在门口又等了一会（背了下八股），大概9点20左右我就进去面试了\r\n\r\n面试的前台小姐先是让我签到，然后就给了我一张面试题（和牛客上看到的是一样的）和一张个人信息表让我填，这里居然手机都没收，直接然我去个地方写，真不怕我百度搜啊！\r\n\r\n写完后就去三楼面试了，面试官就和聊天，没问技术相关的问题，这时候我就发现不对劲了，感觉像 kpi 面，有一个问题印象比较深刻：说说你关于线上和线下面试的看法\r\n\r\n接着面试官因为要开会，所以就让一位正在工作的研发同事问我，我感觉那位研发同事估计也是第一面试不太会问，所以就随便提出来一两个问题就结束了，没有问八股\r\n\r\n之后那个开始面试我的那个人说：不管录没录取都会给我发消息，一周之内给我答复\r\n\r\n笔试 + 面试全程大概2个小时\r\n\r\n接着我就打车回航了，和来的时候一样，坐地铁到高铁站，坐智轨回学校\r\n\r\n## 附笔试题\r\n\r\n### collection与collections的区别，以及一些常用类\r\n\r\nCollection 是集合接口，很多我们熟悉的比如 List、Set、Queue 都是实现的这个接口；Collections 是集合的工具类，包含很多对集合操作的方法，比如：求集合的最大和最小值、排序等。\r\n\r\n常用类：\r\n\r\nCollection:\r\n\r\n- List：ArryList、LinkList\r\n- Set：HashSet\r\n- Queue：LinkQueue\r\n\r\nCollections：\r\n\r\n- sort();\r\n- max()和min()\r\n- reverse()\r\n\r\n### 字符串与数组的切片、分割、获取字串等相关类与方法\r\n\r\n字符串：\r\n\r\n- 切片：substring(int begin, int end);\r\n- 分割：split(String str, int limit)\r\n- 获取某个字符：charAt(int index)，indexOf(string str)，lastIndexOf(String str);\r\n\r\n数组：\r\n\r\n- 切片： Arrays.copyOfRange(int []arry, int begin, int end)\r\n- 分割：循环遍历\r\n\r\nJava反射机制的原理与使用场景\r\n\r\n原理：核心类是 Class 类，通过获取 Class 类就可以对类进行操作，比如：调用类的某个方法、获取类的某个属性等\r\n\r\n应用场景：\r\n\r\n1、广泛运用在框架中，比如：在Spring框架中，通过Spring AOP可以实现日记录等\r\n\r\n### HTTP中的GET请求和POST请求的区别\r\n\r\nGET\r\n\r\n- 请求参数能够看见且在url后面\r\n- 数据没有加密，不安全\r\n- 适合用来获取数据\r\n\r\nPOST:\r\n\r\n- 请求参数不可见，参数在请求体中\r\n- 数据加密，安全\r\n- 适合用来保存、更新数据\r\n\r\n### 大型文件上传过程涉及到分片上传，大致思路\r\n\r\n前端将文件分为多个小片，前端根据文件生成文件的MD5值，按照分片的顺序依次上传，上传的时候需要带上分片的总数、当前分片的序号、分片的文件\r\n\r\n后端收到分片文件后，对分片的序号进行标识缓存，若当前已经上传了就不用保存，否则就保存到一个临时文件目录；等所有分片文件全部上传完成后，就进行合并，合并后需要检验合并后的MD5值是否与之前文件的MD5值是否一致，若不一致就说明上传有误，若一致，就保存到Minio或者阿里云OSS中，最后就是清除文件临时文件\r\n\r\n### 数据结构中常用的排序算法\r\n\r\n冒泡排序、归并排序、选择排序、快速排序\r\n\r\n```\r\nvoid fun(int[] num, int i, int j){\r\n\tif(i >= j) return;\r\n\tint l = i - 1, r = j + 1, mid = num[i + j >> 1];\r\n\twhile(l < r){\r\n\t\tdo l ++; while(num[l] < mid);\r\n\t\tdo r --; while(num[r] > mid);\r\n\t\tif(l < r){\r\n\t\t\tint a = num[r];\r\n\t\t\tnum[r] = num[l];\r\n\t\t\tnum[l] = a;\r\n\t\t}\r\n\t}\r\n\tfun(num, i, r);\r\n\tfun(num, r + 1, j);\r\n}\r\n\r\nfun(num, 0, len - 1);\r\n```\r\n\r\n## 后续\r\n\r\n无，什么消息都没发","title":" 双非菜鸟的第一次面试\r\n","category":[" 生活","面试\r\n"],"date":" 2024-07-02\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n 开篇\r\n\r\n职位：Java 开发实习生\r\n\r\n起因是经过学长介绍一家成都的小公司，我想的是既然是学长介绍的，那么我还是有可能面上的（虽然是第一次面试）。但因为是线下面试，距离较远（需要来回做火车和住宿），所以我得思考下才能答复学长是否能够去\r\n\r\n后面我询问了父母和朋友的意见，决定还是去面试，毕竟机会是留给有准备的人的，而且现在大环境也不好，难得有面试\r\n\r\n 准备\r\n\r\n在牛客上我找到了一篇关于该公司的笔试题目，后面会给出笔试题\r\n\r\n PS：这与我当时的笔试是一样的，算是一个小意外吧\r\n\r\n然后我根据我写的简历又重新背一遍八股，讲项目的那些技术都看了一下，不是说很熟悉，至少能够说个大概\r\n\r\n接着每天就在牛客上看面经，遇到不会的都会记录下来\r\n\r\n 出发去成都\r\n\r\n我是提前一天的去的，当天坐智轨到了高铁站，花了一将近一个小时，然后根据身份证进站，坐车到成都，又花了一个半小时\r\n\r\n到了成都，因为我是第一次到成都，所以我的第一反应就是成都真大啊，我这种土狗难得看到这种高楼建筑\r\n\r\n接着我就在腾讯地图上找附近的酒店，打算住一晚上，第二天是10点面试，所以怕来不及。最后反反复复查找，最终选了一个便宜的民宿，20多块一晚上，还要啥自信车，哈哈哈\r\n\r\n在民宿我也复习了一遍八股，把面试官可能问我的问题猜了个遍\r\n\r\n 面试\r\n\r\n当天我很早就起床了，大概7点左右，然后坐地铁，公交车，到达了公司门口，这时候大概8点半左右，因为是9点开始上班的，所以我在门口又等了一会（背了下八股），大概9点20左右我就进去面试了\r\n\r\n面试的前台小姐先是让我签到，然后就给了我一张面试题（和牛客上看到的是一样的）和一张个人信息表让我填，这里居然手机都没收，直接然我去个地方写，真不怕我百度搜啊！\r\n\r\n写完后就去三楼面试了，面试官就和聊天，没问技术相关的问题，这时候我就发现不对劲了，感觉像 kpi 面，有一个问题印象比较深刻：说说你关于线上和线下面试的看法\r\n\r\n接着面试官因为要开会，所以就让一位正在工作的研发同事问我，我感觉那位研发同事估计也是第一面试不太会问，所以就随便提出来一两个问题就结束了，没有问八股\r\n\r\n之后那个开始面试我的那个人说：不管录没录取都会给我发消息，一周之内给我答复\r\n\r\n笔试 + 面试全程大概2个小时\r\n\r\n接着我就打车回航了，和来的时候一样，坐地铁到高铁站，坐智轨回学校\r\n\r\n 附笔试题\r\n\r\n collection与collections的区别，以及一些常用类\r\n\r\nCollection 是集合接口，很多我们熟悉的比如 List、Set、Queue 都是实现的这个接口；Collections 是集合的工具类，包含很多对集合操作的方法，比如：求集合的最大和最小值、排序等。\r\n\r\n常用类：\r\n\r\nCollection:\r\n\r\n List：ArryList、LinkList\r\n Set：HashSet\r\n Queue：LinkQueue\r\n\r\nCollections：\r\n\r\n sort;\r\n max和min\r\n reverse\r\n\r\n 字符串与数组的切片、分割、获取字串等相关类与方法\r\n\r\n字符串：\r\n\r\n 切片：substringint begin, int end;\r\n 分割：splitString str, int limit\r\n 获取某个字符：charAtint index，indexOfstring str，lastIndexOfString str;\r\n\r\n数组：\r\n\r\n 切片： Arrays.copyOfRangeint arry, int begin, int end\r\n 分割：循环遍历\r\n\r\nJava反射机制的原理与使用场景\r\n\r\n原理：核心类是 Class 类，通过获取 Class 类就可以对类进行操作，比如：调用类的某个方法、获取类的某个属性等\r\n\r\n应用场景：\r\n\r\n1、广泛运用在框架中，比如：在Spring框架中，通过Spring AOP可以实现日记录等\r\n\r\n HTTP中的GET请求和POST请求的区别\r\n\r\nGET\r\n\r\n 请求参数能够看见且在url后面\r\n 数据没有加密，不安全\r\n 适合用来获取数据\r\n\r\nPOST:\r\n\r\n 请求参数不可见，参数在请求体中\r\n 数据加密，安全\r\n 适合用来保存、更新数据\r\n\r\n 大型文件上传过程涉及到分片上传，大致思路\r\n\r\n前端将文件分为多个小片，前端根据文件生成文件的MD5值，按照分片的顺序依次上传，上传的时候需要带上分片的总数、当前分片的序号、分片的文件\r\n\r\n后端收到分片文件后，对分片的序号进行标识缓存，若当前已经上传了就不用保存，否则就保存到一个临时文件目录；等所有分片文件全部上传完成后，就进行合并，合并后需要检验合并后的MD5值是否与之前文件的MD5值是否一致，若不一致就说明上传有误，若一致，就保存到Minio或者阿里云OSS中，最后就是清除文件临时文件\r\n\r\n 数据结构中常用的排序算法\r\n\r\n冒泡排序、归并排序、选择排序、快速排序\r\n\r\n\r\nvoid funint num, int i, int j{\r\n\tifi = j return;\r\n\tint l = i  1, r = j + 1, mid = numi + j  1;\r\n\twhilel < r{\r\n\t\tdo l ++; whilenuml < mid;\r\n\t\tdo r ; whilenumr  mid;\r\n\t\tifl < r{\r\n\t\t\tint a = numr;\r\n\t\t\tnumr = numl;\r\n\t\t\tnuml = a;\r\n\t\t}\r\n\t}\r\n\tfunnum, i, r;\r\n\tfunnum, r + 1, j;\r\n}\r\n\r\nfunnum, 0, len  1;\r\n\r\n\r\n 后续\r\n\r\n无，什么消息都没发"},{"filename":"rabbitmq","category":"middleware","md":{"topSummary":"\r\ntitle: RabbitMQ学习笔记\r\ncategory: RabbitMQ,中间件\r\ndate: 2024-06-27\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## 基本概念\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/sadsad.png)\r\n\r\n- virtual-host：虚拟主机（数据隔离）\r\n- publisher：生产者\r\n- consumer：消费者\r\n- queue：队列（存储消息）\r\n- exchange：交换机（路由消息）\r\n\r\n## 工作模式\r\n\r\n### 简单模式\r\n\r\n一个消费者绑定一个队列\r\n\r\n发送消息：\r\n\r\n```java\r\n@Autowired\r\nprivate RabbitTemplate rabbitTemplate;\r\n\r\n@Test\r\npublic void t1(){\r\n    rabbitTemplate.convertAndSend(\"simple.queue\", \"HelloWorld\");\r\n}\r\n```\r\n\r\n接收消息：\r\n\r\n```java\r\n@RabbitListener(queues = \"simple.queue\")\r\npublic void listenSimpleQueue(String msg){\r\n    log.info(\"收到消息：{}\", msg);\r\n}\r\n```\r\n\r\n### Work 模式\r\n\r\n多个消费者绑定一个队列，共同消费队列中的消息\r\n\r\n![](https://s11.ax1x.com/2024/01/30/pFKdfBt.png)\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t2() throws InterruptedException {\r\n    for(int i = 1; i <= 50; i++){\r\n        rabbitTemplate.convertAndSend(\"work.queue\", \"HelloWorld! Work_\" + i);\r\n        Thread.sleep(20);\r\n    }\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"work.queue\")\r\npublic void listenWorkQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n    Thread.sleep(20);\r\n}\r\n\r\n@RabbitListener(queues = \"work.queue\")\r\npublic void listenWorkQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n    Thread.sleep(200);\r\n}\r\n```\r\n\r\n这里我模拟了两个不同的处理能力消费者，消费者1的消费能力大于消费者2。若我们就直接用这个，控制台打印：\r\n\r\n```\r\n消费者1收到消息：HelloWorld! Work_1\r\n消费者2收到消息：....HelloWorld! Work_2\r\n消费者1收到消息：HelloWorld! Work_3\r\n消费者1收到消息：HelloWorld! Work_5\r\n消费者1收到消息：HelloWorld! Work_7\r\n消费者2收到消息：....HelloWorld! Work_4\r\n消费者1收到消息：HelloWorld! Work_9\r\n消费者1收到消息：HelloWorld! Work_11\r\n消费者1收到消息：HelloWorld! Work_13\r\n消费者2收到消息：....HelloWorld! Work_6\r\n消费者1收到消息：HelloWorld! Work_15\r\n消费者1收到消息：HelloWorld! Work_17\r\n消费者1收到消息：HelloWorld! Work_19\r\n消费者1收到消息：HelloWorld! Work_21\r\n消费者2收到消息：....HelloWorld! Work_8\r\n消费者1收到消息：HelloWorld! Work_23\r\n消费者1收到消息：HelloWorld! Work_25\r\n消费者1收到消息：HelloWorld! Work_27\r\n消费者2收到消息：....HelloWorld! Work_10\r\n消费者1收到消息：HelloWorld! Work_29\r\n消费者1收到消息：HelloWorld! Work_31\r\n消费者1收到消息：HelloWorld! Work_33\r\n消费者2收到消息：....HelloWorld! Work_12\r\n消费者1收到消息：HelloWorld! Work_35\r\n消费者1收到消息：HelloWorld! Work_37\r\n消费者1收到消息：HelloWorld! Work_39\r\n消费者2收到消息：....HelloWorld! Work_14\r\n消费者1收到消息：HelloWorld! Work_41\r\n消费者1收到消息：HelloWorld! Work_43\r\n消费者1收到消息：HelloWorld! Work_45\r\n消费者1收到消息：HelloWorld! Work_47\r\n消费者2收到消息：....HelloWorld! Work_16\r\n消费者1收到消息：HelloWorld! Work_49\r\n消费者2收到消息：....HelloWorld! Work_18\r\n消费者2收到消息：....HelloWorld! Work_20\r\n消费者2收到消息：....HelloWorld! Work_22\r\n消费者2收到消息：....HelloWorld! Work_24\r\n消费者2收到消息：....HelloWorld! Work_26\r\n消费者2收到消息：....HelloWorld! Work_28\r\n消费者2收到消息：....HelloWorld! Work_30\r\n消费者2收到消息：....HelloWorld! Work_32\r\n消费者2收到消息：....HelloWorld! Work_34\r\n消费者2收到消息：....HelloWorld! Work_36\r\n消费者2收到消息：....HelloWorld! Work_38\r\n消费者2收到消息：....HelloWorld! Work_40\r\n消费者2收到消息：....HelloWorld! Work_42\r\n消费者2收到消息：....HelloWorld! Work_44\r\n消费者2收到消息：....HelloWorld! Work_46\r\n消费者2收到消息：....HelloWorld! Work_48\r\n消费者2收到消息：....HelloWorld! Work_50\r\n```\r\n\r\n可以看到，消费者1和消费者2消费的数量是一样的。但是因为消费者1的消费速度大于2，所以消息很快就会被消费完，而消费者2的速度太慢，导致消息一直堆积\r\n\r\n修改代码，添加如下配置：\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n```\r\n\r\n让消费者只有在处理完当前1条消息后才能继续消费，这样执行一遍，控制台打印：\r\n\r\n```\r\n消费者1收到消息：HelloWorld! Work_1\r\n消费者2收到消息：....HelloWorld! Work_2\r\n消费者1收到消息：HelloWorld! Work_3\r\n消费者1收到消息：HelloWorld! Work_4\r\n消费者1收到消息：HelloWorld! Work_5\r\n消费者1收到消息：HelloWorld! Work_6\r\n消费者2收到消息：....HelloWorld! Work_8\r\n消费者1收到消息：HelloWorld! Work_7\r\n消费者1收到消息：HelloWorld! Work_9\r\n消费者1收到消息：HelloWorld! Work_10\r\n消费者1收到消息：HelloWorld! Work_11\r\n消费者1收到消息：HelloWorld! Work_12\r\n消费者1收到消息：HelloWorld! Work_13\r\n消费者1收到消息：HelloWorld! Work_14\r\n消费者2收到消息：....HelloWorld! Work_15\r\n消费者1收到消息：HelloWorld! Work_16\r\n消费者1收到消息：HelloWorld! Work_17\r\n消费者1收到消息：HelloWorld! Work_18\r\n消费者1收到消息：HelloWorld! Work_19\r\n消费者1收到消息：HelloWorld! Work_20\r\n消费者1收到消息：HelloWorld! Work_21\r\n消费者2收到消息：....HelloWorld! Work_23\r\n消费者1收到消息：HelloWorld! Work_22\r\n消费者1收到消息：HelloWorld! Work_24\r\n消费者1收到消息：HelloWorld! Work_25\r\n消费者1收到消息：HelloWorld! Work_26\r\n消费者1收到消息：HelloWorld! Work_27\r\n消费者1收到消息：HelloWorld! Work_28\r\n消费者1收到消息：HelloWorld! Work_29\r\n消费者1收到消息：HelloWorld! Work_30\r\n消费者2收到消息：....HelloWorld! Work_31\r\n消费者1收到消息：HelloWorld! Work_32\r\n消费者1收到消息：HelloWorld! Work_33\r\n消费者1收到消息：HelloWorld! Work_34\r\n消费者1收到消息：HelloWorld! Work_35\r\n消费者1收到消息：HelloWorld! Work_36\r\n消费者1收到消息：HelloWorld! Work_37\r\n消费者2收到消息：....HelloWorld! Work_38\r\n消费者1收到消息：HelloWorld! Work_39\r\n消费者1收到消息：HelloWorld! Work_40\r\n消费者1收到消息：HelloWorld! Work_41\r\n消费者1收到消息：HelloWorld! Work_42\r\n消费者1收到消息：HelloWorld! Work_43\r\n消费者1收到消息：HelloWorld! Work_44\r\n消费者1收到消息：HelloWorld! Work_45\r\n消费者2收到消息：....HelloWorld! Work_46\r\n消费者1收到消息：HelloWorld! Work_47\r\n消费者1收到消息：HelloWorld! Work_48\r\n消费者1收到消息：HelloWorld! Work_49\r\n消费者1收到消息：HelloWorld! Work_50\r\n```\r\n\r\n可以发现，消费者1的消费数量明显多于消费者2，达到了一种能者多劳的效果\r\n\r\n## 交换机\r\n\r\n生产环境中消息不会直接发送到队列，需要经过交换机来转发，有三种交换机类型:\r\n\r\n- Fanou：广播\r\n- Direct：定向\r\n- Topic：话题\r\n\r\n### Fanout 交换机\r\n\r\n创建一个类型为 `fanout` 交换机：`test.fanout`，绑定两个队列 `fanout.queue1` 和 `fanout.queue2`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t3(){\r\n    rabbitTemplate.convertAndSend(\"test.fanout\", null, \"HelloWorld! Fanout\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"fanout.queue1\")\r\npublic void listenFanoutQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"fanout.queue2\")\r\npublic void listenFanoutQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n控制台打印：\r\n\r\n```\r\n消费者2收到消息：....HelloWorld! Fanout\r\n消费者1收到消息：HelloWorld! Fanout\r\n```\r\n\r\n可以知道，消息通过 Fanout 交换机转发，会发送给绑定该交换机的所有队列，这就好理解广播的作用了\r\n\r\n### Direct 交换机\r\n\r\nDirect 交换机可以在 Fanout 交换机的基础上实现更复杂的业务，比如想要在广播的同时，让某些队列不接受消息\r\n\r\n创建一个交换机 `test.dirct`，绑定两个队列：`dirct.queue1` 包括 routing key：`blue `和 `red` 、`dirct.queue2` 包括 routing key：`red` 和 `yellow`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t4(){\r\n      rabbitTemplate.convertAndSend(\"test.direct\", \"red\", \"HelloWorld! Direct Red\");\r\n      rabbitTemplate.convertAndSend(\"test.direct\", \"blue\", \"HelloWorld! Direct Blue\");\r\n    rabbitTemplate.convertAndSend(\"test.direct\", \"yellow\", \"HelloWorld! Direct Yellow\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"direct.queue1\")\r\npublic void listenDirectQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"direct.queue2\")\r\npublic void listenDirectQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n有控制台打印可知：当发送消息 routing key 为 red 的时候，两者都会收到消息；当 routing key 为 blue 的时候，只有第一个消费者能够消费； routing key 为 yellow 的时候，只有第二个消费者能够消费\r\n\r\n### Topic 交换机\r\n\r\nTopic 交换机相对于 Direct 交换机，它能够在使用 routing key 的时候使用通配符表示，适用的场景更多\r\n\r\n有两种通配符，通配符通过 `.` 进行分割\r\n\r\n- #：代指0个或者多个单词\r\n- *：代指1个单词\r\n\r\n创建一个交换机 `test.queue`，绑定两个队列：`topic.queue1` 包括 routing key：`china.#`、`topic.queue2` 包括 routing key：`#.news`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t5(){\r\n      rabbitTemplate.convertAndSend(\"test.topic\", \"china.666\", \"HelloWorld! Topic china\");\r\n      rabbitTemplate.convertAndSend(\"test.topic\", \"japan.news\", \"HelloWorld! Topic 日本\");\r\n    rabbitTemplate.convertAndSend(\"test.topic\", \"china.news\", \"HelloWorld! Topic 都有\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"topic.queue1\")\r\npublic void listenTopicQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"topic.queue2\")\r\npublic void listenTopicQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n## 交换机和队列绑定\r\n\r\n有两种方式，一种是配置实现，一种是注解实现\r\n\r\n第一种当出现交换机和队列数量过多时，代码就要写很多，且绑定关系也会变得复杂，所以选择上最好选用第二种\r\n\r\n### 配置式\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/asdaklsASDjlk.png)\r\n\r\n创建一个 Fanout 交换机\r\n\r\n```java\r\n@Bean\r\npublic FanoutExchange fanoutExchange1(){\r\n    return new FanoutExchange(\"test.fanout2\");\r\n}\r\n```\r\n\r\n创建一个队列\r\n\r\n```java\r\n@Bean\r\npublic Queue fanoutQueue1(){\r\n    return new Queue(\"fanout.queue3\");\r\n}\r\n```\r\n\r\n绑定队列和交换机\r\n\r\n```java\r\n// 第一种绑定方式\r\n@Bean\r\npublic Binding binding(){\r\n    return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange1());\r\n}\r\n// 第二种绑定方式\r\n@Bean\r\npublic Binding binding(FanoutExchange fanoutExchange1, Queue fanoutQueue1){\r\n    return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange1);\r\n}\r\n\r\n// 若是有routing key\r\n@Bean\r\npublic Binding binding(DirectExchange DirectExchange1, Queue fanoutQueue1){\r\n    return BindingBuilder.bind(fanoutQueue1).to(DirectExchange1).with(\"red\");\r\n}\r\n```\r\n\r\n### 注解式\r\n\r\n参考格式\r\n\r\n```java\r\n@RabbitListener(bindings = @QueueBinding(\r\n        value = @Queue(name = \"direct.queue3\", durable = \"true\"),\r\n        exchange = @Exchange(name = \"test.direct2\", type = ExchangeTypes.DIRECT),\r\n        key = {\"red\", \"yellow\"}\r\n))\r\npublic void listenDirectQueue3(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n## 消息转化器\r\n\r\nSpring amqp 默认适用的消息转化器用的是 `SimpleMessageConverter`，当传入一个 Map 对象，因为 Map 实现了 Serializable 接口，所以会用 JDK 自带的 `(new ObjectOutputStream(stream)).writeObject(object)` 方法进行序列化，序列化的结果如下：\r\n\r\n```\r\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAAEVG9ueXQA\r\nAzEzM3QABE1pa2V0AAMyMTN4\r\n```\r\n\r\n所以需要对这个对象进行 jackson 序列化\r\n\r\n添加 yml 依赖\r\n\r\n```yaml\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n    <version>2.15.4</version>\r\n</dependency>\r\n```\r\n\r\n添加 Bean，返回 `Jackson2JsonMessageConverter`\r\n\r\n```java\r\n@Bean\r\npublic MessageConverter jackMessageConverter(){\r\n    return new Jackson2JsonMessageConverter();\r\n}\r\n```\r\n\r\n生产者\r\n\r\n```java\r\n@Test\r\npublic void t6(){\r\n    Map<String, String> res = new HashMap<>();\r\n    res.put(\"Tony\", \"133\");\r\n    res.put(\"Mike\", \"213\");\r\n    rabbitTemplate.convertAndSend(\"object.queue\", res);\r\n}\r\n```\r\n\r\n消费者\r\n\r\n```java\r\n@RabbitListener(queues = \"object.queue\")\r\npublic void listenObjectQueue(Map<String, String> msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n控制台输出\r\n\r\n```\r\n消费者收到消息：....{Tony=133, Mike=213}\r\n```\r\n\r\n可以看到，消息已经成功序列化\r\n\r\n## 消息的可靠性\r\n\r\n### 生产者可靠性\r\n\r\n#### 生产者重连\r\n\r\n由于网络波动，可能出现客户端连接 MQ 失败的情况，导致连接 MQ 失败\r\n\r\n解决：添加 yml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    # 以下配置是MQ连接超时的配置\r\n    connection-timeout: 1s # 超时连接时间\r\n    template:\r\n      retry:\r\n        enabled: true # 开启超时自动重连\r\n        initial-interval: 1000ms # 失败后的初始等待时间\r\n        multiplier: 1 # 失败后下次等待时常的倍数\r\n        max-attempts: 3 # 最大重连次数\r\n```\r\n\r\n当连接超时后，会等待1秒后再次进行重连，若3次重连后任然失败，就会抛出异常\r\n\r\n**注意**：超时重连是阻塞式的重试，也就是说重试不成功是不会执行消息发送后面的代码的\r\n\r\n#### 生产者确认\r\n\r\n有两种确认机制： Publisher Confirm 和 Publisher Return\r\n\r\n当消息发送到了 MQ，返回 ACK，否则都是 NACK\r\n\r\n添加 yml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n   \t...\r\n    # 以下是生产者消息确认\r\n    publisher-confirm-type: correlated # 开启消息确认机制，类型为异步\r\n    publisher-returns: true # 开启消息return机制，用于返回失败消息\r\n```\r\n\r\n有三种消息确认类型\r\n\r\n- none：关闭确认机制\r\n- simple：同步阻塞等待回调消息\r\n- correlated：异步回调执行回调消息\r\n\r\n添加 Confirm 配置类，需要实现 `ApplicationContextAware` 接口\r\n\r\n```java\r\n@Slf4j\r\n@Configuration\r\npublic class MqConfirmConfig implements ApplicationContextAware {\r\n    @Override\r\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\r\n        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);\r\n        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {\r\n            @Override\r\n            public void returnedMessage(ReturnedMessage message) {\r\n                log.error(\"收到消息return callback：message:{}, exchange:{}, code:{}, text:{}, routingKey:{}\",\r\n                        message.getMessage(), message.getExchange(), message.getReplyCode(),\r\n                        message.getReplyText(), message.getRoutingKey());\r\n            }\r\n        });\r\n    }\r\n}\t\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t7(){\r\n    CorrelationData cd = new CorrelationData(UUID.randomUUID().toString(true));\r\n    cd.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {\r\n        @Override\r\n        public void onFailure(Throwable ex) {\r\n            // Spring内部出现错误，与MQ无关，一般不会发生错误\r\n            log.error(\"消息回调失败：\", ex);\r\n        }\r\n\r\n        @Override\r\n        public void onSuccess(CorrelationData.Confirm result) {\r\n            if (result.isAck()){\r\n                log.info(\"消息发送成功，收到ACK\");\r\n            } else {\r\n                log.error(\"消息发送失败，收到NACK，原因：{}\", result.getReason());\r\n            }\r\n        }\r\n    });\r\n\r\n    rabbitTemplate.convertAndSend(\"test.direct\", \"yellow\", \"HelloWorld! Direct Yellow\", cd);\r\n}\r\n```\r\n\r\n此时交换机和 routing key 都是正确的，控制台打印：\r\n\r\n```\r\n消息发送成功，收到ACK\r\n```\r\n\r\n若 routing key 不正确，控制台打印：\r\n\r\n```\r\n消息发送成功，收到ACK\r\n收到消息return callback：message:(Body:'\"HelloWorld! Direct Yellow\"' MessageProperties [headers={spring_returned_message_correlation=f6a38c92958643c299b834c543a56f38, __TypeId__=java.lang.String}, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0]), exchange:test.direct, code:312, text:NO_ROUTE, routingKey:yel1low\r\n```\r\n\r\n若交换机不存在，控制台打印：\r\n\r\n```\r\n消息发送失败，收到NACK，原因：channel error; protocol method: #method<channel.close>(reply-code=404, reply-text=NOT_FOUND - no exchange 'test.direct1' in vhost '/jixer', class-id=60, method-id=40)\r\n```\r\n\r\n**注意**：在实际开发中，尽量不使用生产者确认机制（影响效率）。若一定要使用，无需开启 Publisher Return 机制，因为一般路由失败都是自己业务的问题，比如：交换机名字写出。对于 NACK 消息可以有限次数重试机，依然失败则记录异常消息\r\n\r\n### MQ 可靠性\r\n\r\n#### 数据持久化\r\n\r\n数据持久化有三个方面：\r\n\r\n- 交换机持久化\r\n- 队列持久化\r\n- 消息持久化\r\n\r\n当我们使用 SpringBoot 创建交换机、队列、消息的时候会默认使用持久化\r\n\r\n若我们不用持久化，重启一遍 RabbitMQ，这些数据就会丢失\r\n\r\n下面演示发送消息非持久化带来的问题：\r\n\r\n生产者\r\n\r\n```java\r\n@Test\r\npublic void t8(){\r\n    Message msg = MessageBuilder.withBody(\"123123\".getBytes(StandardCharsets.UTF_8))\r\n            .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)\r\n            .build();\r\n    for(int i = 0; i < 1000000; i++){\r\n        rabbitTemplate.convertAndSend(\"simple.queue\", msg);\r\n    }\r\n}\r\n```\r\n\r\n无消费者，此时观察管理页面\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/124GHDhj.png)\r\n\r\n可以看到，当消息增多，出现堆积，会造成 Page Out，MQ 会陷入短暂的阻塞，接收速度变为0，无法处理消息\r\n\r\n这是因为非持久的消息保存在内存中，MQ 会每隔一段时间当把消息存入内存，这段时间内会阻塞出现 Page Out\r\n\r\n若我们发送持久化就不会出现 Page Out 的问题\r\n\r\n#### Lazy Queue\r\n\r\nLazy Queue的特点：\r\n\r\n- 接收的消息直接存入磁盘，也就是页面显示直接在 Page Out\r\n- 消费者消费需要从磁盘读取并加载到内存中\r\n- 支持百万条消息存储\r\n\r\n**创建 Lazy Queue**\r\n\r\n配置类方式\r\n\r\n```java\r\n@Bean\r\npublic Queue lazyQueue(){\r\n    return QueueBuilder.durable(\"lazy.queue\").lazy().build();\r\n}\r\n```\r\n\r\n注解方式\r\n\r\n```java\r\n@RabbitListener(queuesToDeclare = @Queue(\r\n        name = \"lazy.queue\",\r\n        durable = \"true\",\r\n        arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")\r\n))\r\npublic void listenLazyQueue(String msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n发送100万条消息，管理页面显示：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/dHDlkjae.png)\r\n\r\n可以看到消息一直处于 Page Out，并且速率大部分时间都处于峰值\r\n\r\n### 消费者的可靠性\r\n\r\n#### 消费者确认\r\n\r\n当消费者处理完消息后，可以告知 RabbitMQ 自己消息的处理状态，有三种状态：\r\n\r\n- ACK：成功，MQ 删除消息\r\n- NACK：失败，MQ 需要再次投递消息\r\n- REJECT：失败并拒绝，MQ 删除消息（一般是出现消息格式错误）\r\n\r\n添加 yaml 依赖\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledge-mode: auto # 消费者消息确认类型\r\n```\r\n\r\n消费者确认类型有三种：\r\n\r\n- none：不做处理\r\n- manual：手动模式\r\n- auto：自动模式（默认）\r\n  - 业务异常返回 NACK\r\n  - 消息处理异常或校验异常返回 REJECT\r\n\r\n向 `simple.queue` 队列发送一条消息\r\n\r\n消费者\r\n\r\n```java\r\n@RabbitListener(queues = \"simple.queue\")\r\npublic void listenSimpleQueue(String msg) throws Exception {\r\n    log.info(\"收到消息：{}\", msg);\r\n    throw new Exception(\"故意的\");\r\n}\r\n```\r\n\r\n若选择用 none 类型：走到异常，但这段代码还没走完，消息已经消费了，消息丢失\r\n\r\n若选用 auto 类型：走到异常后，业务返回 NACK，RabbitMQ 自动重新投递，直到消费成功为止；若将传参 String 类型换成其他类型（消息格式错误），业务代码返回 REJECT，MQ 会消费并删除消息\r\n\r\n#### 消费者失败重试\r\n\r\n上面消费者确认有个问题：经过消费者确认后一直失败一直在重试，一直在消耗系统资源\r\n\r\n解决办法：添加消费者失败重试\r\n\r\n当重试次数达一定次数后就自定义重试策略\r\n\r\n有三种重试策略：\r\n\r\n- RepublishMessageRecoverer：将失败消息投递到指定的交换机处理\r\n- RejectAndDontRequeueRecoverer：直接 REJECT，丢弃消息（默认）\r\n- ImmediateRequeueMessageRecoverer：返回 NACK，消息重回入队\r\n\r\n这里选用 RepublishMessageRecoverer 策略\r\n\r\n添加 yaml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n  \t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledge-mode: auto # 消费者消息确认类型\r\n    # 以下是开启消费者失败重试机制\r\n        retry:\r\n          enabled: true\r\n          initial-interval: 1000ms # 初始失败的时长等待\r\n          multiplier: 1 # 失败后下次等待时常的倍数\r\n          max-attempts: 3 # 最大重连次数\r\n          stateless: true # true无状态，false有状态。如果业务包含事务，改为false\r\n```\r\n\r\n新建一个 ErrorConfig 配置类，用于绑定失败处理交换机和队列，并设置失败处理策略\r\n\r\n通过 `@ConditionalOnProperty` 来限制只有当 yml 配置文件中 `retry.enabled` 为 `true` 的时候才创建 Bean\r\n\r\n```java\r\n@Configuration\r\n@ConditionalOnProperty(prefix = \"spring.rabbitmq.listener.simple\", name = \"retry.enabled\", havingValue = \"true\") // 只有当前配置文件为true才创建bean\r\npublic class ErrorConfig {\r\n    @Bean\r\n    public DirectExchange errorExchange(){\r\n        return new DirectExchange(\"test.error\");\r\n    }\t\r\n    @Bean\r\n    public Queue errorQueue(){\r\n        return new Queue(\"error.queue\");\r\n    }\r\n    @Bean\r\n    public Binding binding(){\r\n        return BindingBuilder.bind(errorQueue()).to(errorExchange()).with(\"error\");\r\n    }\r\n    @Bean\r\n    public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){\r\n        return new RepublishMessageRecoverer(rabbitTemplate, \"test.error\", \"error\");\r\n    }\r\n}\r\n```\r\n\r\n在消费者代码处抛出异常，会看到当重试三次后，会将失败消息发送错误处理交换机，再由交换机转发到队列，后面由人工进行处理\r\n\r\n错误消息如下：可以看清楚的看到那块地方出错了\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/d12HSyrash.png)\r\n\r\n#### 消费者的幂等性\r\n\r\n通过上述消费者的确认和消费者的失败重试，可以保证消费者至少能够把消息消费一次，但是可能出现多次消费的情况，多次消费可能导致数据错误\r\n\r\n幂等：执行一次和执行多次对业务的结果是一样的\r\n\r\n**方案一：唯一消息 ID**\r\n\r\n给每个消息设置一个唯一的 ID，每次消费者进行消费的时候将 ID 保存入数据库，下次消费前先判断数据库是否已经存在 ID，存在就代表已经消费，否则就可以消费\r\n\r\n修改消息转化器，设置自动创建消息 ID\r\n\r\n```java\r\n@Bean\r\npublic MessageConverter jackMessageConverter(){\r\n    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();\r\n    jackson2JsonMessageConverter.setCreateMessageIds(true);\r\n    return jackson2JsonMessageConverter;\r\n}\r\n```\r\n\r\n创建后的消息如图所示：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/sadJ1.png)\r\n\r\n**方案二：业务判断**\r\n\r\n根据业务的需求来判断，比如：支付服务完成后发送消息给订单服务，订单服务需要将订单状态由未支付变为已支付，所以这里只需要对未支付的订单进行消费即可，已支付的订单不需要再次处理\r\n\r\n具体的 SQL 语句变为：\r\n\r\n```sql\r\nupdate tb_order set status = 1 where id = xxx and status = 2\r\n```\r\n\r\n只需要对数据库操作一次就满足了要求，而方案一需要对数据库进行多次操作（查询，更新）\r\n\r\n## 延迟消息\r\n\r\n### 死信交换机\r\n\r\n创建队列与交换，关系如图所示：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/asdUI1g.png)\r\n\r\n`simple.direct` 交换机绑定 `simple.queue` 队列， `simple.queue` 绑定 `dlx.direct` 死信交换机\r\n\r\n创建 `simple.queue` 的时候绑定死信交换机方法如下：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/dKLHJh.png)\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t10(){\r\n    rabbitTemplate.convertAndSend(\"simple.direct\", \"simple\", \"你好\", new MessagePostProcessor() {\r\n        @Override\r\n        public Message postProcessMessage(Message message) throws AmqpException {\r\n            message.getMessageProperties().setExpiration(\"10000\"); // 设置过期时间\r\n            return message;\r\n        }\r\n    });\r\n    log.info(\"发送消息\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"dlx.queue\")\r\npublic void listenDlxQueue(String msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n生产者发送过期时间为10s消息，消费者监听的是死信队列，并不是监听的是 `simple.queue` 这个队列\r\n\r\n因为 `simple.queue` 队列的消息没有被消费，所以当10s后消息会被发送到死信交换机，死信交换机转发到死信队列\r\n\r\n### 消息延迟插件\r\n\r\n消息延迟与死信交换机不同，它是将消息发送到交换机，在交换机中暂存一段时间后再投递到队列中\r\n\r\n插件下载地址：[rabbitmq/rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases)\r\n\r\n进入 RabbitMQ 插件目录执行以下命令开启插件\r\n\r\n```\r\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t11(){\r\n    rabbitTemplate.convertAndSend(\"delay.direct\", \"hi\", \"你好\", new MessagePostProcessor() {\r\n        @Override\r\n        public Message postProcessMessage(Message message) throws AmqpException {\r\n            message.getMessageProperties().setDelay(10000); // 设置延迟时间\r\n            return message;\r\n        }\r\n    });\r\n    log.info(\"发送消息\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(bindings = @QueueBinding(\r\n        value = @Queue(name = \"delay.queue\", durable = \"true\"),\r\n        exchange = @Exchange(name = \"delay.direct\", delayed = \"true\"),\r\n        key = {\"hi\", \"hello\"}\r\n))\r\npublic void listenDelayQueue(String msg) throws InterruptedException {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\nRabbitMQ 的延迟消息是有一定的功能损耗的，所以适用于延迟时间不太长的场景\r\n\r\n在一般的超时订单场景中，若设置的超时时间为30分钟，会存在两个问题：\r\n\r\n- 若并发高，30分钟可能堆积消息过多，MQ 压力大\r\n- 大多数订单在下单后1分钟内就会支付，但是 MQ 却需要等待30分钟，浪费资源\r\n\r\n解决方法：设置消息过期时间梯度数组，将30分钟拆分为多个小部分，每个部分个根据可能支付的概率选用合适的等大时间\r\n","title":" RabbitMQ学习笔记\r\n","category":[" RabbitMQ","中间件\r\n"],"date":" 2024-06-27\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n 基本概念\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/sadsad.png\r\n\r\n virtualhost：虚拟主机（数据隔离）\r\n publisher：生产者\r\n consumer：消费者\r\n queue：队列（存储消息）\r\n exchange：交换机（路由消息）\r\n\r\n 工作模式\r\n\r\n 简单模式\r\n\r\n一个消费者绑定一个队列\r\n\r\n发送消息：\r\n\r\njava\r\n@Autowired\r\nprivate RabbitTemplate rabbitTemplate;\r\n\r\n@Test\r\npublic void t1{\r\n    rabbitTemplate.convertAndSend\"simple.queue\", \"HelloWorld\";\r\n}\r\n\r\n\r\n接收消息：\r\n\r\njava\r\n@RabbitListenerqueues = \"simple.queue\"\r\npublic void listenSimpleQueueString msg{\r\n    log.info\"收到消息：{}\", msg;\r\n}\r\n\r\n\r\n Work 模式\r\n\r\n多个消费者绑定一个队列，共同消费队列中的消息\r\n\r\nhttps://s11.ax1x.com/2024/01/30/pFKdfBt.png\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t2 throws InterruptedException {\r\n    forint i = 1; i <= 50; i++{\r\n        rabbitTemplate.convertAndSend\"work.queue\", \"HelloWorld Work\" + i;\r\n        Thread.sleep20;\r\n    }\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"work.queue\"\r\npublic void listenWorkQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n    Thread.sleep20;\r\n}\r\n\r\n@RabbitListenerqueues = \"work.queue\"\r\npublic void listenWorkQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n    Thread.sleep200;\r\n}\r\n\r\n\r\n这里我模拟了两个不同的处理能力消费者，消费者1的消费能力大于消费者2。若我们就直接用这个，控制台打印：\r\n\r\n\r\n消费者1收到消息：HelloWorld Work1\r\n消费者2收到消息：....HelloWorld Work2\r\n消费者1收到消息：HelloWorld Work3\r\n消费者1收到消息：HelloWorld Work5\r\n消费者1收到消息：HelloWorld Work7\r\n消费者2收到消息：....HelloWorld Work4\r\n消费者1收到消息：HelloWorld Work9\r\n消费者1收到消息：HelloWorld Work11\r\n消费者1收到消息：HelloWorld Work13\r\n消费者2收到消息：....HelloWorld Work6\r\n消费者1收到消息：HelloWorld Work15\r\n消费者1收到消息：HelloWorld Work17\r\n消费者1收到消息：HelloWorld Work19\r\n消费者1收到消息：HelloWorld Work21\r\n消费者2收到消息：....HelloWorld Work8\r\n消费者1收到消息：HelloWorld Work23\r\n消费者1收到消息：HelloWorld Work25\r\n消费者1收到消息：HelloWorld Work27\r\n消费者2收到消息：....HelloWorld Work10\r\n消费者1收到消息：HelloWorld Work29\r\n消费者1收到消息：HelloWorld Work31\r\n消费者1收到消息：HelloWorld Work33\r\n消费者2收到消息：....HelloWorld Work12\r\n消费者1收到消息：HelloWorld Work35\r\n消费者1收到消息：HelloWorld Work37\r\n消费者1收到消息：HelloWorld Work39\r\n消费者2收到消息：....HelloWorld Work14\r\n消费者1收到消息：HelloWorld Work41\r\n消费者1收到消息：HelloWorld Work43\r\n消费者1收到消息：HelloWorld Work45\r\n消费者1收到消息：HelloWorld Work47\r\n消费者2收到消息：....HelloWorld Work16\r\n消费者1收到消息：HelloWorld Work49\r\n消费者2收到消息：....HelloWorld Work18\r\n消费者2收到消息：....HelloWorld Work20\r\n消费者2收到消息：....HelloWorld Work22\r\n消费者2收到消息：....HelloWorld Work24\r\n消费者2收到消息：....HelloWorld Work26\r\n消费者2收到消息：....HelloWorld Work28\r\n消费者2收到消息：....HelloWorld Work30\r\n消费者2收到消息：....HelloWorld Work32\r\n消费者2收到消息：....HelloWorld Work34\r\n消费者2收到消息：....HelloWorld Work36\r\n消费者2收到消息：....HelloWorld Work38\r\n消费者2收到消息：....HelloWorld Work40\r\n消费者2收到消息：....HelloWorld Work42\r\n消费者2收到消息：....HelloWorld Work44\r\n消费者2收到消息：....HelloWorld Work46\r\n消费者2收到消息：....HelloWorld Work48\r\n消费者2收到消息：....HelloWorld Work50\r\n\r\n\r\n可以看到，消费者1和消费者2消费的数量是一样的。但是因为消费者1的消费速度大于2，所以消息很快就会被消费完，而消费者2的速度太慢，导致消息一直堆积\r\n\r\n修改代码，添加如下配置：\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n    listener:\r\n      simple:\r\n        prefetch: 1  每次只能领取一条消息，处理完才能获取一下条消息\r\n\r\n\r\n让消费者只有在处理完当前1条消息后才能继续消费，这样执行一遍，控制台打印：\r\n\r\n\r\n消费者1收到消息：HelloWorld Work1\r\n消费者2收到消息：....HelloWorld Work2\r\n消费者1收到消息：HelloWorld Work3\r\n消费者1收到消息：HelloWorld Work4\r\n消费者1收到消息：HelloWorld Work5\r\n消费者1收到消息：HelloWorld Work6\r\n消费者2收到消息：....HelloWorld Work8\r\n消费者1收到消息：HelloWorld Work7\r\n消费者1收到消息：HelloWorld Work9\r\n消费者1收到消息：HelloWorld Work10\r\n消费者1收到消息：HelloWorld Work11\r\n消费者1收到消息：HelloWorld Work12\r\n消费者1收到消息：HelloWorld Work13\r\n消费者1收到消息：HelloWorld Work14\r\n消费者2收到消息：....HelloWorld Work15\r\n消费者1收到消息：HelloWorld Work16\r\n消费者1收到消息：HelloWorld Work17\r\n消费者1收到消息：HelloWorld Work18\r\n消费者1收到消息：HelloWorld Work19\r\n消费者1收到消息：HelloWorld Work20\r\n消费者1收到消息：HelloWorld Work21\r\n消费者2收到消息：....HelloWorld Work23\r\n消费者1收到消息：HelloWorld Work22\r\n消费者1收到消息：HelloWorld Work24\r\n消费者1收到消息：HelloWorld Work25\r\n消费者1收到消息：HelloWorld Work26\r\n消费者1收到消息：HelloWorld Work27\r\n消费者1收到消息：HelloWorld Work28\r\n消费者1收到消息：HelloWorld Work29\r\n消费者1收到消息：HelloWorld Work30\r\n消费者2收到消息：....HelloWorld Work31\r\n消费者1收到消息：HelloWorld Work32\r\n消费者1收到消息：HelloWorld Work33\r\n消费者1收到消息：HelloWorld Work34\r\n消费者1收到消息：HelloWorld Work35\r\n消费者1收到消息：HelloWorld Work36\r\n消费者1收到消息：HelloWorld Work37\r\n消费者2收到消息：....HelloWorld Work38\r\n消费者1收到消息：HelloWorld Work39\r\n消费者1收到消息：HelloWorld Work40\r\n消费者1收到消息：HelloWorld Work41\r\n消费者1收到消息：HelloWorld Work42\r\n消费者1收到消息：HelloWorld Work43\r\n消费者1收到消息：HelloWorld Work44\r\n消费者1收到消息：HelloWorld Work45\r\n消费者2收到消息：....HelloWorld Work46\r\n消费者1收到消息：HelloWorld Work47\r\n消费者1收到消息：HelloWorld Work48\r\n消费者1收到消息：HelloWorld Work49\r\n消费者1收到消息：HelloWorld Work50\r\n\r\n\r\n可以发现，消费者1的消费数量明显多于消费者2，达到了一种能者多劳的效果\r\n\r\n 交换机\r\n\r\n生产环境中消息不会直接发送到队列，需要经过交换机来转发，有三种交换机类型:\r\n\r\n Fanou：广播\r\n Direct：定向\r\n Topic：话题\r\n\r\n Fanout 交换机\r\n\r\n创建一个类型为 fanout 交换机：test.fanout，绑定两个队列 fanout.queue1 和 fanout.queue2\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t3{\r\n    rabbitTemplate.convertAndSend\"test.fanout\", null, \"HelloWorld Fanout\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"fanout.queue1\"\r\npublic void listenFanoutQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n}\r\n\r\n@RabbitListenerqueues = \"fanout.queue2\"\r\npublic void listenFanoutQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n控制台打印：\r\n\r\n\r\n消费者2收到消息：....HelloWorld Fanout\r\n消费者1收到消息：HelloWorld Fanout\r\n\r\n\r\n可以知道，消息通过 Fanout 交换机转发，会发送给绑定该交换机的所有队列，这就好理解广播的作用了\r\n\r\n Direct 交换机\r\n\r\nDirect 交换机可以在 Fanout 交换机的基础上实现更复杂的业务，比如想要在广播的同时，让某些队列不接受消息\r\n\r\n创建一个交换机 test.dirct，绑定两个队列：dirct.queue1 包括 routing key：blue 和 red 、dirct.queue2 包括 routing key：red 和 yellow\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t4{\r\n      rabbitTemplate.convertAndSend\"test.direct\", \"red\", \"HelloWorld Direct Red\";\r\n      rabbitTemplate.convertAndSend\"test.direct\", \"blue\", \"HelloWorld Direct Blue\";\r\n    rabbitTemplate.convertAndSend\"test.direct\", \"yellow\", \"HelloWorld Direct Yellow\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"direct.queue1\"\r\npublic void listenDirectQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n}\r\n\r\n@RabbitListenerqueues = \"direct.queue2\"\r\npublic void listenDirectQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n有控制台打印可知：当发送消息 routing key 为 red 的时候，两者都会收到消息；当 routing key 为 blue 的时候，只有第一个消费者能够消费； routing key 为 yellow 的时候，只有第二个消费者能够消费\r\n\r\n Topic 交换机\r\n\r\nTopic 交换机相对于 Direct 交换机，它能够在使用 routing key 的时候使用通配符表示，适用的场景更多\r\n\r\n有两种通配符，通配符通过 . 进行分割\r\n\r\n ：代指0个或者多个单词\r\n ：代指1个单词\r\n\r\n创建一个交换机 test.queue，绑定两个队列：topic.queue1 包括 routing key：china.、topic.queue2 包括 routing key：.news\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t5{\r\n      rabbitTemplate.convertAndSend\"test.topic\", \"china.666\", \"HelloWorld Topic china\";\r\n      rabbitTemplate.convertAndSend\"test.topic\", \"japan.news\", \"HelloWorld Topic 日本\";\r\n    rabbitTemplate.convertAndSend\"test.topic\", \"china.news\", \"HelloWorld Topic 都有\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"topic.queue1\"\r\npublic void listenTopicQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n}\r\n\r\n@RabbitListenerqueues = \"topic.queue2\"\r\npublic void listenTopicQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n 交换机和队列绑定\r\n\r\n有两种方式，一种是配置实现，一种是注解实现\r\n\r\n第一种当出现交换机和队列数量过多时，代码就要写很多，且绑定关系也会变得复杂，所以选择上最好选用第二种\r\n\r\n 配置式\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/asdaklsASDjlk.png\r\n\r\n创建一个 Fanout 交换机\r\n\r\njava\r\n@Bean\r\npublic FanoutExchange fanoutExchange1{\r\n    return new FanoutExchange\"test.fanout2\";\r\n}\r\n\r\n\r\n创建一个队列\r\n\r\njava\r\n@Bean\r\npublic Queue fanoutQueue1{\r\n    return new Queue\"fanout.queue3\";\r\n}\r\n\r\n\r\n绑定队列和交换机\r\n\r\njava\r\n// 第一种绑定方式\r\n@Bean\r\npublic Binding binding{\r\n    return BindingBuilder.bindfanoutQueue1.tofanoutExchange1;\r\n}\r\n// 第二种绑定方式\r\n@Bean\r\npublic Binding bindingFanoutExchange fanoutExchange1, Queue fanoutQueue1{\r\n    return BindingBuilder.bindfanoutQueue1.tofanoutExchange1;\r\n}\r\n\r\n// 若是有routing key\r\n@Bean\r\npublic Binding bindingDirectExchange DirectExchange1, Queue fanoutQueue1{\r\n    return BindingBuilder.bindfanoutQueue1.toDirectExchange1.with\"red\";\r\n}\r\n\r\n\r\n 注解式\r\n\r\n参考格式\r\n\r\njava\r\n@RabbitListenerbindings = @QueueBinding\r\n        value = @Queuename = \"direct.queue3\", durable = \"true\",\r\n        exchange = @Exchangename = \"test.direct2\", type = ExchangeTypes.DIRECT,\r\n        key = {\"red\", \"yellow\"}\r\n\r\npublic void listenDirectQueue3String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n 消息转化器\r\n\r\nSpring amqp 默认适用的消息转化器用的是 SimpleMessageConverter，当传入一个 Map 对象，因为 Map 实现了 Serializable 接口，所以会用 JDK 自带的 new ObjectOutputStreamstream.writeObjectobject 方法进行序列化，序列化的结果如下：\r\n\r\n\r\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAAEVG9ueXQA\r\nAzEzM3QABE1pa2V0AAMyMTN4\r\n\r\n\r\n所以需要对这个对象进行 jackson 序列化\r\n\r\n添加 yml 依赖\r\n\r\nyaml\r\n<dependency\r\n    <groupIdcom.fasterxml.jackson.core</groupId\r\n    <artifactIdjacksondatabind</artifactId\r\n    <version2.15.4</version\r\n</dependency\r\n\r\n\r\n添加 Bean，返回 Jackson2JsonMessageConverter\r\n\r\njava\r\n@Bean\r\npublic MessageConverter jackMessageConverter{\r\n    return new Jackson2JsonMessageConverter;\r\n}\r\n\r\n\r\n生产者\r\n\r\njava\r\n@Test\r\npublic void t6{\r\n    Map<String, String res = new HashMap<;\r\n    res.put\"Tony\", \"133\";\r\n    res.put\"Mike\", \"213\";\r\n    rabbitTemplate.convertAndSend\"object.queue\", res;\r\n}\r\n\r\n\r\n消费者\r\n\r\njava\r\n@RabbitListenerqueues = \"object.queue\"\r\npublic void listenObjectQueueMap<String, String msg {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n控制台输出\r\n\r\n\r\n消费者收到消息：....{Tony=133, Mike=213}\r\n\r\n\r\n可以看到，消息已经成功序列化\r\n\r\n 消息的可靠性\r\n\r\n 生产者可靠性\r\n\r\n 生产者重连\r\n\r\n由于网络波动，可能出现客户端连接 MQ 失败的情况，导致连接 MQ 失败\r\n\r\n解决：添加 yml 配置\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n     以下配置是MQ连接超时的配置\r\n    connectiontimeout: 1s  超时连接时间\r\n    template:\r\n      retry:\r\n        enabled: true  开启超时自动重连\r\n        initialinterval: 1000ms  失败后的初始等待时间\r\n        multiplier: 1  失败后下次等待时常的倍数\r\n        maxattempts: 3  最大重连次数\r\n\r\n\r\n当连接超时后，会等待1秒后再次进行重连，若3次重连后任然失败，就会抛出异常\r\n\r\n注意：超时重连是阻塞式的重试，也就是说重试不成功是不会执行消息发送后面的代码的\r\n\r\n 生产者确认\r\n\r\n有两种确认机制： Publisher Confirm 和 Publisher Return\r\n\r\n当消息发送到了 MQ，返回 ACK，否则都是 NACK\r\n\r\n添加 yml 配置\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n   \t...\r\n     以下是生产者消息确认\r\n    publisherconfirmtype: correlated  开启消息确认机制，类型为异步\r\n    publisherreturns: true  开启消息return机制，用于返回失败消息\r\n\r\n\r\n有三种消息确认类型\r\n\r\n none：关闭确认机制\r\n simple：同步阻塞等待回调消息\r\n correlated：异步回调执行回调消息\r\n\r\n添加 Confirm 配置类，需要实现 ApplicationContextAware 接口\r\n\r\njava\r\n@Slf4j\r\n@Configuration\r\npublic class MqConfirmConfig implements ApplicationContextAware {\r\n    @Override\r\n    public void setApplicationContextApplicationContext applicationContext throws BeansException {\r\n        RabbitTemplate rabbitTemplate = applicationContext.getBeanRabbitTemplate.class;\r\n        rabbitTemplate.setReturnsCallbacknew RabbitTemplate.ReturnsCallback {\r\n            @Override\r\n            public void returnedMessageReturnedMessage message {\r\n                log.error\"收到消息return callback：message:{}, exchange:{}, code:{}, text:{}, routingKey:{}\",\r\n                        message.getMessage, message.getExchange, message.getReplyCode,\r\n                        message.getReplyText, message.getRoutingKey;\r\n            }\r\n        };\r\n    }\r\n}\t\r\n\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t7{\r\n    CorrelationData cd = new CorrelationDataUUID.randomUUID.toStringtrue;\r\n    cd.getFuture.addCallbacknew ListenableFutureCallback<CorrelationData.Confirm {\r\n        @Override\r\n        public void onFailureThrowable ex {\r\n            // Spring内部出现错误，与MQ无关，一般不会发生错误\r\n            log.error\"消息回调失败：\", ex;\r\n        }\r\n\r\n        @Override\r\n        public void onSuccessCorrelationData.Confirm result {\r\n            if result.isAck{\r\n                log.info\"消息发送成功，收到ACK\";\r\n            } else {\r\n                log.error\"消息发送失败，收到NACK，原因：{}\", result.getReason;\r\n            }\r\n        }\r\n    };\r\n\r\n    rabbitTemplate.convertAndSend\"test.direct\", \"yellow\", \"HelloWorld Direct Yellow\", cd;\r\n}\r\n\r\n\r\n此时交换机和 routing key 都是正确的，控制台打印：\r\n\r\n\r\n消息发送成功，收到ACK\r\n\r\n\r\n若 routing key 不正确，控制台打印：\r\n\r\n\r\n消息发送成功，收到ACK\r\n收到消息return callback：message:Body:'\"HelloWorld Direct Yellow\"' MessageProperties headers={springreturnedmessagecorrelation=f6a38c92958643c299b834c543a56f38, TypeId=java.lang.String}, contentType=application/json, contentEncoding=UTF8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0, exchange:test.direct, code:312, text:NOROUTE, routingKey:yel1low\r\n\r\n\r\n若交换机不存在，控制台打印：\r\n\r\n\r\n消息发送失败，收到NACK，原因：channel error; protocol method: method<channel.closereplycode=404, replytext=NOTFOUND  no exchange 'test.direct1' in vhost '/jixer', classid=60, methodid=40\r\n\r\n\r\n注意：在实际开发中，尽量不使用生产者确认机制（影响效率）。若一定要使用，无需开启 Publisher Return 机制，因为一般路由失败都是自己业务的问题，比如：交换机名字写出。对于 NACK 消息可以有限次数重试机，依然失败则记录异常消息\r\n\r\n MQ 可靠性\r\n\r\n 数据持久化\r\n\r\n数据持久化有三个方面：\r\n\r\n 交换机持久化\r\n 队列持久化\r\n 消息持久化\r\n\r\n当我们使用 SpringBoot 创建交换机、队列、消息的时候会默认使用持久化\r\n\r\n若我们不用持久化，重启一遍 RabbitMQ，这些数据就会丢失\r\n\r\n下面演示发送消息非持久化带来的问题：\r\n\r\n生产者\r\n\r\njava\r\n@Test\r\npublic void t8{\r\n    Message msg = MessageBuilder.withBody\"123123\".getBytesStandardCharsets.UTF8\r\n            .setDeliveryModeMessageDeliveryMode.NONPERSISTENT\r\n            .build;\r\n    forint i = 0; i < 1000000; i++{\r\n        rabbitTemplate.convertAndSend\"simple.queue\", msg;\r\n    }\r\n}\r\n\r\n\r\n无消费者，此时观察管理页面\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/124GHDhj.png\r\n\r\n可以看到，当消息增多，出现堆积，会造成 Page Out，MQ 会陷入短暂的阻塞，接收速度变为0，无法处理消息\r\n\r\n这是因为非持久的消息保存在内存中，MQ 会每隔一段时间当把消息存入内存，这段时间内会阻塞出现 Page Out\r\n\r\n若我们发送持久化就不会出现 Page Out 的问题\r\n\r\n Lazy Queue\r\n\r\nLazy Queue的特点：\r\n\r\n 接收的消息直接存入磁盘，也就是页面显示直接在 Page Out\r\n 消费者消费需要从磁盘读取并加载到内存中\r\n 支持百万条消息存储\r\n\r\n创建 Lazy Queue\r\n\r\n配置类方式\r\n\r\njava\r\n@Bean\r\npublic Queue lazyQueue{\r\n    return QueueBuilder.durable\"lazy.queue\".lazy.build;\r\n}\r\n\r\n\r\n注解方式\r\n\r\njava\r\n@RabbitListenerqueuesToDeclare = @Queue\r\n        name = \"lazy.queue\",\r\n        durable = \"true\",\r\n        arguments = @Argumentname = \"xqueuemode\", value = \"lazy\"\r\n\r\npublic void listenLazyQueueString msg {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n发送100万条消息，管理页面显示：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/dHDlkjae.png\r\n\r\n可以看到消息一直处于 Page Out，并且速率大部分时间都处于峰值\r\n\r\n 消费者的可靠性\r\n\r\n 消费者确认\r\n\r\n当消费者处理完消息后，可以告知 RabbitMQ 自己消息的处理状态，有三种状态：\r\n\r\n ACK：成功，MQ 删除消息\r\n NACK：失败，MQ 需要再次投递消息\r\n REJECT：失败并拒绝，MQ 删除消息（一般是出现消息格式错误）\r\n\r\n添加 yaml 依赖\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1  每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledgemode: auto  消费者消息确认类型\r\n\r\n\r\n消费者确认类型有三种：\r\n\r\n none：不做处理\r\n manual：手动模式\r\n auto：自动模式（默认）\r\n   业务异常返回 NACK\r\n   消息处理异常或校验异常返回 REJECT\r\n\r\n向 simple.queue 队列发送一条消息\r\n\r\n消费者\r\n\r\njava\r\n@RabbitListenerqueues = \"simple.queue\"\r\npublic void listenSimpleQueueString msg throws Exception {\r\n    log.info\"收到消息：{}\", msg;\r\n    throw new Exception\"故意的\";\r\n}\r\n\r\n\r\n若选择用 none 类型：走到异常，但这段代码还没走完，消息已经消费了，消息丢失\r\n\r\n若选用 auto 类型：走到异常后，业务返回 NACK，RabbitMQ 自动重新投递，直到消费成功为止；若将传参 String 类型换成其他类型（消息格式错误），业务代码返回 REJECT，MQ 会消费并删除消息\r\n\r\n 消费者失败重试\r\n\r\n上面消费者确认有个问题：经过消费者确认后一直失败一直在重试，一直在消耗系统资源\r\n\r\n解决办法：添加消费者失败重试\r\n\r\n当重试次数达一定次数后就自定义重试策略\r\n\r\n有三种重试策略：\r\n\r\n RepublishMessageRecoverer：将失败消息投递到指定的交换机处理\r\n RejectAndDontRequeueRecoverer：直接 REJECT，丢弃消息（默认）\r\n ImmediateRequeueMessageRecoverer：返回 NACK，消息重回入队\r\n\r\n这里选用 RepublishMessageRecoverer 策略\r\n\r\n添加 yaml 配置\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n  \t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1  每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledgemode: auto  消费者消息确认类型\r\n     以下是开启消费者失败重试机制\r\n        retry:\r\n          enabled: true\r\n          initialinterval: 1000ms  初始失败的时长等待\r\n          multiplier: 1  失败后下次等待时常的倍数\r\n          maxattempts: 3  最大重连次数\r\n          stateless: true  true无状态，false有状态。如果业务包含事务，改为false\r\n\r\n\r\n新建一个 ErrorConfig 配置类，用于绑定失败处理交换机和队列，并设置失败处理策略\r\n\r\n通过 @ConditionalOnProperty 来限制只有当 yml 配置文件中 retry.enabled 为 true 的时候才创建 Bean\r\n\r\njava\r\n@Configuration\r\n@ConditionalOnPropertyprefix = \"spring.rabbitmq.listener.simple\", name = \"retry.enabled\", havingValue = \"true\" // 只有当前配置文件为true才创建bean\r\npublic class ErrorConfig {\r\n    @Bean\r\n    public DirectExchange errorExchange{\r\n        return new DirectExchange\"test.error\";\r\n    }\t\r\n    @Bean\r\n    public Queue errorQueue{\r\n        return new Queue\"error.queue\";\r\n    }\r\n    @Bean\r\n    public Binding binding{\r\n        return BindingBuilder.binderrorQueue.toerrorExchange.with\"error\";\r\n    }\r\n    @Bean\r\n    public MessageRecoverer messageRecovererRabbitTemplate rabbitTemplate{\r\n        return new RepublishMessageRecovererrabbitTemplate, \"test.error\", \"error\";\r\n    }\r\n}\r\n\r\n\r\n在消费者代码处抛出异常，会看到当重试三次后，会将失败消息发送错误处理交换机，再由交换机转发到队列，后面由人工进行处理\r\n\r\n错误消息如下：可以看清楚的看到那块地方出错了\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/d12HSyrash.png\r\n\r\n 消费者的幂等性\r\n\r\n通过上述消费者的确认和消费者的失败重试，可以保证消费者至少能够把消息消费一次，但是可能出现多次消费的情况，多次消费可能导致数据错误\r\n\r\n幂等：执行一次和执行多次对业务的结果是一样的\r\n\r\n方案一：唯一消息 ID\r\n\r\n给每个消息设置一个唯一的 ID，每次消费者进行消费的时候将 ID 保存入数据库，下次消费前先判断数据库是否已经存在 ID，存在就代表已经消费，否则就可以消费\r\n\r\n修改消息转化器，设置自动创建消息 ID\r\n\r\njava\r\n@Bean\r\npublic MessageConverter jackMessageConverter{\r\n    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter;\r\n    jackson2JsonMessageConverter.setCreateMessageIdstrue;\r\n    return jackson2JsonMessageConverter;\r\n}\r\n\r\n\r\n创建后的消息如图所示：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/sadJ1.png\r\n\r\n方案二：业务判断\r\n\r\n根据业务的需求来判断，比如：支付服务完成后发送消息给订单服务，订单服务需要将订单状态由未支付变为已支付，所以这里只需要对未支付的订单进行消费即可，已支付的订单不需要再次处理\r\n\r\n具体的 SQL 语句变为：\r\n\r\nsql\r\nupdate tborder set status = 1 where id = xxx and status = 2\r\n\r\n\r\n只需要对数据库操作一次就满足了要求，而方案一需要对数据库进行多次操作（查询，更新）\r\n\r\n 延迟消息\r\n\r\n 死信交换机\r\n\r\n创建队列与交换，关系如图所示：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/asdUI1g.png\r\n\r\nsimple.direct 交换机绑定 simple.queue 队列， simple.queue 绑定 dlx.direct 死信交换机\r\n\r\n创建 simple.queue 的时候绑定死信交换机方法如下：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/dKLHJh.png\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t10{\r\n    rabbitTemplate.convertAndSend\"simple.direct\", \"simple\", \"你好\", new MessagePostProcessor {\r\n        @Override\r\n        public Message postProcessMessageMessage message throws AmqpException {\r\n            message.getMessageProperties.setExpiration\"10000\"; // 设置过期时间\r\n            return message;\r\n        }\r\n    };\r\n    log.info\"发送消息\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"dlx.queue\"\r\npublic void listenDlxQueueString msg {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n生产者发送过期时间为10s消息，消费者监听的是死信队列，并不是监听的是 simple.queue 这个队列\r\n\r\n因为 simple.queue 队列的消息没有被消费，所以当10s后消息会被发送到死信交换机，死信交换机转发到死信队列\r\n\r\n 消息延迟插件\r\n\r\n消息延迟与死信交换机不同，它是将消息发送到交换机，在交换机中暂存一段时间后再投递到队列中\r\n\r\n插件下载地址：rabbitmq/rabbitmqdelayedmessageexchangehttps://github.com/rabbitmq/rabbitmqdelayedmessageexchange/releases\r\n\r\n进入 RabbitMQ 插件目录执行以下命令开启插件\r\n\r\n\r\nrabbitmqplugins enable rabbitmqdelayedmessageexchange\r\n\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t11{\r\n    rabbitTemplate.convertAndSend\"delay.direct\", \"hi\", \"你好\", new MessagePostProcessor {\r\n        @Override\r\n        public Message postProcessMessageMessage message throws AmqpException {\r\n            message.getMessageProperties.setDelay10000; // 设置延迟时间\r\n            return message;\r\n        }\r\n    };\r\n    log.info\"发送消息\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerbindings = @QueueBinding\r\n        value = @Queuename = \"delay.queue\", durable = \"true\",\r\n        exchange = @Exchangename = \"delay.direct\", delayed = \"true\",\r\n        key = {\"hi\", \"hello\"}\r\n\r\npublic void listenDelayQueueString msg throws InterruptedException {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\nRabbitMQ 的延迟消息是有一定的功能损耗的，所以适用于延迟时间不太长的场景\r\n\r\n在一般的超时订单场景中，若设置的超时时间为30分钟，会存在两个问题：\r\n\r\n 若并发高，30分钟可能堆积消息过多，MQ 压力大\r\n 大多数订单在下单后1分钟内就会支付，但是 MQ 却需要等待30分钟，浪费资源\r\n\r\n解决方法：设置消息过期时间梯度数组，将30分钟拆分为多个小部分，每个部分个根据可能支付的概率选用合适的等大时间\r\n"},{"filename":"springsecurity-perms-control","category":"java","md":{"topSummary":"\ntitle: SpringSecurity权限控制\ncategory: Java,SpringCloud\ndate: 2024-06-18\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 前置说明\n\n必备知识：SpringSecurity 的使用\n\n提前准备：5个基本表（权限表、角色表、菜单表、角色权限表、角色菜单表），为了方便这里是展示必须的操作，数据库的操作返回的数据是直接模拟的\n\n## 步骤\n\n### 自定义登录逻辑\n\n加入 jar 包我们什么都不做，启动项目，访问任何接口会默认跳转到一个登录页面。我们现在需要做的就是不让他显示这个页面并且通过我们自己定义的登录接口实现认证\n\n定义 `SecurityConfig` 配置类，用来管理整个安全配置\n\n首先修改一下 `configure(HttpSecurity http)` 方法\n\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http\n            // CSRF禁用，因为不使用session\n            .csrf().disable()\n            // 禁用HTTP响应标头\n            .headers().cacheControl().disable().and()\n            // 基于token，所以不需要session\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n            // 过滤请求\n            .authorizeRequests()\n            // 对于登录login 注册register 验证码captchaImage 允许匿名访问\n            .antMatchers(\"/auth/login\", \"/auth/register\").permitAll()\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest().authenticated()\n            .and()\n            .headers().frameOptions().disable();\n}\n```\n\n开放 `/auth/login` 登录接口，自定义 AuthenticationManager 的建造器，并确定加密算法为 `BCryptPasswordEncoder` ，这个加密算法可以替换为 MD5 加密\n\n```java\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\n    auth.userDetailsService(customUserDetailService).passwordEncoder(new BCryptPasswordEncoder());\n}\n```\n\n注入 AuthenticationManager Bean，目的是为了让我们在自己的接口调用 `authenticationManager.authenticate()` 方法进行验证\n\n```java\n@Bean\n@Override\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n```\n\n下面写自己的登录接口，在登陆方法中调用 `authenticationManager.authenticate` 来实现验证，而调用这个方法会调用我们自定义实现的 `CustomUserDetailService` 类的 `loadUserByUsername` 方法\n\n```java\n@Autowired\nprivate AuthenticationManager authenticationManager;\n\n@Override\npublic String login(LoginForm loginForm) {\n    // 若有其他检验项也需要检查\n    Authentication authentication = null;\n    try {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginForm.getUsername(), loginForm.getPassword());\n        UserHolder.setContext(authenticationToken);\n        // 这里会调用 UserDetailService 接口的 loadUserByUsername 方法\n        authentication = authenticationManager.authenticate(authenticationToken);\n    } catch (Exception e){\n        e.printStackTrace();\n    } finally {\n        UserHolder.clearContext();\n    }\n    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n\n    return JwtUtil.createToken(loginUser.getUsername());\n}\n```\n\n自定义 `CustomUserDetailService` 类，实现 `UserDetailsService` 接口，为了让登录验证走我们自己的验证逻辑，判断账号密码，从而生成 Token\n\n注：这里的查询用户拥有的权限是模拟的，真实项目需要联表查询数据库\n\n```java\n@Service\npublic class CustomUserDetailService implements UserDetailsService{\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // 检验账号状态\n        // 查询数据库检验账户密码的正确性\n        // ...\n\n        Authentication context = UserHolder.getContext();\n        return new LoginUser(new User(context.getName(), new BCryptPasswordEncoder().encode(context.getCredentials().toString())),\n                getPermsList());\n    }\n\n    /**\n     * 模拟用户拥有的权限\n     * @return\n     */\n    private Set<String> getPermsList() {\n        Set<String> res = new HashSet<>();\n        res.add(\"user:t1\");\n        res.add(\"user:t2\");\n\n        return res;\n    }\n}\n```\n\n### 自定义认证失败处理\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n\n// 认证失败处理类\nhttp.exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint).and() \n```\n\n`CustomAuthenticationEntryPoint` 类就是我们自定义的认证失败的逻辑处理类，我们可以通过 response 返回失败的 Json 数据\n\n```java\n@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setStatus(HttpStatus.UNAUTHORIZED.value());\n        response.setContentType(\"application/json\");\n        response.setCharacterEncoding(\"utf-8\");\n\n        Map<String, String> res = new HashMap<>();\n        res.put(\"code\", \"401\");\n        res.put(\"msg\", \"认证失败，无法访问系统资源\");\n\n        response.getWriter().print(JSON.toJSON(res));\n    }\n}\n```\n\n### 自定义退出登录处理\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomLogoutSuccessHandler customLogoutSuccessHandler;\n\n// 自定义退出登录\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessHandler(customLogoutSuccessHandler);\n```\n\n这段代码的代码的意思当我们调用接口 `/logout` 会走 `CustomLogoutSuccessHandler` 处理逻辑，我们可以在里面清除用户相关的数据等操作，并返回相关的 Json 数据\n\n```java\n@Component\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        // 清除Redis缓存的用户数据\n        // 写入用户操作日志\n        // ...\n\n        response.setStatus(HttpStatus.OK.value());\n        response.setContentType(\"application/json\");\n        response.setCharacterEncoding(\"utf-8\");\n\n        Map<String, String> res = new HashMap<>();\n        res.put(\"code\", \"200\");\n        res.put(\"msg\", \"退出成功\");\n\n        response.getWriter().print(JSON.toJSON(res));\n    }\n}\n```\n\n### 自定义Token拦截器\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomJwtAuthenticationTokenFilter customJwtAuthenticationTokenFilter;\n\n// 自定义Token拦截器\nhttp.addFilterBefore(customJwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n这段代码的意思就是在 执行 `UsernamePasswordAuthenticationFilter` 之前执行我们定义的 `CustomJwtAuthenticationTokenFilter` Token 拦截器\n\n```java\n@Component\npublic class CustomJwtAuthenticationTokenFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        LoginUser loginUser = JwtUtil.getLoginUser(request);\n        if (Objects.nonNull(loginUser)){\n            // 检验成功，看是否需要刷新token\n             JwtUtil.verifyRefreshToken(loginUser);\n            // 将用户信息设置在SecurityContextHolder中\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());\n            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n            SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        }\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n这里需要将用户信息保存到 `SecurityContextHolder` 中，不保存的化它任然会走认证失败的逻辑\n\n### 自定义跨域配置\n\n实现跨域配置需要实现一个 CorsFilte 的 Bean\n\n```java\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsFilter corsFilter() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        // 设置访问源地址\n        config.addAllowedOriginPattern(\"*\");\n        // 设置访问源请求头\n        config.addAllowedHeader(\"*\");\n        // 设置访问源请求方法\n        config.addAllowedMethod(\"*\");\n        // 有效期 1800秒\n        config.setMaxAge(1800L);\n        // 添加映射路径，拦截一切请求\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        // 返回新的CorsFilter\n        return new CorsFilter(source);\n    }\n}\n```\n\n然后将这个 Bean 写入到安全配置中\n\n```java\n// 添加CORS filter\nhttp.addFilterBefore(corsFilter, CustomJwtAuthenticationTokenFilter.class);\nhttp.addFilterBefore(corsFilter, LogoutFilter.class);\n```\n\n\n\n### 自定义认证白名单\n\n对于接口的匿名认证有两种方式，一种是在代码中写入\n\n```java\nhttp.antMatchers(\"/auth/login\", \"/auth/register\").permitAll()\n```\n\n另一种是通过 yml 配置文件来读取写入，这里我就用后一种方法来演示\n\n新建一个白名单配置类，使用 `@ConfigurationProperties` 注解来表明配置文件的位置\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"security.ignored\")\npublic class IgnorePathConfig {\n\n    private List<String> paths = new ArrayList<>();\n\n    public List<String> getPaths() {\n        return paths;\n    }\n}\n```\n\n在 yml 配置文件中写入\n\n```yml\nsecurity: # 白名单路径\n  ignored:\n    paths:\n      - /auth/test\n```\n\n好了现在就差个将这个白名单配置写入安全配置中，通过遍历白名单，将路径设置为匿名访问\n\n```java\n@Autowired\nprivate IgnorePathConfig ignorePathConfig;\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    // 配置不需要保护的资源路径允许访问\n    ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry registry = http.authorizeRequests();\n    ignorePathConfig.getPaths().forEach(url -> registry.antMatchers(url).permitAll());\n\t// ...\n    // ...\n}\n```\n\n### 自定义动态权限控制\n\n这个动态权限控制说白了还是拦截器，将用户拥有的权限与路径所需要的权限作比较，若用户没有这个权限就走认证逻辑\n\n新建一个拦截器，继承 `AbstractSecurityInterceptor` 类，实现 `Filter` 接口\n\n```java\n@Component\npublic class CustomAbstractSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {\n\n    @Autowired\n    private IgnorePathConfig ignorePathConfig;\n\n    @Autowired\n    private CustomFilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;\n\n    @Autowired\n    public void setMyAccessDecisionManager(CustomAccessDecisionManager myAccessDecisionManager) {\n        super.setAccessDecisionManager(myAccessDecisionManager);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);\n        // OPTIONS请求直接放行\n        if(request.getMethod().equals(HttpMethod.OPTIONS.toString())){\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n            return;\n        }\n        // 白名单请求直接放行\n        PathMatcher pathMatcher = new AntPathMatcher();\n        for (String path : ignorePathConfig.getPaths()) {\n            if(pathMatcher.match(path,request.getRequestURI())){\n                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n                return;\n            }\n        }\n        // 此处会调用AccessDecisionManager中的decide方法进行鉴权操作\n        InterceptorStatusToken token = super.beforeInvocation(fi);\n        try {\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        } finally {\n            super.afterInvocation(token, null);\n        }\n    }\n\n    @Override\n    public Class<?> getSecureObjectClass() {\n        return FilterInvocation.class;\n    }\n\n    @Override\n    public SecurityMetadataSource obtainSecurityMetadataSource() {\n        return filterInvocationSecurityMetadataSource;\n    }\n}\n```\n\n这里将 OPTIONS 和白名单的请求直接放，然后就调用 `AccessDecisionManager` 中的decide方法进行鉴权操作，所以还需要自定以这个鉴权操作\n\n```java\n@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager {\n\n    @Override\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\n        // 当接口未被配置资源时直接放行\n        // configAttributes存在当前路径所需要的权限\n        if (CollUtil.isEmpty(configAttributes)) {\n            return;\n        }\n        Iterator<ConfigAttribute> iterator = configAttributes.iterator();\n        while (iterator.hasNext()) {\n            ConfigAttribute configAttribute = iterator.next();\n            // 将访问所需权限或用户拥有权限进行比对\n            // 用户的权限在登录的时候就会查询保存在Redis中，用户一访问就会根据token查询到权限，所以需要重写getAuthorities方法\n            String needAuthority = configAttribute.getAttribute();\n            System.out.println(\"需要的资源:\" + needAuthority);\n            System.out.println(\"拥有的资源:\" + authentication.getAuthorities());\n            for (GrantedAuthority grantedAuthority : authentication.getAuthorities()) {\n                if (needAuthority.trim().equals(grantedAuthority.getAuthority())) {\n                    return;\n                }\n            }\n        }\n        throw new AccessDeniedException(\"抱歉，您没有访问权限\");\n    }\n\n    @Override\n    public boolean supports(ConfigAttribute configAttribute) {\n        return true;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n}\n```\n\n这个鉴权是核心部分，就是判断用户是否拥有这个请求的权限\n\n那么问题来了：我们是如何知道路径的请求和它的请求权限的呢？\n\n注意在 `CustomAbstractSecurityInterceptor` 类中有个 `obtainSecurityMetadataSource` 方法\n\n```java\n@Override\npublic SecurityMetadataSource obtainSecurityMetadataSource() {\n    return filterInvocationSecurityMetadataSource;\n}\n```\n\n该对象用于读取数据库，获取请求对应的权限信息\n\n```java\n@Component\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {\n\n    private static Map<String, ConfigAttribute> configAttributeMap = null;\n\n    @Autowired\n    private CustomDynamicSecurityService myDynamicSecurityService;\n\n    @PostConstruct\n    public void loadDataSource() {\n        configAttributeMap = myDynamicSecurityService.loadDataSource();\n    }\n\n    public void clearDataSource() {\n        configAttributeMap.clear();\n        configAttributeMap = null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {\n        // 若不存在就先加载（一般都是存在的，因为启动项目的时候已经加载好了）\n        if (configAttributeMap == null) {\n            this.loadDataSource();\n        }\n        List<ConfigAttribute> configAttributes = new ArrayList<>();\n        // 获取当前访问的路径\n        String url = ((FilterInvocation) o).getRequestUrl();\n        String path = URLUtil.getPath(url);\n        PathMatcher pathMatcher = new AntPathMatcher();\n        Iterator<String> iterator = configAttributeMap.keySet().iterator();\n        // 匹配当前路径所需的权限，若当前路径需要某个权限就加入configAttributes中\n        while (iterator.hasNext()) {\n            String pattern = iterator.next();\n            if (pathMatcher.match(pattern, path)) {\n                configAttributes.add(configAttributeMap.get(pattern));\n            }\n        }\n        // 未设置操作请求权限，返回空集合\n        return configAttributes;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return true;\n    }\n}\n```\n\nconfigAttributeMap 是个 Map，键存放的路径，值存放的是权限\n\n这里需要返回 `Collection<ConfigAttribute>` 集合，就获取当前的路径，遍历从数据查询的所有路径的权限，依次匹配，看当前的路径是否需要权限，若需要有就加入 `configAttributes`\n\n`CustomDynamicSecurityService` 是个接口，具体实现需要在用户层实现，因为需要用到 mapper 方法的调用\n\n```java\npublic interface CustomDynamicSecurityService {\n    /**\n     * 加载资源ANT通配符和资源对应MAP\n     * 这里Bean注入需要用到用户模块的权限信息，所以在用户模块注入\n     * 只要与启动项目就回会运行\n     */\n    Map<String, ConfigAttribute>  ();\n}\n```\n\n在用户层中定义一个Bean，实现 `loadDataSource` 方法，同样的，这里的查询权限的数据也是模拟的，真实项目中需要查询数据库\n\n权限说明：访问 `/auth/t1` 接口需要 `user:t1` 权限，其他的同理\n\n```java\n@Bean\npublic CustomDynamicSecurityService dynamicSecurityService() {\n    return new CustomDynamicSecurityService() {\n        @Override\n        public Map<String, ConfigAttribute> loadDataSource() {\n            Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();\n            // 查询所有权限列表\n            // 这里模拟数据\n            map.put(\"/auth/t1\", new org.springframework.security.access.SecurityConfig(\"user:t1\"));\n            map.put(\"/auth/t2\", new org.springframework.security.access.SecurityConfig(\"user:t2\"));\n            map.put(\"/auth/t3\", new org.springframework.security.access.SecurityConfig(\"user:t3\"));\n\n            return map;\n        }\n    };\n}\n```\n\n好了，到这里就结束了，通过重写方法一系列的方法，拦截请求的路径，根据数据库查询的所有的权限，匹配到这个请求路径所需要的权限，再根据用户的权限来匹配，若用户有该权限就放行，否则就拦截\n\n## 代码\n\nGitee：[https://gitee.com/lijunxi666/further-use-of-spring-security](https://gitee.com/lijunxi666/further-use-of-spring-security)","title":" SpringSecurity权限控制\n","category":[" Java","SpringCloud\n"],"date":" 2024-06-18\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 前置说明\n\n必备知识：SpringSecurity 的使用\n\n提前准备：5个基本表（权限表、角色表、菜单表、角色权限表、角色菜单表），为了方便这里是展示必须的操作，数据库的操作返回的数据是直接模拟的\n\n 步骤\n\n 自定义登录逻辑\n\n加入 jar 包我们什么都不做，启动项目，访问任何接口会默认跳转到一个登录页面。我们现在需要做的就是不让他显示这个页面并且通过我们自己定义的登录接口实现认证\n\n定义 SecurityConfig 配置类，用来管理整个安全配置\n\n首先修改一下 configureHttpSecurity http 方法\n\njava\n@Override\nprotected void configureHttpSecurity http throws Exception {\n    http\n            // CSRF禁用，因为不使用session\n            .csrf.disable\n            // 禁用HTTP响应标头\n            .headers.cacheControl.disable.and\n            // 基于token，所以不需要session\n            .sessionManagement.sessionCreationPolicySessionCreationPolicy.STATELESS.and\n            // 过滤请求\n            .authorizeRequests\n            // 对于登录login 注册register 验证码captchaImage 允许匿名访问\n            .antMatchers\"/auth/login\", \"/auth/register\".permitAll\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest.authenticated\n            .and\n            .headers.frameOptions.disable;\n}\n\n\n开放 /auth/login 登录接口，自定义 AuthenticationManager 的建造器，并确定加密算法为 BCryptPasswordEncoder ，这个加密算法可以替换为 MD5 加密\n\njava\n@Override\nprotected void configureAuthenticationManagerBuilder auth throws Exception {\n    auth.userDetailsServicecustomUserDetailService.passwordEncodernew BCryptPasswordEncoder;\n}\n\n\n注入 AuthenticationManager Bean，目的是为了让我们在自己的接口调用 authenticationManager.authenticate 方法进行验证\n\njava\n@Bean\n@Override\npublic AuthenticationManager authenticationManagerBean throws Exception {\n    return super.authenticationManagerBean;\n}\n\n\n下面写自己的登录接口，在登陆方法中调用 authenticationManager.authenticate 来实现验证，而调用这个方法会调用我们自定义实现的 CustomUserDetailService 类的 loadUserByUsername 方法\n\njava\n@Autowired\nprivate AuthenticationManager authenticationManager;\n\n@Override\npublic String loginLoginForm loginForm {\n    // 若有其他检验项也需要检查\n    Authentication authentication = null;\n    try {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationTokenloginForm.getUsername, loginForm.getPassword;\n        UserHolder.setContextauthenticationToken;\n        // 这里会调用 UserDetailService 接口的 loadUserByUsername 方法\n        authentication = authenticationManager.authenticateauthenticationToken;\n    } catch Exception e{\n        e.printStackTrace;\n    } finally {\n        UserHolder.clearContext;\n    }\n    LoginUser loginUser = LoginUser authentication.getPrincipal;\n\n    return JwtUtil.createTokenloginUser.getUsername;\n}\n\n\n自定义 CustomUserDetailService 类，实现 UserDetailsService 接口，为了让登录验证走我们自己的验证逻辑，判断账号密码，从而生成 Token\n\n注：这里的查询用户拥有的权限是模拟的，真实项目需要联表查询数据库\n\njava\n@Service\npublic class CustomUserDetailService implements UserDetailsService{\n\n    @Override\n    public UserDetails loadUserByUsernameString username throws UsernameNotFoundException {\n        // 检验账号状态\n        // 查询数据库检验账户密码的正确性\n        // ...\n\n        Authentication context = UserHolder.getContext;\n        return new LoginUsernew Usercontext.getName, new BCryptPasswordEncoder.encodecontext.getCredentials.toString,\n                getPermsList;\n    }\n\n    /\n      模拟用户拥有的权限\n      @return\n     /\n    private Set<String getPermsList {\n        Set<String res = new HashSet<;\n        res.add\"user:t1\";\n        res.add\"user:t2\";\n\n        return res;\n    }\n}\n\n\n 自定义认证失败处理\n\n在 SecurityConfig 配置类中修改，添加一句话\n\njava\n@Autowired\nprivate CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n\n// 认证失败处理类\nhttp.exceptionHandling.authenticationEntryPointcustomAuthenticationEntryPoint.and \n\n\nCustomAuthenticationEntryPoint 类就是我们自定义的认证失败的逻辑处理类，我们可以通过 response 返回失败的 Json 数据\n\njava\n@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {\n    @Override\n    public void commenceHttpServletRequest request, HttpServletResponse response, AuthenticationException authException throws IOException, ServletException {\n        response.setStatusHttpStatus.UNAUTHORIZED.value;\n        response.setContentType\"application/json\";\n        response.setCharacterEncoding\"utf8\";\n\n        Map<String, String res = new HashMap<;\n        res.put\"code\", \"401\";\n        res.put\"msg\", \"认证失败，无法访问系统资源\";\n\n        response.getWriter.printJSON.toJSONres;\n    }\n}\n\n\n 自定义退出登录处理\n\n在 SecurityConfig 配置类中修改，添加一句话\n\njava\n@Autowired\nprivate CustomLogoutSuccessHandler customLogoutSuccessHandler;\n\n// 自定义退出登录\nhttp.logout.logoutUrl\"/logout\".logoutSuccessHandlercustomLogoutSuccessHandler;\n\n\n这段代码的代码的意思当我们调用接口 /logout 会走 CustomLogoutSuccessHandler 处理逻辑，我们可以在里面清除用户相关的数据等操作，并返回相关的 Json 数据\n\njava\n@Component\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccessHttpServletRequest request, HttpServletResponse response, Authentication authentication throws IOException, ServletException {\n        // 清除Redis缓存的用户数据\n        // 写入用户操作日志\n        // ...\n\n        response.setStatusHttpStatus.OK.value;\n        response.setContentType\"application/json\";\n        response.setCharacterEncoding\"utf8\";\n\n        Map<String, String res = new HashMap<;\n        res.put\"code\", \"200\";\n        res.put\"msg\", \"退出成功\";\n\n        response.getWriter.printJSON.toJSONres;\n    }\n}\n\n\n 自定义Token拦截器\n\n在 SecurityConfig 配置类中修改，添加一句话\n\njava\n@Autowired\nprivate CustomJwtAuthenticationTokenFilter customJwtAuthenticationTokenFilter;\n\n// 自定义Token拦截器\nhttp.addFilterBeforecustomJwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class;\n\n\n这段代码的意思就是在 执行 UsernamePasswordAuthenticationFilter 之前执行我们定义的 CustomJwtAuthenticationTokenFilter Token 拦截器\n\njava\n@Component\npublic class CustomJwtAuthenticationTokenFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternalHttpServletRequest request, HttpServletResponse response, FilterChain filterChain throws ServletException, IOException {\n        LoginUser loginUser = JwtUtil.getLoginUserrequest;\n        if Objects.nonNullloginUser{\n            // 检验成功，看是否需要刷新token\n             JwtUtil.verifyRefreshTokenloginUser;\n            // 将用户信息设置在SecurityContextHolder中\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationTokenloginUser, null, loginUser.getAuthorities;\n            authenticationToken.setDetailsnew WebAuthenticationDetailsSource.buildDetailsrequest;\n            SecurityContextHolder.getContext.setAuthenticationauthenticationToken;\n        }\n        filterChain.doFilterrequest, response;\n    }\n}\n\n\n这里需要将用户信息保存到 SecurityContextHolder 中，不保存的化它任然会走认证失败的逻辑\n\n 自定义跨域配置\n\n实现跨域配置需要实现一个 CorsFilte 的 Bean\n\njava\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsFilter corsFilter {\n        CorsConfiguration config = new CorsConfiguration;\n        config.setAllowCredentialstrue;\n        // 设置访问源地址\n        config.addAllowedOriginPattern\"\";\n        // 设置访问源请求头\n        config.addAllowedHeader\"\";\n        // 设置访问源请求方法\n        config.addAllowedMethod\"\";\n        // 有效期 1800秒\n        config.setMaxAge1800L;\n        // 添加映射路径，拦截一切请求\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource;\n        source.registerCorsConfiguration\"/\", config;\n        // 返回新的CorsFilter\n        return new CorsFiltersource;\n    }\n}\n\n\n然后将这个 Bean 写入到安全配置中\n\njava\n// 添加CORS filter\nhttp.addFilterBeforecorsFilter, CustomJwtAuthenticationTokenFilter.class;\nhttp.addFilterBeforecorsFilter, LogoutFilter.class;\n\n\n\n\n 自定义认证白名单\n\n对于接口的匿名认证有两种方式，一种是在代码中写入\n\njava\nhttp.antMatchers\"/auth/login\", \"/auth/register\".permitAll\n\n\n另一种是通过 yml 配置文件来读取写入，这里我就用后一种方法来演示\n\n新建一个白名单配置类，使用 @ConfigurationProperties 注解来表明配置文件的位置\n\njava\n@Component\n@ConfigurationPropertiesprefix = \"security.ignored\"\npublic class IgnorePathConfig {\n\n    private List<String paths = new ArrayList<;\n\n    public List<String getPaths {\n        return paths;\n    }\n}\n\n\n在 yml 配置文件中写入\n\nyml\nsecurity:  白名单路径\n  ignored:\n    paths:\n       /auth/test\n\n\n好了现在就差个将这个白名单配置写入安全配置中，通过遍历白名单，将路径设置为匿名访问\n\njava\n@Autowired\nprivate IgnorePathConfig ignorePathConfig;\n\n@Override\nprotected void configureHttpSecurity http throws Exception {\n    // 配置不需要保护的资源路径允许访问\n    ExpressionUrlAuthorizationConfigurer<HttpSecurity.ExpressionInterceptUrlRegistry registry = http.authorizeRequests;\n    ignorePathConfig.getPaths.forEachurl  registry.antMatchersurl.permitAll;\n\t// ...\n    // ...\n}\n\n\n 自定义动态权限控制\n\n这个动态权限控制说白了还是拦截器，将用户拥有的权限与路径所需要的权限作比较，若用户没有这个权限就走认证逻辑\n\n新建一个拦截器，继承 AbstractSecurityInterceptor 类，实现 Filter 接口\n\njava\n@Component\npublic class CustomAbstractSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {\n\n    @Autowired\n    private IgnorePathConfig ignorePathConfig;\n\n    @Autowired\n    private CustomFilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;\n\n    @Autowired\n    public void setMyAccessDecisionManagerCustomAccessDecisionManager myAccessDecisionManager {\n        super.setAccessDecisionManagermyAccessDecisionManager;\n    }\n\n    @Override\n    public void doFilterServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain throws IOException, ServletException {\n        HttpServletRequest request = HttpServletRequest servletRequest;\n        FilterInvocation fi = new FilterInvocationservletRequest, servletResponse, filterChain;\n        // OPTIONS请求直接放行\n        ifrequest.getMethod.equalsHttpMethod.OPTIONS.toString{\n            fi.getChain.doFilterfi.getRequest, fi.getResponse;\n            return;\n        }\n        // 白名单请求直接放行\n        PathMatcher pathMatcher = new AntPathMatcher;\n        for String path : ignorePathConfig.getPaths {\n            ifpathMatcher.matchpath,request.getRequestURI{\n                fi.getChain.doFilterfi.getRequest, fi.getResponse;\n                return;\n            }\n        }\n        // 此处会调用AccessDecisionManager中的decide方法进行鉴权操作\n        InterceptorStatusToken token = super.beforeInvocationfi;\n        try {\n            fi.getChain.doFilterfi.getRequest, fi.getResponse;\n        } finally {\n            super.afterInvocationtoken, null;\n        }\n    }\n\n    @Override\n    public Class<? getSecureObjectClass {\n        return FilterInvocation.class;\n    }\n\n    @Override\n    public SecurityMetadataSource obtainSecurityMetadataSource {\n        return filterInvocationSecurityMetadataSource;\n    }\n}\n\n\n这里将 OPTIONS 和白名单的请求直接放，然后就调用 AccessDecisionManager 中的decide方法进行鉴权操作，所以还需要自定以这个鉴权操作\n\njava\n@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager {\n\n    @Override\n    public void decideAuthentication authentication, Object object, Collection<ConfigAttribute configAttributes throws AccessDeniedException, InsufficientAuthenticationException {\n        // 当接口未被配置资源时直接放行\n        // configAttributes存在当前路径所需要的权限\n        if CollUtil.isEmptyconfigAttributes {\n            return;\n        }\n        Iterator<ConfigAttribute iterator = configAttributes.iterator;\n        while iterator.hasNext {\n            ConfigAttribute configAttribute = iterator.next;\n            // 将访问所需权限或用户拥有权限进行比对\n            // 用户的权限在登录的时候就会查询保存在Redis中，用户一访问就会根据token查询到权限，所以需要重写getAuthorities方法\n            String needAuthority = configAttribute.getAttribute;\n            System.out.println\"需要的资源:\" + needAuthority;\n            System.out.println\"拥有的资源:\" + authentication.getAuthorities;\n            for GrantedAuthority grantedAuthority : authentication.getAuthorities {\n                if needAuthority.trim.equalsgrantedAuthority.getAuthority {\n                    return;\n                }\n            }\n        }\n        throw new AccessDeniedException\"抱歉，您没有访问权限\";\n    }\n\n    @Override\n    public boolean supportsConfigAttribute configAttribute {\n        return true;\n    }\n\n    @Override\n    public boolean supportsClass<? aClass {\n        return true;\n    }\n}\n\n\n这个鉴权是核心部分，就是判断用户是否拥有这个请求的权限\n\n那么问题来了：我们是如何知道路径的请求和它的请求权限的呢？\n\n注意在 CustomAbstractSecurityInterceptor 类中有个 obtainSecurityMetadataSource 方法\n\njava\n@Override\npublic SecurityMetadataSource obtainSecurityMetadataSource {\n    return filterInvocationSecurityMetadataSource;\n}\n\n\n该对象用于读取数据库，获取请求对应的权限信息\n\njava\n@Component\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {\n\n    private static Map<String, ConfigAttribute configAttributeMap = null;\n\n    @Autowired\n    private CustomDynamicSecurityService myDynamicSecurityService;\n\n    @PostConstruct\n    public void loadDataSource {\n        configAttributeMap = myDynamicSecurityService.loadDataSource;\n    }\n\n    public void clearDataSource {\n        configAttributeMap.clear;\n        configAttributeMap = null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute getAttributesObject o throws IllegalArgumentException {\n        // 若不存在就先加载（一般都是存在的，因为启动项目的时候已经加载好了）\n        if configAttributeMap == null {\n            this.loadDataSource;\n        }\n        List<ConfigAttribute configAttributes = new ArrayList<;\n        // 获取当前访问的路径\n        String url = FilterInvocation o.getRequestUrl;\n        String path = URLUtil.getPathurl;\n        PathMatcher pathMatcher = new AntPathMatcher;\n        Iterator<String iterator = configAttributeMap.keySet.iterator;\n        // 匹配当前路径所需的权限，若当前路径需要某个权限就加入configAttributes中\n        while iterator.hasNext {\n            String pattern = iterator.next;\n            if pathMatcher.matchpattern, path {\n                configAttributes.addconfigAttributeMap.getpattern;\n            }\n        }\n        // 未设置操作请求权限，返回空集合\n        return configAttributes;\n    }\n\n    @Override\n    public Collection<ConfigAttribute getAllConfigAttributes {\n        return null;\n    }\n\n    @Override\n    public boolean supportsClass<? clazz {\n        return true;\n    }\n}\n\n\nconfigAttributeMap 是个 Map，键存放的路径，值存放的是权限\n\n这里需要返回 Collection<ConfigAttribute 集合，就获取当前的路径，遍历从数据查询的所有路径的权限，依次匹配，看当前的路径是否需要权限，若需要有就加入 configAttributes\n\nCustomDynamicSecurityService 是个接口，具体实现需要在用户层实现，因为需要用到 mapper 方法的调用\n\njava\npublic interface CustomDynamicSecurityService {\n    /\n      加载资源ANT通配符和资源对应MAP\n      这里Bean注入需要用到用户模块的权限信息，所以在用户模块注入\n      只要与启动项目就回会运行\n     /\n    Map<String, ConfigAttribute  ;\n}\n\n\n在用户层中定义一个Bean，实现 loadDataSource 方法，同样的，这里的查询权限的数据也是模拟的，真实项目中需要查询数据库\n\n权限说明：访问 /auth/t1 接口需要 user:t1 权限，其他的同理\n\njava\n@Bean\npublic CustomDynamicSecurityService dynamicSecurityService {\n    return new CustomDynamicSecurityService {\n        @Override\n        public Map<String, ConfigAttribute loadDataSource {\n            Map<String, ConfigAttribute map = new ConcurrentHashMap<;\n            // 查询所有权限列表\n            // 这里模拟数据\n            map.put\"/auth/t1\", new org.springframework.security.access.SecurityConfig\"user:t1\";\n            map.put\"/auth/t2\", new org.springframework.security.access.SecurityConfig\"user:t2\";\n            map.put\"/auth/t3\", new org.springframework.security.access.SecurityConfig\"user:t3\";\n\n            return map;\n        }\n    };\n}\n\n\n好了，到这里就结束了，通过重写方法一系列的方法，拦截请求的路径，根据数据库查询的所有的权限，匹配到这个请求路径所需要的权限，再根据用户的权限来匹配，若用户有该权限就放行，否则就拦截\n\n 代码\n\nGitee：https://gitee.com/lijunxi666/furtheruseofspringsecurityhttps://gitee.com/lijunxi666/furtheruseofspringsecurity"},{"filename":"software-project-manage","category":"major","md":{"topSummary":"\r\ntitle: 软件项目管理资料\r\ncategory: 软件工程\r\ndate: 2024-06-02\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## 一、软件项目管理概述\r\n\r\n### 项目的定义及其特点\r\n\r\n定义：为了创造一个**唯一**的产品或提供一个**唯一**的服务而进行的**临时性**的努力\r\n\r\n特点：\r\n\r\n- 一次性与独特性\r\n-  目标的确定性与过程的不确定性\r\n- 活动的整体性与过程的渐进性\r\n- 组织的临时性和开放性\r\n- 依赖性和冲突性\r\n- 结果的不可逆转性\r\n- 周期性\r\n\r\n**:pencil:例题**\r\n\r\n1、一次性的含义：项目有确定的开始和结束时间\r\n\r\n2、—般而言，项目的范围确定后，项目的三个基本目标是( C ）\r\n\r\nA.时间、功能、成本\r\n\r\nB.成本、功能、质量\r\n\r\nC.时间、成本、质量\r\n\r\nD.时间、功能、质量\r\n\r\n3、下列说法不是项目基本特征的是( B ) \r\n\r\nA.项目具有一次性 B.项目组织采用矩阵式管理 C.项目需要确定的资源 D.项目有一个明确目标\r\n\r\n### 项目与日常运作的区别\r\n\r\n从工作性质、工作环境、管理组织、目的、目标，管理追求等方面分析\r\n\r\n- 项目是一次性的，日常运作是重复进行的\r\n- 项目是以目标为导向的，日常运作是通过效率和有效性体现的\r\n- 项目是通过与项目经理及其团队工作完成的，而日常运作是职能式的线形管理\r\n- 项目存在大量的变更管理，而日常运作则基本保持持续的连贯性的\r\n\r\n**:pencil:例题**\r\n\r\n1、错误说法：1、项目的目标是为了维持业务而持续进行。2、运营的目标是要达到这一目标从而结束项目。3、项目具有连续性和重复性，运营则具有临时性和独特性\r\n\r\n### 项目管理\r\n\r\n项目管理是以**项目**为对象，通过使用知识、技能、工具和方法来组织、计划、实施并监控项目，使之满足项目目标需求的过程\r\n\r\n项目管理通过执行一系列的过程来完成\r\n\r\n项目的成功受到时间、成本、质量、范围等各方面的约束，成功的项目需要满足或者超过干系人的期望\r\n\r\n**:pencil:例题**\r\n\r\n1、错误的说法：项目管理的过程都是顺序进行，不重叠，不交互的\r\n\r\n2、项目质量管理的目标是满足（ C ）的需要。 \r\n\r\nA.组织 B.老板 C.项目 D.项目经理\r\n\r\n3、项目管理是( D )。 \r\n\r\nA.不需要的，如果所有的职能经理都能负起相应的责任\r\n\r\nB.不需要的，除非项目陷入了极大的困难 \r\n\r\nC.需要的，仅当项目具有高度的可见性 \r\n\r\nD.需要的，因为职能组织及其计划和控制方法不能保证复杂的项目按时且在预算内完成\r\n\r\n4、一般来说，要把项目管理好，至少需要4种过程，配置管理过程属于（ D ） \r\n\r\nA.改进类过程 B.技术类过程 C.管理类过程 D.支持类过程\r\n\r\n**项目管理的内容**\r\n\r\n- 从管理职能角度包括：项目计划、组织、人事安排、控制、协调等\r\n- 从项目活动的全过程包括：项目决策、项目规划与设计、项目的招投标项目实施、项目终结等\r\n- 从项目目标和约束角度包括：项目进度管理、项目成本管理、项目质量管理等\r\n\r\n**软件项目管理的必要性**\r\n\r\n- 无规则、混乱的开发状态，进度滞后，费用超支等失败的例子很多\r\n- 业务失败，合同纠纷，法律诉讼，客户投诉等困扰软件业\r\n\r\n### 项目生命周期的阶段及影响\r\n\r\n**分为六个：**\r\n\r\n1、计划阶段\r\n\r\n2、需求分析阶段\r\n\r\n3、软件设计阶段\r\n\r\n4、编码阶段\r\n\r\n5、测试阶段\r\n\r\n6、运行维护阶段\r\n\r\n**分为四个：**\r\n\r\n启动 -> 计划 <=> 执行 -> 结束\r\n\r\n软件项目管理的核心： 计划 <=> 执行\r\n\r\n**影响**\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//665dde2fb02ce.png)\r\n\r\n生命期的几个概念：\r\n\r\n- 检查点：它指在规定的时间间隔内对项目进行检查，比较实际现状与计划之间的差异，并根据差异进行调整\r\n\r\n- 里程碑：它是完成阶段性工作的标志，不同类型的项目里程碑不同\r\n\r\n- 基线：它指一个(或一组)配置项在项目生命期的不同**时间点**上，通过正式评审而进入正式受控的一种状态\r\n\r\n**:pencil:例题**\r\n\r\n1、下列有关项目生命周期的说法错误的是( D ) \r\n\r\nA.项目的生命周期分为启动、计划、执行、收尾4个阶段 \r\n\r\nB.项目开始时，成功地完成项目的把握性较低，因此风险和不确定性是最高的 \r\n\r\nC.项目开始时对费用和人员的需求比较少，随着项目的发展，人力投入和费用会越来越多，并达到一个最高点，当项目接近收尾时又会迅速地减少 \r\n\r\nD.项目的生命周期往往涵盖了产品的生命周期\r\n\r\n2、项目生命周期四个阶段中，第二阶段结束于( A )。\r\n\r\nA.签订合同 B.项目结束 C.申请书的提交 D.需求建议书的发布\r\n\r\n3、下列有关项目生命周期及其特征的描述中不正确的是( C )。\r\n\r\nA.在项目的初始阶段不确定性水平最高，因此达不到项目目标的风险也是最高的\r\n\r\nB.项目的生命周期定义了从项目开始直到结束的项目阶段\r\n\r\nC.在项目初始阶段，项目干系人影响项目的最终产品特征和项目最终费用的能力最弱。【最强】\r\n\r\nD.在项目初始阶段，成本与人员的投入水平较低，在中间阶段达到最高，当项目接近结束时，则快速下降\r\n\r\n### 软件项目管理的过程\r\n\r\n启动 -> 计划 -> 执行 -> 收尾\r\n\r\n**:pencil:例题**\r\n\r\n1、投入成本和时间最多的是（执行）阶段\r\n\r\n### 项目管理知识体系\r\n\r\n项目管理知识体系（PMBOK）知识领域：整体管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理【没有合同管理、招聘管理】\r\n\r\nPMBOK 过程组：启动过程组、计划过程组、执行过程组、控制过程组、收尾过程组\r\n\r\n**:pencil:例题**\r\n\r\n1、人力资源计划编制的输出不包括( A )\r\n\r\nA.人力资源模板 B.项目的组织结构图 C.人员配备管理计划 D.角色和职责\r\n\r\n2、下列选项中，( D ）不是制定项目人力资源计划过程的结果。\r\n\r\nA.人员配置管理计划 B.项目的组织结构图 C.角色和职责的分配 D.团队成员的人际关系\r\n\r\n3、在项目执行过程中，项目经理不断提醒团队成员要集中精力完成工作分解结构中所规定的可交付成果，不要去做其他未经批准的工作。项目经理是在关注（ B ）\r\n\r\nA.团队建设 B.范围管理 C.范围变更管理 D.风险管理\r\n\r\n4、项目范围管理旨在确保（ A )\r\n\r\nA.只做为成功完成项目所需的工作\r\n\r\nB.做尽可能多的工作\r\n\r\nC.确定不包括在项目范围内的工作\r\n\r\nD.为客户提供额外的产品功能\r\n\r\n5、单个项目管理的过程组中，( D ）的主要任务是确定和细化目标，并规划为实现项目目标和项目范围的行动方针和路线，确保实现项目目标。\r\n\r\nA.执行过程组。B.启动过程组。C.监控过程组。D.规划过程组\r\n\r\n## 二、软件项目合同管理\r\n\r\n### 合同的定义及包含的内容\r\n\r\n定义：合同是使卖方负有提供具体产品和服务的责任，买方负有为该产品和产品服务付款的责任的一种双方相互负有义务的协议\r\n\r\n内容：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//Y2O4XLMN9VHM0VXSHV.png)\r\n\r\n**:pencil:例题**\r\n\r\n1、合同内容是当事人订立合同时的各项合同条款。合同的主要内容包括( A ) \r\n\r\nA.以上全部 \r\n\r\nB.违约责任\r\n\r\nC.项目费用及工程款的支付方式 \r\n\r\nD.当事人各自的权利、义务\r\n\r\n2、在项目招标投标过程中，下列说法错误的是( D ) \r\n\r\nA.招标文件不得要求或者标明特定的生产供应者以及含有倾向或者排斥潜在投标人的其他内容 \r\n\r\nB.招标人设有标底的，标底必须保密 \r\n\r\nC.招标人不得以不合理的条件限制或者排斥潜在投标人，不得对潜在投标人实行歧 视待遇 \r\n\r\nD.招标人采用邀请招标方式的，应当向三个以上同行业的组织参加\r\n\r\n3、当（合同甲乙双方损坏了社会共同利益）时，合同可能认定为无效\r\n\r\n4、依据《中华人民共和国招标投标法》，公开招标是指招标人以招标公告的方式要求( C )投标。\r\n\r\nA.通过竞争性谈判的法人或者其他组织\r\n\r\nB.单一来源的法人或者其他组织\r\n\r\nC.不特定的法人或者其他组织\r\n\r\nD.特定的法人或者其他组织\r\n\r\n5、某公司想要对本单位的内部网络和办公室系统进行改造，希望通过招标选择承建商，为此，该公司进行了一系列活动。以下( C )活动不符合《中华人民共和国招标 投标法》的要求。 \r\n\r\nA.该公司计划由一家招标代理机构负责招标，并计划同一天开标。 \r\n\r\nB.有四家公司参加了投标，其中一家投标单位在截止日期之后提交投标文件，该公司认为其违反了招标文件要求，没有接受该投标单位的投标文件 \r\n\r\nC.该公司根据招标文件的要求，在三家投标单位中选择了其中一家作为此项目的承建商，并只将结果通知了中标企业。 \r\n\r\nD.该公司根据此项目的特点和需要编制了招标文件，并确定了提交投标文件的截止日期\r\n\r\n6、在某个软件开发项目中，卖方已经按照合同要求圆满地完成了项目工作。这时，买方又要求在合同中添加一项新工作。鉴于上述情况，卖纺应该如何做?（C）\r\n\r\nA.立即开展新工作，以便维护与买方的良好关\r\n\r\nB.同意添加新工作，但要求用成本补偿的方式来做\r\n\r\nC.开始合同收尾，并要求就新工作签订新合同\r\n\r\nD.拒绝做新工作，因为合同已经完成\r\n\r\n### 合同的生存期\r\n\r\n1、合同准备\r\n\r\n- 招标书的定义：需求定义，及甲方要求采购的内容\r\n- 供方选择：招标文书确定后，就可以进行供方的选择\r\n- 合同文本准备：签署合同，签合同前起草一份合同文本\r\n\r\n2、合同签署：正式签署合同，并分解出合同中需方的任务，下达任务书，指派相应项目经理负责\r\n\r\n3、合同管理\r\n\r\n- 对需求对象的验收\r\n- 对违约事件的处理\r\n\r\n4、合同终止：当项目满足结束条件，项目经理或者合同管理者应该及时宣布项目结束，终止合同的执行\r\n\r\n**:pencil:例题**\r\n\r\n合同生存期不包括( A )。\r\nA.合同环境 B.合同准备 C.合同终止 D.合同管理\r\n\r\n### 需方/供方合同环境\r\n\r\n**需方合同环境**\r\n\r\n企业在需方合同环境下，关键要素是提供准确、清晰和完整的需求，选择合格的供方并对采购对象（采购对象包括产品服务、人力资源等）进行必要的验收。\r\n\r\n这个需求可能来自于企业内部的需要，也可能是在为客户开发的软件项目中的一部分，通过寻找合适的软件开发商，将部分软件外包给其他的开发商。\r\n\r\n**供方合同环境**\r\n\r\n企业在供方(乙方)合同环境下，关键要素是了解清楚需方（甲方）的要求并判断企业是否有能力来满足这些需求。\r\n\r\n作为软件开发商，更多担任的是供方的角色。\r\n\r\n**:pencil:例题**\r\n\r\n1、建设方和承建方甲就某信息系统建设项目进行了多次协商均未达成一致，未能签订 系统建设合同，但在谈判期间建设方获悉了甲的行业关键技术。之后建设方与另一 承建方乙经过合同谈判后就系统建设签定了合同，同时将甲的关键技术指标透露给乙，导致甲蒙受损失。下列说法中，(  B )是正确的。 \r\n\r\nA.建设方和甲未签定合同，对甲蒙受的损失不应承担赔偿责任 \r\n\r\nB.建设方对甲蒙受的损失应承担赔偿责任 \r\n\r\nC.乙和甲未签定合同，对甲蒙受的损失不应承担赔偿责任 \r\n\r\nD.甲的损失是由于其自身保密工作未做好，其损失应全部由其自身承担\r\n\r\n2、下列不属于乙方招投标阶段任务的是?（ C ）\r\n\r\nA.竞标 B.合同签署 C.招标书定义 D.项目分析\r\n\r\n3、下列不属于甲方招投标阶段任务的是？（A）  \r\n\r\nA.编写建议书  B.招标书定义  C.供方选择  D.合同签署\r\n\r\n4、项目建议书是（C）阶段开发的文档  \r\n\r\nA.项目执行 B.项目结尾  C.项目初始  D.项目计划  \r\n\r\n### 合同管理主要内容\r\n\r\n合同履行管理、合同变更管理、合同签订管理【无合同评审管理】\r\n\r\n**:pencil:例题**\r\n\r\n1、下列说法中，( A )不是合同管理的主要作用。\r\n\r\nA.提高项目利润和产品质量 \r\n\r\nB.合同规定了双方的经济关系，包括实施过程中的经济责任、利益和权利 \r\n\r\nC.合同确定了信息系统实施和管理的主要目标 \r\n\r\nD.合同是监理的基本依据，利用合同可以对工程进度、质量和成本实施管理和控制\r\n\r\n## 三、软件开发过程管理\r\n\r\n### SW-CMM 和 CMMI 的基础内容\r\n\r\n**1、SW-CMM**\r\n\r\nSW-CMM的5级框架：\r\n\r\n- 初始级：无序、混乱的软件过程。依赖个别人的努力和机遇。\r\n- 可重复级：建立基本的项目管理过程。相似项目，重复以往成果。\r\n- 已定义级：文档化、标准化和标准的软件过程。\r\n- 已管理级：软件过程和产品质量有详细的度量标准。\r\n- 优化级：持续的对过程进行改进。\r\n\r\n**:pencil:例题**\r\n\r\n1、小张单独一个人随意地进行软件的全部开发过程，属于SW-CMM中的（ A )\r\n\r\nA.初始级\r\n\r\nB.已定义级\r\n\r\nC.已管理级\r\n\r\nD.可重复级\r\n\r\n**2、CMMI**\r\n\r\nCMMI 有两种不同的实施方法：\r\n\r\n- 连续式：主要是衡量一个企业的项目能力\r\n- 阶段式：主要是衡量一个企业的成熟度\r\n\r\nCMMI 的五个台阶：完成级、管理级、定义级、量化管理级、优化级\r\n\r\n**每一个台阶都是上面一阶台阶的基石。要上高层台阶必须首先踏上较低一层台阶**\r\n\r\n### 传统软件开发生命周期模型\r\n\r\n瀑布模型：项目的需求在项目开始前很明确，解决方案在项目开始前也很明确\r\n\r\n螺旋模型：适用于需求不明确的大规模软件项目；可能发生一些重大的变更；项目规模很大；基于风险驱动的开发模型，使用原型法或其它方法来尽量降低风险；项目中采用了新技术\r\n\r\n进化模型：需求和设计不能被准确定义，良好地理解；项目引入了新的或未经证明的技术方法；有多种用户组，可能发生需求冲突；系统功能需要向用户演示以便于演进\r\n\r\n原型模型：在项目开始前，项目的需求不明确；需要减少项目的不确定性\r\n\r\n增量模型：在项目开始时明确了大部分的需求，但是需求可能会发生变化；对于有庞大和复杂功能的系统进行功能改进时需求一步一步实施的项目；对市场和用户的把握不是很准，需求逐步了解的项目\r\n\r\n**:pencil:例题**\r\n\r\n1、目前有一款具有庞大和复杂功能的系统需要进行功能改进，最好选用( B )\r\n\r\nA.原型模型。B.增量模型。C.进化模型。D.瀑布模型\r\n\r\n2、软件开发的增量模型( A ) \r\n\r\nA.是—种能够快速构造可运行产品的好方法\r\n\r\nB.是一种不适用于商业产品的创新模型\r\n\r\nC.最适用于需求被清晰定义的情况\r\n\r\nD.最适合于大规模团队开发的项目\r\n\r\n3、（  A ）把整个软件开发流程分成多个阶段，每一个阶段都由目标设定、风险分析、开发和有效性验证以及评审构成。\r\n\r\nA.螺旋模型。B.增量模型。C.进化模型。D.瀑布模型\r\n\r\n4、对可能存在较大风险的项目进行软件开发过程管理时，常采用的模型是（ C ）。\r\n\r\nA.原型模型 B.V模型 C.螺旋型模型 D.增量模型\r\n\r\n5、适用于需求不明确的大规模软件项目，最好选择（ B ）进行开发。 \r\n\r\nA.原型模型 B.螺旋模型 C.增量模型 D.瀑布模型\r\n\r\n6、在项目开始前，项目的需求不明确的情况，选择（ B ）进行开发。\r\n\r\nA.增量模型 B.原型模型 C.瀑布模型 D.螺旋模型\r\n\r\n7、在项目开始时明确了大部分的需求，但是需求可能会发生变化，选择（ C ）进行开发\r\n\r\nA.原型模型 B.螺旋模型 C.增量模型 D.瀑布模型\r\n\r\n8、在开发一个系统时，如果用户对系统的目标不很清楚，难以定义需求，这时最好使用（ A ）。\r\n\r\nA.原型法 B.增量模型 C.瀑布模型 D.螺旋模型\r\n\r\n## 四、软件质量管理\r\n\r\n### 软件质量的定义和核心内容\r\n\r\n定义：**软件质量等于软件内在质量、过程质量与客户满意度的总和**【不包括软件外在质量】\r\n\r\n核心内容：**需求** 和 **标准**\r\n\r\n**:pencil:例题**\r\n\r\n1、关于软件质量， （ C ）的叙述是正确的。 \r\n\r\n（1）软件满足规定或潜在用户需求特性的总和\r\n\r\n（2）软件特性的总和：软件满足规定用户需求的能力\r\n\r\n（3）是关于软件特性具备“能力”的体现\r\n\r\n（4）软件质量包括“代码质量”、“外部质量”和“使用质量”三部分\r\n\r\nA.（1）和（2） B.（2）和（4） C.（1）和（3） D.（2）和（3）\r\n\r\n2、软件质量的定义是（ B )。\r\n\r\nA.最大限度达到用户满意\r\n\r\nB.软件优秀特性的总和，以及满足规定和潜在用户需求的能力\r\n\r\nC.软件的功能性、可靠性、易用性、效率、可维护性、可移植性\r\n\r\nD.满足规定用户需求的能力\r\n\r\n3、以下关于质量管理的叙述中，不正确的是（ C ）。 \r\n\r\nA.质量方针由最高管理者批准并发布 \r\n\r\nB.质量管理注重预防胜于检查 \r\n\r\nC.产品等级高就是质量好 \r\n\r\nD.质量目标是落实质量方针的具体要求，从属于质量方针\r\n\r\n4、质量管理是在质量方面指挥和控制组织的协调的活动。这些活动中（  A  ）除外。\r\n\r\nA.不做变更，以确保产品质量\tB.制定质量方针\tC.质量控制\tD.质量改进\r\n\r\n### 不同层次的软件质量工作\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//BKEHL1XVS9F1THN.png)\r\n\r\n**:pencil:例题**\r\n\r\n1、（ C ）属于QA的主要职责。\r\n\r\nA.组织对软件过程的改进\r\n\r\nB.组织对概要设计同行评审\r\n\r\nC.检查工作产品及过程与规划的符合性\r\n\r\nD.文件版本管理\r\n\r\n### 软件质量模型\r\n\r\n- 基于经验模型\r\n  - 层次模型：McCall 模型、Boehm 模型、ISO9126 模型\r\n  - 关系模型：Perry 模型\r\n- 基于构建的模型：Dromey 模型\r\n\r\n**:pencil:例题**\r\n\r\n1、以下软件质量模型中，属于关系模型的是 （ C ）。 \r\n\r\nA.MaCall模型 B. ISO9126模型 C.Perry模型 D. Boehm模型\r\n\r\n2、下列质量模型中属于层次模型的是（ C ）。 \r\n\r\nA.Dromey 模型 B.Perry模型  C.ISO9126模型  D.W模型\r\n\r\n3、McCall质量模型不包含（ B ) 。\r\n\r\nA.产品运行  B.产品特点  C.产品修正  D.产品移植\r\n\r\n### 软件质量工具\r\n\r\n1、表格类工具：问题分析\r\n\r\n2、柱状图类工具\r\n\r\n- 直方图：对样本的频率的图形标识，主要用于问题分析，可以针对多个参数变化情况绘制，无任何预测能力\r\n- 帕累托图：特殊的直方图，必须按发生频率的降序排序，主要用于问题识别，用于确定质量属性的因素，并作为软件质量改进应首先采取的措施\r\n\r\n3、折线图类工具\r\n\r\n- 游程图：表示参数随时间变化而变化的图，用于问题识别和问题分析，通过显示一定时间间隔内得到的测量结果，有一定预测能力\r\n- 控制图：高级的游程图，判断过程是否处于空置状态，用于问题分析\r\n\r\n4、枝状图类工具\r\n\r\n- 因果图（鱼骨图）：表示一个质量属性（即结果）与影响该属性的因素（即原因）之间的关系，用于问题识别和问题分析\r\n\r\n5、离散点图类工具：用于展示和发现两组相关数据之间的关系类型和程度，并对未来的发展趋势进行预测\r\n\r\n**📝例题**\r\n\r\n1、下列方法中，能描述由不同原因相互作用所产生的潜在问题的方法是 (D) \r\n\r\nA.控制图 B.趋势分析 C.帕累托图 D.因果图\r\n\r\n2、（D）不是质量控制的方法、技术和工具\r\n\r\nA.因果图 B.直方图 C.散点图 D.成本效益分析\r\n\r\n3、在进行工程质量控制时，直方图可以用来( A )。\r\n\r\nA.判断生产过程的质量状况\r\n\r\nB.分析产生质量问题的原因\r\n\r\nC.分析质量特性与影响因素之间的关系\r\n\r\nD.寻找引起质量问题的主要因素\r\n\r\n4、在质量控制过程中，( B  )是一种基于80/20原理，用于找出影响项目产品或服务质量的主要因素的方法。\r\n\r\nA.因果图 B.帕累托图 C.控制图 D.流程图\r\n\r\n5、按照发生频率大小顺序绘制的，表示有多少结果是由已确认类型或范畴的原因所造成的，这是( D )。\r\n\r\nA.统计抽样 B.因果图C.趋势图D.帕累托图\r\n\r\n6、一个问题将延迟项目并增加成本为避免将来出现这个问题项目经理应使用（B）方法来确定根本原因\r\n\r\nA帕累托图  B鱼骨图  C控制  D直方图\r\n\r\n### 软件质量度量\r\n\r\n软件质量度量就是软件内在质量度量、过程质量度量和维护质量度量的总和\r\n\r\n软件内在质量度量：平均失效时间、复杂性度量（包括文本复杂度和环复杂度）、缺陷密度、文档缺陷密度、用户问题度量、用户满意度量【无开发过程质量度量】\r\n\r\n**📝例题**\r\n\r\n下列描述中（ C ）不属于软件内在质量度量。\r\n\r\nA.环复杂度 B.缺陷密度 C.开发过程质量度量  D.平均失效时间\r\n\r\n### 软件测试过程模型\r\n\r\n1、V 模型\r\n\r\n2、W 模型\r\n\r\n3、H 模型\r\n\r\n### 软件质量保证的措施\r\n\r\n**质量保证计划**是质量管理（质量计划编制、质量保证和质量控制）的第一过程域\r\n\r\n**软件质量保证**是为了保证工作产品及服务充分满足用户质量要求而进行的有计划、有组织的活动\r\n\r\n**📝例题**\r\n\r\n1、为保证项目的质量，要对项目进行质量管理，项目质量管理的第一过程域是（C ）\r\n\r\nA.采用规范方法进行管理 \r\n\r\nB.对项目实施质量监控 \r\n\r\nC.制定项目质量计划 \r\n\r\nD.将实际与标准对照\r\n\r\n2、( D ）是为使项目能够满足相关的质量标准而建立的有计划的、系统的活动。\r\n\r\nA.质量认证。B.质量计划。C.质量记录。D.质量保证\r\n\r\n3、以下有关质量保证的叙述，错误的是（ D ）。\r\n\r\nA.质量保证为质量的持续改进过程提供保证 \r\n\r\nB.质量保证应该贯穿整个项目生命期 \r\n\r\nC.质量审计是质量保证的有效手段 \r\n\r\nD.质量保证主要任务是识别与项目相关的各种质量标准\r\n\r\n4、项目质量控制和项目保证的关系是( A )。\r\n\r\nA.相互交叉、项目重叠\r\n\r\nB.采用相同的方法\r\n\r\nC.有不同的目标\r\n\r\nD.截然分开\r\n\r\n5、项目质量管理由质量计划编制、质量保证和( A )三方面构成。\r\n\r\nA.质量控制  B.质量规范  C.质量记录 D.质量体系\r\n\r\n## 五、软件项目团队管理\r\n\r\n### 软件项目团队\r\n\r\n软件项目开发团队是通过将不同的个体组织在一起，形成一个具有团队精神的高效率队伍来进行软件项目的开发\r\n\r\n软件项目团队包括所有的项目干系人\r\n\r\n**📝例题**\r\n\r\n1、高效的项目团队应该( A )。\r\n\r\nA.以任务和结果为导向\r\n\r\nB.集中办公\r\n\r\nC.通过电子网络联系\r\n\r\nD以领导为导向\r\n\r\n### 干系人\r\n\r\n**指参与项目和受项目活动影响的人，包括：**\r\n\r\n1、项目发起人。2、资助者。3、供应商。4、项目组成员。5、协助人员。6、客户。7、使用者。8、项目的反对人\r\n\r\n**📝例题**\r\n\r\n1、管理项目干系人参与过程的主要作用是( D ) \r\n\r\nA.与干系人进行沟通 \r\n\r\nB.鼓励干系人参与项目 \r\n\r\nC.限制干系人参与项目 \r\n\r\nD.提升干系人对项目的支持\r\n\r\n2、关于干系人管理的描述，不正确的是( A )\r\n\r\nA.干系人分析在项目立项时进行，以便尽早了解干系人对项目的影响\r\n\r\nB.识别干系人的方法包括组织相关会议、专家判断等\r\n\r\nC.干系人分析是系统地收集干系人各种定性和定量信息的一种方法\r\n\r\nD.典型的项目干系人包含客户、用户、高层领导、项目团队等\r\n\r\n3、一般说来，在处理项目干系人之间的争议时，应该偏向于( C ) \r\n\r\nA.执行组织 B.项目发起者 C.顾客 D.高级经理\r\n\r\n4、下列有关项目干系人的描述，错误的是( B ) \r\n\r\nA.项目干系人也叫“项目利益相关者” \r\n\r\nB.不同项目干系人目标是相同的 \r\n\r\nC.项目干系人在具体的项目中可能会有不同的职责和权限 \r\n\r\nD.项目干系人可能会对项目及其结果施加影响\r\n\r\n5、项目的反对人不属于项目干系人。（错）\r\n\r\n### 软件项目团队管理\r\n\r\n- 团队组织计划\r\n- 团队人员获取\r\n- 团队建设\r\n\r\n**📝例题**\r\n\r\n1、项目团队建设的内容一般不包括（ D ） \r\n\r\nA.认可和奖励 B.培训 C.同地办公 D.职责分配\r\n\r\n2、在项目团队建设中，在项目经理的下述做法中，有可能不利于团队建设的是 （ B ） \r\n\r\nA.集中办公 B.奖励加班的成员 C.尽早建立团队基本规则 D.鼓励团队成员间的沟通\r\n\r\n### **项目组织形式**\r\n\r\n**一、直线型**\r\n\r\n各级领导亲自履行管理职能，按隶属关系直线指挥，逐级向上全权负责\r\n\r\n 最大的优点在于可以防止多重指令和防止双头管理现象的出现，对于一个部门来说可以避免出现接收多个相互矛盾指令的情况\r\n\r\n**📝例题**\r\n\r\n1、在（直线型）组织结构中，项目成员没有安全感\r\n\r\n2、具有高度风险和很大不确定性的项目最好由（ A ）处理。 \r\n\r\nA.直线型组织 B.职能组织化的公司 C.矩阵型组织 D.激进的团队\r\n\r\n3、你被任命为对公司前途非常重要的项目经理。如果项目成功，你将在公司管理层获得晋升;如果失败，你将会被解雇。你认识到必须进行最严格的项目资源控制。你会为项目选择（ C ）组织形式。\r\nA.矩阵型\tB.职能型\tC.直线型\tD.弱矩阵型\r\n\r\n**二、职能型**\r\n\r\n在职能组织结构中，工作部门的设置是按照专业职能和管理业务来划分的\r\n\r\n职能组织结构有利于发挥职能部门的专业管理作用和专业管理专长，能适应生产技术发展和间接管理复杂化的特点\r\n\r\n但如果多维指令产生冲突，则将使得下级部门无所适从，容易造成管理混乱。\r\n\r\n**📝例题**\r\n\r\n1、对于规模较小、偏重于技术、团队人员主要来自一个部门的项目最好采用（职能型）\r\n\r\n2、下列关于职能型组织优缺点的描述中，不正确的是( B )\r\n\r\nA.职能利益优先于项目，具有狭隘性\r\n\r\nB.员工缺乏事业上的连续性和保障\r\n\r\nC.组织横向之间的联系薄弱、部门间协调难度大\r\n\r\nD.项目经理极少或缺少权利、权威\r\n\r\n3、下列 （ A ） 不属于职能型组织的优点。 \r\n\r\nA.目前明确单一 \r\n\r\nB.强大的技术支持，便于知识、技能和经验的交流 \r\n\r\nC.清晰的职业生涯晋升路线 \r\n\r\nD.交流简单、责任和权限很清晰\r\n\r\n4、在项目管理的3种组织结构中，适用于主要由一个部门完成的项目或技术比较成熟的项目组织结构是（ A )\r\n\r\nA.职能型组织结构\r\n\r\nB.项目型组织结构\r\n\r\nC.都一样\r\n\r\nD.矩阵型组织结构\r\n\r\n**三、矩阵型**\r\n\r\n主要特点是按两大类型设置工作部门。其命令源是非线性的，因而横向管理部门和纵向管理部门各自负责的工作和管理内容必须明确\r\n\r\n**📝例题**\r\n\r\n1、在矩阵式管理之下，项目经理应该如何取得项目所需的人力资源?（B）\r\n\r\nA.指令职能部门经理提供所需的人力资源\r\n\r\nB.与职能部门经理就所需人力资源进行谈判\r\n\r\nC.从执行组织外部招聘尽可能多的人力资源\r\n\r\nD.直接向职能部门中的员工发出加入项目团队的邀请信\r\n\r\n2、下列( B )不属于矩阵型组织的优点。\r\n\r\nA.最大限度地利用公司的稀缺资源\r\n\r\nB.结构单一，责权分明，利于统一指挥\r\n\r\nC.改善了跨职能部门间的协调合作\r\n\r\nD.改善了项目经理对整体资源的控制\r\n\r\n3、责任分配矩阵是一种常用的描述项目角色和职责的方式，有关说法错误的是（  A ）  \r\n\r\nA.在反映团队成员个人与其承担的工作时，责任分配矩阵不够直观\r\n\r\nB.责任分配矩阵可以分成多个层级\r\n\r\nC.高层级的责任分配矩阵可以界定团队中的哪个小组负责工作分解中的哪一部分工作\r\n\r\nD.低层级的责任分配矩阵用来在小组内为具体活动分配角色、职责层次\r\n\r\n## 六、软件项目需求管理\r\n\r\n### 需求的定义及软件需求的层次\r\n\r\n需求定义：\r\n\r\n- 用户解决问题或达到目标所需的条件或权能(Capability)**；**\r\n\r\n- 系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能\r\n\r\n- 一种反映上面(1)或(2)所描述的条件或权能的文档说明\r\n\r\n软件需求层次：业务需求、用户需求、功能需求、非功能需求、软件规格说明等\r\n\r\n**📝例题**\r\n\r\n1、下列不属于软件需求范畴的是?（ C ）\r\n\r\nA.用户需要软件达到什么样的性能\r\n\r\nB.用户需要软件能做什么样的事情\r\n\r\nC.软件项目采用什么样的实现技术\r\n\r\nD.用户需要软件完成什么样的功能\r\n\r\n### 需求工程\r\n\r\n也叫做需求过程或需求阶段，包括需求开发和需求管理\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//VMC2UM8DKERY.png)\r\n\r\n**📝例题**\r\n\r\n1、确认软件需求是软件项目成功的重要保证，其中反映本组织对系统、产品高层次目标的要求属于( C ) 。\r\n\r\nA.用户需求 B.功能需求 C.业务需求 D.系统需求\r\n\r\n### 需求获取方法\r\n\r\n1、访谈和调研\r\n\r\n2、专题讨论会\r\n\r\n3、脑力风暴\r\n\r\n4、场景串联\r\n\r\n### 需求变更\r\n\r\n需求变更原因：单纯的用户因素、系统因素、工作环境因素、需求开发工作缺陷\r\n\r\n**📝例题**\r\n\r\n1、项目进行中会发生很多需求变更，以下正确的做法是（ B ）\r\n\r\nA.独自修订工作范围，减少干系人的影响\r\n\r\nB.提醒所有人注意变更程序\r\n\r\nC.要求管理层提供帮助\r\n\r\nD.减少和拒绝变更\r\n\r\n2、（ B ）是软件项目的一个突出特点，可以导致软件项目的蔓延\r\n\r\nA.展示性 B.需求变更 C.约束性 D.阶段性\r\n\r\n一名团队成员急于将客户正在考虑的新功能添加到项目可交付成果中。在开始为这些新功能工作之前，需要谁的批准？ （ A ）\r\n\r\nA.变更控制委员会(ccb) B.项目经理 C.项目发起人 D.主题专家\r\n\r\n3、某项目已进入实施阶段，此时用户提出要增加一项新的功能，项目经理应该（ B )\r\n\r\nA.立即实现该变更\r\n\r\nB.通过变更控制流程进行处理\r\n\r\nC.拒绝该变更\r\n\r\nD.要求客户应先去与公司领导协商\r\n\r\n### 建模方法\r\n\r\n用例分析法：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//GF8RA2J1Q.png)\r\n\r\n原型分析法：原型法是为了快速开发系统而推出的一种开发模式，旨在改进传统的结构化生命周期法的不足，缩短开发周期，减少开发风险。\r\n\r\n结构化分析法：强调开发方法的结构合理性以及所开发软件的结构合理性的软件开发方法。\r\n\r\n**📝例题**\r\n\r\n1、下列不属于结构化方法设计的是? （D）\r\n\r\nA.数据流图 B.数据字典 C.系统流程图 D.系统用例图\r\n\r\n2、敏捷开发方法XP是一种轻量级高效低风险的软件开发方法系统的设计，要能够尽可能早交付（C）属于最佳实践\r\n\r\nA持续集成  B隐喻  C小型发布  D重构\r\n\r\n3、需求分析建模的方法不包括( B )  \r\n\r\nA.结构化分析 B.非结构化分析 C.原型分析 D.用例分析\r\n\r\n## 七、软件项目开发计划\r\n\r\n### 软件项目分解\r\n\r\n项目分解就是先把复杂的项目逐步分解成一层一层的要素（工作），直到具体明确为止\r\n\r\n分解的结果就是 **WBS （任务分解结构）图**\r\n\r\nWBS 工作包：\r\n\r\n- WBS 的最低层次的可交付成果\r\n- 工作包应当由唯一主体负责\r\n- 这一交付成果可以分配给另外一位项目经理进行计划和执行，或者通过子项目的方式完成\r\n\r\n**📝例题**\r\n\r\n1、WBS典型的用途是( C )\r\n\r\nA.定义提供商提供给买主的包括的层次\r\n\r\nB.在工作元素分配给个人的时间记录\r\n\r\nC.组织和定义项目的所有范围\r\n\r\nD.去识别合适的项目出资人\r\n\r\n2、创建WBS的工具是（ B ）\r\n\r\nA.产品分析 B.分解 C.头脑风暴 D.滚动式规划\r\n\r\n3、WBS是对项目由粗到细的分解过程，它的结构是（ A ） \r\n\r\nA.分级的树形结构 \r\n\r\nB.分级的图状结构 \r\n\r\nC.分层的线性结构 \r\n\r\nD.分层的集合结构\r\n\r\n### 软件项目进度计划\r\n\r\n**1、项目进度（时间）管理过程**\r\n\r\n- 活动定义：确定为完成项目的各个交付成果所必须进行的诸项具体活动，完成 WBS 中的细目和子细目\r\n- 活动排序：项目各项活动之间存在相互联系与相互依赖关系对，根据这些关系安排各项活动的先后顺序\r\n- 活动历时估计\r\n- 制定进度计划\r\n- 进度控制\r\n\r\n**📝例题**\r\n\r\n1、刘工是某信息系统集成项目的项目经理，WBS分解工作已经完成，现在他把WBS中的工作包再分解成一个个要执行的活动，刘工现在是执行( B )过程。\r\n\r\nA.进度控制。B.定义活动。C.估算活动资源。D.排列活动顺序\r\n\r\n2、某软件开发项目的实际进度已经大幅滞后于计划进度，（ C ）能够较为有效地缩短活动工期。 \r\n\r\nA.要求项目组成员每天加班2到3个小时进行赶工 \r\n\r\nB.购买最新版本的软件开发工具 \r\n\r\nC.请经验丰富的老程序员进行技术指导或协助完成工作 \r\n\r\nD.招聘一批新的程序员到项目组中\r\n\r\n**2、任务(活动)之间的关系依据：**\r\n\r\n- 强制性依赖关系：一件事必须再另一件事之后做，强制的\r\n- 软逻辑关系：做事的时候根据当前进度合理安排，主观的\r\n- 外部依赖关系：项目活动与非项目活动之间的依赖关系\r\n- 里程碑\r\n\r\n**📝例题**\r\n\r\n1、为了缩短项目工期，项目经理想要采用快速跟进的方法。应该针对以下哪项来应用快速跟进的方法?( B )\r\n\r\nA.外部依赖关系。B.软逻辑关系。C.强制性依赖关系。D.内部依赖关系\r\n\r\n2、“软件编码完成之后，我才可以对它进行软件测试”，这句话说明了哪种依赖关系?（B）\r\n\r\nA.里程碑 B.强制性依赖关系 C.外部依赖关系 D.软逻辑关系\r\n\r\n2、以下箭线图，理解正确的是（ B ）\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//SHZFM83P21K8.png)\r\n\r\nA.活动A先于活动B进行;A完成后C即可开始\r\n\r\nB.活动A和B可以同时进行;只有活动A和B都完成后，活动C才开始\r\n\r\nC.活动A先于活动B进行;只有活动A和B都完成后，活动C才开始\r\n\r\nD.活动A和B可以同时进行:A完成后C即可开始\r\n\r\n### **软件项目进度估算**\r\n\r\n1、三点估算法\r\n\r\n1.最理想的完成时间：A天\r\n\r\n2.最正常的完成时间：B天\r\n\r\n3.最差的完成时间：C天\r\n\r\n工期=(a+4b+c)/6\r\n\r\n2、关键路径法\r\n\r\n![from LiZhengXue](https://gitee.com/lijunxi666/picture-bed/raw/master/software-project-manage//dasdashwqw.jpg)\r\n\r\n3、定额估算法：T = Q / ( R \\* S )\r\n\r\nT :活动的持续时间\tQ:活动的工作量\tR :人力或设备的数量\tS :开发（生产）效率，以单位时间完成的工作量表示\r\n\r\n**📝例题**\r\n\r\n1、某项工作估计一般大约需要9周完成。如果一切顺利将在6周内完成，但在最坏的情 况下需要18周完成。利用三点估算法估计完成该项工作的期望时间是（ C ）周。 \r\n\r\nA.9 B.18 C.10 D.6\r\n\r\n2、在进行项目活动历时估算时，如果很难获得项目工作的详细信息，可以采用( B )作为项目活动历时估算的工具。\r\n\r\nA.预留时间估算法 B.类比估算法 C.参数估算法 D.三点估算法\r\n\r\n3、采用三点估算法估算活动持续时间，不需要收集下列哪项信息？( A ） \r\n\r\nA.平均时间 B.最可能时间 C.最悲观时间 D.最乐观时间\r\n\r\n4、一项任务的最早开始时间是第2周，最晚开始时间是第5周，最早完成时间是第3周，最晚完成时间是第6周。该任务（ B ） \r\n\r\nA.在关键路径上 B.不在关键路径上 C.有滞后 D.进展情况良好\r\n\r\n## 八、软件项目风险管理\r\n\r\n### 风险的定义与分类\r\n\r\n风险具有两大属性：**可能性**和**损失**\r\n\r\n分类：\r\n\r\n- 从范围角度上看，风险主要分为下述三种类型：项目风险、技术风险和商业风险\r\n- 软件风险是有关软件项目、软件开发过程和软件产品损失的可能性。软件风险又可区分为软件项目风险、软件过程风险和软件产品风险。 \r\n\r\n**📝例题**\r\n\r\n1、风险是指（对项目有好影响或坏影响的不确定性事件）\r\n\r\n2、以下对于风险的描述，（ A ）是不正确的。\r\n\r\nA.风险的可避免性\r\n\r\nB.风险与不确定性\r\n\r\nC.风险的可度量性\r\n\r\nD.风险与损失\r\n\r\n3、关于项目的风险管理，下列说法中，( D ) 是不正确的。\r\n\r\nA.定性风险分析后，可进行定量分析 \r\n\r\nB.定性风险分析后，可制定和采取风险应对措施 \r\n\r\nC.风险管理包括风险识别、风险分析、风险应对、风险监控等过程 \r\n\r\nD.风险管理的最终目标是消除风险\r\n\r\n4、在以下各类可用于风险识别的历史信息中最不可靠的是（C）\r\n\r\nA商业数据库  B以往项目档案  C团队成员个人知识  D经验教训数据库\r\n\r\n5、风险管理是项目管理中的重要内容，其中风险概率分析是指( C )。\r\n\r\nA.分析风险对项目的潜在影响\r\n\r\nB.分析风险的可能积极影响\r\n\r\nC.调查每项具体风险发生的可能性\r\n\r\nD.分析风险的可能消极影响\r\n\r\n### 风险管理的层次\r\n\r\n四个层次：\r\n\r\n- 危机管理：是在风险已经造成麻烦后才着手处理它们\r\n- 风险缓解：事先制定好风险发生后的补救措施，但不制定任何的防范措施\r\n- 着力预防：将风险识别与风险防范作为软件项目的一部分加以规划和执行\r\n- 消灭根源：识别和消灭可能产生风险的根源\r\n\r\n风险管理策略有两种：救火模式和主动模式。\r\n\r\n**📝例题**\r\n\r\n1、下列不是风险管理过程的是（D）\r\n\r\nA.风险识别 B.风险规划 C.风险评估 D.风险收集\r\n\r\n### 风险预测\r\n\r\n风险评估又称风险预测，就是对识别出的风险做进一步分析，对风险发生的概率进行估计和评价，对风险后果的严重程度进行估计和评价，对风险影响范围进行估计和评价，以及对于风险发生时间进行估计和评价\r\n\r\n总结：风险预测从两方面来评估风险，即**风险发生的可能性**和**风险发生可能带来的后果**\r\n\r\n**📝例题**\r\n\r\n1、风险预测不包括：风险应对措施、风险原因分析和风险发生的时间\r\n\r\n### 风险识别\r\n\r\n风险识别的主要内容 ：识别并确定项目潜在的风险、识别引起风险的主要因素、识别项目风险可能引起的后果\r\n\r\n风险识别的方法：风险条目检查表，德尔菲法，情景分析法，会议法\r\n\r\n**📝例题**\r\n\r\n1、确定风险的来源、风险产生的条件、描述其风险特征和确定哪些风险事件有可能影响本项目，并将其特性记载成文的管理活动。这是( C )过程。\r\n\r\nA.风险定量分析\tB.制定风险管理计划\tC.风险识别\tD.风险定性分析\r\n\r\n2、李工正在为一个项目做风险识别，下列 (  D ) 是此过程不需要经过的步骤。 \r\n\r\nA.根据直接或间接的症状将潜在的风险识别出来\tB.收集资料\tC.风险形势估计\tD.制定风险管理计划\r\n\r\n### 风险评估（风险预测）\r\n\r\n方法：风险评估可采用**定性风险评估**和**定量风险评估**来进行\r\n\r\n定性风险评估主要是针对风险概率及后果进行定性的评估，例如采用历史资料法、概率分布法、风险后果估计法等\r\n\r\n定量风险评估是一种广泛使用的管理决策支持技术。一般，在定性风险分析之后就可以进行定量风险分析\r\n\r\n**📝例题**\r\n\r\n1、某项目经理正根据风险发生的概率，风险发生后对项目目标及其他因素如成本、进度、质量等的影响，来对风险进行优先级排列，说明该项目经理正在 ( B ) \r\n\r\nA.风险识别 B.实施定性风险分析 C.制定风险管理计划 D.实施定量风险分析\r\n\r\n### 风险计划\r\n\r\n降低风险的主要策略：回避风险、转移风险、损失控制、自留风险\r\n\r\n**📝例题**\r\n\r\n1、在一个项目的开发过程中采用了新的技术，为此，项目经理找来专家对项目组人员进行技术培训，这是什么风险应对策略?（ A ）\r\n\r\nA.损失控制。B.回避风险。C.自留风险。D.转移风险\r\n\r\n2、从根本上放弃项目或放弃使用有风险的项目资源、项目技术等，从而避开项目风险的方法是(  B  )  \r\n\r\nA.风险损失控制 B.风险回避 C.风险转移 D.风险自留\r\n\r\n## 十、软件项目配置管理\r\n\r\n### 软件配置管理（SCM）的基本概念\r\n\r\n软件配置管理对产品进行标志、存储和控制，以维护其完整性、可追溯性以及正确性，它为软件开发提供了一套管理办法和活动原则。\r\n\r\n**配置管理主要作用:**\r\n\r\n- 版本管理\r\n- 变更管理\r\n- 其他（过程管理）\r\n\r\n**📝例题**\r\n\r\n1、变更管理首要完成的任务是( C )\r\n\r\nA.记录变更信息、填写变更控制单\r\n\r\nB.修改相应的软件配置项(基线)，确立新的版本\r\n\r\nC.分析变更的必要性和合理性，确认是否实施变更\r\n\r\nD.做出变更，并交上级审批\r\n\r\n2、下列选项中，( A )不是项目配置管理的任务。\r\n\r\nA.配置测试\tB.制定项目配置管理计划。\tC.版本管理\tD.发行管理\r\n\r\n3、某新来的配置人员写了配置管理方法，想让老同事帮忙检查存在哪些问题，这种质量保证与评价方法属于( A )。\r\n\r\nA.同行评审 B.审计 C.管理评审 D.技术评审\r\n\r\n4、以下哪项不是项目配置管理中可能遇到的问题?（C）\r\n\r\nA.开发人员未经授权修改代码或文档\r\n\r\nB.因协同开发中，或者异地开发，版本变更混乱导致整个项目失败\r\n\r\nC.甲方与乙方在资金调配上存在意见差异\r\n\r\nD.找不到某个文件的历史版本\r\n\r\n5、软件配置管理(SCM)是一组用于计算机软件( D ）管理变化的活动。\r\n\r\nA.交付使用后  B.开发过程中  C.测试过程中  D.整个生命周期内\r\n\r\n**配置项的状态：**\r\n\r\n- 处于**草稿**状态的配置项版本格式：0.YZ\r\n- 处于**正式发布**状态的配置项版本格式：X.Y\r\n- 处于**正在修改**状态的配置项版本格式：X.YZ\r\n\r\n草稿：随着草稿的不断完善，“YZ”的取值应递增。“YZ”的初值和增幅由用户自己把握。 \r\n\r\n正式发布：如果配置项的版本升级幅度比较小，一般只增大Y值，X值保持不变。只有当配置项版本升级幅度比较大时，才允许增大X值。 \r\n\r\n正在修改：配置项正在修改时，一般只增大Z值，X.Y值保持不变。 当配置项修改完毕，状态重新成为“正式发布”时，将Z值设置为0，增加X.Y值\r\n\r\n**📝例题**\r\n\r\n1、某个配置项的版本由 1.0 变为 2.0，按照配置版本号规则表明 ( A ) \r\n\r\nA.目前配置项处于正式发布状态，配置项版本升级幅度较大 \r\n\r\nB.目前配置项处于正在修改状态，配置项版本升级幅度较大 \r\n\r\nC.目前配置项处于正在修改状态，配置项版本升级幅度较小 \r\n\r\nD.目前配置项处于正式发布状态，配置项版本升级幅度较小\r\n\r\n2、以下关于配置项的描述中，不正确的是( C )\r\n\r\nA.所有配置项都必须按照相关规定进行统一编号\r\n\r\nB.基线配置项要向软件开发人员开放读取的权限\r\n\r\nC.所有配置项的操作权限应该由项目经理严格统一管理\r\n\r\nD.非基线配置项向CCB及相关人员开放\r\n\r\n3、以下关于基线的说法，不正确的是(  C ) \r\n\r\nA.产品的一个测试版本是基线的一个例子 \r\n\r\nB.一个产品可以有多个基线，也可以只有一个基线 \r\n\r\nC.通常将给客户用的基线称为一个\"Build\"，为内部开发用的基线则称为一个“Release” \r\n\r\nD.基线中的配置项被\"冻结\"了，不能再被任何人随意修改\r\n\r\n4、配置项的版本号规则与配置项的状态相关，以下叙述中正确的是( A ) \r\n\r\nA.处于正式状态的配置项版本号为X.Y，X为主版本号，取值范围为1到9 \r\n\r\nB.处于草稿状态的配置项版本号格式为X.YZ，当配置项通过评审，状态第一次成为 “正式”时，版本号直接设置为1.0 \r\n\r\nC.处于修改状态的配置项版本号格式为X.YZ，其中X保持不变，YZ在01到99之间递增 \r\n\r\nD.处于正式状态的配置项版本号为0.YZ，随着草稿的修正，YZ取值逐渐递增\r\n\r\n5、配置管理计划由( C )审批。\r\n\r\nA.项目经理 B.监理工程师 C.配置管理员 D.CCB\r\n\r\n6、如果一个配置项的版本号为2.13，那么这个配置项处于( A ) 状态。 \r\n\r\nA.修改 B.草稿 C.完成 D.正式\r\n\r\n7、一些配置项形成并通过审核，即形成基线。（对）\r\n\r\n8、一个软件配置项可能有多个标识。（错）\r\n\r\n### 配置管理委员会（SCCB）\r\n\r\n主要负责评估变更、批准变更申请、在生存期内规范变更申请流程、对变更进行反馈、与项目管理层沟通 \r\n\r\n**📝例题**\r\n\r\n1、下列不属于SCCB的职责的是( B ) \r\n\r\nA.与项目管理层沟通 \r\n\r\nB.提出变更申请 \r\n\r\nC.评估变更 \r\n\r\nD.对变更进行反馈\r\n\r\n### 基线\r\n\r\n基线是软件生存期各开发阶段末尾的特定点，也称为里程碑\r\n\r\n**📝例题**\r\n\r\n下列关于里程碑的说法，不正确的是（ A )。\r\n\r\nA.可以是一个时间点，也可以是一个时间段\r\n\r\nB.里程碑是项目中的重要事件\r\n\r\nC.里程碑通常是项目上的关键节点\r\n\r\nD.可以是强制性的，也可以是选择性的\r\n\r\n### 配置库\r\n\r\n1、开发库：开发周期的某个阶段，存放与该阶段工作有关系的信息；开发库也称为工作空间\r\n\r\n2、受控库：开发周期的某个阶段结束时，存放做为该阶段产品及其相关的信息，配置管理对其中的信息进行管理，也称配置库\r\n\r\n3、产品库：存放最终产品的软件库\r\n\r\n**📝例题**\r\n\r\n1、用于管理当前基线和控制对基线的变更的配置库是（A）\r\n\r\nA、受控库。B、静态库。C、产品库。D、动态库\r\n\r\n## 十一、**软件项目收尾**\r\n\r\n### 软件项目收尾过程\r\n\r\n制定项目结束计划、完成收尾工作、项目最后评审、项目结束总结\r\n\r\n**📝例题**\r\n\r\n1、你目前正忙着做项目的收尾工作。在这个最后阶段，在下列哪个方面最容易引发冲突(  B  )。 \r\n\r\nA.缺乏客户的认同 B.进度问题 C.技术问题 D.成本超支\r\n\r\n2、关于认可与奖励，下列说法错误的是( B )。\r\n\r\nA.除了金钱奖励，还存在各种有效的无形奖励\r\n\r\nB.认可与奖励应该在项目结束之后做\r\n\r\nC.只有满足被奖励者的某个重要需求的奖励，才是有效的奖励\r\n\r\nD.在决定认可与奖励时，应考虑文化差异\r\n\r\n## 新增题目\r\n\r\n1、为保证合同订立的合法性，关于合同签订，以下说法不正确的（  D ）\r\n\r\nA.合同价款或者报酬等内容，在合同签署生效后，还可以进行协议补充\r\n\r\nB.为保障双方利益，应在合同正文部分或附件中清晰规定质量验收标准，并可在合同签署生效后协议补充\r\n\r\nC.订立合同的当事人双方，应当具有相应的民事权利能力和民事行为能力\r\n\r\nD.对于项目完成后发生技术性问题的处理与维护，如果合同中没有相关条款，默认维护期限为一年\r\n\r\n2、以下资格要求中对于项目经理最重要的是（ C )\r\n\r\nA.管理经验\tB.技术领域的教育背景\tC.与他人有效合作的能力\tD.谈判技巧\r\n\r\n3、某软件开发项目计划设置如下基线:需求基线、设计基线、产品基线。在编码阶段，详细设计文件需要变更，以下叙述中( B )是正确的。\r\n\r\nA.设计基线已建立，不允许变更\r\n\r\nB.设计基线已经建立，若变更必须走变更控制流程\r\n\r\nC.设计文件评审已通过，直接变更即可\r\n\r\nD.详细设计与设计基线无关，直接变更即可\r\n\r\n4、项目人力资源管理就是有效地发挥每一个项目参与人作用的过程。关于项目人力资源管理说法错误的是(  D )\r\n\r\nA.好的项目经理需要有高超的冲突管理技巧\r\n\r\nB.责任分配矩阵（RAM）被用来表示需要完成的工作和团队成员之间的联系\r\n\r\nC.项目人力资源管理包括人力资源编制、组建项目团队、项目团队建设、管理项目团队四个过程\r\n\r\nD.组织分解结构(OBS）根据项目的交付物进行分解，因此团队成员能够了解应提供哪些交付物\r\n\r\n5、某工程项目进行了施工承包商的招标，共有10家承包商投标。评标工作结束时，招标人决定不接受任何一家的投标。为此，投标价最低的三家承包商想要联名起诉招标方，要求招标方必须接受一家投标。作为一名建筑业律师，你可以给他们什么建议?（A）\r\n\r\nA.不要起诉招标方，因为他有不接受任何投标的权利\r\n\r\nB.招标文件是要约，对招标方有法律约束力\r\n\r\nC.如果起诉，自己的投标保证金会被业主没收\r\n\r\nD.应该起诉招标方，因为招标工作不严肃\r\n\r\n6、刘工是某项目经理，在风险识别时，专家之间采用匿名发表意见的方式，不发生横向联系，只与调查人员发生关系，通过多轮次调查专家对问卷所提问题的看法，从而对将来的可能风险做出预测，刘工采用了(  C )\r\n\r\nA.访谈方法\tB.头脑风暴\tC.德尔菲法\t D.风险分解结构\r\n\r\n7、组建团队是指获得人力资源的过程，项目管理团队应确保所选择的人力资源可以达到项目的要求。在此要求下团队人员获取需要的输入应包括( A ）\r\n\r\n①人员配置管理计划\t②人员库说明\t③招募规则\t④环境和组织因素\t⑤项目人员分配\r\n\r\nA.①②③\tB.③④⑤\tC.①③④\tD.②③⑤\r\n\r\n8、你所管理的项目正处在实施的高峰时期，所在公司又启动了一个新项目。由于公司把新项目的优先程度排在你的项目前面，以至于你的几个重要的团队成员向你提交辞职报告，打算到新项目上去工作。这几个成员的离开，将给你的项目带来很大的麻烦。你应该（ D ） \r\n\r\nA.不批准这几个成员的辞职报告 \r\n\r\nB.向项目发起人求助 \r\n\r\nC.要求新项目的经理不要接受这几个人员 \r\n\r\nD.向管理层求助\r\n\r\n9、下列选项中，（ A ）不属于常见的典型配置项。 \r\nA.合同 B.源代码 C.需求文档 D.项目计划书\r\n\r\n10、在具体识别风险时，需要综合利用 一些专门技术和工具，以保证高效率地识别风险并不发生遗漏，这些方法中，下列 ( B  ) 除外。\r\n\r\nA.情景分析法 B.建模技术 C.德尔菲法 D.头脑风暴法\r\n\r\n11、下列生存期模型中项目被分解为子项目阶段提交的是( C ) 。\r\n\r\nA.螺旋型模型\tB.瀑布模型\tC.增量模型\tD.V模型\r\n\r\n12、制定项目章程过程是属于(\tA\t)。\r\n\r\nA.启动过程组\tB.计划过程组\tC.监督和控制过程组\tD.执行过程组\r\n\r\n13、某项目经理制定了风险管理计划，此计划不应该包含( B )\r\n\r\nA.风险分类\tB.风险登记单\tC.角色和职责\tD.方法论\r\n\r\n14、质量管理人员在安排时间进度时，为了能够从全局出发、抓住关键路径、统筹安排，从而达到按时或提前完成计划的目标，可以使用( C ) 。\r\n\r\nA.因果图\tB.检查表\tC.活动网络图\tD.优先矩阵图\r\n\r\n15、项目合同评审是项目管理中的一项重要工作，其中不包括( A )\r\n\r\nA.进行初步的项目任务分解 B.对自身的资源和能力进行确认 C.确认合同的需求 D.对合同条款进行分析\r\n\r\n16、瀑布模型表达了一种系统的、顺序的软件开发方法。以下关于瀑布模型的正确叙述的是(  A  )。\r\n\r\nA.瀑布模型适用于软件需求确定，开发过程能够采用线性方式完成的项目。\r\n\r\nB.瀑布模型适合需求不明确的的软件开发环境。\r\n\r\nC.瀑布模型能够非常快速地开发大规模软件项目。\r\n\r\nD.只有很大的开发团队才使用瀑布模型。\r\n\r\n17、合同要用可以理解的和强制的形式书写，如果下列所有的选择可用，编写合同满足项目的最好的行动方针是( D )。\r\n\r\nA.准备独特的条款和条件 \tB.使用一个现有的合同\tC.避免使用合同文件\tD.只要有可能就使用标准条款\r\n\r\n18、下列选项中，不属于项目经理的权力的是（ D )\r\n\r\nA.挑选项目团队成员\tB.对项目团队的资源进行分配\tC.知道项目有关的决策\tD.决定项目的预算\r\n\r\n19、下列活动不属于项目团队建设的是( A ) 。\r\n\r\nA.编写人力资源计划\tB.非正式培训\tC.组织娱乐活动让大家互相认识了解\tD.集中办公\r\n\r\n20、关于质量计划与质量体系之间的描述，正确的是（ A ) 。\r\n\r\nA.质量计划是为具体产品、项目、服务或合同准备的\r\n\r\nB.质量体系由单个组织实体采用，通常是质量保证部门\r\n\r\nC.质量计划并非组织管理系统的一个组成部分\r\n\r\nD.质量体系是为具体产品、项目、服务或合同准备的\r\n\r\n21、风险管理的四个层次不包括 ( A ) \r\n\r\nA.风险解决 B.消灭根源 C.着力预防 D.危机管理\r\n\r\n22、配置项是构成产品配置的主要元素，其中( C ）不属于配置项。\r\n\r\nA.测试用例\tB.需求规格说明书\tC.设备清单\tD.源代码","title":" 软件项目管理资料\r\n","category":[" 软件工程\r\n"],"date":" 2024-06-02\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n 一、软件项目管理概述\r\n\r\n 项目的定义及其特点\r\n\r\n定义：为了创造一个唯一的产品或提供一个唯一的服务而进行的临时性的努力\r\n\r\n特点：\r\n\r\n 一次性与独特性\r\n  目标的确定性与过程的不确定性\r\n 活动的整体性与过程的渐进性\r\n 组织的临时性和开放性\r\n 依赖性和冲突性\r\n 结果的不可逆转性\r\n 周期性\r\n\r\n:pencil:例题\r\n\r\n1、一次性的含义：项目有确定的开始和结束时间\r\n\r\n2、—般而言，项目的范围确定后，项目的三个基本目标是 C ）\r\n\r\nA.时间、功能、成本\r\n\r\nB.成本、功能、质量\r\n\r\nC.时间、成本、质量\r\n\r\nD.时间、功能、质量\r\n\r\n3、下列说法不是项目基本特征的是 B  \r\n\r\nA.项目具有一次性 B.项目组织采用矩阵式管理 C.项目需要确定的资源 D.项目有一个明确目标\r\n\r\n 项目与日常运作的区别\r\n\r\n从工作性质、工作环境、管理组织、目的、目标，管理追求等方面分析\r\n\r\n 项目是一次性的，日常运作是重复进行的\r\n 项目是以目标为导向的，日常运作是通过效率和有效性体现的\r\n 项目是通过与项目经理及其团队工作完成的，而日常运作是职能式的线形管理\r\n 项目存在大量的变更管理，而日常运作则基本保持持续的连贯性的\r\n\r\n:pencil:例题\r\n\r\n1、错误说法：1、项目的目标是为了维持业务而持续进行。2、运营的目标是要达到这一目标从而结束项目。3、项目具有连续性和重复性，运营则具有临时性和独特性\r\n\r\n 项目管理\r\n\r\n项目管理是以项目为对象，通过使用知识、技能、工具和方法来组织、计划、实施并监控项目，使之满足项目目标需求的过程\r\n\r\n项目管理通过执行一系列的过程来完成\r\n\r\n项目的成功受到时间、成本、质量、范围等各方面的约束，成功的项目需要满足或者超过干系人的期望\r\n\r\n:pencil:例题\r\n\r\n1、错误的说法：项目管理的过程都是顺序进行，不重叠，不交互的\r\n\r\n2、项目质量管理的目标是满足（ C ）的需要。 \r\n\r\nA.组织 B.老板 C.项目 D.项目经理\r\n\r\n3、项目管理是 D 。 \r\n\r\nA.不需要的，如果所有的职能经理都能负起相应的责任\r\n\r\nB.不需要的，除非项目陷入了极大的困难 \r\n\r\nC.需要的，仅当项目具有高度的可见性 \r\n\r\nD.需要的，因为职能组织及其计划和控制方法不能保证复杂的项目按时且在预算内完成\r\n\r\n4、一般来说，要把项目管理好，至少需要4种过程，配置管理过程属于（ D ） \r\n\r\nA.改进类过程 B.技术类过程 C.管理类过程 D.支持类过程\r\n\r\n项目管理的内容\r\n\r\n 从管理职能角度包括：项目计划、组织、人事安排、控制、协调等\r\n 从项目活动的全过程包括：项目决策、项目规划与设计、项目的招投标项目实施、项目终结等\r\n 从项目目标和约束角度包括：项目进度管理、项目成本管理、项目质量管理等\r\n\r\n软件项目管理的必要性\r\n\r\n 无规则、混乱的开发状态，进度滞后，费用超支等失败的例子很多\r\n 业务失败，合同纠纷，法律诉讼，客户投诉等困扰软件业\r\n\r\n 项目生命周期的阶段及影响\r\n\r\n分为六个：\r\n\r\n1、计划阶段\r\n\r\n2、需求分析阶段\r\n\r\n3、软件设计阶段\r\n\r\n4、编码阶段\r\n\r\n5、测试阶段\r\n\r\n6、运行维护阶段\r\n\r\n分为四个：\r\n\r\n启动  计划 <= 执行  结束\r\n\r\n软件项目管理的核心： 计划 <= 执行\r\n\r\n影响\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//665dde2fb02ce.png\r\n\r\n生命期的几个概念：\r\n\r\n 检查点：它指在规定的时间间隔内对项目进行检查，比较实际现状与计划之间的差异，并根据差异进行调整\r\n\r\n 里程碑：它是完成阶段性工作的标志，不同类型的项目里程碑不同\r\n\r\n 基线：它指一个或一组配置项在项目生命期的不同时间点上，通过正式评审而进入正式受控的一种状态\r\n\r\n:pencil:例题\r\n\r\n1、下列有关项目生命周期的说法错误的是 D  \r\n\r\nA.项目的生命周期分为启动、计划、执行、收尾4个阶段 \r\n\r\nB.项目开始时，成功地完成项目的把握性较低，因此风险和不确定性是最高的 \r\n\r\nC.项目开始时对费用和人员的需求比较少，随着项目的发展，人力投入和费用会越来越多，并达到一个最高点，当项目接近收尾时又会迅速地减少 \r\n\r\nD.项目的生命周期往往涵盖了产品的生命周期\r\n\r\n2、项目生命周期四个阶段中，第二阶段结束于 A 。\r\n\r\nA.签订合同 B.项目结束 C.申请书的提交 D.需求建议书的发布\r\n\r\n3、下列有关项目生命周期及其特征的描述中不正确的是 C 。\r\n\r\nA.在项目的初始阶段不确定性水平最高，因此达不到项目目标的风险也是最高的\r\n\r\nB.项目的生命周期定义了从项目开始直到结束的项目阶段\r\n\r\nC.在项目初始阶段，项目干系人影响项目的最终产品特征和项目最终费用的能力最弱。【最强】\r\n\r\nD.在项目初始阶段，成本与人员的投入水平较低，在中间阶段达到最高，当项目接近结束时，则快速下降\r\n\r\n 软件项目管理的过程\r\n\r\n启动  计划  执行  收尾\r\n\r\n:pencil:例题\r\n\r\n1、投入成本和时间最多的是（执行）阶段\r\n\r\n 项目管理知识体系\r\n\r\n项目管理知识体系（PMBOK）知识领域：整体管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理【没有合同管理、招聘管理】\r\n\r\nPMBOK 过程组：启动过程组、计划过程组、执行过程组、控制过程组、收尾过程组\r\n\r\n:pencil:例题\r\n\r\n1、人力资源计划编制的输出不包括 A \r\n\r\nA.人力资源模板 B.项目的组织结构图 C.人员配备管理计划 D.角色和职责\r\n\r\n2、下列选项中， D ）不是制定项目人力资源计划过程的结果。\r\n\r\nA.人员配置管理计划 B.项目的组织结构图 C.角色和职责的分配 D.团队成员的人际关系\r\n\r\n3、在项目执行过程中，项目经理不断提醒团队成员要集中精力完成工作分解结构中所规定的可交付成果，不要去做其他未经批准的工作。项目经理是在关注（ B ）\r\n\r\nA.团队建设 B.范围管理 C.范围变更管理 D.风险管理\r\n\r\n4、项目范围管理旨在确保（ A \r\n\r\nA.只做为成功完成项目所需的工作\r\n\r\nB.做尽可能多的工作\r\n\r\nC.确定不包括在项目范围内的工作\r\n\r\nD.为客户提供额外的产品功能\r\n\r\n5、单个项目管理的过程组中， D ）的主要任务是确定和细化目标，并规划为实现项目目标和项目范围的行动方针和路线，确保实现项目目标。\r\n\r\nA.执行过程组。B.启动过程组。C.监控过程组。D.规划过程组\r\n\r\n 二、软件项目合同管理\r\n\r\n 合同的定义及包含的内容\r\n\r\n定义：合同是使卖方负有提供具体产品和服务的责任，买方负有为该产品和产品服务付款的责任的一种双方相互负有义务的协议\r\n\r\n内容：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//Y2O4XLMN9VHM0VXSHV.png\r\n\r\n:pencil:例题\r\n\r\n1、合同内容是当事人订立合同时的各项合同条款。合同的主要内容包括 A  \r\n\r\nA.以上全部 \r\n\r\nB.违约责任\r\n\r\nC.项目费用及工程款的支付方式 \r\n\r\nD.当事人各自的权利、义务\r\n\r\n2、在项目招标投标过程中，下列说法错误的是 D  \r\n\r\nA.招标文件不得要求或者标明特定的生产供应者以及含有倾向或者排斥潜在投标人的其他内容 \r\n\r\nB.招标人设有标底的，标底必须保密 \r\n\r\nC.招标人不得以不合理的条件限制或者排斥潜在投标人，不得对潜在投标人实行歧 视待遇 \r\n\r\nD.招标人采用邀请招标方式的，应当向三个以上同行业的组织参加\r\n\r\n3、当（合同甲乙双方损坏了社会共同利益）时，合同可能认定为无效\r\n\r\n4、依据《中华人民共和国招标投标法》，公开招标是指招标人以招标公告的方式要求 C 投标。\r\n\r\nA.通过竞争性谈判的法人或者其他组织\r\n\r\nB.单一来源的法人或者其他组织\r\n\r\nC.不特定的法人或者其他组织\r\n\r\nD.特定的法人或者其他组织\r\n\r\n5、某公司想要对本单位的内部网络和办公室系统进行改造，希望通过招标选择承建商，为此，该公司进行了一系列活动。以下 C 活动不符合《中华人民共和国招标 投标法》的要求。 \r\n\r\nA.该公司计划由一家招标代理机构负责招标，并计划同一天开标。 \r\n\r\nB.有四家公司参加了投标，其中一家投标单位在截止日期之后提交投标文件，该公司认为其违反了招标文件要求，没有接受该投标单位的投标文件 \r\n\r\nC.该公司根据招标文件的要求，在三家投标单位中选择了其中一家作为此项目的承建商，并只将结果通知了中标企业。 \r\n\r\nD.该公司根据此项目的特点和需要编制了招标文件，并确定了提交投标文件的截止日期\r\n\r\n6、在某个软件开发项目中，卖方已经按照合同要求圆满地完成了项目工作。这时，买方又要求在合同中添加一项新工作。鉴于上述情况，卖纺应该如何做?（C）\r\n\r\nA.立即开展新工作，以便维护与买方的良好关\r\n\r\nB.同意添加新工作，但要求用成本补偿的方式来做\r\n\r\nC.开始合同收尾，并要求就新工作签订新合同\r\n\r\nD.拒绝做新工作，因为合同已经完成\r\n\r\n 合同的生存期\r\n\r\n1、合同准备\r\n\r\n 招标书的定义：需求定义，及甲方要求采购的内容\r\n 供方选择：招标文书确定后，就可以进行供方的选择\r\n 合同文本准备：签署合同，签合同前起草一份合同文本\r\n\r\n2、合同签署：正式签署合同，并分解出合同中需方的任务，下达任务书，指派相应项目经理负责\r\n\r\n3、合同管理\r\n\r\n 对需求对象的验收\r\n 对违约事件的处理\r\n\r\n4、合同终止：当项目满足结束条件，项目经理或者合同管理者应该及时宣布项目结束，终止合同的执行\r\n\r\n:pencil:例题\r\n\r\n合同生存期不包括 A 。\r\nA.合同环境 B.合同准备 C.合同终止 D.合同管理\r\n\r\n 需方/供方合同环境\r\n\r\n需方合同环境\r\n\r\n企业在需方合同环境下，关键要素是提供准确、清晰和完整的需求，选择合格的供方并对采购对象（采购对象包括产品服务、人力资源等）进行必要的验收。\r\n\r\n这个需求可能来自于企业内部的需要，也可能是在为客户开发的软件项目中的一部分，通过寻找合适的软件开发商，将部分软件外包给其他的开发商。\r\n\r\n供方合同环境\r\n\r\n企业在供方乙方合同环境下，关键要素是了解清楚需方（甲方）的要求并判断企业是否有能力来满足这些需求。\r\n\r\n作为软件开发商，更多担任的是供方的角色。\r\n\r\n:pencil:例题\r\n\r\n1、建设方和承建方甲就某信息系统建设项目进行了多次协商均未达成一致，未能签订 系统建设合同，但在谈判期间建设方获悉了甲的行业关键技术。之后建设方与另一 承建方乙经过合同谈判后就系统建设签定了合同，同时将甲的关键技术指标透露给乙，导致甲蒙受损失。下列说法中，  B 是正确的。 \r\n\r\nA.建设方和甲未签定合同，对甲蒙受的损失不应承担赔偿责任 \r\n\r\nB.建设方对甲蒙受的损失应承担赔偿责任 \r\n\r\nC.乙和甲未签定合同，对甲蒙受的损失不应承担赔偿责任 \r\n\r\nD.甲的损失是由于其自身保密工作未做好，其损失应全部由其自身承担\r\n\r\n2、下列不属于乙方招投标阶段任务的是?（ C ）\r\n\r\nA.竞标 B.合同签署 C.招标书定义 D.项目分析\r\n\r\n3、下列不属于甲方招投标阶段任务的是？（A）  \r\n\r\nA.编写建议书  B.招标书定义  C.供方选择  D.合同签署\r\n\r\n4、项目建议书是（C）阶段开发的文档  \r\n\r\nA.项目执行 B.项目结尾  C.项目初始  D.项目计划  \r\n\r\n 合同管理主要内容\r\n\r\n合同履行管理、合同变更管理、合同签订管理【无合同评审管理】\r\n\r\n:pencil:例题\r\n\r\n1、下列说法中， A 不是合同管理的主要作用。\r\n\r\nA.提高项目利润和产品质量 \r\n\r\nB.合同规定了双方的经济关系，包括实施过程中的经济责任、利益和权利 \r\n\r\nC.合同确定了信息系统实施和管理的主要目标 \r\n\r\nD.合同是监理的基本依据，利用合同可以对工程进度、质量和成本实施管理和控制\r\n\r\n 三、软件开发过程管理\r\n\r\n SWCMM 和 CMMI 的基础内容\r\n\r\n1、SWCMM\r\n\r\nSWCMM的5级框架：\r\n\r\n 初始级：无序、混乱的软件过程。依赖个别人的努力和机遇。\r\n 可重复级：建立基本的项目管理过程。相似项目，重复以往成果。\r\n 已定义级：文档化、标准化和标准的软件过程。\r\n 已管理级：软件过程和产品质量有详细的度量标准。\r\n 优化级：持续的对过程进行改进。\r\n\r\n:pencil:例题\r\n\r\n1、小张单独一个人随意地进行软件的全部开发过程，属于SWCMM中的（ A \r\n\r\nA.初始级\r\n\r\nB.已定义级\r\n\r\nC.已管理级\r\n\r\nD.可重复级\r\n\r\n2、CMMI\r\n\r\nCMMI 有两种不同的实施方法：\r\n\r\n 连续式：主要是衡量一个企业的项目能力\r\n 阶段式：主要是衡量一个企业的成熟度\r\n\r\nCMMI 的五个台阶：完成级、管理级、定义级、量化管理级、优化级\r\n\r\n每一个台阶都是上面一阶台阶的基石。要上高层台阶必须首先踏上较低一层台阶\r\n\r\n 传统软件开发生命周期模型\r\n\r\n瀑布模型：项目的需求在项目开始前很明确，解决方案在项目开始前也很明确\r\n\r\n螺旋模型：适用于需求不明确的大规模软件项目；可能发生一些重大的变更；项目规模很大；基于风险驱动的开发模型，使用原型法或其它方法来尽量降低风险；项目中采用了新技术\r\n\r\n进化模型：需求和设计不能被准确定义，良好地理解；项目引入了新的或未经证明的技术方法；有多种用户组，可能发生需求冲突；系统功能需要向用户演示以便于演进\r\n\r\n原型模型：在项目开始前，项目的需求不明确；需要减少项目的不确定性\r\n\r\n增量模型：在项目开始时明确了大部分的需求，但是需求可能会发生变化；对于有庞大和复杂功能的系统进行功能改进时需求一步一步实施的项目；对市场和用户的把握不是很准，需求逐步了解的项目\r\n\r\n:pencil:例题\r\n\r\n1、目前有一款具有庞大和复杂功能的系统需要进行功能改进，最好选用 B \r\n\r\nA.原型模型。B.增量模型。C.进化模型。D.瀑布模型\r\n\r\n2、软件开发的增量模型 A  \r\n\r\nA.是—种能够快速构造可运行产品的好方法\r\n\r\nB.是一种不适用于商业产品的创新模型\r\n\r\nC.最适用于需求被清晰定义的情况\r\n\r\nD.最适合于大规模团队开发的项目\r\n\r\n3、（  A ）把整个软件开发流程分成多个阶段，每一个阶段都由目标设定、风险分析、开发和有效性验证以及评审构成。\r\n\r\nA.螺旋模型。B.增量模型。C.进化模型。D.瀑布模型\r\n\r\n4、对可能存在较大风险的项目进行软件开发过程管理时，常采用的模型是（ C ）。\r\n\r\nA.原型模型 B.V模型 C.螺旋型模型 D.增量模型\r\n\r\n5、适用于需求不明确的大规模软件项目，最好选择（ B ）进行开发。 \r\n\r\nA.原型模型 B.螺旋模型 C.增量模型 D.瀑布模型\r\n\r\n6、在项目开始前，项目的需求不明确的情况，选择（ B ）进行开发。\r\n\r\nA.增量模型 B.原型模型 C.瀑布模型 D.螺旋模型\r\n\r\n7、在项目开始时明确了大部分的需求，但是需求可能会发生变化，选择（ C ）进行开发\r\n\r\nA.原型模型 B.螺旋模型 C.增量模型 D.瀑布模型\r\n\r\n8、在开发一个系统时，如果用户对系统的目标不很清楚，难以定义需求，这时最好使用（ A ）。\r\n\r\nA.原型法 B.增量模型 C.瀑布模型 D.螺旋模型\r\n\r\n 四、软件质量管理\r\n\r\n 软件质量的定义和核心内容\r\n\r\n定义：软件质量等于软件内在质量、过程质量与客户满意度的总和【不包括软件外在质量】\r\n\r\n核心内容：需求 和 标准\r\n\r\n:pencil:例题\r\n\r\n1、关于软件质量， （ C ）的叙述是正确的。 \r\n\r\n（1）软件满足规定或潜在用户需求特性的总和\r\n\r\n（2）软件特性的总和：软件满足规定用户需求的能力\r\n\r\n（3）是关于软件特性具备“能力”的体现\r\n\r\n（4）软件质量包括“代码质量”、“外部质量”和“使用质量”三部分\r\n\r\nA.（1）和（2） B.（2）和（4） C.（1）和（3） D.（2）和（3）\r\n\r\n2、软件质量的定义是（ B 。\r\n\r\nA.最大限度达到用户满意\r\n\r\nB.软件优秀特性的总和，以及满足规定和潜在用户需求的能力\r\n\r\nC.软件的功能性、可靠性、易用性、效率、可维护性、可移植性\r\n\r\nD.满足规定用户需求的能力\r\n\r\n3、以下关于质量管理的叙述中，不正确的是（ C ）。 \r\n\r\nA.质量方针由最高管理者批准并发布 \r\n\r\nB.质量管理注重预防胜于检查 \r\n\r\nC.产品等级高就是质量好 \r\n\r\nD.质量目标是落实质量方针的具体要求，从属于质量方针\r\n\r\n4、质量管理是在质量方面指挥和控制组织的协调的活动。这些活动中（  A  ）除外。\r\n\r\nA.不做变更，以确保产品质量\tB.制定质量方针\tC.质量控制\tD.质量改进\r\n\r\n 不同层次的软件质量工作\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//BKEHL1XVS9F1THN.png\r\n\r\n:pencil:例题\r\n\r\n1、（ C ）属于QA的主要职责。\r\n\r\nA.组织对软件过程的改进\r\n\r\nB.组织对概要设计同行评审\r\n\r\nC.检查工作产品及过程与规划的符合性\r\n\r\nD.文件版本管理\r\n\r\n 软件质量模型\r\n\r\n 基于经验模型\r\n   层次模型：McCall 模型、Boehm 模型、ISO9126 模型\r\n   关系模型：Perry 模型\r\n 基于构建的模型：Dromey 模型\r\n\r\n:pencil:例题\r\n\r\n1、以下软件质量模型中，属于关系模型的是 （ C ）。 \r\n\r\nA.MaCall模型 B. ISO9126模型 C.Perry模型 D. Boehm模型\r\n\r\n2、下列质量模型中属于层次模型的是（ C ）。 \r\n\r\nA.Dromey 模型 B.Perry模型  C.ISO9126模型  D.W模型\r\n\r\n3、McCall质量模型不包含（ B  。\r\n\r\nA.产品运行  B.产品特点  C.产品修正  D.产品移植\r\n\r\n 软件质量工具\r\n\r\n1、表格类工具：问题分析\r\n\r\n2、柱状图类工具\r\n\r\n 直方图：对样本的频率的图形标识，主要用于问题分析，可以针对多个参数变化情况绘制，无任何预测能力\r\n 帕累托图：特殊的直方图，必须按发生频率的降序排序，主要用于问题识别，用于确定质量属性的因素，并作为软件质量改进应首先采取的措施\r\n\r\n3、折线图类工具\r\n\r\n 游程图：表示参数随时间变化而变化的图，用于问题识别和问题分析，通过显示一定时间间隔内得到的测量结果，有一定预测能力\r\n 控制图：高级的游程图，判断过程是否处于空置状态，用于问题分析\r\n\r\n4、枝状图类工具\r\n\r\n 因果图（鱼骨图）：表示一个质量属性（即结果）与影响该属性的因素（即原因）之间的关系，用于问题识别和问题分析\r\n\r\n5、离散点图类工具：用于展示和发现两组相关数据之间的关系类型和程度，并对未来的发展趋势进行预测\r\n\r\n📝例题\r\n\r\n1、下列方法中，能描述由不同原因相互作用所产生的潜在问题的方法是 D \r\n\r\nA.控制图 B.趋势分析 C.帕累托图 D.因果图\r\n\r\n2、（D）不是质量控制的方法、技术和工具\r\n\r\nA.因果图 B.直方图 C.散点图 D.成本效益分析\r\n\r\n3、在进行工程质量控制时，直方图可以用来 A 。\r\n\r\nA.判断生产过程的质量状况\r\n\r\nB.分析产生质量问题的原因\r\n\r\nC.分析质量特性与影响因素之间的关系\r\n\r\nD.寻找引起质量问题的主要因素\r\n\r\n4、在质量控制过程中， B  是一种基于80/20原理，用于找出影响项目产品或服务质量的主要因素的方法。\r\n\r\nA.因果图 B.帕累托图 C.控制图 D.流程图\r\n\r\n5、按照发生频率大小顺序绘制的，表示有多少结果是由已确认类型或范畴的原因所造成的，这是 D 。\r\n\r\nA.统计抽样 B.因果图C.趋势图D.帕累托图\r\n\r\n6、一个问题将延迟项目并增加成本为避免将来出现这个问题项目经理应使用（B）方法来确定根本原因\r\n\r\nA帕累托图  B鱼骨图  C控制  D直方图\r\n\r\n 软件质量度量\r\n\r\n软件质量度量就是软件内在质量度量、过程质量度量和维护质量度量的总和\r\n\r\n软件内在质量度量：平均失效时间、复杂性度量（包括文本复杂度和环复杂度）、缺陷密度、文档缺陷密度、用户问题度量、用户满意度量【无开发过程质量度量】\r\n\r\n📝例题\r\n\r\n下列描述中（ C ）不属于软件内在质量度量。\r\n\r\nA.环复杂度 B.缺陷密度 C.开发过程质量度量  D.平均失效时间\r\n\r\n 软件测试过程模型\r\n\r\n1、V 模型\r\n\r\n2、W 模型\r\n\r\n3、H 模型\r\n\r\n 软件质量保证的措施\r\n\r\n质量保证计划是质量管理（质量计划编制、质量保证和质量控制）的第一过程域\r\n\r\n软件质量保证是为了保证工作产品及服务充分满足用户质量要求而进行的有计划、有组织的活动\r\n\r\n📝例题\r\n\r\n1、为保证项目的质量，要对项目进行质量管理，项目质量管理的第一过程域是（C ）\r\n\r\nA.采用规范方法进行管理 \r\n\r\nB.对项目实施质量监控 \r\n\r\nC.制定项目质量计划 \r\n\r\nD.将实际与标准对照\r\n\r\n2、 D ）是为使项目能够满足相关的质量标准而建立的有计划的、系统的活动。\r\n\r\nA.质量认证。B.质量计划。C.质量记录。D.质量保证\r\n\r\n3、以下有关质量保证的叙述，错误的是（ D ）。\r\n\r\nA.质量保证为质量的持续改进过程提供保证 \r\n\r\nB.质量保证应该贯穿整个项目生命期 \r\n\r\nC.质量审计是质量保证的有效手段 \r\n\r\nD.质量保证主要任务是识别与项目相关的各种质量标准\r\n\r\n4、项目质量控制和项目保证的关系是 A 。\r\n\r\nA.相互交叉、项目重叠\r\n\r\nB.采用相同的方法\r\n\r\nC.有不同的目标\r\n\r\nD.截然分开\r\n\r\n5、项目质量管理由质量计划编制、质量保证和 A 三方面构成。\r\n\r\nA.质量控制  B.质量规范  C.质量记录 D.质量体系\r\n\r\n 五、软件项目团队管理\r\n\r\n 软件项目团队\r\n\r\n软件项目开发团队是通过将不同的个体组织在一起，形成一个具有团队精神的高效率队伍来进行软件项目的开发\r\n\r\n软件项目团队包括所有的项目干系人\r\n\r\n📝例题\r\n\r\n1、高效的项目团队应该 A 。\r\n\r\nA.以任务和结果为导向\r\n\r\nB.集中办公\r\n\r\nC.通过电子网络联系\r\n\r\nD以领导为导向\r\n\r\n 干系人\r\n\r\n指参与项目和受项目活动影响的人，包括：\r\n\r\n1、项目发起人。2、资助者。3、供应商。4、项目组成员。5、协助人员。6、客户。7、使用者。8、项目的反对人\r\n\r\n📝例题\r\n\r\n1、管理项目干系人参与过程的主要作用是 D  \r\n\r\nA.与干系人进行沟通 \r\n\r\nB.鼓励干系人参与项目 \r\n\r\nC.限制干系人参与项目 \r\n\r\nD.提升干系人对项目的支持\r\n\r\n2、关于干系人管理的描述，不正确的是 A \r\n\r\nA.干系人分析在项目立项时进行，以便尽早了解干系人对项目的影响\r\n\r\nB.识别干系人的方法包括组织相关会议、专家判断等\r\n\r\nC.干系人分析是系统地收集干系人各种定性和定量信息的一种方法\r\n\r\nD.典型的项目干系人包含客户、用户、高层领导、项目团队等\r\n\r\n3、一般说来，在处理项目干系人之间的争议时，应该偏向于 C  \r\n\r\nA.执行组织 B.项目发起者 C.顾客 D.高级经理\r\n\r\n4、下列有关项目干系人的描述，错误的是 B  \r\n\r\nA.项目干系人也叫“项目利益相关者” \r\n\r\nB.不同项目干系人目标是相同的 \r\n\r\nC.项目干系人在具体的项目中可能会有不同的职责和权限 \r\n\r\nD.项目干系人可能会对项目及其结果施加影响\r\n\r\n5、项目的反对人不属于项目干系人。（错）\r\n\r\n 软件项目团队管理\r\n\r\n 团队组织计划\r\n 团队人员获取\r\n 团队建设\r\n\r\n📝例题\r\n\r\n1、项目团队建设的内容一般不包括（ D ） \r\n\r\nA.认可和奖励 B.培训 C.同地办公 D.职责分配\r\n\r\n2、在项目团队建设中，在项目经理的下述做法中，有可能不利于团队建设的是 （ B ） \r\n\r\nA.集中办公 B.奖励加班的成员 C.尽早建立团队基本规则 D.鼓励团队成员间的沟通\r\n\r\n 项目组织形式\r\n\r\n一、直线型\r\n\r\n各级领导亲自履行管理职能，按隶属关系直线指挥，逐级向上全权负责\r\n\r\n 最大的优点在于可以防止多重指令和防止双头管理现象的出现，对于一个部门来说可以避免出现接收多个相互矛盾指令的情况\r\n\r\n📝例题\r\n\r\n1、在（直线型）组织结构中，项目成员没有安全感\r\n\r\n2、具有高度风险和很大不确定性的项目最好由（ A ）处理。 \r\n\r\nA.直线型组织 B.职能组织化的公司 C.矩阵型组织 D.激进的团队\r\n\r\n3、你被任命为对公司前途非常重要的项目经理。如果项目成功，你将在公司管理层获得晋升;如果失败，你将会被解雇。你认识到必须进行最严格的项目资源控制。你会为项目选择（ C ）组织形式。\r\nA.矩阵型\tB.职能型\tC.直线型\tD.弱矩阵型\r\n\r\n二、职能型\r\n\r\n在职能组织结构中，工作部门的设置是按照专业职能和管理业务来划分的\r\n\r\n职能组织结构有利于发挥职能部门的专业管理作用和专业管理专长，能适应生产技术发展和间接管理复杂化的特点\r\n\r\n但如果多维指令产生冲突，则将使得下级部门无所适从，容易造成管理混乱。\r\n\r\n📝例题\r\n\r\n1、对于规模较小、偏重于技术、团队人员主要来自一个部门的项目最好采用（职能型）\r\n\r\n2、下列关于职能型组织优缺点的描述中，不正确的是 B \r\n\r\nA.职能利益优先于项目，具有狭隘性\r\n\r\nB.员工缺乏事业上的连续性和保障\r\n\r\nC.组织横向之间的联系薄弱、部门间协调难度大\r\n\r\nD.项目经理极少或缺少权利、权威\r\n\r\n3、下列 （ A ） 不属于职能型组织的优点。 \r\n\r\nA.目前明确单一 \r\n\r\nB.强大的技术支持，便于知识、技能和经验的交流 \r\n\r\nC.清晰的职业生涯晋升路线 \r\n\r\nD.交流简单、责任和权限很清晰\r\n\r\n4、在项目管理的3种组织结构中，适用于主要由一个部门完成的项目或技术比较成熟的项目组织结构是（ A \r\n\r\nA.职能型组织结构\r\n\r\nB.项目型组织结构\r\n\r\nC.都一样\r\n\r\nD.矩阵型组织结构\r\n\r\n三、矩阵型\r\n\r\n主要特点是按两大类型设置工作部门。其命令源是非线性的，因而横向管理部门和纵向管理部门各自负责的工作和管理内容必须明确\r\n\r\n📝例题\r\n\r\n1、在矩阵式管理之下，项目经理应该如何取得项目所需的人力资源?（B）\r\n\r\nA.指令职能部门经理提供所需的人力资源\r\n\r\nB.与职能部门经理就所需人力资源进行谈判\r\n\r\nC.从执行组织外部招聘尽可能多的人力资源\r\n\r\nD.直接向职能部门中的员工发出加入项目团队的邀请信\r\n\r\n2、下列 B 不属于矩阵型组织的优点。\r\n\r\nA.最大限度地利用公司的稀缺资源\r\n\r\nB.结构单一，责权分明，利于统一指挥\r\n\r\nC.改善了跨职能部门间的协调合作\r\n\r\nD.改善了项目经理对整体资源的控制\r\n\r\n3、责任分配矩阵是一种常用的描述项目角色和职责的方式，有关说法错误的是（  A ）  \r\n\r\nA.在反映团队成员个人与其承担的工作时，责任分配矩阵不够直观\r\n\r\nB.责任分配矩阵可以分成多个层级\r\n\r\nC.高层级的责任分配矩阵可以界定团队中的哪个小组负责工作分解中的哪一部分工作\r\n\r\nD.低层级的责任分配矩阵用来在小组内为具体活动分配角色、职责层次\r\n\r\n 六、软件项目需求管理\r\n\r\n 需求的定义及软件需求的层次\r\n\r\n需求定义：\r\n\r\n 用户解决问题或达到目标所需的条件或权能Capability；\r\n\r\n 系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能\r\n\r\n 一种反映上面1或2所描述的条件或权能的文档说明\r\n\r\n软件需求层次：业务需求、用户需求、功能需求、非功能需求、软件规格说明等\r\n\r\n📝例题\r\n\r\n1、下列不属于软件需求范畴的是?（ C ）\r\n\r\nA.用户需要软件达到什么样的性能\r\n\r\nB.用户需要软件能做什么样的事情\r\n\r\nC.软件项目采用什么样的实现技术\r\n\r\nD.用户需要软件完成什么样的功能\r\n\r\n 需求工程\r\n\r\n也叫做需求过程或需求阶段，包括需求开发和需求管理\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//VMC2UM8DKERY.png\r\n\r\n📝例题\r\n\r\n1、确认软件需求是软件项目成功的重要保证，其中反映本组织对系统、产品高层次目标的要求属于 C  。\r\n\r\nA.用户需求 B.功能需求 C.业务需求 D.系统需求\r\n\r\n 需求获取方法\r\n\r\n1、访谈和调研\r\n\r\n2、专题讨论会\r\n\r\n3、脑力风暴\r\n\r\n4、场景串联\r\n\r\n 需求变更\r\n\r\n需求变更原因：单纯的用户因素、系统因素、工作环境因素、需求开发工作缺陷\r\n\r\n📝例题\r\n\r\n1、项目进行中会发生很多需求变更，以下正确的做法是（ B ）\r\n\r\nA.独自修订工作范围，减少干系人的影响\r\n\r\nB.提醒所有人注意变更程序\r\n\r\nC.要求管理层提供帮助\r\n\r\nD.减少和拒绝变更\r\n\r\n2、（ B ）是软件项目的一个突出特点，可以导致软件项目的蔓延\r\n\r\nA.展示性 B.需求变更 C.约束性 D.阶段性\r\n\r\n一名团队成员急于将客户正在考虑的新功能添加到项目可交付成果中。在开始为这些新功能工作之前，需要谁的批准？ （ A ）\r\n\r\nA.变更控制委员会ccb B.项目经理 C.项目发起人 D.主题专家\r\n\r\n3、某项目已进入实施阶段，此时用户提出要增加一项新的功能，项目经理应该（ B \r\n\r\nA.立即实现该变更\r\n\r\nB.通过变更控制流程进行处理\r\n\r\nC.拒绝该变更\r\n\r\nD.要求客户应先去与公司领导协商\r\n\r\n 建模方法\r\n\r\n用例分析法：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//GF8RA2J1Q.png\r\n\r\n原型分析法：原型法是为了快速开发系统而推出的一种开发模式，旨在改进传统的结构化生命周期法的不足，缩短开发周期，减少开发风险。\r\n\r\n结构化分析法：强调开发方法的结构合理性以及所开发软件的结构合理性的软件开发方法。\r\n\r\n📝例题\r\n\r\n1、下列不属于结构化方法设计的是? （D）\r\n\r\nA.数据流图 B.数据字典 C.系统流程图 D.系统用例图\r\n\r\n2、敏捷开发方法XP是一种轻量级高效低风险的软件开发方法系统的设计，要能够尽可能早交付（C）属于最佳实践\r\n\r\nA持续集成  B隐喻  C小型发布  D重构\r\n\r\n3、需求分析建模的方法不包括 B   \r\n\r\nA.结构化分析 B.非结构化分析 C.原型分析 D.用例分析\r\n\r\n 七、软件项目开发计划\r\n\r\n 软件项目分解\r\n\r\n项目分解就是先把复杂的项目逐步分解成一层一层的要素（工作），直到具体明确为止\r\n\r\n分解的结果就是 WBS （任务分解结构）图\r\n\r\nWBS 工作包：\r\n\r\n WBS 的最低层次的可交付成果\r\n 工作包应当由唯一主体负责\r\n 这一交付成果可以分配给另外一位项目经理进行计划和执行，或者通过子项目的方式完成\r\n\r\n📝例题\r\n\r\n1、WBS典型的用途是 C \r\n\r\nA.定义提供商提供给买主的包括的层次\r\n\r\nB.在工作元素分配给个人的时间记录\r\n\r\nC.组织和定义项目的所有范围\r\n\r\nD.去识别合适的项目出资人\r\n\r\n2、创建WBS的工具是（ B ）\r\n\r\nA.产品分析 B.分解 C.头脑风暴 D.滚动式规划\r\n\r\n3、WBS是对项目由粗到细的分解过程，它的结构是（ A ） \r\n\r\nA.分级的树形结构 \r\n\r\nB.分级的图状结构 \r\n\r\nC.分层的线性结构 \r\n\r\nD.分层的集合结构\r\n\r\n 软件项目进度计划\r\n\r\n1、项目进度（时间）管理过程\r\n\r\n 活动定义：确定为完成项目的各个交付成果所必须进行的诸项具体活动，完成 WBS 中的细目和子细目\r\n 活动排序：项目各项活动之间存在相互联系与相互依赖关系对，根据这些关系安排各项活动的先后顺序\r\n 活动历时估计\r\n 制定进度计划\r\n 进度控制\r\n\r\n📝例题\r\n\r\n1、刘工是某信息系统集成项目的项目经理，WBS分解工作已经完成，现在他把WBS中的工作包再分解成一个个要执行的活动，刘工现在是执行 B 过程。\r\n\r\nA.进度控制。B.定义活动。C.估算活动资源。D.排列活动顺序\r\n\r\n2、某软件开发项目的实际进度已经大幅滞后于计划进度，（ C ）能够较为有效地缩短活动工期。 \r\n\r\nA.要求项目组成员每天加班2到3个小时进行赶工 \r\n\r\nB.购买最新版本的软件开发工具 \r\n\r\nC.请经验丰富的老程序员进行技术指导或协助完成工作 \r\n\r\nD.招聘一批新的程序员到项目组中\r\n\r\n2、任务活动之间的关系依据：\r\n\r\n 强制性依赖关系：一件事必须再另一件事之后做，强制的\r\n 软逻辑关系：做事的时候根据当前进度合理安排，主观的\r\n 外部依赖关系：项目活动与非项目活动之间的依赖关系\r\n 里程碑\r\n\r\n📝例题\r\n\r\n1、为了缩短项目工期，项目经理想要采用快速跟进的方法。应该针对以下哪项来应用快速跟进的方法? B \r\n\r\nA.外部依赖关系。B.软逻辑关系。C.强制性依赖关系。D.内部依赖关系\r\n\r\n2、“软件编码完成之后，我才可以对它进行软件测试”，这句话说明了哪种依赖关系?（B）\r\n\r\nA.里程碑 B.强制性依赖关系 C.外部依赖关系 D.软逻辑关系\r\n\r\n2、以下箭线图，理解正确的是（ B ）\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//SHZFM83P21K8.png\r\n\r\nA.活动A先于活动B进行;A完成后C即可开始\r\n\r\nB.活动A和B可以同时进行;只有活动A和B都完成后，活动C才开始\r\n\r\nC.活动A先于活动B进行;只有活动A和B都完成后，活动C才开始\r\n\r\nD.活动A和B可以同时进行:A完成后C即可开始\r\n\r\n 软件项目进度估算\r\n\r\n1、三点估算法\r\n\r\n1.最理想的完成时间：A天\r\n\r\n2.最正常的完成时间：B天\r\n\r\n3.最差的完成时间：C天\r\n\r\n工期=a+4b+c/6\r\n\r\n2、关键路径法\r\n\r\nfrom LiZhengXuehttps://gitee.com/lijunxi666/picturebed/raw/master/softwareprojectmanage//dasdashwqw.jpg\r\n\r\n3、定额估算法：T = Q /  R \\ S \r\n\r\nT :活动的持续时间\tQ:活动的工作量\tR :人力或设备的数量\tS :开发（生产）效率，以单位时间完成的工作量表示\r\n\r\n📝例题\r\n\r\n1、某项工作估计一般大约需要9周完成。如果一切顺利将在6周内完成，但在最坏的情 况下需要18周完成。利用三点估算法估计完成该项工作的期望时间是（ C ）周。 \r\n\r\nA.9 B.18 C.10 D.6\r\n\r\n2、在进行项目活动历时估算时，如果很难获得项目工作的详细信息，可以采用 B 作为项目活动历时估算的工具。\r\n\r\nA.预留时间估算法 B.类比估算法 C.参数估算法 D.三点估算法\r\n\r\n3、采用三点估算法估算活动持续时间，不需要收集下列哪项信息？ A ） \r\n\r\nA.平均时间 B.最可能时间 C.最悲观时间 D.最乐观时间\r\n\r\n4、一项任务的最早开始时间是第2周，最晚开始时间是第5周，最早完成时间是第3周，最晚完成时间是第6周。该任务（ B ） \r\n\r\nA.在关键路径上 B.不在关键路径上 C.有滞后 D.进展情况良好\r\n\r\n 八、软件项目风险管理\r\n\r\n 风险的定义与分类\r\n\r\n风险具有两大属性：可能性和损失\r\n\r\n分类：\r\n\r\n 从范围角度上看，风险主要分为下述三种类型：项目风险、技术风险和商业风险\r\n 软件风险是有关软件项目、软件开发过程和软件产品损失的可能性。软件风险又可区分为软件项目风险、软件过程风险和软件产品风险。 \r\n\r\n📝例题\r\n\r\n1、风险是指（对项目有好影响或坏影响的不确定性事件）\r\n\r\n2、以下对于风险的描述，（ A ）是不正确的。\r\n\r\nA.风险的可避免性\r\n\r\nB.风险与不确定性\r\n\r\nC.风险的可度量性\r\n\r\nD.风险与损失\r\n\r\n3、关于项目的风险管理，下列说法中， D  是不正确的。\r\n\r\nA.定性风险分析后，可进行定量分析 \r\n\r\nB.定性风险分析后，可制定和采取风险应对措施 \r\n\r\nC.风险管理包括风险识别、风险分析、风险应对、风险监控等过程 \r\n\r\nD.风险管理的最终目标是消除风险\r\n\r\n4、在以下各类可用于风险识别的历史信息中最不可靠的是（C）\r\n\r\nA商业数据库  B以往项目档案  C团队成员个人知识  D经验教训数据库\r\n\r\n5、风险管理是项目管理中的重要内容，其中风险概率分析是指 C 。\r\n\r\nA.分析风险对项目的潜在影响\r\n\r\nB.分析风险的可能积极影响\r\n\r\nC.调查每项具体风险发生的可能性\r\n\r\nD.分析风险的可能消极影响\r\n\r\n 风险管理的层次\r\n\r\n四个层次：\r\n\r\n 危机管理：是在风险已经造成麻烦后才着手处理它们\r\n 风险缓解：事先制定好风险发生后的补救措施，但不制定任何的防范措施\r\n 着力预防：将风险识别与风险防范作为软件项目的一部分加以规划和执行\r\n 消灭根源：识别和消灭可能产生风险的根源\r\n\r\n风险管理策略有两种：救火模式和主动模式。\r\n\r\n📝例题\r\n\r\n1、下列不是风险管理过程的是（D）\r\n\r\nA.风险识别 B.风险规划 C.风险评估 D.风险收集\r\n\r\n 风险预测\r\n\r\n风险评估又称风险预测，就是对识别出的风险做进一步分析，对风险发生的概率进行估计和评价，对风险后果的严重程度进行估计和评价，对风险影响范围进行估计和评价，以及对于风险发生时间进行估计和评价\r\n\r\n总结：风险预测从两方面来评估风险，即风险发生的可能性和风险发生可能带来的后果\r\n\r\n📝例题\r\n\r\n1、风险预测不包括：风险应对措施、风险原因分析和风险发生的时间\r\n\r\n 风险识别\r\n\r\n风险识别的主要内容 ：识别并确定项目潜在的风险、识别引起风险的主要因素、识别项目风险可能引起的后果\r\n\r\n风险识别的方法：风险条目检查表，德尔菲法，情景分析法，会议法\r\n\r\n📝例题\r\n\r\n1、确定风险的来源、风险产生的条件、描述其风险特征和确定哪些风险事件有可能影响本项目，并将其特性记载成文的管理活动。这是 C 过程。\r\n\r\nA.风险定量分析\tB.制定风险管理计划\tC.风险识别\tD.风险定性分析\r\n\r\n2、李工正在为一个项目做风险识别，下列   D  是此过程不需要经过的步骤。 \r\n\r\nA.根据直接或间接的症状将潜在的风险识别出来\tB.收集资料\tC.风险形势估计\tD.制定风险管理计划\r\n\r\n 风险评估（风险预测）\r\n\r\n方法：风险评估可采用定性风险评估和定量风险评估来进行\r\n\r\n定性风险评估主要是针对风险概率及后果进行定性的评估，例如采用历史资料法、概率分布法、风险后果估计法等\r\n\r\n定量风险评估是一种广泛使用的管理决策支持技术。一般，在定性风险分析之后就可以进行定量风险分析\r\n\r\n📝例题\r\n\r\n1、某项目经理正根据风险发生的概率，风险发生后对项目目标及其他因素如成本、进度、质量等的影响，来对风险进行优先级排列，说明该项目经理正在  B  \r\n\r\nA.风险识别 B.实施定性风险分析 C.制定风险管理计划 D.实施定量风险分析\r\n\r\n 风险计划\r\n\r\n降低风险的主要策略：回避风险、转移风险、损失控制、自留风险\r\n\r\n📝例题\r\n\r\n1、在一个项目的开发过程中采用了新的技术，为此，项目经理找来专家对项目组人员进行技术培训，这是什么风险应对策略?（ A ）\r\n\r\nA.损失控制。B.回避风险。C.自留风险。D.转移风险\r\n\r\n2、从根本上放弃项目或放弃使用有风险的项目资源、项目技术等，从而避开项目风险的方法是  B    \r\n\r\nA.风险损失控制 B.风险回避 C.风险转移 D.风险自留\r\n\r\n 十、软件项目配置管理\r\n\r\n 软件配置管理（SCM）的基本概念\r\n\r\n软件配置管理对产品进行标志、存储和控制，以维护其完整性、可追溯性以及正确性，它为软件开发提供了一套管理办法和活动原则。\r\n\r\n配置管理主要作用:\r\n\r\n 版本管理\r\n 变更管理\r\n 其他（过程管理）\r\n\r\n📝例题\r\n\r\n1、变更管理首要完成的任务是 C \r\n\r\nA.记录变更信息、填写变更控制单\r\n\r\nB.修改相应的软件配置项基线，确立新的版本\r\n\r\nC.分析变更的必要性和合理性，确认是否实施变更\r\n\r\nD.做出变更，并交上级审批\r\n\r\n2、下列选项中， A 不是项目配置管理的任务。\r\n\r\nA.配置测试\tB.制定项目配置管理计划。\tC.版本管理\tD.发行管理\r\n\r\n3、某新来的配置人员写了配置管理方法，想让老同事帮忙检查存在哪些问题，这种质量保证与评价方法属于 A 。\r\n\r\nA.同行评审 B.审计 C.管理评审 D.技术评审\r\n\r\n4、以下哪项不是项目配置管理中可能遇到的问题?（C）\r\n\r\nA.开发人员未经授权修改代码或文档\r\n\r\nB.因协同开发中，或者异地开发，版本变更混乱导致整个项目失败\r\n\r\nC.甲方与乙方在资金调配上存在意见差异\r\n\r\nD.找不到某个文件的历史版本\r\n\r\n5、软件配置管理SCM是一组用于计算机软件 D ）管理变化的活动。\r\n\r\nA.交付使用后  B.开发过程中  C.测试过程中  D.整个生命周期内\r\n\r\n配置项的状态：\r\n\r\n 处于草稿状态的配置项版本格式：0.YZ\r\n 处于正式发布状态的配置项版本格式：X.Y\r\n 处于正在修改状态的配置项版本格式：X.YZ\r\n\r\n草稿：随着草稿的不断完善，“YZ”的取值应递增。“YZ”的初值和增幅由用户自己把握。 \r\n\r\n正式发布：如果配置项的版本升级幅度比较小，一般只增大Y值，X值保持不变。只有当配置项版本升级幅度比较大时，才允许增大X值。 \r\n\r\n正在修改：配置项正在修改时，一般只增大Z值，X.Y值保持不变。 当配置项修改完毕，状态重新成为“正式发布”时，将Z值设置为0，增加X.Y值\r\n\r\n📝例题\r\n\r\n1、某个配置项的版本由 1.0 变为 2.0，按照配置版本号规则表明  A  \r\n\r\nA.目前配置项处于正式发布状态，配置项版本升级幅度较大 \r\n\r\nB.目前配置项处于正在修改状态，配置项版本升级幅度较大 \r\n\r\nC.目前配置项处于正在修改状态，配置项版本升级幅度较小 \r\n\r\nD.目前配置项处于正式发布状态，配置项版本升级幅度较小\r\n\r\n2、以下关于配置项的描述中，不正确的是 C \r\n\r\nA.所有配置项都必须按照相关规定进行统一编号\r\n\r\nB.基线配置项要向软件开发人员开放读取的权限\r\n\r\nC.所有配置项的操作权限应该由项目经理严格统一管理\r\n\r\nD.非基线配置项向CCB及相关人员开放\r\n\r\n3、以下关于基线的说法，不正确的是  C  \r\n\r\nA.产品的一个测试版本是基线的一个例子 \r\n\r\nB.一个产品可以有多个基线，也可以只有一个基线 \r\n\r\nC.通常将给客户用的基线称为一个\"Build\"，为内部开发用的基线则称为一个“Release” \r\n\r\nD.基线中的配置项被\"冻结\"了，不能再被任何人随意修改\r\n\r\n4、配置项的版本号规则与配置项的状态相关，以下叙述中正确的是 A  \r\n\r\nA.处于正式状态的配置项版本号为X.Y，X为主版本号，取值范围为1到9 \r\n\r\nB.处于草稿状态的配置项版本号格式为X.YZ，当配置项通过评审，状态第一次成为 “正式”时，版本号直接设置为1.0 \r\n\r\nC.处于修改状态的配置项版本号格式为X.YZ，其中X保持不变，YZ在01到99之间递增 \r\n\r\nD.处于正式状态的配置项版本号为0.YZ，随着草稿的修正，YZ取值逐渐递增\r\n\r\n5、配置管理计划由 C 审批。\r\n\r\nA.项目经理 B.监理工程师 C.配置管理员 D.CCB\r\n\r\n6、如果一个配置项的版本号为2.13，那么这个配置项处于 A  状态。 \r\n\r\nA.修改 B.草稿 C.完成 D.正式\r\n\r\n7、一些配置项形成并通过审核，即形成基线。（对）\r\n\r\n8、一个软件配置项可能有多个标识。（错）\r\n\r\n 配置管理委员会（SCCB）\r\n\r\n主要负责评估变更、批准变更申请、在生存期内规范变更申请流程、对变更进行反馈、与项目管理层沟通 \r\n\r\n📝例题\r\n\r\n1、下列不属于SCCB的职责的是 B  \r\n\r\nA.与项目管理层沟通 \r\n\r\nB.提出变更申请 \r\n\r\nC.评估变更 \r\n\r\nD.对变更进行反馈\r\n\r\n 基线\r\n\r\n基线是软件生存期各开发阶段末尾的特定点，也称为里程碑\r\n\r\n📝例题\r\n\r\n下列关于里程碑的说法，不正确的是（ A 。\r\n\r\nA.可以是一个时间点，也可以是一个时间段\r\n\r\nB.里程碑是项目中的重要事件\r\n\r\nC.里程碑通常是项目上的关键节点\r\n\r\nD.可以是强制性的，也可以是选择性的\r\n\r\n 配置库\r\n\r\n1、开发库：开发周期的某个阶段，存放与该阶段工作有关系的信息；开发库也称为工作空间\r\n\r\n2、受控库：开发周期的某个阶段结束时，存放做为该阶段产品及其相关的信息，配置管理对其中的信息进行管理，也称配置库\r\n\r\n3、产品库：存放最终产品的软件库\r\n\r\n📝例题\r\n\r\n1、用于管理当前基线和控制对基线的变更的配置库是（A）\r\n\r\nA、受控库。B、静态库。C、产品库。D、动态库\r\n\r\n 十一、软件项目收尾\r\n\r\n 软件项目收尾过程\r\n\r\n制定项目结束计划、完成收尾工作、项目最后评审、项目结束总结\r\n\r\n📝例题\r\n\r\n1、你目前正忙着做项目的收尾工作。在这个最后阶段，在下列哪个方面最容易引发冲突  B  。 \r\n\r\nA.缺乏客户的认同 B.进度问题 C.技术问题 D.成本超支\r\n\r\n2、关于认可与奖励，下列说法错误的是 B 。\r\n\r\nA.除了金钱奖励，还存在各种有效的无形奖励\r\n\r\nB.认可与奖励应该在项目结束之后做\r\n\r\nC.只有满足被奖励者的某个重要需求的奖励，才是有效的奖励\r\n\r\nD.在决定认可与奖励时，应考虑文化差异\r\n\r\n 新增题目\r\n\r\n1、为保证合同订立的合法性，关于合同签订，以下说法不正确的（  D ）\r\n\r\nA.合同价款或者报酬等内容，在合同签署生效后，还可以进行协议补充\r\n\r\nB.为保障双方利益，应在合同正文部分或附件中清晰规定质量验收标准，并可在合同签署生效后协议补充\r\n\r\nC.订立合同的当事人双方，应当具有相应的民事权利能力和民事行为能力\r\n\r\nD.对于项目完成后发生技术性问题的处理与维护，如果合同中没有相关条款，默认维护期限为一年\r\n\r\n2、以下资格要求中对于项目经理最重要的是（ C \r\n\r\nA.管理经验\tB.技术领域的教育背景\tC.与他人有效合作的能力\tD.谈判技巧\r\n\r\n3、某软件开发项目计划设置如下基线:需求基线、设计基线、产品基线。在编码阶段，详细设计文件需要变更，以下叙述中 B 是正确的。\r\n\r\nA.设计基线已建立，不允许变更\r\n\r\nB.设计基线已经建立，若变更必须走变更控制流程\r\n\r\nC.设计文件评审已通过，直接变更即可\r\n\r\nD.详细设计与设计基线无关，直接变更即可\r\n\r\n4、项目人力资源管理就是有效地发挥每一个项目参与人作用的过程。关于项目人力资源管理说法错误的是  D \r\n\r\nA.好的项目经理需要有高超的冲突管理技巧\r\n\r\nB.责任分配矩阵（RAM）被用来表示需要完成的工作和团队成员之间的联系\r\n\r\nC.项目人力资源管理包括人力资源编制、组建项目团队、项目团队建设、管理项目团队四个过程\r\n\r\nD.组织分解结构OBS）根据项目的交付物进行分解，因此团队成员能够了解应提供哪些交付物\r\n\r\n5、某工程项目进行了施工承包商的招标，共有10家承包商投标。评标工作结束时，招标人决定不接受任何一家的投标。为此，投标价最低的三家承包商想要联名起诉招标方，要求招标方必须接受一家投标。作为一名建筑业律师，你可以给他们什么建议?（A）\r\n\r\nA.不要起诉招标方，因为他有不接受任何投标的权利\r\n\r\nB.招标文件是要约，对招标方有法律约束力\r\n\r\nC.如果起诉，自己的投标保证金会被业主没收\r\n\r\nD.应该起诉招标方，因为招标工作不严肃\r\n\r\n6、刘工是某项目经理，在风险识别时，专家之间采用匿名发表意见的方式，不发生横向联系，只与调查人员发生关系，通过多轮次调查专家对问卷所提问题的看法，从而对将来的可能风险做出预测，刘工采用了  C \r\n\r\nA.访谈方法\tB.头脑风暴\tC.德尔菲法\t D.风险分解结构\r\n\r\n7、组建团队是指获得人力资源的过程，项目管理团队应确保所选择的人力资源可以达到项目的要求。在此要求下团队人员获取需要的输入应包括 A ）\r\n\r\n①人员配置管理计划\t②人员库说明\t③招募规则\t④环境和组织因素\t⑤项目人员分配\r\n\r\nA.①②③\tB.③④⑤\tC.①③④\tD.②③⑤\r\n\r\n8、你所管理的项目正处在实施的高峰时期，所在公司又启动了一个新项目。由于公司把新项目的优先程度排在你的项目前面，以至于你的几个重要的团队成员向你提交辞职报告，打算到新项目上去工作。这几个成员的离开，将给你的项目带来很大的麻烦。你应该（ D ） \r\n\r\nA.不批准这几个成员的辞职报告 \r\n\r\nB.向项目发起人求助 \r\n\r\nC.要求新项目的经理不要接受这几个人员 \r\n\r\nD.向管理层求助\r\n\r\n9、下列选项中，（ A ）不属于常见的典型配置项。 \r\nA.合同 B.源代码 C.需求文档 D.项目计划书\r\n\r\n10、在具体识别风险时，需要综合利用 一些专门技术和工具，以保证高效率地识别风险并不发生遗漏，这些方法中，下列  B   除外。\r\n\r\nA.情景分析法 B.建模技术 C.德尔菲法 D.头脑风暴法\r\n\r\n11、下列生存期模型中项目被分解为子项目阶段提交的是 C  。\r\n\r\nA.螺旋型模型\tB.瀑布模型\tC.增量模型\tD.V模型\r\n\r\n12、制定项目章程过程是属于\tA\t。\r\n\r\nA.启动过程组\tB.计划过程组\tC.监督和控制过程组\tD.执行过程组\r\n\r\n13、某项目经理制定了风险管理计划，此计划不应该包含 B \r\n\r\nA.风险分类\tB.风险登记单\tC.角色和职责\tD.方法论\r\n\r\n14、质量管理人员在安排时间进度时，为了能够从全局出发、抓住关键路径、统筹安排，从而达到按时或提前完成计划的目标，可以使用 C  。\r\n\r\nA.因果图\tB.检查表\tC.活动网络图\tD.优先矩阵图\r\n\r\n15、项目合同评审是项目管理中的一项重要工作，其中不包括 A \r\n\r\nA.进行初步的项目任务分解 B.对自身的资源和能力进行确认 C.确认合同的需求 D.对合同条款进行分析\r\n\r\n16、瀑布模型表达了一种系统的、顺序的软件开发方法。以下关于瀑布模型的正确叙述的是  A  。\r\n\r\nA.瀑布模型适用于软件需求确定，开发过程能够采用线性方式完成的项目。\r\n\r\nB.瀑布模型适合需求不明确的的软件开发环境。\r\n\r\nC.瀑布模型能够非常快速地开发大规模软件项目。\r\n\r\nD.只有很大的开发团队才使用瀑布模型。\r\n\r\n17、合同要用可以理解的和强制的形式书写，如果下列所有的选择可用，编写合同满足项目的最好的行动方针是 D 。\r\n\r\nA.准备独特的条款和条件 \tB.使用一个现有的合同\tC.避免使用合同文件\tD.只要有可能就使用标准条款\r\n\r\n18、下列选项中，不属于项目经理的权力的是（ D \r\n\r\nA.挑选项目团队成员\tB.对项目团队的资源进行分配\tC.知道项目有关的决策\tD.决定项目的预算\r\n\r\n19、下列活动不属于项目团队建设的是 A  。\r\n\r\nA.编写人力资源计划\tB.非正式培训\tC.组织娱乐活动让大家互相认识了解\tD.集中办公\r\n\r\n20、关于质量计划与质量体系之间的描述，正确的是（ A  。\r\n\r\nA.质量计划是为具体产品、项目、服务或合同准备的\r\n\r\nB.质量体系由单个组织实体采用，通常是质量保证部门\r\n\r\nC.质量计划并非组织管理系统的一个组成部分\r\n\r\nD.质量体系是为具体产品、项目、服务或合同准备的\r\n\r\n21、风险管理的四个层次不包括  A  \r\n\r\nA.风险解决 B.消灭根源 C.着力预防 D.危机管理\r\n\r\n22、配置项是构成产品配置的主要元素，其中 C ）不属于配置项。\r\n\r\nA.测试用例\tB.需求规格说明书\tC.设备清单\tD.源代码"},{"filename":"mysql","category":"database","md":{"topSummary":"\r\ntitle: MySQL知识点总结\r\ncategory: MySQL,数据库\r\ndate: 2024-05-23\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n近日看了小林 code 的关于 MySQL 的八股文，易忘，于是在此提取重点记下\r\n\r\n参考文章：[小林code-MySQL篇](https://xiaolincoding.com/mysql/index/index_interview.html)，[JavaGuide-MySQL篇](https://javaguide.cn/database/mysql/mysql-questions-01.html)以及部分知识库\r\n\r\n## 索引\r\n\r\n若把数据库库的表比作一本书，那么索引就是书的目录，通过索引我们可以快速定位想要寻找的位置\r\n\r\n### 索引分类\r\n\r\nMySQL的默认采用存储结构是 InnoDB ，使用最多的索引类型是 B+ 树\r\n\r\n这里我们将不同的索引类型进行分开讨论：\r\n\r\n- 按照数据结构进行划分：B+ 树索引、\tHash 索引、Full-Text 索引\r\n- 按照物理存储进行划分：主键索引、二级索引\r\n- 按照字段特性进行划分：主键索引、唯一索引、普通索引、前缀索引\r\n- 按照字段个数进行划分：单列索引、联合索引\r\n\r\n> 补充 => 按存储方式划分：\r\n>\r\n> - 聚簇索引：非叶子结点只存储 key，叶子结点存储 key 和实际存储\r\n> - 非聚簇索引：非叶子结点只存储 key，叶子结点存储聚簇索引\r\n\r\n### MySQL选取索引探讨\r\n\r\nMySQL所选用的索引第一个目的肯定是查询越快越好，这里我们就到了二分查找，但是二分查找的数组的插入性能低下，就需要用到二分查找树，二分查找树有个弊端：当插入的数据是递增的时候（特殊的数据例子），这时候的查找效率就变成了 O(n)，所以我们需要在插入的时候限制不能让他一直插入到一端结点，这时候就想到了平衡二叉树，平衡二叉树保证了每个节点的左子树和右子树的高度差不能超过 1，很符合当前二分查找树出现弊端的情况，但是新的问题又出现了，平衡二叉树只有两个子节点，当数据非常大的情况下，树的高度就会变得很高，就需要很多次查询，影响效率；于是 B 树就横空出世了，它解决了平衡二叉树结点只有两个导致树高的问题，它可以由很多个子结点，想到用 B 树，那么 B+ 树岂不是更好？，B+ 树的查询、插入和删除、范围查询效率更高，于是就采用了 B+ 树结构作为默认的索引\r\n\r\n### B+ 树索引执行过程\r\n\r\n若存在如下结构的 B+ 树\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/btree.drawio.png)\r\n\r\n当要查询 ID 为5的时候，首先会用二分查询在(1，10，20)之间进行查询，找到在(1，10)之间，接着在第二层进行查询(1，4，7)，找到是在(4，7)范围内，最后在叶子结点进行查找(4，5，6)，找到5，范围其数据即可\r\n\r\n上面是只有主键索引的情况，若出现既有主键索引，又有二级索引的情况，方式就会有变化：二级索引的叶子节点存放的(二级索引，主键索引)，而没有存在具体的数据，如果我们质询要查询主键值，就直接返回【这种在二级索引就能查询到的结果叫做**覆盖索引**】，若要查询其他的具体所以，我们需要通过二级索引查找得到主键值，再通过主键值【**回表**】查询数据，也就是需要查询两个 B+ 树才能查到数据\r\n\r\n### 最左匹配原则\r\n\r\n在使用联合索引的时候，存在最左匹配原则\r\n\r\n比如一个表的索引字段为（a，b，c），当我们查询以下条件的时候（查询的时候与 abc 顺序无关）\r\n\r\n```sql\r\nwhere a=1；\r\nwhere a=1 and b=2 and c=3；\r\nwhere a=1 and b=2；\r\n```\r\n\r\n就会匹配上联合索引，但是若是以下条件时候就不会，不满足最左匹配原则\r\n\r\n```sql\r\nwhere b=2；\r\nwhere c=3；\r\nwhere b=2 and c=3；\r\n```\r\n\r\n为什么呢？因为我们通过B+ 树索引执行过程可知，是先按照 a 进行排序的，当 a 想同，在按照 b 排序，当 b 相同，再按照 c 排序。\r\n\r\n所以 **b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。\t\r\n\r\n### 字段索引选用的情况\r\n\r\n事物都存在两面性，索引既然有好的一面，那么也有坏的一面，例如：\r\n\r\n1. 索引需要的占用物理空间\r\n2. 创建索引和维护索引需要耗费时间，所需时间随数据量增大而增加\r\n3. 降低增删改效率，因为每次增删改，都会动态维护 B+ 树的有序性\r\n\r\n**字段选用索引的情况：**\r\n\r\n1. 经常用 `where` 查询条件的字段\r\n2. 具有唯一性的字段\r\n3. 经常用 `group by` 和 `order by` 的字段【我们不需要再次排序，因为 B+ 树的记录是有序的】\r\n\r\n**字段不选用索引的情况：**\r\n\r\n1. 更新频繁的字段\r\n2. 表数据太少的时候\r\n3. `where`、`group by` 和 `order by` 的用不上的字段\r\n4. 字段中存在大量重复数据的时候\r\n\r\n### 索引失效\r\n\r\nMySQL中索引失效是一个常见的面试题，以下是索引失效的几种情况：\r\n\r\n1. 使用左或者左右模糊匹配的时候，如：`%x` 或 `%xx%` 【注意：`%x` 并不一定会导致索引失效，当表中的字段都是索引字段，没有遵循最左匹配原则也是走全扫描二级索引树】\r\n2. 条件查询中对索引使用函数、计算、类型转换\r\n3. 若是联合索引未遵守最左匹配原则\r\n4. 在 WHERE 子句中，OR 前的条件是索引列，而 OR 后的条件不是索引列\r\n5. 对联合索引进行排序的时候，asc 和 desc 混合使用或者排序的列不是来自同一个联合索引\r\n\r\n### 索引优化的方法\r\n\r\n1、**前缀索引优化**\r\n\r\n2、**覆盖索引优化**：\r\n\r\n添加冗余字段当作联合索引\r\n\r\n3、**主键索引最好自增**：\r\n\r\n若主键自增，每次插入的时候就不用移动数据，直接插到最后；若不是自增，插入位置是随机的，我们就不得不移动其他的数据，甚至是需要从一个页面移到另一个页面，这种现象就是**页分裂**【存在大量空间碎片，结构不紧凑影响查询效率】\r\n\r\n4、**索引最好设置为 NOT NULL**：\r\n\r\n- 为 null 的索引字段进行索引统计和值比较更为复杂，比如：进行索引统计，count 会省略值为 null 的行\r\n- null 会占用至少1字节的物理空间\r\n\r\n5、**防止索引失效**\r\n\r\n### 索引的代价\r\n\r\n**空间代价**\r\n\r\n每次建立一个索引，都会建立一个 B+ 树，一个 B+ 树节点就是一个 MySQL 数据页 16 KB\r\n\r\n**时间代价**\r\n\r\n1、当对数据进行增删改的时候，如果修改的列为索引列，那么也会要对这颗 B+ 树进行修改（设计也分裂，合并，回收）\r\n\r\n2、二级索引需要回表（若查询的数据列不属于索引范畴）\r\n\r\n3、查询的时候需要生成查询计划，以成本为指标，计算各个索引的成本，选取最低的成本索引进行查询\r\n\r\n### 索引查询相关概念\r\n\r\n例如 SQL 语句：`select * from test where id >= 10 and id <= 20`\r\n\r\n**扫描区间**\r\n\r\n需要扫描的记录，所在的区间，这里指的是：[133，982]\r\n\r\n**边界条件**\r\n\r\n形成扫描区间的搜索条件，这里指的是 `id >= 10 and id <= 20 `\r\n\r\n> 注意不是所有的搜索条件都能成为边界条件：\r\n> 如果查询语句变为 id >= 10 and id <= 20 and content = \"123\"，那么在 id 在 [10, 20] 的区间中，并不是按照 content 排序的，content 只作为普通的搜索条件，需要回表后才能判断【效率比全表扫描还低】\r\n\r\n### 执行计划\r\n\r\n一、**table**：无论查询多少张表，最终都会一步步变成单表\r\n\r\n二、**id**：每一个 select 关键字对应一个 id，无论查询多少张表，id 都是一样的。出现在前面的是驱动表，出现在后边的被驱动表\r\n\r\n三、**select_type**：一个大查询被分割成多个小查询，逐步完成\r\n\r\n- SIMPLE：不包含 union 和子查询的查询类型\r\n- PRIMARY：对包含 UNION、UNION ALL 或子查询的大查询来说，最左边的那个 SELECT 对应的 select_type 为 PRIMARY\r\n- UNION：对包含 UNION、UNION ALL 除了最左边的那个 SELECT 对应的小查询外，其余小查询的select_type为 UNION\r\n- UNION RESULT：MySQL 使用临时表来完成UNION的去重工作，这个临时表的 select_type 为  UNION RESULT ，id 为 NULL\r\n- SUBQUERY：如果包含子查询的 SQL 不能转为半连接形式，并且子查询不是相关子查询，且优化器决定采用物化子查询的方式来进行子查询时，这个子查询的第一个 SELECT 关键字对应的查询的  select_type 为 SUBQUERY\r\n- DEPENDENT SUBQUERY ：如果包含子查询的 SQL 不能转为半连接形式，并且子查询被优化器转换为相关子查询，这个子查询的第一个 SELECT 关键字对应的查询的 select_type 为 DEPENDENT  SUBQUERY\r\n\r\n四、**type**：每一条记录对应的表的访问方式\r\n\r\n有如下 SQL\r\n\r\n```sql\r\nCREATE TABLE test (\r\n  id INT NOT NULL AUTO_INCREMENT,\r\n  key1 VARCHAR ( 16 ),\r\n  key2 INT,\r\n  key3 VARCHAR ( 16 ),\r\n  part1 VARCHAR ( 16 ),\r\n  part2 VARCHAR ( 16 ),\r\n  part3 VARCHAR ( 16 ),\r\n  content VARCHAR ( 32 ),\r\n  PRIMARY KEY ( id ),\r\n  KEY idx_key1 ( key1 ),\r\n  UNIQUE uk_key2 ( key2 ),\r\n  KEY idx_key3 ( key3 ),\r\nKEY idx_key_part ( part1, part2, part3 ) \r\n) ENGINE = InnoDB CHARSET = utf8mb4;\r\n```\r\n\r\n效率排序：all < index < range < ref < ref_eq < const < system\r\n\r\n1、const : 通过主键或唯一二级索引定位一条数据，表示常数级别，代价忽略不计\r\n\r\n```sql\r\nEXPLAIN SELECT  * FROM test WHERE id = 1\r\n```\r\n\r\n2、ref：普通二级索引列与常数进行比较（或唯一二级索引列可以为NULL）\r\n只要左起连续的列都是等值匹配，就可以使用ref方式\r\n\r\n```sql\r\nSELECT * FROM test WHERE part1 = 'a'\r\n```\r\n\r\n3、ref_or_null : 通过二级索引进行等值匹配**以及列为NULL的值**\r\n\r\n```sql\r\nexplain SELECT  * FROM test WHERE key1 = '1' OR key1 IS NULL\r\n```\r\n\r\n4、range：使用索引进行查询，并且形成了多个单点扫描区间或范围扫描区间 （(-∞ ， +∞ )不算）\r\n\r\n```sql\r\nexplain SELECT * FROM test WHERE key2 >= 1 or key2 in (123, 312)\r\n```\r\n\r\n5、index：当可以使用索引覆盖，却需要扫描全部索引记录时候的访问方式\r\n\r\n```sql\r\nexplain SELECT part2 FROM test WHERE part3 = 'opq'\r\n```\r\n\r\n6、eq_ref：针对被驱动表，如果是以主键或不问NULL的唯一二级索引进行等值匹配的查询\r\n\r\n五、**possible_keys** ：可能用到的索引\r\n\r\n六、**key**：实际用到的索引\r\n\r\n七、**key_len**：简单的说，是用到的索引的列的长度\r\n\r\n八、**ref**：当访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 时，与索引等值匹配的是什么，一个常数或是一个列\r\n\r\n### 查询的成本\r\n\r\n1、根据搜索条件找出可能使用的索引\r\n\r\n2、计算出全表扫描的代价\r\n\r\n3、计算可能使用不同索引的执行查询的代价\r\n\r\n4、对比各种执行方案的代价，选用成本最低的那个方案\r\n\r\n成本计算 = I/O 成本 + CPU 成本\r\n\r\n- I/O 成本：数据页数  X 1.0 +1.1(微调值)\r\n- CPU 成本：数据记录数 X 0.2 +1.0(微调值)\r\n\r\n使用 SQL 命令：`show TABLE STATUS LIKE 'test'` 用来查看页数和记录数\r\n\r\n- 数据页数：`Data_length` / 16 / 1024\r\n- 数据记录数：`Rows`\r\n\r\n## 事务\r\n\r\nA 向 B 转账100元，首先 A 扣除了100元，但是当 B 接收100元的时候，服务器出现故障导致 B 没有收到转账，但是 A 已经扣除了100元，也就是100元就不见了。要想让操作全部执行成功或者全部执行失败，就需要用到**事务**\r\n\r\n### 事务特性\r\n\r\n事务有四个特性，如下：\r\n\r\n- **原子性**：要么全部成功，要么全部失败\r\n- **一致性**：A 给 B 100元，A 扣除了100元，不会出现B没有增加100元的情况\r\n- **隔离性**：多个事务使用相同的数据时，不会相互干扰\r\n- **持久性**：数据修改后是永久保存的，即使重启后也不会丢失\r\n\r\n### 并行事务引发的问题\r\n\r\n1、**脏读**：一个事务读取到另一个事务未提交的数据\r\n\r\n有一个数据为100，现在 A 将数据修改为200，这时候还未提交事务，这时候 B 获取数据200，拿到别处地方用，可是 A 出现某种状况导致回滚，A 的数据变回100\r\n\r\n2、**不可重复读**：在同一个事务中多次读取同一个数据，但这些读取中取得了不同的结果\r\n\r\n有一个数据为100，现在 A 读取了数据100，接着 B 将数据修改为200并提交了事务，当 A 再次读取的时候数据变成了200，与之前读取的数据不一致\r\n\r\n3、**幻读**：在同一事务中多次查询符合条件的记录数量，出现查询到的数量不一样\r\n\r\n有大于1的记录为100条，现在 B 对大于1的记录条数进行查询得到100，现在 A 插入了一条记录3并提交了事务，当 B 再次查询的时候发现条数为101条，前后两次查询到的记录数量不一样\r\n\r\n**严重性排序**：脏读 > 不可重复读 > 幻读\r\n\r\n### Read View\r\n\r\nRead View 结构如下：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/readview结构.drawio.png)\r\n\r\n### 事务隔离级别\r\n\r\nMySQL有四种事务隔离级别\r\n\r\n#### **读未提交**\r\n\r\n一个事务还未提交，它做的变更就能被其他事务看到\r\n\r\n可能造成：脏读、不可重复读、幻读\r\n\r\n实现：因为能读到未提交事务修改的数据，所以直接读取最新的数据就行\r\n\r\n#### **读提交**\r\n\r\n一个事务提交后才能被其他事务看到\r\n\r\n可能造成：不可重复读、幻读\r\n\r\n实现：**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**\r\n\r\n建议先看可重复读的实现部分，再来看此处的实现部分，进行对比\r\n\r\n比如：例子和可重复读一致\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100（创建了 Read View）\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100（创建了 Read View）\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 为 200（创建了 Read View）\r\n\r\n解释：\r\n\r\n1. 第一次读取事务 B 创建了 Read View\r\n\r\n```\r\ncreator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n事务的 min_trx_id 值51大于 trx_id 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n2. 事务 A 修改了 money 值，记录的字段创建了版本链\r\n\r\n```\r\nid:1, name: Jixer, money: 200, trx_id:51, roll_pointer:o--------->id:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o\r\n```\r\n\r\n3. 事务 B 再次读取，创建了Read View\r\n\r\n```\r\ncreator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n分析和可重复读那块一致\r\n\r\n4. 事务 A 提交了事务，事务 B 第三次读取的时候创建了 Read View\r\n\r\n```\r\nx creator_trx_id:52, mids:[52], min_trx_id: 52, max_trx_id: 53\r\n```\r\n\r\n发现此时的 min_trx_id 值52已经大于了 trx_id 值51，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n所以在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录并提交了事务\r\n\r\n#### **可重复读**\r\n\r\n**MySQL 默认的隔离级别**\r\n\r\n一个事务执行过程中看到的数据一直和事务启动前看到的数据是一致的\r\n\r\n可能造成：幻读【这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，解决方案见下个目录】\r\n\r\n实现：**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**\t\r\n\r\n比如：\r\n\r\n有一条字段如下，trx_id 和 roll_pointer 为**聚簇索引**（一般情况下就是主键索引，但是并不一定是主键索引）记录中的两个隐藏列\r\n\r\n```\r\nid:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o(undo日志)\r\n```\r\n\r\n现在有两个事务 A 和 B\r\n\r\n```\r\nA：creator_trx_id:51, mids:[51], min_trx_id: 51, max_trx_id: 52\r\nB：creator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 依然 100\r\n\r\n解释：\r\n\r\n1. 事务 B 读取的时候最小的 min_trx_id 值51大于 trx_id 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n2. 事务 A 修改了记录，此时 MySQL 会记录相应的 undo log，以链表的形式串联起来，形成**版本链**，如下所示\r\n\r\n```\r\nid:1, name: Jixer, money: 200, trx_id:51, roll_pointer:o--------->id:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o\r\n```\r\n\r\n3. 事务 B 再次读取的时候，此时的 trx_id值51在 Read View 的 min_trx_id 值51和 max_trx_id 值53之间，所以需判断 trx_id 是否在 m_ids 范围内，判断结果是在的，说明这条记录是还未提交的，因此 B 不会读取此时的记录，而是沿着 undo log向下找第一条小于 Read View 的 min_trx_id 值的旧版本记录，所以事务 B 找到 trx_id 为 50的记录，此时读取到 money 为100\r\n4. 事务 A 提交事务后，由于 Read View 还是用到最开始创建的，所以和步骤3一样任然查询出 money 为100\r\n\r\n> 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 **MVCC（多版本并发控制）**\r\n\r\n#### **串行化**\r\n\r\n会对记录加上读写锁，当多个事务对这个条记录进行读写操作的时候，若发生读写冲突，后访问的事务必须等前一个事务执行完才能继续执行\r\n\r\n实现：加读写锁来避免并行访问\r\n\r\n**隔离水平高低：**串行化 > 可重复读 > 读已提交 > 读未提交\r\n\r\n### 可重复读并没有完全解决幻读\r\n\r\n这种隔离级别很大程度上避免了幻读现象，**但并不是完全解决了**，目前采用的解决方案有两种\r\n\r\n- 针对快照读（普通 select 语句）：通过 **MVCC** 解决了幻读，事务执行过程中即使中途插入了一条数据，但是还是查询不出来这条数据，看到的数据一直和事务启动时看到的数据是一致的，所以避免幻读问题\r\n- 针对当前读（select ... for update 等语句）：通过 **next-key lock（记录锁+间隙锁）**方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就避免幻读问题\r\n\r\n举例了两个发生幻读场景的例子。\r\n\r\n第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n### 开启事务命令\r\n\r\n开始事务有两种命令，事务时机不同，如下：\r\n\r\n- begin/start transaction 命令：执行这条语句后事务并不会立刻启动，而是需要当执行了第一条 select 语句后才是真正的启动时机\r\n- start transaction with consistent snapshot 命令：执行命令后会立刻启动事务\r\n\r\n## 锁\r\n\r\n### 全局锁\r\n\r\n使用全局锁的命令：\r\n\r\n```mysql\r\nflush tables with read lock\r\n```\r\n\r\n执行过后，整个数据库就处于**只读状态**，此时对数据库的任何增删改操作都会被阻塞\r\n\r\n释放全局锁命令如下，断开会话也会自动释放全局锁\r\n\r\n```mysq\r\nunlock tables\r\n```\r\n\r\n**适用场景：**全局锁适用于**全库逻辑备份**，在备份数据库期间不会因为数据或表结构的更新，而出现导致备份文件的数据与预期的不一样\r\n\r\n**缺点：**全库逻辑备份的时候，没法更新新的数据，会导致业务停滞【但是这种缺点可以避免，如果数据库支持**可重复读的隔离级别**，那么会先创建 Read View ，整个事务都在用这个 Read View，而且由于 MVCC 的支持，备份期间数据依然可以进行更新操作】\r\n\r\n### 表级锁\r\n\r\n#### 表锁\r\n\r\n使用命令：\r\n\r\n```mysql\r\n//表级别的共享锁，也就是读锁；\r\nlock tables t_student read;\r\n//表级别的独占锁，也就是写锁；\r\nlock tables t_stuent write;\r\n```\r\n\r\n要释放表锁命令如下，断开会话也会自动释放表锁\r\n\r\n```sql\r\nunlock tables\r\n```\r\n\r\n若一个线程对表加了表锁，那么这个线程是对该表进行写操作会被阻塞，其他的线程也是会被阻塞\r\n\r\n#### 元数据锁（MDL）\r\n\r\n我们不需要显示的使用元数据锁，当我们对表进行操作会自动的帮我们加上元数据锁\r\n\r\n- 当对表数据进行 CRUD 的时候，加的是**元数据读锁**\r\n- 当对表结构进行修改的时候，加的是**元数据写锁**\r\n\r\n当有线程 A 使用 select 语句，此时对表加了元数据读锁，若线程 B 也用 select 语句，此时并不会阻塞线程 B，因为都是读锁；若线程 B 对表结构进行修改，则由于线程 A 读锁还在占用，所以线程 B 会进行阻塞，之后大量的线程若都是 select 语句，那么就都会被阻塞，数据库的线程很快就会爆满了\r\n\r\n这是因为申请元数据锁都会被放在一个队列中，队列中**写锁优先级大于读锁**，所以若写锁阻塞了，后面的读锁都会被阻塞。所以在数据库表结构更改前都要先看看那些长事务是否已经加了元数据读锁，可以考虑 kill 掉这个长事务，在对表结构进行修改\r\n\r\n#### 意向锁\r\n\r\n意向锁的目的：**是为了快速判断表里是否有记录被加锁**\r\n\r\n- 在加共享锁之前，会先加上意向共享锁\r\n- 在加独占锁之前，会先加上意向独占锁\r\n\r\n表锁和行锁是满足读读共享、读写互斥、写写互斥的\r\n\r\n#### AUTO-INC 锁\r\n\r\n当主键的值设置为自增的情况时，我们可以不用专门传入主键值进行保存，这主要是由于 **AUTO-INC 锁**实现的\r\n\r\nAUTO-INC 锁**不是在提交事务后释放，而是在在执行完插入语句后就释放**\r\n\r\n> 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增\r\n> 在插入的时候会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，接着就把所释放了，而不是在执行完插入语句后释放\r\n\r\n### 行级锁\r\n\r\n#### 记录锁（Record Lock）\r\n\r\n锁住的是一条记录，有两种不同的记录锁：S 锁和 X 锁\r\n\r\n- 记录加了 S 锁后任能加 S 锁，但不能加 X 锁\r\n- 记录加了 X 锁后不能加 S 锁，也不能加 X 锁\r\n\r\n执行语句如下：\r\n\r\n```mysql\r\nselect * from t_test where id = 1 for update;\r\n```\r\n\r\n#### 间隙锁（Gap Lock）\r\n\r\n锁的是一个范围，只存在于可重复读隔离级别，目的是**为了解决可重复读隔离级别下幻读的现象**\r\n\r\n例如：表中有一个 范围id 为（3, 5）间隙锁，那么 id 为4就不能插入\r\n\r\n#### 临键锁（Next-key Lock）\r\n\r\n临键锁 = Record Lock + Gap Lock\r\n\r\n锁定一个范围，并且锁定记录本身\r\n\r\n例如：表中有一个 范围id 为（3, 5] 间隙锁，那么 id 为4就不能插入并且 id  为5的记录也不能修改\r\n\r\n#### 插入意向锁\r\n\r\n一个事务在插入数据的时候需要判断该记录是否已经加了间隙锁，若加了间隙锁就会阻塞，直到释放间隙锁为止，在此期间会生成一个**插入意向锁**\r\n\r\n插入意向锁不是意向锁，是一种特殊的间隙锁，属于行级锁\r\n\r\n如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点\r\n\r\n一条记录在同一区间内不能既有插入意向锁，又有间隙锁\r\n\r\n## 日志\r\n\r\n\r\n\r\n## 执行一条 select 语句期间发生了什么\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/mysql查询流程.png)\r\n\r\n1. 连接器：客户端与连接器进行连接，校验用户身份\r\n2. 查询缓存：若是查询语句就需要查询缓存，命中就返回，否则就继续向下执行\r\n3. 解析 SQL：对 SQL 语句继续词法分析和语法分析，构建语法树\r\n4. 处理 SQL：\r\n   - 预处理阶段：检查表或字段是否存在，将 `select *` 中的 `*` 符号扩展为表上的所有列\r\n   - 优化阶段：选择查询成本最小的执行计划\r\n   - 执行阶段：根据执行计划执行 SQL 语句，从存储引擎读取记录，返回给客户端\r\n\r\n## 存储引擎\r\n\r\nMySQL 5.5.5 之前的版本，**MyISAM** 是 MySQL 的默认存储引擎，在5.5.5之后用 **InnoDB** 作为默认存储引擎\r\n\r\n### 存储引擎架构\r\n\r\nMySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎。我们可以为不同的数据库设置不同的存储引擎，存储引擎是**基于表的，而不是数据库**\r\n\r\n### MyISAM与InnoDB对比\r\n\r\n1、InnoDB 支持行级锁，而 MyISAM 只支持表级锁\r\n\r\n2、InnoDB 提供事务，而 MyISAM 不提供事务\r\n\r\n3、InnoDB 支持外键，而 MyISAM 不支持外键\r\n\r\n4、InnoDB 支持数据库崩溃后安全恢复（依赖于 `redo log` ），而 MyISAM 不支持\r\n\r\n5、都是采用 B+ 树索引，但是索引实现不一样\r\n\r\n6、InnoDB 性能比 MyISAM 好\r\n","title":" MySQL知识点总结\r\n","category":[" MySQL","数据库\r\n"],"date":" 2024-05-23\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n近日看了小林 code 的关于 MySQL 的八股文，易忘，于是在此提取重点记下\r\n\r\n参考文章：小林codeMySQL篇https://xiaolincoding.com/mysql/index/indexinterview.html，JavaGuideMySQL篇https://javaguide.cn/database/mysql/mysqlquestions01.html以及部分知识库\r\n\r\n 索引\r\n\r\n若把数据库库的表比作一本书，那么索引就是书的目录，通过索引我们可以快速定位想要寻找的位置\r\n\r\n 索引分类\r\n\r\nMySQL的默认采用存储结构是 InnoDB ，使用最多的索引类型是 B+ 树\r\n\r\n这里我们将不同的索引类型进行分开讨论：\r\n\r\n 按照数据结构进行划分：B+ 树索引、\tHash 索引、FullText 索引\r\n 按照物理存储进行划分：主键索引、二级索引\r\n 按照字段特性进行划分：主键索引、唯一索引、普通索引、前缀索引\r\n 按照字段个数进行划分：单列索引、联合索引\r\n\r\n 补充 = 按存储方式划分：\r\n\r\n  聚簇索引：非叶子结点只存储 key，叶子结点存储 key 和实际存储\r\n  非聚簇索引：非叶子结点只存储 key，叶子结点存储聚簇索引\r\n\r\n MySQL选取索引探讨\r\n\r\nMySQL所选用的索引第一个目的肯定是查询越快越好，这里我们就到了二分查找，但是二分查找的数组的插入性能低下，就需要用到二分查找树，二分查找树有个弊端：当插入的数据是递增的时候（特殊的数据例子），这时候的查找效率就变成了 On，所以我们需要在插入的时候限制不能让他一直插入到一端结点，这时候就想到了平衡二叉树，平衡二叉树保证了每个节点的左子树和右子树的高度差不能超过 1，很符合当前二分查找树出现弊端的情况，但是新的问题又出现了，平衡二叉树只有两个子节点，当数据非常大的情况下，树的高度就会变得很高，就需要很多次查询，影响效率；于是 B 树就横空出世了，它解决了平衡二叉树结点只有两个导致树高的问题，它可以由很多个子结点，想到用 B 树，那么 B+ 树岂不是更好？，B+ 树的查询、插入和删除、范围查询效率更高，于是就采用了 B+ 树结构作为默认的索引\r\n\r\n B+ 树索引执行过程\r\n\r\n若存在如下结构的 B+ 树\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/mysql/btree.drawio.png\r\n\r\n当要查询 ID 为5的时候，首先会用二分查询在1，10，20之间进行查询，找到在1，10之间，接着在第二层进行查询1，4，7，找到是在4，7范围内，最后在叶子结点进行查找4，5，6，找到5，范围其数据即可\r\n\r\n上面是只有主键索引的情况，若出现既有主键索引，又有二级索引的情况，方式就会有变化：二级索引的叶子节点存放的二级索引，主键索引，而没有存在具体的数据，如果我们质询要查询主键值，就直接返回【这种在二级索引就能查询到的结果叫做覆盖索引】，若要查询其他的具体所以，我们需要通过二级索引查找得到主键值，再通过主键值【回表】查询数据，也就是需要查询两个 B+ 树才能查到数据\r\n\r\n 最左匹配原则\r\n\r\n在使用联合索引的时候，存在最左匹配原则\r\n\r\n比如一个表的索引字段为（a，b，c），当我们查询以下条件的时候（查询的时候与 abc 顺序无关）\r\n\r\nsql\r\nwhere a=1；\r\nwhere a=1 and b=2 and c=3；\r\nwhere a=1 and b=2；\r\n\r\n\r\n就会匹配上联合索引，但是若是以下条件时候就不会，不满足最左匹配原则\r\n\r\nsql\r\nwhere b=2；\r\nwhere c=3；\r\nwhere b=2 and c=3；\r\n\r\n\r\n为什么呢？因为我们通过B+ 树索引执行过程可知，是先按照 a 进行排序的，当 a 想同，在按照 b 排序，当 b 相同，再按照 c 排序。\r\n\r\n所以 b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。\t\r\n\r\n 字段索引选用的情况\r\n\r\n事物都存在两面性，索引既然有好的一面，那么也有坏的一面，例如：\r\n\r\n1. 索引需要的占用物理空间\r\n2. 创建索引和维护索引需要耗费时间，所需时间随数据量增大而增加\r\n3. 降低增删改效率，因为每次增删改，都会动态维护 B+ 树的有序性\r\n\r\n字段选用索引的情况：\r\n\r\n1. 经常用 where 查询条件的字段\r\n2. 具有唯一性的字段\r\n3. 经常用 group by 和 order by 的字段【我们不需要再次排序，因为 B+ 树的记录是有序的】\r\n\r\n字段不选用索引的情况：\r\n\r\n1. 更新频繁的字段\r\n2. 表数据太少的时候\r\n3. where、group by 和 order by 的用不上的字段\r\n4. 字段中存在大量重复数据的时候\r\n\r\n 索引失效\r\n\r\nMySQL中索引失效是一个常见的面试题，以下是索引失效的几种情况：\r\n\r\n1. 使用左或者左右模糊匹配的时候，如：%x 或 %xx% 【注意：%x 并不一定会导致索引失效，当表中的字段都是索引字段，没有遵循最左匹配原则也是走全扫描二级索引树】\r\n2. 条件查询中对索引使用函数、计算、类型转换\r\n3. 若是联合索引未遵守最左匹配原则\r\n4. 在 WHERE 子句中，OR 前的条件是索引列，而 OR 后的条件不是索引列\r\n5. 对联合索引进行排序的时候，asc 和 desc 混合使用或者排序的列不是来自同一个联合索引\r\n\r\n 索引优化的方法\r\n\r\n1、前缀索引优化\r\n\r\n2、覆盖索引优化：\r\n\r\n添加冗余字段当作联合索引\r\n\r\n3、主键索引最好自增：\r\n\r\n若主键自增，每次插入的时候就不用移动数据，直接插到最后；若不是自增，插入位置是随机的，我们就不得不移动其他的数据，甚至是需要从一个页面移到另一个页面，这种现象就是页分裂【存在大量空间碎片，结构不紧凑影响查询效率】\r\n\r\n4、索引最好设置为 NOT NULL：\r\n\r\n 为 null 的索引字段进行索引统计和值比较更为复杂，比如：进行索引统计，count 会省略值为 null 的行\r\n null 会占用至少1字节的物理空间\r\n\r\n5、防止索引失效\r\n\r\n 索引的代价\r\n\r\n空间代价\r\n\r\n每次建立一个索引，都会建立一个 B+ 树，一个 B+ 树节点就是一个 MySQL 数据页 16 KB\r\n\r\n时间代价\r\n\r\n1、当对数据进行增删改的时候，如果修改的列为索引列，那么也会要对这颗 B+ 树进行修改（设计也分裂，合并，回收）\r\n\r\n2、二级索引需要回表（若查询的数据列不属于索引范畴）\r\n\r\n3、查询的时候需要生成查询计划，以成本为指标，计算各个索引的成本，选取最低的成本索引进行查询\r\n\r\n 索引查询相关概念\r\n\r\n例如 SQL 语句：select  from test where id = 10 and id <= 20\r\n\r\n扫描区间\r\n\r\n需要扫描的记录，所在的区间，这里指的是：133，982\r\n\r\n边界条件\r\n\r\n形成扫描区间的搜索条件，这里指的是 id = 10 and id <= 20 \r\n\r\n 注意不是所有的搜索条件都能成为边界条件：\r\n 如果查询语句变为 id = 10 and id <= 20 and content = \"123\"，那么在 id 在 10, 20 的区间中，并不是按照 content 排序的，content 只作为普通的搜索条件，需要回表后才能判断【效率比全表扫描还低】\r\n\r\n 执行计划\r\n\r\n一、table：无论查询多少张表，最终都会一步步变成单表\r\n\r\n二、id：每一个 select 关键字对应一个 id，无论查询多少张表，id 都是一样的。出现在前面的是驱动表，出现在后边的被驱动表\r\n\r\n三、selecttype：一个大查询被分割成多个小查询，逐步完成\r\n\r\n SIMPLE：不包含 union 和子查询的查询类型\r\n PRIMARY：对包含 UNION、UNION ALL 或子查询的大查询来说，最左边的那个 SELECT 对应的 selecttype 为 PRIMARY\r\n UNION：对包含 UNION、UNION ALL 除了最左边的那个 SELECT 对应的小查询外，其余小查询的selecttype为 UNION\r\n UNION RESULT：MySQL 使用临时表来完成UNION的去重工作，这个临时表的 selecttype 为  UNION RESULT ，id 为 NULL\r\n SUBQUERY：如果包含子查询的 SQL 不能转为半连接形式，并且子查询不是相关子查询，且优化器决定采用物化子查询的方式来进行子查询时，这个子查询的第一个 SELECT 关键字对应的查询的  selecttype 为 SUBQUERY\r\n DEPENDENT SUBQUERY ：如果包含子查询的 SQL 不能转为半连接形式，并且子查询被优化器转换为相关子查询，这个子查询的第一个 SELECT 关键字对应的查询的 selecttype 为 DEPENDENT  SUBQUERY\r\n\r\n四、type：每一条记录对应的表的访问方式\r\n\r\n有如下 SQL\r\n\r\nsql\r\nCREATE TABLE test \r\n  id INT NOT NULL AUTOINCREMENT,\r\n  key1 VARCHAR  16 ,\r\n  key2 INT,\r\n  key3 VARCHAR  16 ,\r\n  part1 VARCHAR  16 ,\r\n  part2 VARCHAR  16 ,\r\n  part3 VARCHAR  16 ,\r\n  content VARCHAR  32 ,\r\n  PRIMARY KEY  id ,\r\n  KEY idxkey1  key1 ,\r\n  UNIQUE ukkey2  key2 ,\r\n  KEY idxkey3  key3 ,\r\nKEY idxkeypart  part1, part2, part3  \r\n ENGINE = InnoDB CHARSET = utf8mb4;\r\n\r\n\r\n效率排序：all < index < range < ref < refeq < const < system\r\n\r\n1、const : 通过主键或唯一二级索引定位一条数据，表示常数级别，代价忽略不计\r\n\r\nsql\r\nEXPLAIN SELECT   FROM test WHERE id = 1\r\n\r\n\r\n2、ref：普通二级索引列与常数进行比较（或唯一二级索引列可以为NULL）\r\n只要左起连续的列都是等值匹配，就可以使用ref方式\r\n\r\nsql\r\nSELECT  FROM test WHERE part1 = 'a'\r\n\r\n\r\n3、refornull : 通过二级索引进行等值匹配以及列为NULL的值\r\n\r\nsql\r\nexplain SELECT   FROM test WHERE key1 = '1' OR key1 IS NULL\r\n\r\n\r\n4、range：使用索引进行查询，并且形成了多个单点扫描区间或范围扫描区间 （∞ ， +∞ 不算）\r\n\r\nsql\r\nexplain SELECT  FROM test WHERE key2 = 1 or key2 in 123, 312\r\n\r\n\r\n5、index：当可以使用索引覆盖，却需要扫描全部索引记录时候的访问方式\r\n\r\nsql\r\nexplain SELECT part2 FROM test WHERE part3 = 'opq'\r\n\r\n\r\n6、eqref：针对被驱动表，如果是以主键或不问NULL的唯一二级索引进行等值匹配的查询\r\n\r\n五、possiblekeys ：可能用到的索引\r\n\r\n六、key：实际用到的索引\r\n\r\n七、keylen：简单的说，是用到的索引的列的长度\r\n\r\n八、ref：当访问方法是 const、eqref、ref、refornull、uniquesubquery、indexsubquery 时，与索引等值匹配的是什么，一个常数或是一个列\r\n\r\n 查询的成本\r\n\r\n1、根据搜索条件找出可能使用的索引\r\n\r\n2、计算出全表扫描的代价\r\n\r\n3、计算可能使用不同索引的执行查询的代价\r\n\r\n4、对比各种执行方案的代价，选用成本最低的那个方案\r\n\r\n成本计算 = I/O 成本 + CPU 成本\r\n\r\n I/O 成本：数据页数  X 1.0 +1.1微调值\r\n CPU 成本：数据记录数 X 0.2 +1.0微调值\r\n\r\n使用 SQL 命令：show TABLE STATUS LIKE 'test' 用来查看页数和记录数\r\n\r\n 数据页数：Datalength / 16 / 1024\r\n 数据记录数：Rows\r\n\r\n 事务\r\n\r\nA 向 B 转账100元，首先 A 扣除了100元，但是当 B 接收100元的时候，服务器出现故障导致 B 没有收到转账，但是 A 已经扣除了100元，也就是100元就不见了。要想让操作全部执行成功或者全部执行失败，就需要用到事务\r\n\r\n 事务特性\r\n\r\n事务有四个特性，如下：\r\n\r\n 原子性：要么全部成功，要么全部失败\r\n 一致性：A 给 B 100元，A 扣除了100元，不会出现B没有增加100元的情况\r\n 隔离性：多个事务使用相同的数据时，不会相互干扰\r\n 持久性：数据修改后是永久保存的，即使重启后也不会丢失\r\n\r\n 并行事务引发的问题\r\n\r\n1、脏读：一个事务读取到另一个事务未提交的数据\r\n\r\n有一个数据为100，现在 A 将数据修改为200，这时候还未提交事务，这时候 B 获取数据200，拿到别处地方用，可是 A 出现某种状况导致回滚，A 的数据变回100\r\n\r\n2、不可重复读：在同一个事务中多次读取同一个数据，但这些读取中取得了不同的结果\r\n\r\n有一个数据为100，现在 A 读取了数据100，接着 B 将数据修改为200并提交了事务，当 A 再次读取的时候数据变成了200，与之前读取的数据不一致\r\n\r\n3、幻读：在同一事务中多次查询符合条件的记录数量，出现查询到的数量不一样\r\n\r\n有大于1的记录为100条，现在 B 对大于1的记录条数进行查询得到100，现在 A 插入了一条记录3并提交了事务，当 B 再次查询的时候发现条数为101条，前后两次查询到的记录数量不一样\r\n\r\n严重性排序：脏读  不可重复读  幻读\r\n\r\n Read View\r\n\r\nRead View 结构如下：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/mysql/readview结构.drawio.png\r\n\r\n 事务隔离级别\r\n\r\nMySQL有四种事务隔离级别\r\n\r\n 读未提交\r\n\r\n一个事务还未提交，它做的变更就能被其他事务看到\r\n\r\n可能造成：脏读、不可重复读、幻读\r\n\r\n实现：因为能读到未提交事务修改的数据，所以直接读取最新的数据就行\r\n\r\n 读提交\r\n\r\n一个事务提交后才能被其他事务看到\r\n\r\n可能造成：不可重复读、幻读\r\n\r\n实现：读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View\r\n\r\n建议先看可重复读的实现部分，再来看此处的实现部分，进行对比\r\n\r\n比如：例子和可重复读一致\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100（创建了 Read View）\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100（创建了 Read View）\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 为 200（创建了 Read View）\r\n\r\n解释：\r\n\r\n1. 第一次读取事务 B 创建了 Read View\r\n\r\n\r\ncreatortrxid:52, mids:51,52, mintrxid: 51, maxtrxid: 53\r\n\r\n\r\n事务的 mintrxid 值51大于 trxid 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n2. 事务 A 修改了 money 值，记录的字段创建了版本链\r\n\r\n\r\nid:1, name: Jixer, money: 200, trxid:51, rollpointer:oid:1, name: Jixer, money: 100, trxid:50, rollpointer:o\r\n\r\n\r\n3. 事务 B 再次读取，创建了Read View\r\n\r\n\r\ncreatortrxid:52, mids:51,52, mintrxid: 51, maxtrxid: 53\r\n\r\n\r\n分析和可重复读那块一致\r\n\r\n4. 事务 A 提交了事务，事务 B 第三次读取的时候创建了 Read View\r\n\r\n\r\nx creatortrxid:52, mids:52, mintrxid: 52, maxtrxid: 53\r\n\r\n\r\n发现此时的 mintrxid 值52已经大于了 trxid 值51，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n所以在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录并提交了事务\r\n\r\n 可重复读\r\n\r\nMySQL 默认的隔离级别\r\n\r\n一个事务执行过程中看到的数据一直和事务启动前看到的数据是一致的\r\n\r\n可能造成：幻读【这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，解决方案见下个目录】\r\n\r\n实现：可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View\t\r\n\r\n比如：\r\n\r\n有一条字段如下，trxid 和 rollpointer 为聚簇索引（一般情况下就是主键索引，但是并不一定是主键索引）记录中的两个隐藏列\r\n\r\n\r\nid:1, name: Jixer, money: 100, trxid:50, rollpointer:oundo日志\r\n\r\n\r\n现在有两个事务 A 和 B\r\n\r\n\r\nA：creatortrxid:51, mids:51, mintrxid: 51, maxtrxid: 52\r\nB：creatortrxid:52, mids:51,52, mintrxid: 51, maxtrxid: 53\r\n\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 依然 100\r\n\r\n解释：\r\n\r\n1. 事务 B 读取的时候最小的 mintrxid 值51大于 trxid 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n2. 事务 A 修改了记录，此时 MySQL 会记录相应的 undo log，以链表的形式串联起来，形成版本链，如下所示\r\n\r\n\r\nid:1, name: Jixer, money: 200, trxid:51, rollpointer:oid:1, name: Jixer, money: 100, trxid:50, rollpointer:o\r\n\r\n\r\n3. 事务 B 再次读取的时候，此时的 trxid值51在 Read View 的 mintrxid 值51和 maxtrxid 值53之间，所以需判断 trxid 是否在 mids 范围内，判断结果是在的，说明这条记录是还未提交的，因此 B 不会读取此时的记录，而是沿着 undo log向下找第一条小于 Read View 的 mintrxid 值的旧版本记录，所以事务 B 找到 trxid 为 50的记录，此时读取到 money 为100\r\n4. 事务 A 提交事务后，由于 Read View 还是用到最开始创建的，所以和步骤3一样任然查询出 money 为100\r\n\r\n 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）\r\n\r\n 串行化\r\n\r\n会对记录加上读写锁，当多个事务对这个条记录进行读写操作的时候，若发生读写冲突，后访问的事务必须等前一个事务执行完才能继续执行\r\n\r\n实现：加读写锁来避免并行访问\r\n\r\n隔离水平高低：串行化  可重复读  读已提交  读未提交\r\n\r\n 可重复读并没有完全解决幻读\r\n\r\n这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，目前采用的解决方案有两种\r\n\r\n 针对快照读（普通 select 语句）：通过 MVCC 解决了幻读，事务执行过程中即使中途插入了一条数据，但是还是查询不出来这条数据，看到的数据一直和事务启动时看到的数据是一致的，所以避免幻读问题\r\n 针对当前读（select ... for update 等语句）：通过 nextkey lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 nextkey lock，如果有其他事务在 nextkey lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就避免幻读问题\r\n\r\n举例了两个发生幻读场景的例子。\r\n\r\n第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n 开启事务命令\r\n\r\n开始事务有两种命令，事务时机不同，如下：\r\n\r\n begin/start transaction 命令：执行这条语句后事务并不会立刻启动，而是需要当执行了第一条 select 语句后才是真正的启动时机\r\n start transaction with consistent snapshot 命令：执行命令后会立刻启动事务\r\n\r\n 锁\r\n\r\n 全局锁\r\n\r\n使用全局锁的命令：\r\n\r\nmysql\r\nflush tables with read lock\r\n\r\n\r\n执行过后，整个数据库就处于只读状态，此时对数据库的任何增删改操作都会被阻塞\r\n\r\n释放全局锁命令如下，断开会话也会自动释放全局锁\r\n\r\nmysq\r\nunlock tables\r\n\r\n\r\n适用场景：全局锁适用于全库逻辑备份，在备份数据库期间不会因为数据或表结构的更新，而出现导致备份文件的数据与预期的不一样\r\n\r\n缺点：全库逻辑备份的时候，没法更新新的数据，会导致业务停滞【但是这种缺点可以避免，如果数据库支持可重复读的隔离级别，那么会先创建 Read View ，整个事务都在用这个 Read View，而且由于 MVCC 的支持，备份期间数据依然可以进行更新操作】\r\n\r\n 表级锁\r\n\r\n 表锁\r\n\r\n使用命令：\r\n\r\nmysql\r\n//表级别的共享锁，也就是读锁；\r\nlock tables tstudent read;\r\n//表级别的独占锁，也就是写锁；\r\nlock tables tstuent write;\r\n\r\n\r\n要释放表锁命令如下，断开会话也会自动释放表锁\r\n\r\nsql\r\nunlock tables\r\n\r\n\r\n若一个线程对表加了表锁，那么这个线程是对该表进行写操作会被阻塞，其他的线程也是会被阻塞\r\n\r\n 元数据锁（MDL）\r\n\r\n我们不需要显示的使用元数据锁，当我们对表进行操作会自动的帮我们加上元数据锁\r\n\r\n 当对表数据进行 CRUD 的时候，加的是元数据读锁\r\n 当对表结构进行修改的时候，加的是元数据写锁\r\n\r\n当有线程 A 使用 select 语句，此时对表加了元数据读锁，若线程 B 也用 select 语句，此时并不会阻塞线程 B，因为都是读锁；若线程 B 对表结构进行修改，则由于线程 A 读锁还在占用，所以线程 B 会进行阻塞，之后大量的线程若都是 select 语句，那么就都会被阻塞，数据库的线程很快就会爆满了\r\n\r\n这是因为申请元数据锁都会被放在一个队列中，队列中写锁优先级大于读锁，所以若写锁阻塞了，后面的读锁都会被阻塞。所以在数据库表结构更改前都要先看看那些长事务是否已经加了元数据读锁，可以考虑 kill 掉这个长事务，在对表结构进行修改\r\n\r\n 意向锁\r\n\r\n意向锁的目的：是为了快速判断表里是否有记录被加锁\r\n\r\n 在加共享锁之前，会先加上意向共享锁\r\n 在加独占锁之前，会先加上意向独占锁\r\n\r\n表锁和行锁是满足读读共享、读写互斥、写写互斥的\r\n\r\n AUTOINC 锁\r\n\r\n当主键的值设置为自增的情况时，我们可以不用专门传入主键值进行保存，这主要是由于 AUTOINC 锁实现的\r\n\r\nAUTOINC 锁不是在提交事务后释放，而是在在执行完插入语句后就释放\r\n\r\n 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增\r\n 在插入的时候会为被 AUTOINCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，接着就把所释放了，而不是在执行完插入语句后释放\r\n\r\n 行级锁\r\n\r\n 记录锁（Record Lock）\r\n\r\n锁住的是一条记录，有两种不同的记录锁：S 锁和 X 锁\r\n\r\n 记录加了 S 锁后任能加 S 锁，但不能加 X 锁\r\n 记录加了 X 锁后不能加 S 锁，也不能加 X 锁\r\n\r\n执行语句如下：\r\n\r\nmysql\r\nselect  from ttest where id = 1 for update;\r\n\r\n\r\n 间隙锁（Gap Lock）\r\n\r\n锁的是一个范围，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象\r\n\r\n例如：表中有一个 范围id 为（3, 5）间隙锁，那么 id 为4就不能插入\r\n\r\n 临键锁（Nextkey Lock）\r\n\r\n临键锁 = Record Lock + Gap Lock\r\n\r\n锁定一个范围，并且锁定记录本身\r\n\r\n例如：表中有一个 范围id 为（3, 5 间隙锁，那么 id 为4就不能插入并且 id  为5的记录也不能修改\r\n\r\n 插入意向锁\r\n\r\n一个事务在插入数据的时候需要判断该记录是否已经加了间隙锁，若加了间隙锁就会阻塞，直到释放间隙锁为止，在此期间会生成一个插入意向锁\r\n\r\n插入意向锁不是意向锁，是一种特殊的间隙锁，属于行级锁\r\n\r\n如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点\r\n\r\n一条记录在同一区间内不能既有插入意向锁，又有间隙锁\r\n\r\n 日志\r\n\r\n\r\n\r\n 执行一条 select 语句期间发生了什么\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/mysql/mysql查询流程.png\r\n\r\n1. 连接器：客户端与连接器进行连接，校验用户身份\r\n2. 查询缓存：若是查询语句就需要查询缓存，命中就返回，否则就继续向下执行\r\n3. 解析 SQL：对 SQL 语句继续词法分析和语法分析，构建语法树\r\n4. 处理 SQL：\r\n    预处理阶段：检查表或字段是否存在，将 select  中的  符号扩展为表上的所有列\r\n    优化阶段：选择查询成本最小的执行计划\r\n    执行阶段：根据执行计划执行 SQL 语句，从存储引擎读取记录，返回给客户端\r\n\r\n 存储引擎\r\n\r\nMySQL 5.5.5 之前的版本，MyISAM 是 MySQL 的默认存储引擎，在5.5.5之后用 InnoDB 作为默认存储引擎\r\n\r\n 存储引擎架构\r\n\r\nMySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎。我们可以为不同的数据库设置不同的存储引擎，存储引擎是基于表的，而不是数据库\r\n\r\n MyISAM与InnoDB对比\r\n\r\n1、InnoDB 支持行级锁，而 MyISAM 只支持表级锁\r\n\r\n2、InnoDB 提供事务，而 MyISAM 不提供事务\r\n\r\n3、InnoDB 支持外键，而 MyISAM 不支持外键\r\n\r\n4、InnoDB 支持数据库崩溃后安全恢复（依赖于 redo log ），而 MyISAM 不支持\r\n\r\n5、都是采用 B+ 树索引，但是索引实现不一样\r\n\r\n6、InnoDB 性能比 MyISAM 好\r\n"},{"filename":"leetcode-week-398","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第398场周赛\ncategory: 算法\ndate: 2024-05-20\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 3151. 特殊数组 I\n\n简单模拟\n\n```c++\nclass Solution {\npublic:\n    bool isArraySpecial(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1){\n            return true;\n        }\n        for(int i = 1; i < len; i++){\n            if(nums[i] % 2 == nums[i - 1] % 2){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n## 特殊数组 II\n\n前缀和处理相邻特殊元素总数\n\n```c++\nclass Solution {\npublic:\n    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int len = nums.size();\n        vector<bool> res;\n        if(len == 1){\n            for(int i = 0; i < queries.size(); i++){\n                res.push_back(true);\n            }\n            return res;\n        }\n        vector<int> v(len + 1);\n        v[0] = 0;\n        for(int i = 1; i < len; i++){\n            if(nums[i] % 2 == nums[i - 1] % 2){\n                v[i] = v[i - 1] + 1;\n            } else {\n                v[i] = v[i - 1];\n            }\n        }\n        for(int i = 0; i < queries.size(); i++){\n            if(v[queries[i][1]] - v[queries[i][0]] == 0){\n                res.push_back(true);\n            } else {\n                res.push_back(false);\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 所有数对中数位不同之和\n\n拆分位运算贡献\n\n```c++\nclass Solution {\npublic:\n    long long n[100010][20];\n    long long sumDigitDifferences(vector<int>& nums) {\n        int len = nums.size();\n        long long res = 0;\n        for(int i = 0; i < len; i++){\n            int cc = nums[i], idx = 0;\n            while(cc){\n                int j = cc % 10;\n                res += i * 1ll - n[idx][j];\n                cc /= 10;   \n                n[idx][j] ++;\n                idx ++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 到达第 K 级台阶的方案数\n\n记忆化搜索\n\n灵神这题做法是用记忆存储的元素与以往题目不一样，使用 `long long p = (long long) x << 10 | num << 1 | f; `来确定元素的唯一性，这个做法tql，换我来做就需要用个二维数组来标志\n\n```c++\nclass Solution {\npublic:\n    unordered_map<long long, int> ump;\n    int dfs(int x, int num, bool f, int k){\n        if(x > k + 1 || x < 0){\n            return 0;\n        }\n        long long p = (long long) x << 10 | num << 1 | f;\n        if(ump.find(p) != ump.end()){\n            return ump[p];\n        }\n        int ss = (x == k);\n        ss += dfs(x + (1 << num), num + 1, false, k);\n        if(!f){\n            ss += dfs(x - 1, num, true, k);\n        }\n        ump[p] = ss;\n        return ss;\n    }\n    int waysToReachStair(int k) {\n        return dfs(1, 0, false, k);\n    }\n};\n```\n\n","title":" Leetcode第398场周赛\n","category":[" 算法\n"],"date":" 2024-05-20\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 3151. 特殊数组 I\n\n简单模拟\n\nc++\nclass Solution {\npublic:\n    bool isArraySpecialvector<int& nums {\n        int len = nums.size;\n        iflen == 1{\n            return true;\n        }\n        forint i = 1; i < len; i++{\n            ifnumsi % 2 == numsi  1 % 2{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n 特殊数组 II\n\n前缀和处理相邻特殊元素总数\n\nc++\nclass Solution {\npublic:\n    vector<bool isArraySpecialvector<int& nums, vector<vector<int& queries {\n        int len = nums.size;\n        vector<bool res;\n        iflen == 1{\n            forint i = 0; i < queries.size; i++{\n                res.pushbacktrue;\n            }\n            return res;\n        }\n        vector<int vlen + 1;\n        v0 = 0;\n        forint i = 1; i < len; i++{\n            ifnumsi % 2 == numsi  1 % 2{\n                vi = vi  1 + 1;\n            } else {\n                vi = vi  1;\n            }\n        }\n        forint i = 0; i < queries.size; i++{\n            ifvqueriesi1  vqueriesi0 == 0{\n                res.pushbacktrue;\n            } else {\n                res.pushbackfalse;\n            }\n        }\n        return res;\n    }\n};\n\n\n 所有数对中数位不同之和\n\n拆分位运算贡献\n\nc++\nclass Solution {\npublic:\n    long long n10001020;\n    long long sumDigitDifferencesvector<int& nums {\n        int len = nums.size;\n        long long res = 0;\n        forint i = 0; i < len; i++{\n            int cc = numsi, idx = 0;\n            whilecc{\n                int j = cc % 10;\n                res += i  1ll  nidxj;\n                cc /= 10;   \n                nidxj ++;\n                idx ++;\n            }\n        }\n        return res;\n    }\n};\n\n\n 到达第 K 级台阶的方案数\n\n记忆化搜索\n\n灵神这题做法是用记忆存储的元素与以往题目不一样，使用 long long p = long long x << 10  num << 1  f; 来确定元素的唯一性，这个做法tql，换我来做就需要用个二维数组来标志\n\nc++\nclass Solution {\npublic:\n    unorderedmap<long long, int ump;\n    int dfsint x, int num, bool f, int k{\n        ifx  k + 1  x < 0{\n            return 0;\n        }\n        long long p = long long x << 10  num << 1  f;\n        ifump.findp = ump.end{\n            return umpp;\n        }\n        int ss = x == k;\n        ss += dfsx + 1 << num, num + 1, false, k;\n        iff{\n            ss += dfsx  1, num, true, k;\n        }\n        umpp = ss;\n        return ss;\n    }\n    int waysToReachStairint k {\n        return dfs1, 0, false, k;\n    }\n};\n\n\n"},{"filename":"jvm","category":"java","md":{"topSummary":"\ntitle: JVM知识点总结\ncategory: Java\ndate: 2024-05-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n参考文章：[JavaGuide](https://javaguide.cn/java/jvm/memory-area.html) 和 黑马程序员笔记\n\n## 运行时数据区域\n\n**JDK1.7**\n\n1、线程共享：堆（包括字符串常量池），方法区（包括运行时常量池，使用的是永久代空间）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：直接内存\n\n**JDK1.8**\n\n1、线程共享：堆（包括字符串常量池）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：元空间（包括运行时常量池）、直接内存\n\n### 程序计数器\n\n一小块固定的内存空间，每个线程的程序计数器不会相互影响，独立存储。随着线程的创建而创建，随着线程的结束而死亡，所以程序计数器**不会出现内存溢出的情况**\n\n有两个作用：\n\n- 控制程序指令的进行，实现代码的流程控制\n- 在多线程下，程序计数器记录了当前线程执行的位置，以便于在线程执行完后切换回来能够返回到当前位置\n\n### Java虚拟机栈\n\nJava虚拟机栈中存放了一个个栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法返回地址。随着线程的创建而创建，随着线程的结束而死亡。\n\n每个方法调用都会有一个对应的栈帧压入栈中，调用结束后，都会有一个栈帧被弹出。\n\n可能出现的两种错误：\n\n- 当在循环条件下进行调用的话会导致栈中被压入太多栈帧而占用空间，当超过Java虚拟机最大深度的时候会报出`StackOverFlowError`的错误。\n- 当栈内存可以动态拓展的时候，如果虚拟机无法申请到足够的内存空间会报出`OutOfMemoryError`错误\n\n#### 局部变量表\n\n存放编译时可知的基本数据类型、对象类型。\n\n#### 操作数栈\n\n存放方法执行过程中产生的中间计算结果，也存放临时变量。\n\n#### 动态链接\n\n主要用在当一个方法调用另一个方法的时候，需要将 Class 文件常量池中的符号引用转为内存地址的直接引用。\n\n### 本地方法栈\n\n与Java虚拟栈不同的是：Java虚拟机栈存放的是Java方法栈帧，而本地方法栈存放的是Native方法栈帧。\n\n### 堆\n\n最大的一块内存区域，主要存放的是**对象实例以及数组**（局部变量表中存放的是堆上对象的引用）。\n\n**几乎所有的对象都在堆上分配内存**，但是随着技术升级，如果某些方法中的对象没有被外部使用或者没有被返回，那么对象可以直接在Java虚拟机栈上分配内存。\n\n### 方法区\n\n方法区存放类的元信息（类的基本信息、字段信息、变量信息等），还包括运行时常量池、字符串常量池(JDK7之前)\n\nJDK1.8之前方法区实现是永久代空间，存放在堆区域中\n\nJDK1.8之后方法区实现是元空间，存放在直接内存区域中\n\n> 方法区与永久代和元空间的关系就像是接口和实现类的关系，方法区是接口，永久代和元空间是实现类\n\n### 运行时常量池\n\n方法区的一部分，存放编译期生成的各种字面量和符号引用\n\n### 字符串常量池\n\n方法区的一部分，存放常量字符串内容\n\n主要目的是为了避免字符串的重复创建\n\n#### 与运行时常量池的关系\n\nJDK7之前：运行时常量池包括字符串常量池，方法区实现为永久代\n\nJDK7：字符串常量池从方法区拿到堆中，运行时常量池剩下的还在方法区的永久代中\n\nJDK8之后：方法区用元空间替换了永久代空间，字符串常量池还在堆中\n\n### 直接内存\n\n一种特殊的内存缓冲区\n\n## 垃圾回收\n\nJava的自动内存管理主要针对对象内存回收和对象内存分配，最核心的功能是堆内存中对象的回收和分配\n\nJava堆是垃圾收集器管理的主要区域，因此也被称作**GC堆**\n\n### 堆空间基本结构\n\nJava堆分为不同的 区域，根据各个区域的特点选择合适的垃圾收集算法\n\n**JDK1.7：**\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、永久代：PerGen\n\n**JDK1.8：**\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、元空间：MetaSpace\n\n### 垃圾回收流程\n\n大部分情况，对象首先在Eden区域分配内存，若在一次新生代垃圾回收后，该对象还存活，就将它放到S0或S1并将年龄加1。当再一次一次新生代垃圾回收后，若对象任然存在，那么就回将当前存活的对象放到另一个地方（若当前是 S0，就放到 S1；若是 S1，就放到 S0）并将年龄加1，当年龄增加到默认值阈值（15）的时候，会将对象晋升至老年代中。若老年代空间不足，会触发 Full GC 对整个堆进行垃圾回收。若 Full GC 无法回收老年代的对象，那么当对象继续放入老年代时，就会抛出 `Out Of Memory` 异常。\n\n> 年龄是0-15的原因：年龄记录区域大小通常是4位，最大的二进制表示是1111，也就是15。\n\n### 对象判断死亡的方法\n\n当一个对象可以被回收，不一定代表一定会被回收！对象回收至少需要经过两次标记的过程，可达分析法是第一次筛选，筛选的条件是对象是否有必要执行`finalize`方法（若对象没有覆盖`finalize`方法或 `finalize` 方法已经被虚拟机调用过，就说明没有执行的必要），将需要执行的对象放在一个队列中进行第二次筛选，当这个对象与引用链上任意一个对象相关联，就不会回收，否则就会回收。\n\n#### 引用计数法\n\n给对象添加一个引用计数器，当对象被引用的时候就，计数器就加1，当引用消失的时候，引用就减1。当引用为0的时候就说明对象可以被回收\n\n优点：实现简单\n\n缺点：1、每次对象引用和取消都需要维护一下，影响系统的性能。2、当出现A引用B，同时B引用A的情况，也就是循环引用时会出现无法回收的问题\n\n#### 可达性分析算法\n\n用一个GC ROOT座作为根节点，与每个有引用的对象相连接，若对象到GC ROOT没有连接就说明对象可以被回收。\n\n**常见的GC ROOT：**\n\n- 虚拟机栈(栈帧中的局部变量表)中引用的对象\n- 本地方法栈(Native 方法)中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 所有被同步锁持有的对象\n- JNI（Java Native Interface）引用的对象\n\n### 引用类型\n\n#### 强引用\n\n大部分使用的引用都是强引用，垃圾回收器绝不会回收此类引用\n\n#### 软引用\n\n软引用通过`SoftReference`类实现，若系统内存不足，就会回收它，若内存足够，就不管。\n\n软引用可以用来实现内存敏感的高速缓存\n\n软引用可以和一个引用对象联合使用，若软引用的对象被垃圾回收，就会放到与之关联的引用队列中，通过遍历引用队列，将`SoftReference`的强引用删除\n\n#### 弱引用\n\n只具有弱引用的对象拥有更短暂的生命周期\n\n不管系统内存是否足够，只要发现是弱引用，就可能被垃圾回收。但是垃圾回收器是一个优先级很低的线程，不一定发现得了弱引用\n\n与软引用类似，弱引用可以和一个引用对象联合使用，若弱引用的对象被垃圾回收，就会放到与之关联的引用队列中\n\n#### 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n### 垃圾回收算法\n\n#### 标记-清除法\n\n标记出不需要回收的对象，在标记完后统一回收没有标记的对象\n\n优点：实现简单\n\n缺点：1、碎片化问题，没有标志的内存不连续，标记清除后会产生大量不连续的内存碎片。2、标记和清除两个过程效率都不高\n\n**实现过程：**\n\n1、对象被创建的时候，标记为0\n\n2、在标记阶段，将所有可达的对象标记为1\n\n3、扫描阶段，清除所有标记为0的对象\n\n#### 复制算法\n\n将内存分为相同的两块，每次使用其中的一块，当进行了垃圾回收后，将存活的对象移到另一块未使用的内存，然后将使用的内存一次性清除掉，这样每次回收都是内存的一半\n\n优点：解决了碎片化问题\n\n缺点：1、可用内存减小为原来的一般。2、存活对象数量多的化复制性能就变得很差\n\n#### 标记-整理算法\n\n过程与标记-清除算法类似，但是它标记后并不会回收对象，而是让存活的对象移动到另一端，清除掉段边界以外的内存\n\n#### 分代收集算法\n\n当前虚拟机都采用的这种算法，可以根据年代的特点进行使用不同的回收算法\n\n例如在新生代中，每次收集都会有大量对象死去，所以就采用标记-复制算法（只需要少部分复制成本就能完成对象收集），老年代中的对象存活率较高，所以就采用标记-整理或者标记-清除算法\n\n### 垃圾收集器\n\n如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是内存回收后的实现\n\n#### Serial收集器\n\n单线程收集器，在进行垃圾收集的时候会停止掉所有的工作线程，直到它收集结束\n\n优点就是简单高效，没有线程交互的开销\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### ParNew收集器\n\nParNew收集器是Serial收集器的多线程版本\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### Parallel Scavenge收集器\n\nParallel Scavenge收集器看上去和ParNew收集器都一样，不同点是Parallel Scavenge收集器关注点是吞吐量（高效率的的利用CPU），而CMS等收集器关注点是用户线程的停顿时间（提高用户体验）\n\nParallel Scavenge收集器提供很多参数供用户找到最合适的停顿时间或最大吞吐量\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### Serial Old收集器\n\nSerial收集器的老年代版本，主要有两大用途：\n\n1、JDK1.5版本之前与Parallel Scavenge收集器配合使用\n\n2、作为CMS收集器的后备方案\n\n#### Parallel Old收集器\n\nParallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法\n\n> 在关注吞吐量和CPU资源的场景下，可以优先考虑Parallel Scavenge收集器和Parallel Old收集器\n\n#### CMS收集器\n\n一款老年代收集器，可以分配新生代的 Serial 和 ParNew 收集器一起使用\n\n**一种以获取最短回收时间为目的的收集器，注重用户体验，能够实现GC和用户线程（基本上）同时进行**\n\n执行过程：\n\n1、初始标记：暂停所有其他的线程，快速记录与root相连接的对象\n\n2、并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象（但是这个闭包结构并不能将所有的可达对象都记录，因为用户线程在不断的更新引用域，GC线程无法保证可达分析的及时性）\n\n3、重新标记：修正并发标记的阶段因为用户线程继续运行而导致标记产生变动的那一部分对象标记记录\n\n4、清除标记：开启用户线程，同时GC线程对未标记的区域作清扫（垃圾回收）\n\n优点：并发收集，低停顿\n\n缺点：1、对CPU资源敏感。2、无法处理浮动垃圾。3、会产生大量空间碎片\n\n采用的算法：**标记-清除算法**\n\n**CMS 垃圾回收器在 Java 9 中已经被标记为过时，并在 Java 14 中被移除**\n\n#### G1收集器\n\n收集范围是新生代和老年代收，不需要结合其他收集器使用\n\n一款面向服务器的垃圾收集器，满足 GC 停顿时间要求的同时，还具备高吞吐量的特性\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region\n\n执行过程：1、初始标记。2、并发标记。3、最终标记。4、筛选回收。\n\n优点：1、并发与并行。2、分代收集。3、空间整理（整体上看是标记-整理算法，局部来看是标记-复制算法）4、可预测的停顿。\n\n**从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器**\n\n#### ZGC收集器\n\n与ParNew和G1类似，ZGC也采用标记-复制算法，但是ZGC做了重大改进：可以将暂停时间控制在几毫秒内，且暂停时间不受堆内存大小的影响\n\n## 类文件结构\n\n### 魔数\n\n每个Class文件的头4个字节称为魔数，通过这4个字节来确定一个文件的类型\n\nJava文件为kj0xcadebabe\n\n### Class文件版本号\n\n接着魔数的第5个和第6个此节表示的是**次版本号**，第7和第8个字节是**主版本号**\n\n通过这个版本号能够计算出JDK版本\n\nJDK1.2之后的版本计算方法：主版本号 - 44\n\n### 常量池\n\n接着主次版本号之后就是常量池，常量池存放：**字面量**和**符号引用**\n\n### 访问标志\n\n接常量池之后，紧挨着的两个字节代表访问标志\n\n访问标志用于识别一些类或接口的信息：这个Class是类还是接口，是 `public `还是 `private` 等\n\n### 当前类、父类、接口索引集合\n\nJava 类的继承关系由类索引、父类索引和接口索引集合三项确定\n\n### 字段表集合\n\n字段表用于描述接口或类中声明的变量，但不包括方法内的局部变量\n\n字段表结构：访问标志、名称索引、描述符索引、属性表集合\n\n### 方法集合\n\n字段表用于描述接口或类中声明的方法\n\n与字段表结构类似，但是与字段表不同的是少了 `volatile` 修饰符和 `transient` 修饰符这两个不可以修饰方法的访问标志，增加了`synchronized`、`native`、`abstract`等关键字修饰方法\n\n### 属性表集合\n\n字段表、方法表中都存在自己的属性表集合，以用于描述某些场景专有的信息\n\n## 类的加载过程\n\n### 类的生命周期\n\n加载->连接（验证->准备->解析）->初始化->使用->卸载\n\n### 加载\n\n这一阶段由**类加载器**完成，主要是完成下面三件事：\n\n1、通过全类名获取二进制流\n\n2、在方法去保存一个InstanceKClass对象，保存类的所有信息\n\n3、同时还会在堆上生成与方法区类似的java.lang.Class对象，作为方法区这些数据的访问入口\n\n加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了\n\n### 连接\n\n#### 验证\n\n检验字节码文件是否遵守了《Java虚拟机规范》的约束要求\n\n检查的部分：\n\n1、文件格式验证（Class文件格式）\n\n2、元数据验证（字节码语义）\n\n3、字节码验证（程序语义）\n\n4、符号引用验证（类的正确性）\n\n#### 准备\n\n正式的为类变量分配内存并设置类变量初始值\n\n#### 解析\n\n将常量池内的符号引用替换为直接引用\n\n### 初始化\n\n执行初始化方法（cinit）\n\n以下几种情况会进行类初始化\n\n1、当遇到 `new`、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条字节码指令时\n\n2、使用 `java.lang.reflect` 包的方法对类进行反射调用时\n\n3、初始化一个类，如果其父类还未初始化，则先触发该父类的初始化\n\n4、执行Main方法的当前类\n\n....\n\n以下几种情况不会进行类初始化\n\n1、无静态代码块且无静态变量赋值语句\n\n2、有静态变量的声明，但是没有赋值语句，如：`private static int a;`\n\n3、静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化，如：`private final static int a = 10;`\n\n### 卸载\n\n类的Class对象被GC\n\n## 类加载器\n\n### 介绍\n\n 类加载器的主要作用就是加载Java类的字节码（.Class文件）到JVM中（在内存中生成一个代表类的Class对象）\n\nJVM内置的三个重要类加载器：\n\n- **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载器，由C++实现，通常为null（因为C++实现的类加载器在Java无与之对应的类），无父类，用来加载JDK内部的核心类库\n- **`ExtensionClassLoader`(扩展类加载器)**：加载/jre/lib/ext下的类文件\n- **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类\n\n执行流程图：\n![](https://img2.imgtp.com/2024/05/20/fYIF5GzX.png)\n\n### 双亲委派模型\n\n类加载器有很多种，当我们需要加载一个类的时候需要哪一个类加载器呢？这时候就需要用到双亲委派模型了\n\n#### 执行流程\n\n执行流程集中在ClassLoader的loadClass方法中\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        //首先，检查该类是否已经加载过\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            //如果 c 为 null，则说明该类没有被加载过\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                    //当父类的加载器不为空，则通过父类的loadClass来加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                    //当父类的加载器为空，则调用启动类加载器来加载该类\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                //非空父类的类加载器无法找到相应的类，则抛出异常\n            }\n\n            if (c == null) {\n                //当父类加载器无法加载时，则调用findClass方法来加载该类\n                //用户可通过覆写该方法，来自定义类加载器\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                //用于统计类加载器相关的信息\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            //对类进行link操作\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n**总结：首先类加载器先判断自己是否已经加载过这个类了，若已经加载就直接返回，否则自己先不会加载，而是让父类加载器进行加载，只有当前父类加载器也没法加载的时候，自己才加载**\n\n由此可知，判断两个类是否相同，不但要看类的全名是否一致，还要看类加载器是否一致\n\n#### 打破双亲委派模型\n\n**1、自定义类加载器**\n\n自定义类加载器需要继承`ClassLoader`类，若不想打破双亲委派机制就重写`ClassLoder`类的`findClass`方法，若想打破，就重写`loadClass`方法（因为类加载器进行类加载的时候，会先调用父类加载器的`loadClass`方法，改变了传统双亲委派模型的执行流程）\n\n**2、线程上下文类加载器**\n\n有些时候，高层的类加载器需要加载底层的类加载才能加载的类\n\n例如：JDBC就是由启动类加载器委派应用类加载器去加载类的方式\n\n- 启动类加载器加载DriverManager\n- 在初始化DriverManager时，通过SPI机制加载jar中的msql驱动\n- SPI利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象\n\n获取线程线程上下文类加载器的代码：\n\n```java\nClassLoader cl = Thread.currentThread().getContextClassLoader();\n```\n\n**3、Osgi框架的类加载器**\n","title":" JVM知识点总结\n","category":[" Java\n"],"date":" 2024-05-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n参考文章：JavaGuidehttps://javaguide.cn/java/jvm/memoryarea.html 和 黑马程序员笔记\n\n 运行时数据区域\n\nJDK1.7\n\n1、线程共享：堆（包括字符串常量池），方法区（包括运行时常量池，使用的是永久代空间）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：直接内存\n\nJDK1.8\n\n1、线程共享：堆（包括字符串常量池）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：元空间（包括运行时常量池）、直接内存\n\n 程序计数器\n\n一小块固定的内存空间，每个线程的程序计数器不会相互影响，独立存储。随着线程的创建而创建，随着线程的结束而死亡，所以程序计数器不会出现内存溢出的情况\n\n有两个作用：\n\n 控制程序指令的进行，实现代码的流程控制\n 在多线程下，程序计数器记录了当前线程执行的位置，以便于在线程执行完后切换回来能够返回到当前位置\n\n Java虚拟机栈\n\nJava虚拟机栈中存放了一个个栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法返回地址。随着线程的创建而创建，随着线程的结束而死亡。\n\n每个方法调用都会有一个对应的栈帧压入栈中，调用结束后，都会有一个栈帧被弹出。\n\n可能出现的两种错误：\n\n 当在循环条件下进行调用的话会导致栈中被压入太多栈帧而占用空间，当超过Java虚拟机最大深度的时候会报出StackOverFlowError的错误。\n 当栈内存可以动态拓展的时候，如果虚拟机无法申请到足够的内存空间会报出OutOfMemoryError错误\n\n 局部变量表\n\n存放编译时可知的基本数据类型、对象类型。\n\n 操作数栈\n\n存放方法执行过程中产生的中间计算结果，也存放临时变量。\n\n 动态链接\n\n主要用在当一个方法调用另一个方法的时候，需要将 Class 文件常量池中的符号引用转为内存地址的直接引用。\n\n 本地方法栈\n\n与Java虚拟栈不同的是：Java虚拟机栈存放的是Java方法栈帧，而本地方法栈存放的是Native方法栈帧。\n\n 堆\n\n最大的一块内存区域，主要存放的是对象实例以及数组（局部变量表中存放的是堆上对象的引用）。\n\n几乎所有的对象都在堆上分配内存，但是随着技术升级，如果某些方法中的对象没有被外部使用或者没有被返回，那么对象可以直接在Java虚拟机栈上分配内存。\n\n 方法区\n\n方法区存放类的元信息（类的基本信息、字段信息、变量信息等），还包括运行时常量池、字符串常量池JDK7之前\n\nJDK1.8之前方法区实现是永久代空间，存放在堆区域中\n\nJDK1.8之后方法区实现是元空间，存放在直接内存区域中\n\n 方法区与永久代和元空间的关系就像是接口和实现类的关系，方法区是接口，永久代和元空间是实现类\n\n 运行时常量池\n\n方法区的一部分，存放编译期生成的各种字面量和符号引用\n\n 字符串常量池\n\n方法区的一部分，存放常量字符串内容\n\n主要目的是为了避免字符串的重复创建\n\n 与运行时常量池的关系\n\nJDK7之前：运行时常量池包括字符串常量池，方法区实现为永久代\n\nJDK7：字符串常量池从方法区拿到堆中，运行时常量池剩下的还在方法区的永久代中\n\nJDK8之后：方法区用元空间替换了永久代空间，字符串常量池还在堆中\n\n 直接内存\n\n一种特殊的内存缓冲区\n\n 垃圾回收\n\nJava的自动内存管理主要针对对象内存回收和对象内存分配，最核心的功能是堆内存中对象的回收和分配\n\nJava堆是垃圾收集器管理的主要区域，因此也被称作GC堆\n\n 堆空间基本结构\n\nJava堆分为不同的 区域，根据各个区域的特点选择合适的垃圾收集算法\n\nJDK1.7：\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、永久代：PerGen\n\nJDK1.8：\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、元空间：MetaSpace\n\n 垃圾回收流程\n\n大部分情况，对象首先在Eden区域分配内存，若在一次新生代垃圾回收后，该对象还存活，就将它放到S0或S1并将年龄加1。当再一次一次新生代垃圾回收后，若对象任然存在，那么就回将当前存活的对象放到另一个地方（若当前是 S0，就放到 S1；若是 S1，就放到 S0）并将年龄加1，当年龄增加到默认值阈值（15）的时候，会将对象晋升至老年代中。若老年代空间不足，会触发 Full GC 对整个堆进行垃圾回收。若 Full GC 无法回收老年代的对象，那么当对象继续放入老年代时，就会抛出 Out Of Memory 异常。\n\n 年龄是015的原因：年龄记录区域大小通常是4位，最大的二进制表示是1111，也就是15。\n\n 对象判断死亡的方法\n\n当一个对象可以被回收，不一定代表一定会被回收！对象回收至少需要经过两次标记的过程，可达分析法是第一次筛选，筛选的条件是对象是否有必要执行finalize方法（若对象没有覆盖finalize方法或 finalize 方法已经被虚拟机调用过，就说明没有执行的必要），将需要执行的对象放在一个队列中进行第二次筛选，当这个对象与引用链上任意一个对象相关联，就不会回收，否则就会回收。\n\n 引用计数法\n\n给对象添加一个引用计数器，当对象被引用的时候就，计数器就加1，当引用消失的时候，引用就减1。当引用为0的时候就说明对象可以被回收\n\n优点：实现简单\n\n缺点：1、每次对象引用和取消都需要维护一下，影响系统的性能。2、当出现A引用B，同时B引用A的情况，也就是循环引用时会出现无法回收的问题\n\n 可达性分析算法\n\n用一个GC ROOT座作为根节点，与每个有引用的对象相连接，若对象到GC ROOT没有连接就说明对象可以被回收。\n\n常见的GC ROOT：\n\n 虚拟机栈栈帧中的局部变量表中引用的对象\n 本地方法栈Native 方法中引用的对象\n 方法区中类静态属性引用的对象\n 方法区中常量引用的对象\n 所有被同步锁持有的对象\n JNI（Java Native Interface）引用的对象\n\n 引用类型\n\n 强引用\n\n大部分使用的引用都是强引用，垃圾回收器绝不会回收此类引用\n\n 软引用\n\n软引用通过SoftReference类实现，若系统内存不足，就会回收它，若内存足够，就不管。\n\n软引用可以用来实现内存敏感的高速缓存\n\n软引用可以和一个引用对象联合使用，若软引用的对象被垃圾回收，就会放到与之关联的引用队列中，通过遍历引用队列，将SoftReference的强引用删除\n\n 弱引用\n\n只具有弱引用的对象拥有更短暂的生命周期\n\n不管系统内存是否足够，只要发现是弱引用，就可能被垃圾回收。但是垃圾回收器是一个优先级很低的线程，不一定发现得了弱引用\n\n与软引用类似，弱引用可以和一个引用对象联合使用，若弱引用的对象被垃圾回收，就会放到与之关联的引用队列中\n\n 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n 垃圾回收算法\n\n 标记清除法\n\n标记出不需要回收的对象，在标记完后统一回收没有标记的对象\n\n优点：实现简单\n\n缺点：1、碎片化问题，没有标志的内存不连续，标记清除后会产生大量不连续的内存碎片。2、标记和清除两个过程效率都不高\n\n实现过程：\n\n1、对象被创建的时候，标记为0\n\n2、在标记阶段，将所有可达的对象标记为1\n\n3、扫描阶段，清除所有标记为0的对象\n\n 复制算法\n\n将内存分为相同的两块，每次使用其中的一块，当进行了垃圾回收后，将存活的对象移到另一块未使用的内存，然后将使用的内存一次性清除掉，这样每次回收都是内存的一半\n\n优点：解决了碎片化问题\n\n缺点：1、可用内存减小为原来的一般。2、存活对象数量多的化复制性能就变得很差\n\n 标记整理算法\n\n过程与标记清除算法类似，但是它标记后并不会回收对象，而是让存活的对象移动到另一端，清除掉段边界以外的内存\n\n 分代收集算法\n\n当前虚拟机都采用的这种算法，可以根据年代的特点进行使用不同的回收算法\n\n例如在新生代中，每次收集都会有大量对象死去，所以就采用标记复制算法（只需要少部分复制成本就能完成对象收集），老年代中的对象存活率较高，所以就采用标记整理或者标记清除算法\n\n 垃圾收集器\n\n如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是内存回收后的实现\n\n Serial收集器\n\n单线程收集器，在进行垃圾收集的时候会停止掉所有的工作线程，直到它收集结束\n\n优点就是简单高效，没有线程交互的开销\n\n采用的算法：新生代采用标记复制算法，老年代采用标记整理算法。\n\n ParNew收集器\n\nParNew收集器是Serial收集器的多线程版本\n\n采用的算法：新生代采用标记复制算法，老年代采用标记整理算法。\n\n Parallel Scavenge收集器\n\nParallel Scavenge收集器看上去和ParNew收集器都一样，不同点是Parallel Scavenge收集器关注点是吞吐量（高效率的的利用CPU），而CMS等收集器关注点是用户线程的停顿时间（提高用户体验）\n\nParallel Scavenge收集器提供很多参数供用户找到最合适的停顿时间或最大吞吐量\n\n采用的算法：新生代采用标记复制算法，老年代采用标记整理算法。\n\n Serial Old收集器\n\nSerial收集器的老年代版本，主要有两大用途：\n\n1、JDK1.5版本之前与Parallel Scavenge收集器配合使用\n\n2、作为CMS收集器的后备方案\n\n Parallel Old收集器\n\nParallel Scavenge收集器的老年代版本，使用多线程和标记整理算法\n\n 在关注吞吐量和CPU资源的场景下，可以优先考虑Parallel Scavenge收集器和Parallel Old收集器\n\n CMS收集器\n\n一款老年代收集器，可以分配新生代的 Serial 和 ParNew 收集器一起使用\n\n一种以获取最短回收时间为目的的收集器，注重用户体验，能够实现GC和用户线程（基本上）同时进行\n\n执行过程：\n\n1、初始标记：暂停所有其他的线程，快速记录与root相连接的对象\n\n2、并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象（但是这个闭包结构并不能将所有的可达对象都记录，因为用户线程在不断的更新引用域，GC线程无法保证可达分析的及时性）\n\n3、重新标记：修正并发标记的阶段因为用户线程继续运行而导致标记产生变动的那一部分对象标记记录\n\n4、清除标记：开启用户线程，同时GC线程对未标记的区域作清扫（垃圾回收）\n\n优点：并发收集，低停顿\n\n缺点：1、对CPU资源敏感。2、无法处理浮动垃圾。3、会产生大量空间碎片\n\n采用的算法：标记清除算法\n\nCMS 垃圾回收器在 Java 9 中已经被标记为过时，并在 Java 14 中被移除\n\n G1收集器\n\n收集范围是新生代和老年代收，不需要结合其他收集器使用\n\n一款面向服务器的垃圾收集器，满足 GC 停顿时间要求的同时，还具备高吞吐量的特性\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region\n\n执行过程：1、初始标记。2、并发标记。3、最终标记。4、筛选回收。\n\n优点：1、并发与并行。2、分代收集。3、空间整理（整体上看是标记整理算法，局部来看是标记复制算法）4、可预测的停顿。\n\n从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器\n\n ZGC收集器\n\n与ParNew和G1类似，ZGC也采用标记复制算法，但是ZGC做了重大改进：可以将暂停时间控制在几毫秒内，且暂停时间不受堆内存大小的影响\n\n 类文件结构\n\n 魔数\n\n每个Class文件的头4个字节称为魔数，通过这4个字节来确定一个文件的类型\n\nJava文件为kj0xcadebabe\n\n Class文件版本号\n\n接着魔数的第5个和第6个此节表示的是次版本号，第7和第8个字节是主版本号\n\n通过这个版本号能够计算出JDK版本\n\nJDK1.2之后的版本计算方法：主版本号  44\n\n 常量池\n\n接着主次版本号之后就是常量池，常量池存放：字面量和符号引用\n\n 访问标志\n\n接常量池之后，紧挨着的两个字节代表访问标志\n\n访问标志用于识别一些类或接口的信息：这个Class是类还是接口，是 public 还是 private 等\n\n 当前类、父类、接口索引集合\n\nJava 类的继承关系由类索引、父类索引和接口索引集合三项确定\n\n 字段表集合\n\n字段表用于描述接口或类中声明的变量，但不包括方法内的局部变量\n\n字段表结构：访问标志、名称索引、描述符索引、属性表集合\n\n 方法集合\n\n字段表用于描述接口或类中声明的方法\n\n与字段表结构类似，但是与字段表不同的是少了 volatile 修饰符和 transient 修饰符这两个不可以修饰方法的访问标志，增加了synchronized、native、abstract等关键字修饰方法\n\n 属性表集合\n\n字段表、方法表中都存在自己的属性表集合，以用于描述某些场景专有的信息\n\n 类的加载过程\n\n 类的生命周期\n\n加载连接（验证准备解析）初始化使用卸载\n\n 加载\n\n这一阶段由类加载器完成，主要是完成下面三件事：\n\n1、通过全类名获取二进制流\n\n2、在方法去保存一个InstanceKClass对象，保存类的所有信息\n\n3、同时还会在堆上生成与方法区类似的java.lang.Class对象，作为方法区这些数据的访问入口\n\n加载阶段与连接阶段的部分动作如一部分字节码文件格式验证动作是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了\n\n 连接\n\n 验证\n\n检验字节码文件是否遵守了《Java虚拟机规范》的约束要求\n\n检查的部分：\n\n1、文件格式验证（Class文件格式）\n\n2、元数据验证（字节码语义）\n\n3、字节码验证（程序语义）\n\n4、符号引用验证（类的正确性）\n\n 准备\n\n正式的为类变量分配内存并设置类变量初始值\n\n 解析\n\n将常量池内的符号引用替换为直接引用\n\n 初始化\n\n执行初始化方法（cinit）\n\n以下几种情况会进行类初始化\n\n1、当遇到 new、 getstatic、putstatic 或 invokestatic 这 4 条字节码指令时\n\n2、使用 java.lang.reflect 包的方法对类进行反射调用时\n\n3、初始化一个类，如果其父类还未初始化，则先触发该父类的初始化\n\n4、执行Main方法的当前类\n\n....\n\n以下几种情况不会进行类初始化\n\n1、无静态代码块且无静态变量赋值语句\n\n2、有静态变量的声明，但是没有赋值语句，如：private static int a;\n\n3、静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化，如：private final static int a = 10;\n\n 卸载\n\n类的Class对象被GC\n\n 类加载器\n\n 介绍\n\n 类加载器的主要作用就是加载Java类的字节码（.Class文件）到JVM中（在内存中生成一个代表类的Class对象）\n\nJVM内置的三个重要类加载器：\n\n BootstrapClassLoader启动类加载器：最顶层的加载器，由C++实现，通常为null（因为C++实现的类加载器在Java无与之对应的类），无父类，用来加载JDK内部的核心类库\n ExtensionClassLoader扩展类加载器：加载/jre/lib/ext下的类文件\n AppClassLoader应用程序类加载器：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类\n\n执行流程图：\nhttps://img2.imgtp.com/2024/05/20/fYIF5GzX.png\n\n 双亲委派模型\n\n类加载器有很多种，当我们需要加载一个类的时候需要哪一个类加载器呢？这时候就需要用到双亲委派模型了\n\n 执行流程\n\n执行流程集中在ClassLoader的loadClass方法中\n\njava\nprotected Class<? loadClassString name, boolean resolve\n    throws ClassNotFoundException\n{\n    synchronized getClassLoadingLockname {\n        //首先，检查该类是否已经加载过\n        Class c = findLoadedClassname;\n        if c == null {\n            //如果 c 为 null，则说明该类没有被加载过\n            long t0 = System.nanoTime;\n            try {\n                if parent = null {\n                    //当父类的加载器不为空，则通过父类的loadClass来加载该类\n                    c = parent.loadClassname, false;\n                } else {\n                    //当父类的加载器为空，则调用启动类加载器来加载该类\n                    c = findBootstrapClassOrNullname;\n                }\n            } catch ClassNotFoundException e {\n                //非空父类的类加载器无法找到相应的类，则抛出异常\n            }\n\n            if c == null {\n                //当父类加载器无法加载时，则调用findClass方法来加载该类\n                //用户可通过覆写该方法，来自定义类加载器\n                long t1 = System.nanoTime;\n                c = findClassname;\n\n                //用于统计类加载器相关的信息\n                sun.misc.PerfCounter.getParentDelegationTime.addTimet1  t0;\n                sun.misc.PerfCounter.getFindClassTime.addElapsedTimeFromt1;\n                sun.misc.PerfCounter.getFindClasses.increment;\n            }\n        }\n        if resolve {\n            //对类进行link操作\n            resolveClassc;\n        }\n        return c;\n    }\n}\n\n\n总结：首先类加载器先判断自己是否已经加载过这个类了，若已经加载就直接返回，否则自己先不会加载，而是让父类加载器进行加载，只有当前父类加载器也没法加载的时候，自己才加载\n\n由此可知，判断两个类是否相同，不但要看类的全名是否一致，还要看类加载器是否一致\n\n 打破双亲委派模型\n\n1、自定义类加载器\n\n自定义类加载器需要继承ClassLoader类，若不想打破双亲委派机制就重写ClassLoder类的findClass方法，若想打破，就重写loadClass方法（因为类加载器进行类加载的时候，会先调用父类加载器的loadClass方法，改变了传统双亲委派模型的执行流程）\n\n2、线程上下文类加载器\n\n有些时候，高层的类加载器需要加载底层的类加载才能加载的类\n\n例如：JDBC就是由启动类加载器委派应用类加载器去加载类的方式\n\n 启动类加载器加载DriverManager\n 在初始化DriverManager时，通过SPI机制加载jar中的msql驱动\n SPI利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象\n\n获取线程线程上下文类加载器的代码：\n\njava\nClassLoader cl = Thread.currentThread.getContextClassLoader;\n\n\n3、Osgi框架的类加载器\n"},{"filename":"2022-team-select-race","category":"aigorithm","md":{"topSummary":"\ntitle: 2022年算法队选拔赛\ncategory: 算法\ndate: 2024-05-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n回顾大二打的算法队选拔的算法赛\n\n感觉现在做起来很轻松，练题还是有效果的\n\n题目地址：https://vjudge.net/contest/513277\n\n## A - Numbers\n\n签到题，很清除的记得当时没看清楚题要求，输出化简后的格式，一直没化简....\n\n ```c++\n #include<bits/stdc++.h>\n #define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int> PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n int a, b, x, y, z, res;\n \n int fun(int x, int y){\n \treturn y ? fun(y, x % y) : x;\n }\n \n int main(){\n \tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n \tcin >> a;\n \tfor(int i = 2; i <= a - 1; i ++){\n \t\tint num = a;\n \t\twhile(num){\n \t\t\tres += num % i;\n \t\t\tnum /= i;\n \t\t} \n \t}\n \tint cc = fun(res, a - 2);\n \tcout << res / cc << \"/\" << (a - 2) / cc << endl; \n \t\n \treturn 0;\n }\n ```\n\n## B - 表达式求值\n\n不用考虑括号写起来就很nice\n\n ```c++\n #include<bits/stdc++.h>\n #define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int> PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n int a, b, x, y, z;\n ll res;\n stack<ll> s1;\n stack<char> s2;\n unordered_map<char, int> ump;\n \n void init(){\n \tump['+'] = 1;\n \tump['*'] = 2;\n }\n \n void fun(char c){\n \twhile(s2.size() && s1.size() >= 2 && ump[s2.top()] >= ump[c]){\n \t\tll num1 = s1.top(), cot = 0;\n \t\ts1.pop();\n \t\tll num2 = s1.top();\n \t\ts1.pop();\n \t\tchar c = s2.top();\n \t\ts2.pop();\n \t\tif(c == '+') cot = num1 + num2;\n \t\telse cot = num1 * num2;\n \t\ts1.push(cot);\n \t}\t\n \ts2.push(c);\t\n }\n \n void end(){\n \twhile(s2.size() && s1.size() >= 2){\n \t\tll num1 = s1.top(), cot = 0;\n \t\ts1.pop();\n \t\tll num2 = s1.top();\n \t\ts1.pop();\n \t\tchar c = s2.top();\n \t\ts2.pop();\n \t\tif(c == '+') cot = num1 + num2;\n \t\telse cot = num1 * num2;\n \t\ts1.push(cot);\n \t}\t\n }\n \n int main(){\n \tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n \tinit();\n \tstring str;\n \tcin >> str;\n \tfor(int i = 0; i < str.size(); i++){\n \t\tint idx = i;\n \t\tll num = 0;\n \t\twhile(str[idx] >= '0' && str[idx] <= '9'){\n \t\t\tnum = num * 10 + str[idx] - '0';\n \t\t\tidx ++;\n \t\t}\n \t\tif(num != 0){\n \t\t\ts1.push(num);\n \t\t\ti = idx - 1;\n \t\t\tcontinue;\n \t\t}\n \t\tif(str[i] == '+' || str[i] == '*'){\n \t\t\tfun(str[i]);\n \t\t}\n \t}\n \tend();\n \tcout << s1.top() % 10000 << endl;\n \t\n \treturn 0;\n }\n ```\n\n## C - T-primes\n\n数据量很大，需要用到质数筛\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\nint n[N], st[N], idx;\n\nvoid init(){\n\tst[1] = 1;\n\tfor(int i = 2; i <= N; i ++){\n\t\tif(!st[i]) n[idx ++] = i; \n\t\tfor(int j = 0; n[j] <= N / i; j ++){\n\t\t\tst[n[j] * i] = 1;\n\t\t\tif(i % n[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tinit();\n\tcin >> a;\n\tfor(int i = 0; i < a; i++){\n\t\tll num;\n\t\tcin >> num;\n\t\tll cc = sqrt(num);\n\t\tif(cc * cc == num && !st[cc]){\n\t\t\tcout << \"YES\" << endl; \n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n```\n\n## D - New Year's Number\n\n签到题\n\n ```c++\n #include<bits/stdc++.h>\n #define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int> PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n int a, b, x, y, z;\n \n int main(){\n \tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n \tcin >> a;\n \twhile(a --){\n \t\tcin >> b;\n \t\tint flag = 0;\n \t\tfor(int i = 0; i <= b / 2020; i ++){\n \t\t\tint f = 0;\n \t\t\tfor(int j = 0; j <= b / 2021; j ++){\n \t\t\t\tint cc = i * 2020 + j * 2021;\n \t\t\t\tif(cc > b){\n \t\t\t\t\tbreak;\n \t\t\t\t} else if(cc == b){\n \t\t\t\t\tf = 1;\n \t\t\t\t\tflag = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t} \n \t\t\t}\n \t\t\tif(f){\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(flag) cout << \"YES\" << endl;\n \t\telse cout << \"NO\" << endl;\n \t} \n \t\n \treturn 0;\n }\n ```\n\n## E - 最小新整数\n\n 单调栈\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n\nstring get(stack<char> s){\n\tstring res = \"\";\n\twhile(s.size()){\n\t\tres = s.top() + res;\n\t\ts.pop();\n\t} \n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str;\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> str >> x;\n\t\tstack<char> s;\n\t\tint len = str.size(), cot = 0;\n\t\tfor(int i = 0; i < len; i++){\n\t\t\twhile(!s.empty() && s.top() > str[i] && cot < x){\n\t\t\t\tcot ++;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(str[i]);\n\t\t}\n\t\tif(cot == x){\n\t\t\tcout << get(s) << endl;\n\t\t} else {\n\t\t\tint num = x - cot;\n\t\t\tstring str = get(s);\n\t\t\tfor(int i = 0; i < str.size() - num; i++){\n\t\t\t\tcout << str[i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n```\n\n## F - Count\n\n 矩阵快速幂\n\n\n\n\n\n","title":" 2022年算法队选拔赛\n","category":[" 算法\n"],"date":" 2024-05-09\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n回顾大二打的算法队选拔的算法赛\n\n感觉现在做起来很轻松，练题还是有效果的\n\n题目地址：https://vjudge.net/contest/513277\n\n A  Numbers\n\n签到题，很清除的记得当时没看清楚题要求，输出化简后的格式，一直没化简....\n\n c++\n include<bits/stdc++.h\n define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n int a, b, x, y, z, res;\n \n int funint x, int y{\n \treturn y ? funy, x % y : x;\n }\n \n int main{\n \tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n \tcin  a;\n \tforint i = 2; i <= a  1; i ++{\n \t\tint num = a;\n \t\twhilenum{\n \t\t\tres += num % i;\n \t\t\tnum /= i;\n \t\t} \n \t}\n \tint cc = funres, a  2;\n \tcout << res / cc << \"/\" << a  2 / cc << endl; \n \t\n \treturn 0;\n }\n \n\n B  表达式求值\n\n不用考虑括号写起来就很nice\n\n c++\n include<bits/stdc++.h\n define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n int a, b, x, y, z;\n ll res;\n stack<ll s1;\n stack<char s2;\n unorderedmap<char, int ump;\n \n void init{\n \tump'+' = 1;\n \tump'' = 2;\n }\n \n void funchar c{\n \twhiles2.size && s1.size = 2 && umps2.top = umpc{\n \t\tll num1 = s1.top, cot = 0;\n \t\ts1.pop;\n \t\tll num2 = s1.top;\n \t\ts1.pop;\n \t\tchar c = s2.top;\n \t\ts2.pop;\n \t\tifc == '+' cot = num1 + num2;\n \t\telse cot = num1  num2;\n \t\ts1.pushcot;\n \t}\t\n \ts2.pushc;\t\n }\n \n void end{\n \twhiles2.size && s1.size = 2{\n \t\tll num1 = s1.top, cot = 0;\n \t\ts1.pop;\n \t\tll num2 = s1.top;\n \t\ts1.pop;\n \t\tchar c = s2.top;\n \t\ts2.pop;\n \t\tifc == '+' cot = num1 + num2;\n \t\telse cot = num1  num2;\n \t\ts1.pushcot;\n \t}\t\n }\n \n int main{\n \tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n \tinit;\n \tstring str;\n \tcin  str;\n \tforint i = 0; i < str.size; i++{\n \t\tint idx = i;\n \t\tll num = 0;\n \t\twhilestridx = '0' && stridx <= '9'{\n \t\t\tnum = num  10 + stridx  '0';\n \t\t\tidx ++;\n \t\t}\n \t\tifnum = 0{\n \t\t\ts1.pushnum;\n \t\t\ti = idx  1;\n \t\t\tcontinue;\n \t\t}\n \t\tifstri == '+'  stri == ''{\n \t\t\tfunstri;\n \t\t}\n \t}\n \tend;\n \tcout << s1.top % 10000 << endl;\n \t\n \treturn 0;\n }\n \n\n C  Tprimes\n\n数据量很大，需要用到质数筛\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\nint nN, stN, idx;\n\nvoid init{\n\tst1 = 1;\n\tforint i = 2; i <= N; i ++{\n\t\tifsti nidx ++ = i; \n\t\tforint j = 0; nj <= N / i; j ++{\n\t\t\tstnj  i = 1;\n\t\t\tifi % nj == 0 break;\n\t\t}\n\t}\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tinit;\n\tcin  a;\n\tforint i = 0; i < a; i++{\n\t\tll num;\n\t\tcin  num;\n\t\tll cc = sqrtnum;\n\t\tifcc  cc == num && stcc{\n\t\t\tcout << \"YES\" << endl; \n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n\n\n D  New Year's Number\n\n签到题\n\n c++\n include<bits/stdc++.h\n define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n int a, b, x, y, z;\n \n int main{\n \tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n \tcin  a;\n \twhilea {\n \t\tcin  b;\n \t\tint flag = 0;\n \t\tforint i = 0; i <= b / 2020; i ++{\n \t\t\tint f = 0;\n \t\t\tforint j = 0; j <= b / 2021; j ++{\n \t\t\t\tint cc = i  2020 + j  2021;\n \t\t\t\tifcc  b{\n \t\t\t\t\tbreak;\n \t\t\t\t} else ifcc == b{\n \t\t\t\t\tf = 1;\n \t\t\t\t\tflag = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t} \n \t\t\t}\n \t\t\tiff{\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tifflag cout << \"YES\" << endl;\n \t\telse cout << \"NO\" << endl;\n \t} \n \t\n \treturn 0;\n }\n \n\n E  最小新整数\n\n 单调栈\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n\nstring getstack<char s{\n\tstring res = \"\";\n\twhiles.size{\n\t\tres = s.top + res;\n\t\ts.pop;\n\t} \n\treturn res;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str;\n\tcin  a;\n\twhilea {\n\t\tcin  str  x;\n\t\tstack<char s;\n\t\tint len = str.size, cot = 0;\n\t\tforint i = 0; i < len; i++{\n\t\t\twhiles.empty && s.top  stri && cot < x{\n\t\t\t\tcot ++;\n\t\t\t\ts.pop;\n\t\t\t}\n\t\t\ts.pushstri;\n\t\t}\n\t\tifcot == x{\n\t\t\tcout << gets << endl;\n\t\t} else {\n\t\t\tint num = x  cot;\n\t\t\tstring str = gets;\n\t\t\tforint i = 0; i < str.size  num; i++{\n\t\t\t\tcout << stri;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n\n\n F  Count\n\n 矩阵快速幂\n\n\n\n\n\n"},{"filename":"nowcoder-month-84","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛84\ncategory: 算法\ndate: 2024-05-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 打靶\n\n签到题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> b >> x >> y >> z;\n\t\tif(y > z){\n\t\t\tcout << \"No\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << (b - x >= z - y ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n## 小蓝的疑惑\n\n只有 gcd % gcd == 0 的数才有答案，否则输出-1\n\n 找出规律可以知道，要让a最小，那么只有最大公约数为a的时候最小；要让b也最小 ，a和b的最小公倍数为x，只有b为最小公倍数的时候最小\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> x >> y;\n\t\tif(y % x != 0){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tcout << x << \" \" << y << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## k级序列\n\n设当前下标为i，分两种情况\n\n- 当前数比前一个数大的时候，就取 min(v[i - 1], v[i] - k);\n- 当前数比前一个数小的时候\n  - 若 v[i] + k 任然小于 v[i - 1] 就是不满足条件的输出No\n  - 否则，就取 min(v[i] + k, v[i - 1]);\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> x >> y;\n\t\tvector<int> v(x);\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tif(x == 1){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint flag = 1;\n\t\tv[0] -= y; \n\t\tfor(int i = 1; i < x; i++){\n\t\t\tif(v[i] >= v[i - 1]){\n\t\t\t\tv[i] = max(v[i] - y, v[i - 1]);\n\t\t\t} else {\n\t\t\t\tif(v[i] + y < v[i - 1]){\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t\tv[i] = min(v[i] + y, v[i - 1]);\n\t\t\t}\n\t\t}\n\t\tcout << (flag ? \"Yes\" : \"No\") << endl;\n\n\t}\n\t\n\treturn 0;\n}\n```\n\n## Reverse\n\n先遍历找出现在有多少连续的1段，设置为 res。两端分分开判断，其次判断中间区间\n\n设当左右下标为x，y，分情况讨论，这里只讨论 v[x] != v[y]，因为相等的情况一致讨论没意义\n\n- 若 x == 1，若判断 v[x] == 1并且 v[y + 1] == v[x]，就需要 res--；若 v[x] == 0 并且 v[y + 1] != v[x]，则 res ++;\n- 若 y == a，判断同上\n- 若 v[x - 1] == v[x] 并且 v[y] == v[y + 1]，则 res --;  若v[x - 1] != v[x] 并且 v[y] != v[y + 1]，则 res ++;\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0, flag = 0;\n\tcin >> a >> b;\n\tvector<char> v(a);\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tif(v[i] == '1' && !flag){\n\t\t\tres ++, flag = 1;\n\t\t} else if(v[i ] == '0') flag = 0;\n\t}\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tint cot = res;\n\t\tif(v[x] != v[y]){\n\t\t\tif(x == 1){\n\t\t\t\tif(y != a && v[x] == '0' && v[y + 1] != v[x]) cot ++;\n\t\t\t\telse if(y != a && v[x] == '1' && v[y + 1] == v[x]) cot --;\n\t\t\t} else if(y == a){\n\t\t\t\tif(x != 1 && v[y] == '0' && v[x - 1] != v[y]) cot ++;\t\n\t\t\t\telse if(x != 1 && v[y] == '1' && v[x - 1] == v[y]) cot --;\t\t\t\n\t\t\t} else {\n\t\t\t\tif(v[x - 1] == v[x] && v[y] == v[y + 1]){\n\t\t\t\t\tcot ++; \n\t\t\t\t} else if(v[x - 1] != v[x] && v[y] != v[y + 1]){\n\t\t\t\t\tcot --;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cot << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## Dog vs Cat\n\n这题也是需要分开讨论，难就难在需要讨论个数为2的特殊情况\n\n- 当个数为2的时候\n  - 若两个数相差1，且最小的不是0，输出 Cat\n  - 否则输出Dog\n- 其他情况：算出所有数与1的差之和，设为 res；计算数组个数的一半，若是奇数需要 / 2 + 1，设为 cc；计算 res + cc 是否是奇数，若是奇数输出 Dog，否则输出 Cat\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint a;\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b);\n\t\tll res = 0;\n\t\tint cot = 0;\n\t\tfor(int i = 0; i < b; i++){\n\t\t\tcin >> v[i];\n\t\t\tif(v[i] != 0){\n\t\t\t\tres += v[i] - 1;\n\t\t\t} else {\n\t\t\t\tcot ++;\n\t\t\t}\n\t\t}\n\t\tif(b == 2){\n            sort(v.begin(),v.end());\n\t\t\tif(v[0] && v[0] + 1 == v[1]) cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl;\n\t\t\tcontinue;\n\t\t}\n        \n        int ban;\n        if(b % 2 == 0) ban = b / 2;\n        else ban = b / 2 + 1;\n\t\tif(cot >= ban){\n\t\t\tcout << \"Dog\" << endl;\n\t\t} else {\n\t\t\tint cc = ban - cot;\n\t\t\tif((res + cc) % 2 == 0) cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl; \n\t\t}\n\t\n\t}\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛84\n","category":[" 算法\n"],"date":" 2024-05-08\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 打靶\n\n签到题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea{\n\t\tcin  b  x  y  z;\n\t\tify  z{\n\t\t\tcout << \"No\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << b  x = z  y ? \"Yes\" : \"No\" << endl;\n\t}\n\n\treturn 0;\n}\n\n\n 小蓝的疑惑\n\n只有 gcd % gcd == 0 的数才有答案，否则输出1\n\n 找出规律可以知道，要让a最小，那么只有最大公约数为a的时候最小；要让b也最小 ，a和b的最小公倍数为x，只有b为最小公倍数的时候最小\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea{\n\t\tcin  x  y;\n\t\tify % x = 0{\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tcout << x << \" \" << y << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n k级序列\n\n设当前下标为i，分两种情况\n\n 当前数比前一个数大的时候，就取 minvi  1, vi  k;\n 当前数比前一个数小的时候\n   若 vi + k 任然小于 vi  1 就是不满足条件的输出No\n   否则，就取 minvi + k, vi  1;\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea{\n\t\tcin  x  y;\n\t\tvector<int vx;\n\t\tforint i = 0; i < x; i++{\n\t\t\tcin  vi;\n\t\t}\n\t\tifx == 1{\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint flag = 1;\n\t\tv0 = y; \n\t\tforint i = 1; i < x; i++{\n\t\t\tifvi = vi  1{\n\t\t\t\tvi = maxvi  y, vi  1;\n\t\t\t} else {\n\t\t\t\tifvi + y < vi  1{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t\tvi = minvi + y, vi  1;\n\t\t\t}\n\t\t}\n\t\tcout << flag ? \"Yes\" : \"No\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n\n\n Reverse\n\n先遍历找出现在有多少连续的1段，设置为 res。两端分分开判断，其次判断中间区间\n\n设当左右下标为x，y，分情况讨论，这里只讨论 vx = vy，因为相等的情况一致讨论没意义\n\n 若 x == 1，若判断 vx == 1并且 vy + 1 == vx，就需要 res；若 vx == 0 并且 vy + 1 = vx，则 res ++;\n 若 y == a，判断同上\n 若 vx  1 == vx 并且 vy == vy + 1，则 res ;  若vx  1 = vx 并且 vy = vy + 1，则 res ++;\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0, flag = 0;\n\tcin  a  b;\n\tvector<char va;\n\tforint i = 1; i <= a; i++{\n\t\tcin  vi;\n\t\tifvi == '1' && flag{\n\t\t\tres ++, flag = 1;\n\t\t} else ifvi  == '0' flag = 0;\n\t}\n\twhileb {\n\t\tcin  x  y;\n\t\tint cot = res;\n\t\tifvx = vy{\n\t\t\tifx == 1{\n\t\t\t\tify = a && vx == '0' && vy + 1 = vx cot ++;\n\t\t\t\telse ify = a && vx == '1' && vy + 1 == vx cot ;\n\t\t\t} else ify == a{\n\t\t\t\tifx = 1 && vy == '0' && vx  1 = vy cot ++;\t\n\t\t\t\telse ifx = 1 && vy == '1' && vx  1 == vy cot ;\t\t\t\n\t\t\t} else {\n\t\t\t\tifvx  1 == vx && vy == vy + 1{\n\t\t\t\t\tcot ++; \n\t\t\t\t} else ifvx  1 = vx && vy = vy + 1{\n\t\t\t\t\tcot ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cot << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n Dog vs Cat\n\n这题也是需要分开讨论，难就难在需要讨论个数为2的特殊情况\n\n 当个数为2的时候\n   若两个数相差1，且最小的不是0，输出 Cat\n   否则输出Dog\n 其他情况：算出所有数与1的差之和，设为 res；计算数组个数的一半，若是奇数需要 / 2 + 1，设为 cc；计算 res + cc 是否是奇数，若是奇数输出 Dog，否则输出 Cat\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint a;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tvector<int vb;\n\t\tll res = 0;\n\t\tint cot = 0;\n\t\tforint i = 0; i < b; i++{\n\t\t\tcin  vi;\n\t\t\tifvi = 0{\n\t\t\t\tres += vi  1;\n\t\t\t} else {\n\t\t\t\tcot ++;\n\t\t\t}\n\t\t}\n\t\tifb == 2{\n            sortv.begin,v.end;\n\t\t\tifv0 && v0 + 1 == v1 cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl;\n\t\t\tcontinue;\n\t\t}\n        \n        int ban;\n        ifb % 2 == 0 ban = b / 2;\n        else ban = b / 2 + 1;\n\t\tifcot = ban{\n\t\t\tcout << \"Dog\" << endl;\n\t\t} else {\n\t\t\tint cc = ban  cot;\n\t\t\tifres + cc % 2 == 0 cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl; \n\t\t}\n\t\n\t}\n\t\n\treturn 0;\n}\n\n\n"},{"filename":"software-test","category":"major","md":{"topSummary":"\ntitle: 软件测试资料\ncategory: 软件工程\ndate: 2024-05-07\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 1.软件测试层次（P10）\n\n- **单元测试**：包括代码评审（静态测试）和运行单元程序进行测试（动态测试）。单元测试一 般由开发人员完成。\n- **集成测试**：也称组装测试、联合测试、子系统测试，在单元测试的基础上，将模块按照设 计要求组装起来同时进行测试，主要目标是发现与接口有关的模块之间问题。\n- **系统测试**：是将软件放在整个计算机环境下，包括软硬件平台、某些支持软件、数据和人 员等，在实际运行环境下进行一系列的测试，包括恢复测试、安全测试、强度测试和性能 测试等。\n- **验收测试**：是指在软件产品完成了系统测试之后、产品发布之前所进行的软件测试活动。 它是技术测试的最后一个阶段，也称为交付测试，确保所开发的软件产品是否符合用户预 期的各项要求。验收测试的重要特征就是用户参与。\n\n## 2.软件测试中的评审包括（P19）\n\n- 技术评审\n- 文档评审\n\n> 补充两个：管理评审、流程评审\n\n## 3.评审方法（P20）\n\n方法从上到下逐渐正式\n\n- 临时评审（最不正式）\n- 轮查：邮件分发审查的方法，通过邮件将评审的内容分发下去，然后再收集大家的反馈意见\n- 互为复审（同行评审）：一对一相互审查\n- 走查（应用最广泛）：评审的对象从头到尾检查一遍。\n- 会议审查（最正式）\n\n## 4.软件测试中，修正一个错误的代价（P26）\n\n要修正问题，必须重新设计、重新编程和重新测试，代价是不是很大？问题发现得越迟，要重做的事情就会越多，返工量就越大。也就是说，缺陷发现或解决得越迟，其带来的成本就越大。\n\n## 5.用户故事要素（P30）\n\n三个要素\n\n- 角色：谁要使用这个功能，即确定最终用户角色\n- 活动：需要完成什么样的功能\n- 商业价值：为什么需要这个功能，这个功能带来什么样的价值\n\n> 用户故事通常按如下格式来表达：\n> 作为一个<角色>，我想要<做什么、活动>，以便达到<什么目的、商业价值>\n\n## 6.修复软件缺陷费用（P26）\n\n![](https://img2.imgtp.com/2024/05/12/H7X03NE2.png)\n\n## 7.静态测试，动态测试（P9）\n\n- 动态测试是通过运行程序来发现软件系统中的问题。这种测试是在程序运行过程中将缺陷发现出来,具有动态性,所以称为动态测试。\n- 静态测试主要活动是评审，即通过对需求、设计、配置、程序和其他各类文档的审查来检验相应内容是否满足用户的需求。不需要运行程序，测试对象属于静态的。\n\n> 额外内容：\n> 黑盒测试有可能是动态测试（运行程序，看输入输出），也有可能是静态测试（不运行，只看界面） \n> 白盒测试有可能是动态测试（运行程序并分析代码结构），也有可能是静态测试（不运行程序，只静态察看代码） \n> 动态测试有可能是黑盒测试（运行，只看输入输出），也有可能是白盒测试 （运行并分析代码结构） \n> 静态测试有可能是黑盒测试（不运行，只察看界面），也有可能是白盒测试（不运行，只察看代码）\n\n## 8.驱动程序、桩程序（P85）\n\n- **驱动程序（driver )，对底层或子层模块进行(单元或集成）测试时所编制的调用被测模块的程序，用以模拟被测模块的上级模块。**驱动模块在集成测试中接受测试数据，调用被测模块,并把相关的数据传送给被测模块，然后获得测试结果。当被测模块是底层模块时，如图5-3中的模块E、F、C和G,需要创建驱动程序。\n\n- **桩程序（stub）,也有人称为存根程序，对顶层或上层模块进行测试时，所编制的替代下层模块的程序,用以模拟被测模块工作过程中所调用的模块。**桩模块相当于电路中的短路器，使上层模块不需要调用真实模块，就能获得所需要的参数、返回值等。桩模块由被测试模块调用，其内部尽量简单，例如，按照简单条件进行判断,给出返回值，使被测试模块得到它需要得到的值。当被测模块是上层模块时,如图5-3中的模块A，就需要建立桩程序。\n\n![](https://img2.imgtp.com/2024/05/10/AtaR3jre.png)\n\n## 9.单元测试中测试用例设计覆盖方法（P86）\n\n- **语句覆盖**：使得程序中每一条可执行语句至少被执行一次。\n- **分支覆盖（判定覆盖）**：使得程序中每一个分支都至少被执行一次。（要求判定表达式的值的真假分支都被执行）\n- **条件覆盖**：程序中每一个条件至少有一次被满足。（要求判定表达式的每个条件的值的真假分支都被执行）\n- **路径覆盖**：对程序模块的所有独立的基本路径至少要测试一次。\n\n> 额外内容：\n>\n> 条件覆盖跟判定覆盖的区别：\n> 举个例子：\n> 判定表达式：a > 3 and b > 0\n> 用判定覆盖设计的测试用例:\n> a: true, b: true\n> a: false,b: false\n> -> a = 5, b = 1 (判定表达式的值为“真”)\n> -> a = 0, b = 1 (判定表达式的值为“假”)\n> 注意：这里并不需要管b的取值，就已经满足判定覆盖的条件了。\n> 用条件覆盖设计的测试用例：\n> a: true, b: false\n> a: ture, b: true\n> a: alse, b: false\n> a: false, b: true\n> -> a = 5, b = 1 (条件a > 3为真， 条件b > 0为真)\n> -> a = 5, b = -1 (条件a > 3为真， 条件b > 0为假)\n> -> a = -5, b = 1 (条件a > 3为假， 条件b > 0为真)\n> -> a = -5, b = -1(条件a > 3为假， 条件b > 0为假)\n\n## 10.移动应用 APP特有的测试（P196）\n\n针对移动App应用测试,除了针对代码的单元测试、系统功能测试之外,侧重考虑下列测试。\n\n- 兼容性测试，包括硬件差异、操作系统版本等。\n- 交互性测试，不同的操作同时发生，例如微信操作时电话来了。\n- 用户体验测试，即用户易用性测试,如横竖切换、触摸、多指触摸、缩放、分页和导航等操作灵活性、局限性。\n- 耗电量测试，可以通过仪器来检测,也可以通过判断计算效率是否是最优的来进行评估。\n- **网络流量测试**，数据传输是否压缩,是否只传输必要的信息?\n- **网络连接**，在低速无线连接、不同网络间的切换情况下，软件容错性、稳定性如何?在无网络的情况下，App支持离线操作吗?\n- 性能测试，在移动设备端，主要通过内存、进程占有CPU资源等分析来完成任务。\n- 稳定性测试，移动App闪退问题比较多，如何更好地发现App应用崩溃问题？\n\n## 11.缺陷优先级（P235）\n\n- 立即解决（P1级）：缺陷导致系统几乎不能运行、使用，或者严重妨碍测试的执行，需立即修正、尽快修正\n- 高优先级（P2级）：缺陷严重，影响测试，需要优先考虑修正。例如不超过24小时修正\n- 正常排队（P3级）：缺陷需要修正，但可以正常排队等待修正\n- 低优先级（P4级）：缺陷可以在开发人有时间的时候被修正，如果没有时间，可以不修正\n\n> 额外内容：软件缺陷**严重性**\n>\n> - 0级（致命）：最严重等级,缺陷导致系统任何一个主要功能完全丧失、用户数据受到破坏、系统崩溃悬挂、死机等 \n> - 1级（严重）：系统的主要功能部分丧失，数据不能完整保存，系统的次要功能完全丧失，系统所提供的功能或服务受到明显的影响\n> - 2级（一般）：系统的次要功能没有完全实现，但不影响用户的正常使用。例如提示信息不太准确;或用户界面差、操作时间稍长等问题\n> - 3级（较小）：操作者不方便或遇到麻烦，但不影响功能的操作和执行,如字体不美观、按钮大小不是很合适、文字排列不对齐等一些小问题\n\n## 12.缺陷分析的方法（P242）\n\n从缺陷的层次看，可以分为：\n\n- 宏观分析：根据缺陷的总体数据分析，可以了解整体的测试效率、开发人员修正缺陷的效率、测试是否能达到预期的目标。 \n- 微观分析：发现测试的漏洞，评估具体模块的代码质量以及具体缺陷描述中所存在的问题。\n\n> 额外内容：最常用的缺陷分析方法有4种，分别是**缺陷分布报告、缺陷趋势报告、缺陷年龄报告、测试结果进度报告**。\n\n## 13.软件缺陷的生命周期（P239）\n\n![](https://img2.imgtp.com/2024/05/06/iVxh2EVm.png)\n\n简化：打开->修正->关闭\n\n## 14.测试风险分类（P267）\n\n测试风险很多，但可以分为两类——**测试对象剖面的风险**和**测试操作剖面的风险**。\n（1）测试对象剖面的风险，即测试对象比较复杂，测试的广度和深度都不够。例如，系统所涉及的业务处理复杂、测试范围没有说明清楚、用户的各种使用场景(scenario)未被捕捉到、某些例外的测试用例没有想到等。\n（2）测试操作剖面的风险，主要指测试操作过程中存在的各种风险，例如测试环境和真实运行环境差异较大、测试流程不够完善导致测试执行难以控制、回归测试中以风险换时间的策略等。\n\n>额外内容：\n>![](https://img2.imgtp.com/2024/05/07/59AL8CEr.png)\n\n\n## 15.测试分析与设计的目标（P40）\n\n目标就是解决“测什么”、“如何测”这两个基本问题，也会引出“什么是测试用例”、“什么是测试脚本”等基本问题。\n\n## 16.集成测试策略（P97）\n\n- 自顶向下集成策略：从主控模块开始，沿着软件的控制层次向下移动，从而逐渐把各个模块结合起来。在组装过程中，可以使用深度优先或宽度优先的策略。\n- 自底向上集成策略：从底层模块开始（即在软件结构最底层的模块）开始，向上推进，不 断进行集成测试的方法。 \n- 混合策略：对软件结构中较上层，使用的是\"自顶向下\"法；对软件结构中较下层，使用 的是\"自底向上\"法，两者相结合。\n\n## 17.负载测试，压力测试，性能测试（P157）\n\n- **负载测试是通过模拟实际软件系统所承受的负载条件、改变系统负载大小和负载方式来发现系统中所存在的问题。**例如，逐渐增加模拟用户的数量来观察系统的响应时间和数据吞吐量、系统占用的资源（如CPU、内存）等，以检验系统的行为和特性，发现系统可能存在的性能瓶颈、内存泄漏、不能实时回步寺问题。贝我测A文地以为性能测试、压力测试所采用。\n- **压力测试是在强负载情况下（如大数据量、大量并发用户连接等）对稳定性进行测试，查看应用系统在峰值（瞬间使用高峰)使用情况下的行为表现;更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等，确认系统是否具有良好的容错能力和可恢复能力。**压力测试分为高负载下的长时间（如24小时以上)的稳定性压力测试和极限负载情况下导致系统崩溃的破坏性压力测试。\n- **性能测试是为获取或验证系统性能指标而进行的测试。**性能测试，目的明确，事先有明确的性能指标，并要求在严格的测试环境和所定义的测试负载情况下进行,获得在不同的负载情况下的性能指标数据。性能测试使用负载测试的技术、工具以及用不同的负载水平来度量性能指标和建立性能基准。\n\n## 18.测试用例的元素（P47）\n\n**5W1H**\n\n- Why\n- What\n- Where\n- When\n- Which\n- How\n\n> 没有Who\n\n![](https://img2.imgtp.com/2024/05/11/aYmCiie1.png)\n\n## 19.功能测试用例的设计方法（P120）\n\n- 等价类划分法\n  - 有效等价类16-40，无效等价类>40,<16\n  - 使用该方法设计测试用例的步骤：（1）数据分类，分出有效等价类和无效等价类（2）针对有效等价类，进一步进行分割，直到不能划分为止，形成等价类表，为每一等价类规定一个唯一的编号（3）就每一个具体的等价类，设计一个测试用例，直到所有有效等价类均被测试用例所覆盖（4）对无效等价类进行相同的处理\n- 边界值分析法\n- 循环结构测试的综合方法\n- 因果图法\n- 决策表方法\n- 功能图法\n- 正交试验设计方法\n\n> 额外内容：\n> 黑盒测试方法（blake-box testing)，是把程序看作一个不能打开的黑盒子，如图5-1所示，不考虑程序内部结构和内部特性，而是考察数据的输入、条件限制和数据输出，完成测试。\n> 白盒测试方法（ white-box testing )，也称结构测试或逻辑驱动测试。白盒测试方法是根据模块内部结构了解，基于内部逻辑结构，针对程序语句、路径、变量状态等来进行测试，如图5-2所示，检验程序中的各个分支条件是否得到满足，每条执行路径是否按预定要求正确地工作\n>\n> ---\n>\n> 黑盒测试方法的具体方法：等价类划分方法、边界值分析、因果分析、决策表方法、正交实验设计方法等。----> ## 19.功能测试用例的设计方法\n> 白盒测试的主要方法：逻辑覆盖、分支覆盖、条件组合覆盖、基本路径测试等。----> ## 9.单元测试中测试用例设计覆盖方法\n\n## 20.设计评审的难点（作业题）\n\n设计评审的难点主要集中在以下几个方面：\n（1）设计目标的理解：设计评审需要确保设计符合规定的目标，但有时设计者可能对目标理解不透彻，导致设计方案与实际需求不符。\n（2）设计方案的选择：在设计评审中，需要从多个设计方案中选择最优的方案，但有时设计者可能无法准确评估各个方案的优缺点，导致选择不当。\n（3）设计的实际可行性：设计评审需要评估设计的适宜性、充分性、有效性和效率，但有时设计者可能无法预测设计在实际应用中的表现，导致方案不可行。\n（4）设计的可持续性：设计评审需要考虑设计对环境、资源和经济的影响，但有时设计者可能只关注当前的需求，而忽视了设计的长期影响。\n（5）设计的创新性：设计评审需要鼓励创新的设计思路，但有时设计者可能过于追求创新，而忽视了设计的实际性和可用性。\n   因此，设计评审需要综合考虑以上难点，确保设计方案符合实际需求，具备可持续性和创新性，同时满足规定的目标。\n\n## 21.软件测试的目的（P255）\n\n在开发周期内，尽可能早地发现最严重的缺陷\n\n> 额外内容：\n> 测试目的:（1）证明：获取系统在可接受风险范围内可用的信心;尝试在非正常情况和条件下的功能和特性;保证一个工作产品是完整的并且可用或可被集成。（2）检测：发现缺陷、错误和系统不足;定义系统的能力和局限性;提供组件、工作产品和系统的质量信息。(3）预防：澄清系统的规格和性能;提供预防或减少可能制造错误的信息;在过程中尽早检测错误;确认问题和风险，并且提前确认解决这些问题和风险的途径。\n\n## 22.测试最低目标，基本目标（P255）\n\n- 最低目的：正常的输入+正常的处理过程，有一个正确的输出\n- 基本目的：对异常的输入有错误的捕获，并进行相应提示或者屏蔽\n\n> 额外内容：\n> 较高目的：对隐式需求进行测试\n\n## 23.软件质量概念\n\n概括地说，软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。从管理角度对软件质量进行度量，可将影响软件质量的主要因素划分为三组，分别反应用户在使用软件产品时的三种不同倾向或观点：产品运行(正确性、健壮性、效率、完整性、可用性、风险);产品修改(可理解性、可维修性、灵活性、可测试性);产品转移(可移植性、可再用性、互运行性)。\n\n> 软件质量特性是指软件的功能性、可靠性、易用性、效率、可维护性、可移植性  \n\n## 24.软件测试中的V&V模型（P8）\n\n软件测试中的V&V模型分别代表**验证**和**有效性确认**\n\n验证：是否正确地构造了软件？即是否正确地做事，验证开发过程是否遵守已定义好的内容。验证产品满足规格设计说明书的一致性。\n\n有效性确认：是否构造了正是用户所需要的软件？即是否正在做正确的事。验证产品所实现的功能是否满足用户的需求。\n\n## 25.向前兼容，向后兼容（P182）\n\n- 向后兼容是指新发布的软件版本可以使用该软件的以前版本所产生的数据;\n- 向前兼容是指在设计和开发软件一个新版本时，考虑如何和未来版本的数据兼容。\n\n> 额外内容：\n> 数据向后兼容测试是必不可少的，而数据向前兼容测试是可选的，一般是不需要的\n\n## 26.自动化测试的五种技术原理（P65）\n\n- 代码分析  \n- GUI 对象识别  \n- DOM 对象识别  \n- 自动比较技术  \n- 脚本技术 \n\n## 27.软件测试的原则（P250）\n\n- 尽早和不断地测试\n- 重点测试\n- 测试阶段性\n- 测试独立性\n- 测试客观性\n- 计划是一个过程\n- 测试开发的一部分\n- 发现缺陷更多的地方，其风险越大\n- 想用户所想\n\n## 28.软件测试中控制风险的对策（P268）\n\n- 消除执行风险：通过系统复审、测试人员之间互审、测试人员在不同的测试模块上相互调换、自动化测试和抽查等方法,及时发现问题，并产生震慑作用，确保测试用例被100%执行。\n- 降低进度风险：进行测试资源、时间等估算时,要留有余地,增加10%的空间，以降低测试资源可能不足的风险。\n- 减少人员风险：对每个关键性技术人员培养后备人员，做好不同领域知识的培训，从而确保人员一旦离开公司,项目不会受到严重影响。\n\n## 29.因果图\n\n一个程序规格说明要求如下：输入第一个字符必须是 # 或 * ,第二个字符必须是一个数字，在此情况可对文件修改；若第一个字符非 # 或 * ,则程序给出信息N，若第二个字符非数字，则程序给出信息M，试用因果图法设计该程序测试用例。\n\n![write by LiZhengXue](https://img2.imgtp.com/2024/05/14/5JfXIPV7.png)\n","title":" 软件测试资料\n","category":[" 软件工程\n"],"date":" 2024-05-07\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 1.软件测试层次（P10）\n\n 单元测试：包括代码评审（静态测试）和运行单元程序进行测试（动态测试）。单元测试一 般由开发人员完成。\n 集成测试：也称组装测试、联合测试、子系统测试，在单元测试的基础上，将模块按照设 计要求组装起来同时进行测试，主要目标是发现与接口有关的模块之间问题。\n 系统测试：是将软件放在整个计算机环境下，包括软硬件平台、某些支持软件、数据和人 员等，在实际运行环境下进行一系列的测试，包括恢复测试、安全测试、强度测试和性能 测试等。\n 验收测试：是指在软件产品完成了系统测试之后、产品发布之前所进行的软件测试活动。 它是技术测试的最后一个阶段，也称为交付测试，确保所开发的软件产品是否符合用户预 期的各项要求。验收测试的重要特征就是用户参与。\n\n 2.软件测试中的评审包括（P19）\n\n 技术评审\n 文档评审\n\n 补充两个：管理评审、流程评审\n\n 3.评审方法（P20）\n\n方法从上到下逐渐正式\n\n 临时评审（最不正式）\n 轮查：邮件分发审查的方法，通过邮件将评审的内容分发下去，然后再收集大家的反馈意见\n 互为复审（同行评审）：一对一相互审查\n 走查（应用最广泛）：评审的对象从头到尾检查一遍。\n 会议审查（最正式）\n\n 4.软件测试中，修正一个错误的代价（P26）\n\n要修正问题，必须重新设计、重新编程和重新测试，代价是不是很大？问题发现得越迟，要重做的事情就会越多，返工量就越大。也就是说，缺陷发现或解决得越迟，其带来的成本就越大。\n\n 5.用户故事要素（P30）\n\n三个要素\n\n 角色：谁要使用这个功能，即确定最终用户角色\n 活动：需要完成什么样的功能\n 商业价值：为什么需要这个功能，这个功能带来什么样的价值\n\n 用户故事通常按如下格式来表达：\n 作为一个<角色，我想要<做什么、活动，以便达到<什么目的、商业价值\n\n 6.修复软件缺陷费用（P26）\n\nhttps://img2.imgtp.com/2024/05/12/H7X03NE2.png\n\n 7.静态测试，动态测试（P9）\n\n 动态测试是通过运行程序来发现软件系统中的问题。这种测试是在程序运行过程中将缺陷发现出来,具有动态性,所以称为动态测试。\n 静态测试主要活动是评审，即通过对需求、设计、配置、程序和其他各类文档的审查来检验相应内容是否满足用户的需求。不需要运行程序，测试对象属于静态的。\n\n 额外内容：\n 黑盒测试有可能是动态测试（运行程序，看输入输出），也有可能是静态测试（不运行，只看界面） \n 白盒测试有可能是动态测试（运行程序并分析代码结构），也有可能是静态测试（不运行程序，只静态察看代码） \n 动态测试有可能是黑盒测试（运行，只看输入输出），也有可能是白盒测试 （运行并分析代码结构） \n 静态测试有可能是黑盒测试（不运行，只察看界面），也有可能是白盒测试（不运行，只察看代码）\n\n 8.驱动程序、桩程序（P85）\n\n 驱动程序（driver ，对底层或子层模块进行单元或集成）测试时所编制的调用被测模块的程序，用以模拟被测模块的上级模块。驱动模块在集成测试中接受测试数据，调用被测模块,并把相关的数据传送给被测模块，然后获得测试结果。当被测模块是底层模块时，如图53中的模块E、F、C和G,需要创建驱动程序。\n\n 桩程序（stub）,也有人称为存根程序，对顶层或上层模块进行测试时，所编制的替代下层模块的程序,用以模拟被测模块工作过程中所调用的模块。桩模块相当于电路中的短路器，使上层模块不需要调用真实模块，就能获得所需要的参数、返回值等。桩模块由被测试模块调用，其内部尽量简单，例如，按照简单条件进行判断,给出返回值，使被测试模块得到它需要得到的值。当被测模块是上层模块时,如图53中的模块A，就需要建立桩程序。\n\nhttps://img2.imgtp.com/2024/05/10/AtaR3jre.png\n\n 9.单元测试中测试用例设计覆盖方法（P86）\n\n 语句覆盖：使得程序中每一条可执行语句至少被执行一次。\n 分支覆盖（判定覆盖）：使得程序中每一个分支都至少被执行一次。（要求判定表达式的值的真假分支都被执行）\n 条件覆盖：程序中每一个条件至少有一次被满足。（要求判定表达式的每个条件的值的真假分支都被执行）\n 路径覆盖：对程序模块的所有独立的基本路径至少要测试一次。\n\n 额外内容：\n\n 条件覆盖跟判定覆盖的区别：\n 举个例子：\n 判定表达式：a  3 and b  0\n 用判定覆盖设计的测试用例:\n a: true, b: true\n a: false,b: false\n  a = 5, b = 1 判定表达式的值为“真”\n  a = 0, b = 1 判定表达式的值为“假”\n 注意：这里并不需要管b的取值，就已经满足判定覆盖的条件了。\n 用条件覆盖设计的测试用例：\n a: true, b: false\n a: ture, b: true\n a: alse, b: false\n a: false, b: true\n  a = 5, b = 1 条件a  3为真， 条件b  0为真\n  a = 5, b = 1 条件a  3为真， 条件b  0为假\n  a = 5, b = 1 条件a  3为假， 条件b  0为真\n  a = 5, b = 1条件a  3为假， 条件b  0为假\n\n 10.移动应用 APP特有的测试（P196）\n\n针对移动App应用测试,除了针对代码的单元测试、系统功能测试之外,侧重考虑下列测试。\n\n 兼容性测试，包括硬件差异、操作系统版本等。\n 交互性测试，不同的操作同时发生，例如微信操作时电话来了。\n 用户体验测试，即用户易用性测试,如横竖切换、触摸、多指触摸、缩放、分页和导航等操作灵活性、局限性。\n 耗电量测试，可以通过仪器来检测,也可以通过判断计算效率是否是最优的来进行评估。\n 网络流量测试，数据传输是否压缩,是否只传输必要的信息?\n 网络连接，在低速无线连接、不同网络间的切换情况下，软件容错性、稳定性如何?在无网络的情况下，App支持离线操作吗?\n 性能测试，在移动设备端，主要通过内存、进程占有CPU资源等分析来完成任务。\n 稳定性测试，移动App闪退问题比较多，如何更好地发现App应用崩溃问题？\n\n 11.缺陷优先级（P235）\n\n 立即解决（P1级）：缺陷导致系统几乎不能运行、使用，或者严重妨碍测试的执行，需立即修正、尽快修正\n 高优先级（P2级）：缺陷严重，影响测试，需要优先考虑修正。例如不超过24小时修正\n 正常排队（P3级）：缺陷需要修正，但可以正常排队等待修正\n 低优先级（P4级）：缺陷可以在开发人有时间的时候被修正，如果没有时间，可以不修正\n\n 额外内容：软件缺陷严重性\n\n  0级（致命）：最严重等级,缺陷导致系统任何一个主要功能完全丧失、用户数据受到破坏、系统崩溃悬挂、死机等 \n  1级（严重）：系统的主要功能部分丧失，数据不能完整保存，系统的次要功能完全丧失，系统所提供的功能或服务受到明显的影响\n  2级（一般）：系统的次要功能没有完全实现，但不影响用户的正常使用。例如提示信息不太准确;或用户界面差、操作时间稍长等问题\n  3级（较小）：操作者不方便或遇到麻烦，但不影响功能的操作和执行,如字体不美观、按钮大小不是很合适、文字排列不对齐等一些小问题\n\n 12.缺陷分析的方法（P242）\n\n从缺陷的层次看，可以分为：\n\n 宏观分析：根据缺陷的总体数据分析，可以了解整体的测试效率、开发人员修正缺陷的效率、测试是否能达到预期的目标。 \n 微观分析：发现测试的漏洞，评估具体模块的代码质量以及具体缺陷描述中所存在的问题。\n\n 额外内容：最常用的缺陷分析方法有4种，分别是缺陷分布报告、缺陷趋势报告、缺陷年龄报告、测试结果进度报告。\n\n 13.软件缺陷的生命周期（P239）\n\nhttps://img2.imgtp.com/2024/05/06/iVxh2EVm.png\n\n简化：打开修正关闭\n\n 14.测试风险分类（P267）\n\n测试风险很多，但可以分为两类——测试对象剖面的风险和测试操作剖面的风险。\n（1）测试对象剖面的风险，即测试对象比较复杂，测试的广度和深度都不够。例如，系统所涉及的业务处理复杂、测试范围没有说明清楚、用户的各种使用场景scenario未被捕捉到、某些例外的测试用例没有想到等。\n（2）测试操作剖面的风险，主要指测试操作过程中存在的各种风险，例如测试环境和真实运行环境差异较大、测试流程不够完善导致测试执行难以控制、回归测试中以风险换时间的策略等。\n\n额外内容：\nhttps://img2.imgtp.com/2024/05/07/59AL8CEr.png\n\n\n 15.测试分析与设计的目标（P40）\n\n目标就是解决“测什么”、“如何测”这两个基本问题，也会引出“什么是测试用例”、“什么是测试脚本”等基本问题。\n\n 16.集成测试策略（P97）\n\n 自顶向下集成策略：从主控模块开始，沿着软件的控制层次向下移动，从而逐渐把各个模块结合起来。在组装过程中，可以使用深度优先或宽度优先的策略。\n 自底向上集成策略：从底层模块开始（即在软件结构最底层的模块）开始，向上推进，不 断进行集成测试的方法。 \n 混合策略：对软件结构中较上层，使用的是\"自顶向下\"法；对软件结构中较下层，使用 的是\"自底向上\"法，两者相结合。\n\n 17.负载测试，压力测试，性能测试（P157）\n\n 负载测试是通过模拟实际软件系统所承受的负载条件、改变系统负载大小和负载方式来发现系统中所存在的问题。例如，逐渐增加模拟用户的数量来观察系统的响应时间和数据吞吐量、系统占用的资源（如CPU、内存）等，以检验系统的行为和特性，发现系统可能存在的性能瓶颈、内存泄漏、不能实时回步寺问题。贝我测A文地以为性能测试、压力测试所采用。\n 压力测试是在强负载情况下（如大数据量、大量并发用户连接等）对稳定性进行测试，查看应用系统在峰值（瞬间使用高峰使用情况下的行为表现;更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等，确认系统是否具有良好的容错能力和可恢复能力。压力测试分为高负载下的长时间（如24小时以上的稳定性压力测试和极限负载情况下导致系统崩溃的破坏性压力测试。\n 性能测试是为获取或验证系统性能指标而进行的测试。性能测试，目的明确，事先有明确的性能指标，并要求在严格的测试环境和所定义的测试负载情况下进行,获得在不同的负载情况下的性能指标数据。性能测试使用负载测试的技术、工具以及用不同的负载水平来度量性能指标和建立性能基准。\n\n 18.测试用例的元素（P47）\n\n5W1H\n\n Why\n What\n Where\n When\n Which\n How\n\n 没有Who\n\nhttps://img2.imgtp.com/2024/05/11/aYmCiie1.png\n\n 19.功能测试用例的设计方法（P120）\n\n 等价类划分法\n   有效等价类1640，无效等价类40,<16\n   使用该方法设计测试用例的步骤：（1）数据分类，分出有效等价类和无效等价类（2）针对有效等价类，进一步进行分割，直到不能划分为止，形成等价类表，为每一等价类规定一个唯一的编号（3）就每一个具体的等价类，设计一个测试用例，直到所有有效等价类均被测试用例所覆盖（4）对无效等价类进行相同的处理\n 边界值分析法\n 循环结构测试的综合方法\n 因果图法\n 决策表方法\n 功能图法\n 正交试验设计方法\n\n 额外内容：\n 黑盒测试方法（blakebox testing，是把程序看作一个不能打开的黑盒子，如图51所示，不考虑程序内部结构和内部特性，而是考察数据的输入、条件限制和数据输出，完成测试。\n 白盒测试方法（ whitebox testing ，也称结构测试或逻辑驱动测试。白盒测试方法是根据模块内部结构了解，基于内部逻辑结构，针对程序语句、路径、变量状态等来进行测试，如图52所示，检验程序中的各个分支条件是否得到满足，每条执行路径是否按预定要求正确地工作\n\n \n\n 黑盒测试方法的具体方法：等价类划分方法、边界值分析、因果分析、决策表方法、正交实验设计方法等。  19.功能测试用例的设计方法\n 白盒测试的主要方法：逻辑覆盖、分支覆盖、条件组合覆盖、基本路径测试等。  9.单元测试中测试用例设计覆盖方法\n\n 20.设计评审的难点（作业题）\n\n设计评审的难点主要集中在以下几个方面：\n（1）设计目标的理解：设计评审需要确保设计符合规定的目标，但有时设计者可能对目标理解不透彻，导致设计方案与实际需求不符。\n（2）设计方案的选择：在设计评审中，需要从多个设计方案中选择最优的方案，但有时设计者可能无法准确评估各个方案的优缺点，导致选择不当。\n（3）设计的实际可行性：设计评审需要评估设计的适宜性、充分性、有效性和效率，但有时设计者可能无法预测设计在实际应用中的表现，导致方案不可行。\n（4）设计的可持续性：设计评审需要考虑设计对环境、资源和经济的影响，但有时设计者可能只关注当前的需求，而忽视了设计的长期影响。\n（5）设计的创新性：设计评审需要鼓励创新的设计思路，但有时设计者可能过于追求创新，而忽视了设计的实际性和可用性。\n   因此，设计评审需要综合考虑以上难点，确保设计方案符合实际需求，具备可持续性和创新性，同时满足规定的目标。\n\n 21.软件测试的目的（P255）\n\n在开发周期内，尽可能早地发现最严重的缺陷\n\n 额外内容：\n 测试目的:（1）证明：获取系统在可接受风险范围内可用的信心;尝试在非正常情况和条件下的功能和特性;保证一个工作产品是完整的并且可用或可被集成。（2）检测：发现缺陷、错误和系统不足;定义系统的能力和局限性;提供组件、工作产品和系统的质量信息。3）预防：澄清系统的规格和性能;提供预防或减少可能制造错误的信息;在过程中尽早检测错误;确认问题和风险，并且提前确认解决这些问题和风险的途径。\n\n 22.测试最低目标，基本目标（P255）\n\n 最低目的：正常的输入+正常的处理过程，有一个正确的输出\n 基本目的：对异常的输入有错误的捕获，并进行相应提示或者屏蔽\n\n 额外内容：\n 较高目的：对隐式需求进行测试\n\n 23.软件质量概念\n\n概括地说，软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。从管理角度对软件质量进行度量，可将影响软件质量的主要因素划分为三组，分别反应用户在使用软件产品时的三种不同倾向或观点：产品运行正确性、健壮性、效率、完整性、可用性、风险;产品修改可理解性、可维修性、灵活性、可测试性;产品转移可移植性、可再用性、互运行性。\n\n 软件质量特性是指软件的功能性、可靠性、易用性、效率、可维护性、可移植性  \n\n 24.软件测试中的V&V模型（P8）\n\n软件测试中的V&V模型分别代表验证和有效性确认\n\n验证：是否正确地构造了软件？即是否正确地做事，验证开发过程是否遵守已定义好的内容。验证产品满足规格设计说明书的一致性。\n\n有效性确认：是否构造了正是用户所需要的软件？即是否正在做正确的事。验证产品所实现的功能是否满足用户的需求。\n\n 25.向前兼容，向后兼容（P182）\n\n 向后兼容是指新发布的软件版本可以使用该软件的以前版本所产生的数据;\n 向前兼容是指在设计和开发软件一个新版本时，考虑如何和未来版本的数据兼容。\n\n 额外内容：\n 数据向后兼容测试是必不可少的，而数据向前兼容测试是可选的，一般是不需要的\n\n 26.自动化测试的五种技术原理（P65）\n\n 代码分析  \n GUI 对象识别  \n DOM 对象识别  \n 自动比较技术  \n 脚本技术 \n\n 27.软件测试的原则（P250）\n\n 尽早和不断地测试\n 重点测试\n 测试阶段性\n 测试独立性\n 测试客观性\n 计划是一个过程\n 测试开发的一部分\n 发现缺陷更多的地方，其风险越大\n 想用户所想\n\n 28.软件测试中控制风险的对策（P268）\n\n 消除执行风险：通过系统复审、测试人员之间互审、测试人员在不同的测试模块上相互调换、自动化测试和抽查等方法,及时发现问题，并产生震慑作用，确保测试用例被100%执行。\n 降低进度风险：进行测试资源、时间等估算时,要留有余地,增加10%的空间，以降低测试资源可能不足的风险。\n 减少人员风险：对每个关键性技术人员培养后备人员，做好不同领域知识的培训，从而确保人员一旦离开公司,项目不会受到严重影响。\n\n 29.因果图\n\n一个程序规格说明要求如下：输入第一个字符必须是  或  ,第二个字符必须是一个数字，在此情况可对文件修改；若第一个字符非  或  ,则程序给出信息N，若第二个字符非数字，则程序给出信息M，试用因果图法设计该程序测试用例。\n\nwrite by LiZhengXuehttps://img2.imgtp.com/2024/05/14/5JfXIPV7.png\n"},{"filename":"14th-lqb-B-1","category":"aigorithm","md":{"topSummary":"\ntitle: 第十四届蓝桥杯B组国赛\ncategory: 算法\ndate: 2024-05-05\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 子2023\n\n有两种方法，一种暴力枚举，一种动态规划\n\n暴力枚举：需要等一两分钟\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str = \"\";\n\tfor(int i = 1; i <= 2023; i++){\n\t\tstring ss = to_string(i);\n\t\tfor(int j = 0 ; j < ss.size(); j++){\n\t\t\tif(ss[j] == '2' || ss[j] == '0' || ss[j] == '3'){\n\t\t\t\tstr += ss[j];\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size();\n\tll res = 0;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] != '2') continue;\n\t\tfor(int j = i + 1; j < len; j ++){\n\t\t\tif(str[j] != '0') continue;\n\t\t\tfor(int z = j + 1; z < len; z ++){\n\t\t\t\tif(str[z] != '2') continue;\n\t\t\t\tfor(int x = z + 1; x < len; x ++){\n\t\t\t\t\tif(str[x] != '3') continue;\n\t\t\t\t\tif(str[i] == '2' && str[j] == '0' && str[z] == '2' && str[x] == '3'){\n\t\t\t\t\t\tres ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n动态规划\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\nll dp[5];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str = \"\";\n\tfor(int i = 1; i <= 2023; i++){\n\t\tstring ss = to_string(i);\n\t\tfor(int j = 0 ; j < ss.size(); j++){\n\t\t\tif(ss[j] == '2' || ss[j] == '0' || ss[j] == '3'){\n\t\t\t\tstr += ss[j];\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size();\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == '2'){\n\t\t\tdp[1] ++;\n\t\t\tdp[3] += dp[2]; \n\t\t} else if(str[i] == '0'){\n\t\t\tdp[2] += dp[1];\n\t\t} else if(str[i] == '3'){\n\t\t\tdp[4] += dp[3]; \n\t\t}\n\t}\n\tcout << dp[4] << endl;\n\t\n\treturn 0;\n}\n```\n\n\n\n## 班级活动\n\n本题需要注意一下几点：\n\n- 重复学生数量小于没有重复的数量\n- 重复学生数量大于没有重复数量，且重复数量为偶数\n- 重复学生数量大于没有重复数量，且重复数量为奇数\n\n```c++\n#include<bits/stdc++.h>a\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tunordered_map<int, int> ump;\n\tint idx = 0, idx2 = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tint num;\n\t\tcin >> num;\n\t\tump[num] ++;\n\t\tif(ump[num] == 2){\n\t\t\tidx ++;\n\t\t} else if(ump[num] > 2){\n\t\t\tidx2 ++;\n\t\t}\n\t}\n\tint cc = a - idx * 2 - idx2;\n\tif(cc >= idx2){\n\t\tcout << idx2 + (cc - idx2) / 2 << endl;\n\t} else {\n\t\tcout << idx2 << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## 合并数列\n\n双指针，一个指向A数组最左边，一个指向B数组最左边，同时向右移动。遇到一致的跳过，不一致的停下来只让该一个指针移动直到相同为止\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<int> v1(a), v2(b);\n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v1[i];\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tcin >> v2[i];\n\t}\n\tint idx1 = 0, idx2 = 0, res = 0;\n\twhile(idx1 < a){\n\t\tint num1 = v1[idx1], num2 = v2[idx2];\n\t\twhile(num1 != num2){\n\t\t\tif(num1 > num2){\n\t\t\t\tidx2 ++;\n\t\t\t\tnum2 += v2[idx2];\n\t\t\t} else {\n\t\t\t\tidx1 ++;\n\t\t\t\tnum1 += v1[idx1];\n\t\t\t}\n\t\t\tres ++;\n\t\t}\n\t\tidx1 ++;\n\t\tidx2 ++;\n\t}\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n```\n\n## AB路线\n\nBFS模板题，注意以下测试数据\n\n```\n2 2 10\nAA\nAB\n```\n答案为10\n这题需要标记 **走过且走的次数的点**，走过的点只要次数不一致还可以再次走，所以需要用到三维数组st来标记\n\n```cpp\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res = -1;\nchar n[1010][1010];\nint st[1010][1010][12];\n\nstruct p{\n\tint x, y, cot, cc;\n};\n\nvoid bfs(int k){\n\t\n\tqueue<p> q;\n\tq.push({0, 0, 1, 0});\n\tst[0][0][1] = 1;\n\twhile(!q.empty()){\n\t\tauto top = q.front();\n\t\tq.pop();\n\t\tint x = top.x, y = top.y, cot = top.cot, cc = top.cc;\n\t\tif(x == a - 1 && y == b - 1){\n\t\t\tres = cc;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + ix[i], yy = y + iy[i];\n\t\t\tif(xx >= 0 && xx < a && yy >= 0 && yy < b){\n\t\t\t\tif(cot == k){\n\t\t\t\t\tif(n[x][y] == n[xx][yy] || st[xx][yy][1]) continue;\n\t\t\t\t\tst[xx][yy][1] = 1;\n\t\t\t\t\tq.push({xx, yy, 1, cc + 1});\n\t\t\t\t} else if(n[xx][yy] == n[x][y]){\n\t\t\t\t\tif(st[xx][yy][cot + 1]) continue;\n\t\t\t\t\tst[xx][yy][cot + 1] = 1;\n\t\t\t\t\tq.push({xx, yy, cot + 1, cc + 1});\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\t\n\t\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b >> x;\n\tfor(int i = 0; i < a; i++){\n\t\tfor(int j = 0; j < b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tbfs(x);\n\tcout << res << endl;\t\n\t\n\treturn 0;\n}\n```\n\n## 抓娃娃\n\n用前缀和的思想来做\n\n根据给出的线段的两个点，求出中点，在求助中点数组的前缀和\n\n注意：因为 l，r两个点相加除2后可能出现小数，所以这里需要变通一下改为乘2\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 2e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++){\n\t\tcin >> x >> y;\n\t\tn[x + y] ++;\n\t}\n\tfor(int i = 0; i <= N; i++){\n\t\tn[i] += n[i - 1];\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tcin >> x >> y;\n\t\tcout << n[2 * y] - n[x * 2 - 1] << endl;\n\t}\n\t\n\treturn 0;\n} \n```\n\n\n\n","title":" 第十四届蓝桥杯B组国赛\n","category":[" 算法\n"],"date":" 2024-05-05\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 子2023\n\n有两种方法，一种暴力枚举，一种动态规划\n\n暴力枚举：需要等一两分钟\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str = \"\";\n\tforint i = 1; i <= 2023; i++{\n\t\tstring ss = tostringi;\n\t\tforint j = 0 ; j < ss.size; j++{\n\t\t\tifssj == '2'  ssj == '0'  ssj == '3'{\n\t\t\t\tstr += ssj;\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size;\n\tll res = 0;\n\tforint i = 0; i < len; i++{\n\t\tifstri = '2' continue;\n\t\tforint j = i + 1; j < len; j ++{\n\t\t\tifstrj = '0' continue;\n\t\t\tforint z = j + 1; z < len; z ++{\n\t\t\t\tifstrz = '2' continue;\n\t\t\t\tforint x = z + 1; x < len; x ++{\n\t\t\t\t\tifstrx = '3' continue;\n\t\t\t\t\tifstri == '2' && strj == '0' && strz == '2' && strx == '3'{\n\t\t\t\t\t\tres ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n动态规划\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\nll dp5;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str = \"\";\n\tforint i = 1; i <= 2023; i++{\n\t\tstring ss = tostringi;\n\t\tforint j = 0 ; j < ss.size; j++{\n\t\t\tifssj == '2'  ssj == '0'  ssj == '3'{\n\t\t\t\tstr += ssj;\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size;\n\tforint i = 0; i < len; i++{\n\t\tifstri == '2'{\n\t\t\tdp1 ++;\n\t\t\tdp3 += dp2; \n\t\t} else ifstri == '0'{\n\t\t\tdp2 += dp1;\n\t\t} else ifstri == '3'{\n\t\t\tdp4 += dp3; \n\t\t}\n\t}\n\tcout << dp4 << endl;\n\t\n\treturn 0;\n}\n\n\n\n\n 班级活动\n\n本题需要注意一下几点：\n\n 重复学生数量小于没有重复的数量\n 重复学生数量大于没有重复数量，且重复数量为偶数\n 重复学生数量大于没有重复数量，且重复数量为奇数\n\nc++\ninclude<bits/stdc++.ha\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tunorderedmap<int, int ump;\n\tint idx = 0, idx2 = 0;\n\tforint i = 0; i < a; i++{\n\t\tint num;\n\t\tcin  num;\n\t\tumpnum ++;\n\t\tifumpnum == 2{\n\t\t\tidx ++;\n\t\t} else ifumpnum  2{\n\t\t\tidx2 ++;\n\t\t}\n\t}\n\tint cc = a  idx  2  idx2;\n\tifcc = idx2{\n\t\tcout << idx2 + cc  idx2 / 2 << endl;\n\t} else {\n\t\tcout << idx2 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n 合并数列\n\n双指针，一个指向A数组最左边，一个指向B数组最左边，同时向右移动。遇到一致的跳过，不一致的停下来只让该一个指针移动直到相同为止\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<int v1a, v2b;\n\tforint i = 0; i < a; i++{\n\t\tcin  v1i;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tcin  v2i;\n\t}\n\tint idx1 = 0, idx2 = 0, res = 0;\n\twhileidx1 < a{\n\t\tint num1 = v1idx1, num2 = v2idx2;\n\t\twhilenum1 = num2{\n\t\t\tifnum1  num2{\n\t\t\t\tidx2 ++;\n\t\t\t\tnum2 += v2idx2;\n\t\t\t} else {\n\t\t\t\tidx1 ++;\n\t\t\t\tnum1 += v1idx1;\n\t\t\t}\n\t\t\tres ++;\n\t\t}\n\t\tidx1 ++;\n\t\tidx2 ++;\n\t}\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n\n\n AB路线\n\nBFS模板题，注意以下测试数据\n\n\n2 2 10\nAA\nAB\n\n答案为10\n这题需要标记 走过且走的次数的点，走过的点只要次数不一致还可以再次走，所以需要用到三维数组st来标记\n\ncpp\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res = 1;\nchar n10101010;\nint st1010101012;\n\nstruct p{\n\tint x, y, cot, cc;\n};\n\nvoid bfsint k{\n\t\n\tqueue<p q;\n\tq.push{0, 0, 1, 0};\n\tst001 = 1;\n\twhileq.empty{\n\t\tauto top = q.front;\n\t\tq.pop;\n\t\tint x = top.x, y = top.y, cot = top.cot, cc = top.cc;\n\t\tifx == a  1 && y == b  1{\n\t\t\tres = cc;\n\t\t\tbreak;\n\t\t}\n\t\tforint i = 0; i < 4; i++{\n\t\t\tint xx = x + ixi, yy = y + iyi;\n\t\t\tifxx = 0 && xx < a && yy = 0 && yy < b{\n\t\t\t\tifcot == k{\n\t\t\t\t\tifnxy == nxxyy  stxxyy1 continue;\n\t\t\t\t\tstxxyy1 = 1;\n\t\t\t\t\tq.push{xx, yy, 1, cc + 1};\n\t\t\t\t} else ifnxxyy == nxy{\n\t\t\t\t\tifstxxyycot + 1 continue;\n\t\t\t\t\tstxxyycot + 1 = 1;\n\t\t\t\t\tq.push{xx, yy, cot + 1, cc + 1};\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\t\n\t\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b  x;\n\tforint i = 0; i < a; i++{\n\t\tforint j = 0; j < b; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\n\tbfsx;\n\tcout << res << endl;\t\n\t\n\treturn 0;\n}\n\n\n 抓娃娃\n\n用前缀和的思想来做\n\n根据给出的线段的两个点，求出中点，在求助中点数组的前缀和\n\n注意：因为 l，r两个点相加除2后可能出现小数，所以这里需要变通一下改为乘2\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 2e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tforint i = 0; i < a; i++{\n\t\tcin  x  y;\n\t\tnx + y ++;\n\t}\n\tforint i = 0; i <= N; i++{\n\t\tni += ni  1;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tcin  x  y;\n\t\tcout << n2  y  nx  2  1 << endl;\n\t}\n\t\n\treturn 0;\n} \n\n\n\n\n"},{"filename":"leetcode-week-396","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第396场周赛\ncategory: 算法\ndate: 2024-05-05\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本次比赛WA嘛了，最后3分钟把第三题解了，一直错本来都打算放弃了，突然就给我对了。\n\n字符串这方面还是太弱了，本场基本都是字符串的题目.....\n\n## 有效单词\n\n签到题，如果数组元素较多的的化建议用循环做\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string word) {\n        int len = word.size();\n        if(len < 3){\n            return false;\n        }\n        int f1 = 0, f2 = 0;\n        for(int i = 0; i < len; i++){\n            char c = word[i];\n            if(c == 'a' || c == 'e' || c == 'i' || c =='o' || c == 'u' ||\n              c == 'A' || c == 'E' || c == 'I' || c =='O' || c == 'U' ){\n                f1 = 1;\n            } else {\n                if(c >= 'a' && c <= 'z' || c >= '0' && c <= '9' || c >= 'A' && c <= 'Z'){\n                    if(c >= 'a' && c <= 'z' ||  c >= 'A' && c <= 'Z'){\n                         f2 = 1;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        if(f1 && f2) return true;\n        else return false;\n    }\n};\n```\n\n## K 周期字符串需要的最少操作次数\n\n一开始没读懂题目，后面发现不必要考虑两个字符串相隔的位置\n\n```c++\nclass Solution {\npublic:\n    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int len = word.size(), maxlen = 0, cot = 0, idx = 0;\n        string mstr = \"\";\n        unordered_map<string, int> ump;\n        for(int i = 0;  i < len; i++){\n            string ss = word.substr(i, k);\n            ump[ss] ++;\n            if(ump[ss] > maxlen){\n                maxlen = ump[ss];\n                mstr = ss;\n            }\n            i += k - 1;\n        }\n        idx = 0;\n        for(int i = 0;  i < len; i++){\n            string ss = word.substr(i, k);\n            if(ss == mstr){\n                cot ++;\n            }\n            i += k - 1;\n        }\n        return (len - cot * k) / k;\n    }\n};\n```\n\n## 同位字符串连接的最小长度\n\n通过求出每个元素的个数，然后求出所有个数的最大公约数来判断可以分为多少组，从而求出每组的个数\n\n个人感觉这题的数据量不是很多，我这个思路遇多多少少是有点问题的\n\n```c++\nclass Solution {\npublic:\n    int fun(int x, int y){\n        return y == 0? x : fun(y, x % y);\n    }\n    int minAnagramLength(string s) {\n        set<char> ss;\n        int len = s.size();\n        unordered_map<char, int> ump;\n        int cot = INT_MAX, f = 0, cot2 = 0, bf = 0;\n        for(int i = 0; i < len; i++){\n            ump[s[i]] ++;\n        }\n        for(auto item : ump){\n            if(bf == 0){\n                bf = item.second;\n            } else {\n                cot = min(cot, fun(bf, item.second));\n                bf = item.second;\n            }\n        }\n\n        return cot != INT_MAX ? len / cot: len / bf;\n    }\n};\n```\n\n## 使数组中所有元素相等的最小开销\n\n待补充\n","title":" Leetcode第396场周赛\n","category":[" 算法\n"],"date":" 2024-05-05\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n本次比赛WA嘛了，最后3分钟把第三题解了，一直错本来都打算放弃了，突然就给我对了。\n\n字符串这方面还是太弱了，本场基本都是字符串的题目.....\n\n 有效单词\n\n签到题，如果数组元素较多的的化建议用循环做\n\nc++\nclass Solution {\npublic:\n    bool isValidstring word {\n        int len = word.size;\n        iflen < 3{\n            return false;\n        }\n        int f1 = 0, f2 = 0;\n        forint i = 0; i < len; i++{\n            char c = wordi;\n            ifc == 'a'  c == 'e'  c == 'i'  c =='o'  c == 'u' \n              c == 'A'  c == 'E'  c == 'I'  c =='O'  c == 'U' {\n                f1 = 1;\n            } else {\n                ifc = 'a' && c <= 'z'  c = '0' && c <= '9'  c = 'A' && c <= 'Z'{\n                    ifc = 'a' && c <= 'z'   c = 'A' && c <= 'Z'{\n                         f2 = 1;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        iff1 && f2 return true;\n        else return false;\n    }\n};\n\n\n K 周期字符串需要的最少操作次数\n\n一开始没读懂题目，后面发现不必要考虑两个字符串相隔的位置\n\nc++\nclass Solution {\npublic:\n    int minimumOperationsToMakeKPeriodicstring word, int k {\n        int len = word.size, maxlen = 0, cot = 0, idx = 0;\n        string mstr = \"\";\n        unorderedmap<string, int ump;\n        forint i = 0;  i < len; i++{\n            string ss = word.substri, k;\n            umpss ++;\n            ifumpss  maxlen{\n                maxlen = umpss;\n                mstr = ss;\n            }\n            i += k  1;\n        }\n        idx = 0;\n        forint i = 0;  i < len; i++{\n            string ss = word.substri, k;\n            ifss == mstr{\n                cot ++;\n            }\n            i += k  1;\n        }\n        return len  cot  k / k;\n    }\n};\n\n\n 同位字符串连接的最小长度\n\n通过求出每个元素的个数，然后求出所有个数的最大公约数来判断可以分为多少组，从而求出每组的个数\n\n个人感觉这题的数据量不是很多，我这个思路遇多多少少是有点问题的\n\nc++\nclass Solution {\npublic:\n    int funint x, int y{\n        return y == 0? x : funy, x % y;\n    }\n    int minAnagramLengthstring s {\n        set<char ss;\n        int len = s.size;\n        unorderedmap<char, int ump;\n        int cot = INTMAX, f = 0, cot2 = 0, bf = 0;\n        forint i = 0; i < len; i++{\n            umpsi ++;\n        }\n        forauto item : ump{\n            ifbf == 0{\n                bf = item.second;\n            } else {\n                cot = mincot, funbf, item.second;\n                bf = item.second;\n            }\n        }\n\n        return cot = INTMAX ? len / cot: len / bf;\n    }\n};\n\n\n 使数组中所有元素相等的最小开销\n\n待补充\n"},{"filename":"nowcoder-month-92","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛92\ncategory: 算法\ndate: 2024-05-04\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本次算法赛主题是MC，一下就来兴趣了\n\n## 获得木头\n\n签到题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tcout << a * 8 << endl;\t\n   \n\treturn 0;\n}\n```\n\n## 采矿时间到！\n\nwa了一次，这题坑点在于会有一种这样的情况\n\n```\n#################*##\n#########*##########\n....................\n#####*######**######\n#*##########*#######\n```\n\n最外层和最内层都有矿石，此时就只需要消耗2体力就能够挖到两个矿石\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n char v[1010][1010];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint idx = 0;\n\tcin >> a >> b;\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> v[i][j];\n\t\t\tif(v[i][j] == '*') idx ++;\n\t\t}\n\t}\n\tint cot = 0, res = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tif(v[1][i] == '*') cot ++;\n\t\tif(v[3][i] == '*') cot ++; \n\t} \n\tif(cot > b){\n\t\tcout << b << endl;\n\t\treturn 0; \n\t}\n\tint cc = (b - cot) / 2;\n\tcout << min(cc, idx - cot) + cot << endl;\n\treturn 0;\n}\n```\n\n## 耕种时间到！\n\n这题是个模拟题，很容易想到模拟的过程\n\n我在赛时把分解的过程直接化了，简单的想成了小麦种子的数量为`收割次数总次数 * 2`，正解是`pow(2, 收割次数总次数 )`\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint idx = 0;\n\tcin >> a;\n\tvector<int> v(a);\n\tunordered_map<int, ll> m; \n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v[i];\n\t}\n\tcin >> b;\n\tfor(int i = 0; i < a; i++){\n\t\tll idx = 0, cnt = 1;\n\t\twhile(v[i] > b){\n\t\t\tv[i] = ceil(v[i] * 1.0 / 3);\n\t\t\tidx ++;\n\t\t\tcnt *= 2;\n\t\t}\n\t\tif(v[i] == b){\n\t\t\tm[idx] += cnt;\n\t\t}\n\t}\n\tll res = 0;\n\tfor(auto i: m){\n\t\tres = max(res, i.second);\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n## 探索的时光\n\n这题我想了很多思考思路：\n\n- 前缀和\n\n- dp\n- 推公式，找规律\n\n但是都没法实现，问题就出在了推公式，吃了没文化的亏。正解也是推公式，我遇到求和符合就卡了，不知道怎么化简\n\n最终推出来的结论：（@为+号）\n\n![](https://img2.imgtp.com/2024/05/04/ycrX8KeI.png)\n\n你以为这就结束了？这题还需要注意坑点是数据范围！！！\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a + 1);\n\tll all = 0, all2 = 0, all3 = 0, res = 0x3f3f3f3f3f3f3f3f;\n\tfor(ll i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tall += v[i];\n\t\tall2 += i * v[i];\n\t\tall3 += i * i * v[i];\n\t}\n\tfor(ll i = 1; i <= a; i++){\n\t\tres = min(res, i * i * all + all3 - 2 * i * all2);\n\t}\n\n\tcout << res << endl; \n\t\n\t\n\treturn 0;\n}\n```\n\n## 来硬的\n\n背包问题\n\n首先从数据范围上很容易看出是DP问题，需要双循环更新\n\n~~其次我知道它是DP，但我设计不出来状态转移方程，淦~~\n\n设计状态：`dp[i][j][0/1]` 表示前i个煤炭，获得j个矿石的最短时间，0/1表示是否使用过魔法\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nstruct p{\n\tint x, y;\n}n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<vector<vector<ll>>> dp(a + 1, vector<vector<ll>>(b + 1, vector<ll>(2, 0x3f3f3f3f3f3f3f3f)));\n\tdp[0][0][0] = 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> n[i].x >> n[i].y;\n\t}\n\tfor(int i = 1;  i <= a; i++){\n\t\tfor(int j = 0; j <= b; j++){\n\t\t\tdp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][max(j - n[i].x, 0)][0] + n[i].y);\n\t\t\tdp[i][j][1] = min({dp[i - 1][j][1], dp[i - 1][max(j - n[i].x * 2, 0)][0] + n[i].y / 2, dp[i - 1][max(j - n[i].x, 0)][1] + n[i].y});\n\t\t} \n\t}\n\t\n\tcout << min(dp[a][b][1], dp[a][b][0]) << endl;\t\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛92\n","category":[" 算法\n"],"date":" 2024-05-04\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n本次算法赛主题是MC，一下就来兴趣了\n\n 获得木头\n\n签到题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tcout << a  8 << endl;\t\n   \n\treturn 0;\n}\n\n\n 采矿时间到！\n\nwa了一次，这题坑点在于会有一种这样的情况\n\n\n\n\n....................\n\n\n\n\n最外层和最内层都有矿石，此时就只需要消耗2体力就能够挖到两个矿石\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n char v10101010;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint idx = 0;\n\tcin  a  b;\n\tforint i = 0; i < 5; i++{\n\t\tforint j = 0; j < a; j++{\n\t\t\tcin  vij;\n\t\t\tifvij == '' idx ++;\n\t\t}\n\t}\n\tint cot = 0, res = 0;\n\tforint i = 0; i < a; i++{\n\t\tifv1i == '' cot ++;\n\t\tifv3i == '' cot ++; \n\t} \n\tifcot  b{\n\t\tcout << b << endl;\n\t\treturn 0; \n\t}\n\tint cc = b  cot / 2;\n\tcout << mincc, idx  cot + cot << endl;\n\treturn 0;\n}\n\n\n 耕种时间到！\n\n这题是个模拟题，很容易想到模拟的过程\n\n我在赛时把分解的过程直接化了，简单的想成了小麦种子的数量为收割次数总次数  2，正解是pow2, 收割次数总次数 \n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint idx = 0;\n\tcin  a;\n\tvector<int va;\n\tunorderedmap<int, ll m; \n\tforint i = 0; i < a; i++{\n\t\tcin  vi;\n\t}\n\tcin  b;\n\tforint i = 0; i < a; i++{\n\t\tll idx = 0, cnt = 1;\n\t\twhilevi  b{\n\t\t\tvi = ceilvi  1.0 / 3;\n\t\t\tidx ++;\n\t\t\tcnt = 2;\n\t\t}\n\t\tifvi == b{\n\t\t\tmidx += cnt;\n\t\t}\n\t}\n\tll res = 0;\n\tforauto i: m{\n\t\tres = maxres, i.second;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n 探索的时光\n\n这题我想了很多思考思路：\n\n 前缀和\n\n dp\n 推公式，找规律\n\n但是都没法实现，问题就出在了推公式，吃了没文化的亏。正解也是推公式，我遇到求和符合就卡了，不知道怎么化简\n\n最终推出来的结论：（@为+号）\n\nhttps://img2.imgtp.com/2024/05/04/ycrX8KeI.png\n\n你以为这就结束了？这题还需要注意坑点是数据范围！！！\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<int va + 1;\n\tll all = 0, all2 = 0, all3 = 0, res = 0x3f3f3f3f3f3f3f3f;\n\tforll i = 1; i <= a; i++{\n\t\tcin  vi;\n\t\tall += vi;\n\t\tall2 += i  vi;\n\t\tall3 += i  i  vi;\n\t}\n\tforll i = 1; i <= a; i++{\n\t\tres = minres, i  i  all + all3  2  i  all2;\n\t}\n\n\tcout << res << endl; \n\t\n\t\n\treturn 0;\n}\n\n\n 来硬的\n\n背包问题\n\n首先从数据范围上很容易看出是DP问题，需要双循环更新\n\n其次我知道它是DP，但我设计不出来状态转移方程，淦\n\n设计状态：dpij0/1 表示前i个煤炭，获得j个矿石的最短时间，0/1表示是否使用过魔法\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nstruct p{\n\tint x, y;\n}nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<vector<vector<ll dpa + 1, vector<vector<llb + 1, vector<ll2, 0x3f3f3f3f3f3f3f3f;\n\tdp000 = 0;\n\tforint i = 1; i <= a; i++{\n\t\tcin  ni.x  ni.y;\n\t}\n\tforint i = 1;  i <= a; i++{\n\t\tforint j = 0; j <= b; j++{\n\t\t\tdpij0 = mindpi  1j0, dpi  1maxj  ni.x, 00 + ni.y;\n\t\t\tdpij1 = min{dpi  1j1, dpi  1maxj  ni.x  2, 00 + ni.y / 2, dpi  1maxj  ni.x, 01 + ni.y};\n\t\t} \n\t}\n\t\n\tcout << mindpab1, dpab0 << endl;\t\n\t\n\treturn 0;\n}\n\n\n"},{"filename":"leetcode-week-128","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第128场双周赛\ncategory: 算法\ndate: 2024-05-01\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n今日刷哔哩哔哩小羊肖恩大神10分钟都没到就AK了本场比赛，于是就想来试着做下\n\n### 字符串的分数\n\n求相邻字母的ASCALL码值之和\n\n```c++\nclass Solution {\npublic:\n    int scoreOfString(string s) {\n        int res = 0;\n        for(int i = 1; i < s.size(); i++){\n            res += fabs(s[i] - s[i - 1]);\n        }\n        return res;\n    }\n};\n```\n\n### 覆盖所有点的最少矩形数目\n\n一眼贪心，只用考虑横坐标\n\n```c++\\\nclass Solution {\npublic:\n    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        int cot = 0, res = 0;\n        vector<int> v;\n        for(int i = 0; i < points.size(); i++){\n            v.push_back(points[i][0]);\n        }\n        int len = v.size();\n        sort(v.begin(), v.end());\n        cot = -1e9 - 10;\n        for(int i = 0; i < len; i++){\n            if(v[i] - cot > w){\n                cot = v[i];\n                res ++;\n            }\n        }\n        return res;\n\n    }\n};\n```\n\n### 访问消失节点的最少时间\n\nDjakarta模板题，这里提供两种做法，一种参考灵神的，一种是yxc模板的。\n\n参考灵神做法\n\n```c++\nclass Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        vector<vector<pair<int, int>>> g(n);\n        for(int i = 0; i < edges.size(); i++){\n            g[edges[i][0]].push_back({edges[i][1], edges[i][2]});\n            g[edges[i][1]].push_back({edges[i][0], edges[i][2]});\n        }\n\n        vector<int> dis(n, 0x3f3f3f3f);\n        vector<bool> st(n ,false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dis[0] = 0;\n        pq.push({0, 0});\n        while(!pq.empty()){\n            auto [len, xx] = pq.top();\n            pq.pop();\n            if(st[xx]) continue;\n            st[xx] = 1;\n            for(auto [_ne, _w] : g[xx]){\n                if(dis[_ne] > len + _w  && len + _w < disappear[_ne]){\n                    dis[_ne] = len + _w;\n                    pq.push({dis[_ne], _ne});\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(dis[i] == 0x3f3f3f3f) dis[i] = -1;\n        }\n       \n        return dis;\n    }\n};\n```\n\nyxc模板做法\n\n```c++\nconst int N = 1e6 + 10;\nclass Solution {\npublic:\n    int n[N], ne[N], w[N], h[N], dis[N], st[N], idx;\n    void dj(vector<int>& disappear){\n        memset(dis, 0x3f3f3f3f, sizeof dis);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dis[0] = 0;\n        pq.push({0, 0});\n        while(pq.size()){\n            auto top = pq.top();\n            pq.pop();\n            int yy = top.first, xx = top.second;\n            if(st[xx]) continue;\n            st[xx] = 1;\n            for(int i = h[xx]; i != -1; i = ne[i]){\n                int j = n[i];\n                if(dis[j] > yy + w[i] && yy + w[i] < disappear[j]){\n                    dis[j] = yy + w[i];\n                    pq.push({dis[j], j});\n                }\n            }\n        }\n    }\n    void add(int x, int y, int z){\n        n[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++;\n    }\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        memset(h, -1, sizeof h);\n        for(int i = 0; i < edges.size(); i++){\n            add(edges[i][0], edges[i][1], edges[i][2]);\n            add(edges[i][1], edges[i][0], edges[i][2]);\n        }\n        dj(disappear);\n        vector<int> res;\n        for(int i = 0; i < n; i ++){\n            res.push_back((dis[i] ==  0x3f3f3f3f ? -1 : dis[i]));\n        }\n       \n        return res;\n    }\n};\n```\n\n### 边界元素是最大值的子数组数目\n\n这题只要想到单调栈就很好做啦\n\n```c++\nclass Solution {\npublic:\n    long long numberOfSubarrays(vector<int>& nums) {\n        long long res = 0;\n        int len = nums.size();\n        stack<int> s;\n        vector<int> v(len, 0);\n        for(int i = 0; i < len; i++){\n            v[i] ++;\n            while(!s.empty() && nums[s.top()] < nums[i]){\n                s.pop();\n            }\n            if(!s.empty() && nums[s.top()] == nums[i]){\n                v[i] = v[s.top()] + 1;\n            }\n            res += v[i];\n            s.push(i);\n        }\n        return res;\n    }\n};\n```\n\n","title":" Leetcode第128场双周赛\n","category":[" 算法\n"],"date":" 2024-05-01\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n今日刷哔哩哔哩小羊肖恩大神10分钟都没到就AK了本场比赛，于是就想来试着做下\n\n 字符串的分数\n\n求相邻字母的ASCALL码值之和\n\nc++\nclass Solution {\npublic:\n    int scoreOfStringstring s {\n        int res = 0;\n        forint i = 1; i < s.size; i++{\n            res += fabssi  si  1;\n        }\n        return res;\n    }\n};\n\n\n 覆盖所有点的最少矩形数目\n\n一眼贪心，只用考虑横坐标\n\nc++\\\nclass Solution {\npublic:\n    int minRectanglesToCoverPointsvector<vector<int& points, int w {\n        int cot = 0, res = 0;\n        vector<int v;\n        forint i = 0; i < points.size; i++{\n            v.pushbackpointsi0;\n        }\n        int len = v.size;\n        sortv.begin, v.end;\n        cot = 1e9  10;\n        forint i = 0; i < len; i++{\n            ifvi  cot  w{\n                cot = vi;\n                res ++;\n            }\n        }\n        return res;\n\n    }\n};\n\n\n 访问消失节点的最少时间\n\nDjakarta模板题，这里提供两种做法，一种参考灵神的，一种是yxc模板的。\n\n参考灵神做法\n\nc++\nclass Solution {\npublic:\n    vector<int minimumTimeint n, vector<vector<int& edges, vector<int& disappear {\n        vector<vector<pair<int, int gn;\n        forint i = 0; i < edges.size; i++{\n            gedgesi0.pushback{edgesi1, edgesi2};\n            gedgesi1.pushback{edgesi0, edgesi2};\n        }\n\n        vector<int disn, 0x3f3f3f3f;\n        vector<bool stn ,false;\n        priorityqueue<pair<int, int, vector<pair<int, int, greater<pair<int, int pq;\n        dis0 = 0;\n        pq.push{0, 0};\n        whilepq.empty{\n            auto len, xx = pq.top;\n            pq.pop;\n            ifstxx continue;\n            stxx = 1;\n            forauto ne, w : gxx{\n                ifdisne  len + w  && len + w < disappearne{\n                    disne = len + w;\n                    pq.push{disne, ne};\n                }\n            }\n        }\n        forint i = 0; i < n; i++{\n            ifdisi == 0x3f3f3f3f disi = 1;\n        }\n       \n        return dis;\n    }\n};\n\n\nyxc模板做法\n\nc++\nconst int N = 1e6 + 10;\nclass Solution {\npublic:\n    int nN, neN, wN, hN, disN, stN, idx;\n    void djvector<int& disappear{\n        memsetdis, 0x3f3f3f3f, sizeof dis;\n        priorityqueue<pair<int, int, vector<pair<int, int, greater<pair<int, int pq;\n        dis0 = 0;\n        pq.push{0, 0};\n        whilepq.size{\n            auto top = pq.top;\n            pq.pop;\n            int yy = top.first, xx = top.second;\n            ifstxx continue;\n            stxx = 1;\n            forint i = hxx; i = 1; i = nei{\n                int j = ni;\n                ifdisj  yy + wi && yy + wi < disappearj{\n                    disj = yy + wi;\n                    pq.push{disj, j};\n                }\n            }\n        }\n    }\n    void addint x, int y, int z{\n        nidx = y, widx = z, neidx = hx, hx = idx ++;\n    }\n    vector<int minimumTimeint n, vector<vector<int& edges, vector<int& disappear {\n        memseth, 1, sizeof h;\n        forint i = 0; i < edges.size; i++{\n            addedgesi0, edgesi1, edgesi2;\n            addedgesi1, edgesi0, edgesi2;\n        }\n        djdisappear;\n        vector<int res;\n        forint i = 0; i < n; i ++{\n            res.pushbackdisi ==  0x3f3f3f3f ? 1 : disi;\n        }\n       \n        return res;\n    }\n};\n\n\n 边界元素是最大值的子数组数目\n\n这题只要想到单调栈就很好做啦\n\nc++\nclass Solution {\npublic:\n    long long numberOfSubarraysvector<int& nums {\n        long long res = 0;\n        int len = nums.size;\n        stack<int s;\n        vector<int vlen, 0;\n        forint i = 0; i < len; i++{\n            vi ++;\n            whiles.empty && numss.top < numsi{\n                s.pop;\n            }\n            ifs.empty && numss.top == numsi{\n                vi = vs.top + 1;\n            }\n            res += vi;\n            s.pushi;\n        }\n        return res;\n    }\n};\n\n\n"},{"filename":"nowcoder-month-91","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛91\ncategory: 算法\ndate: 2024-04-29\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### Bingbong的化学世界\n\n找出几个图形不同的点，根据不同的点来输出就很简单了\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tchar n[7][7];\n\tfor(int i = 0; i < 6; i++){\n\t\tfor(int j = 0; j < 7; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\t\n\tif(n[0][3] == '.') cout << \"o\" << endl;\n\telse if(n[5][3] == '.') cout << \"m\" << endl;\n\telse cout << \"p\" << endl;\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的数数世界\n\n思维题，需要我们找出最终的胜利者\n\n只要这个数是奇数并且这个数除以2的结果也是偶数的话就是`Bing`，否则就是`Bong`\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tif(b / 2 % 2 == 1 || b % 2 == 1){\n\t\t\tcout << \"Bing\" << endl;\n\t\t} else {\n\t\t\tcout << \"Bong\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的蛋仔世界\n\n这题一看到需要向四个方位移动，我立马就想到了DFS，可是仔细读题后发现后并不需要。\n\n只需要判断某个点是否能在边界消失完到达中心点即可；该点到中心点的距离 = 横坐标之差 + 纵坐标之差\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b >> x;\n\tint midx = a / 2, midy = b / 2;\n\tint mcot = max(midx, midy);\n\twhile(x --){\n\t\tint n1, n2;\n\t\tcin >> n1 >> n2;\n\t\tn1 --, n2 --;\n\t\tint cot = fabs(n1 - midx) + fabs(n2 - midy);\n\t\tif(cot <= mcot) res ++;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的奇偶世界\n\n~~每次到差不多第三，四个题的位置总是会卡~~，这题我赛时的思路和题解的思路大差不差，估计某处细节没考虑不到导致一直卡。\n\n思路：比如当前点为`i`，那么这点之前的所有满足条件的个数有`pow(i - 1, 2) + 1 - 含有前导0的数` ，每次循环遍历的时候都需要判断是否是0、奇数、偶数。并且在每次循环的时候就需要维护`pow`和`前导0的数`这两个值，不能直接通过`pow`来计算因为会超时，我感觉我g应该就出在这里。\n\n我的代码\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot = 1, cc = 1;\n\tchar c;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> c;\n\t\tif((c - '0') % 2 == 0){\n\t\t\tn[i] = (n[i - 1] + cc + 1 - cot) % mod;\n\t\t\tif(c == '0'){\n\t\t\t\tcot = cot * 2 % mod;\n\t\t\t}\n\t\t} else {\n\t\t\tn[i] = n[i - 1];\n\t\t}\n\t\tcc = cc * 2 % mod;\n\t}\n\n\tcout << n[a] << endl; \n\treturn 0;\n}\n```\n\n正解\n\n思路是每次循环的时候就去掉了0的前导数的值，当不是0的时候就直接相加，不需要想我的思路那样单独来减，容易出错。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot = 0, cc = 0;\n\tchar c;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> c;\n\t\tif(c == '0'){\n\t\t\tcot = (cot + cc + 1) % mod;\n\t\t\tcc = cc * 2 % mod; \n\t\t} else if((c - '0') % 2 == 0){\n\t\t\tcot = (cot + cc + 1) % mod;;\n\t\t\tcc = (cc * 2 + 1) % mod; \n\t\t} else {\n\t\t\tcc = (cc * 2 + 1) % mod;\n\t\t}\n\n\t}\n\n\tcout << cot << endl; \n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛91\n","category":[" 算法\n"],"date":" 2024-04-29\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n Bingbong的化学世界\n\n找出几个图形不同的点，根据不同的点来输出就很简单了\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tchar n77;\n\tforint i = 0; i < 6; i++{\n\t\tforint j = 0; j < 7; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\t\n\tifn03 == '.' cout << \"o\" << endl;\n\telse ifn53 == '.' cout << \"m\" << endl;\n\telse cout << \"p\" << endl;\n\t\n\treturn 0;\n}\n\n\n Bingbong的数数世界\n\n思维题，需要我们找出最终的胜利者\n\n只要这个数是奇数并且这个数除以2的结果也是偶数的话就是Bing，否则就是Bong\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tifb / 2 % 2 == 1  b % 2 == 1{\n\t\t\tcout << \"Bing\" << endl;\n\t\t} else {\n\t\t\tcout << \"Bong\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n\n Bingbong的蛋仔世界\n\n这题一看到需要向四个方位移动，我立马就想到了DFS，可是仔细读题后发现后并不需要。\n\n只需要判断某个点是否能在边界消失完到达中心点即可；该点到中心点的距离 = 横坐标之差 + 纵坐标之差\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b  x;\n\tint midx = a / 2, midy = b / 2;\n\tint mcot = maxmidx, midy;\n\twhilex {\n\t\tint n1, n2;\n\t\tcin  n1  n2;\n\t\tn1 , n2 ;\n\t\tint cot = fabsn1  midx + fabsn2  midy;\n\t\tifcot <= mcot res ++;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n Bingbong的奇偶世界\n\n每次到差不多第三，四个题的位置总是会卡，这题我赛时的思路和题解的思路大差不差，估计某处细节没考虑不到导致一直卡。\n\n思路：比如当前点为i，那么这点之前的所有满足条件的个数有powi  1, 2 + 1  含有前导0的数 ，每次循环遍历的时候都需要判断是否是0、奇数、偶数。并且在每次循环的时候就需要维护pow和前导0的数这两个值，不能直接通过pow来计算因为会超时，我感觉我g应该就出在这里。\n\n我的代码\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll cot = 1, cc = 1;\n\tchar c;\n\tforint i = 1; i <= a; i++{\n\t\tcin  c;\n\t\tifc  '0' % 2 == 0{\n\t\t\tni = ni  1 + cc + 1  cot % mod;\n\t\t\tifc == '0'{\n\t\t\t\tcot = cot  2 % mod;\n\t\t\t}\n\t\t} else {\n\t\t\tni = ni  1;\n\t\t}\n\t\tcc = cc  2 % mod;\n\t}\n\n\tcout << na << endl; \n\treturn 0;\n}\n\n\n正解\n\n思路是每次循环的时候就去掉了0的前导数的值，当不是0的时候就直接相加，不需要想我的思路那样单独来减，容易出错。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll cot = 0, cc = 0;\n\tchar c;\n\tforint i = 1; i <= a; i++{\n\t\tcin  c;\n\t\tifc == '0'{\n\t\t\tcot = cot + cc + 1 % mod;\n\t\t\tcc = cc  2 % mod; \n\t\t} else ifc  '0' % 2 == 0{\n\t\t\tcot = cot + cc + 1 % mod;;\n\t\t\tcc = cc  2 + 1 % mod; \n\t\t} else {\n\t\t\tcc = cc  2 + 1 % mod;\n\t\t}\n\n\t}\n\n\tcout << cot << endl; \n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-87","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛87\ncategory: 算法\ndate: 2024-04-25\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 小苯的石子游戏\n\n模拟两者选石头，判断最终结果\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b + 1);\n\t\tint l = 0, r = 0;\n\t\tfor(int i = 1; i <= b; i++) {\n\t\t\tcin >> v[i];\n\t\t} \n\t\tint idx = 1;\n\t\tfor(int i = b; i >= 1; i --){\n\t\t\tif(idx % 2 == 1) l += v[i];\n\t\t\telse r += v[i];\n\t\t\tidx ++;\n\t\t}\n\t\tcout << (l > r ? \"Alice\" : \"Bob\") << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的排序疑惑\n\n思维题，只需对数组的两边值进行考虑\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b);\n\t\tint minn = INT_MAX, maxx = 0; \n\t\tfor(int i = 0; i < b; i++) {\n\t\t\tcin >> v[i];\n\t\t\tif(i != 0){\n\t\t\t\tminn = min(minn, v[i]);\n\t\t\t}\n\t\t\tif(i != b - 1){\n\t\t\t\tmaxx = max(maxx, v[i]);\n\t\t\t}\n\t\t} \n\t\tcout << (v[0] <= minn || v[b - 1] >= maxx ? \"YES\" : \"NO\") << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的IDE括号问题（easy）\n\n使用两字符数组分别模拟 `I` 前后两个字符串的操作\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\nstring str, s;\nchar v[N], m[N]; \nint len1, len2, c1, c2;\n\nvoid fun1(){\n\tif(len1 >= 0 && len2 < c2){\n\t\tif(v[len1] == '(' && m[len2] == ')'){\n\t\t\tlen1 --;\n\t\t\tlen2 ++;\n\t\t} else {\n\t\t\tlen1 --;\n\t\t}\t\n\t} else {\n\t\tlen1 --;\n\t}\n\t\n}\n\nvoid fun2(){\n\tlen2 ++;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tcin >> str;\n\tint idx = 0, len = str.size();\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == 'I'){\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\tv[i] = str[i];\n\t\tc1 ++;\n\t}\n\tfor(int i = idx + 1; i < len; i++){\n\t\tm[i - idx - 1] = str[i];\n\t\tc2 ++;\n\t}\n\tlen1 = c1 - 1, len2 = 0;\n\twhile(b --){\n\t\tcin >> s;\n\t\tif(s[0] == 'b'){\n\t\t\tfun1();\n\t\t} else {\n\t\t\tfun2();\n\t\t}\n\t} \n\n\tfor(int i = 0; i <= len1; i++) cout << v[i];\n\tcout << \"I\";\n\tfor(int i = len2; i < c2; i++) cout << m[i]; \n\t\n\t\n\treturn 0;\n}\n```\n\n### 小苯的IDE括号问题（hard）\n\n这题与前一题的区别在于操作数增加了两个左移和右移，若再次使用数组的话不好模拟（需要遍历），于是采用两个双端队列进模拟（上一题也可以使用双端队列进行模拟）\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\nstring str, s;\ndeque<char> d1, d2;\n\nvoid fun1(){\n\tint len1 = d1.size(), len2 = d2.size();\n\tif(len1 && len2){\n\t\tif(d1.back() == '(' && d2.front() == ')'){\n\t\t\td1.pop_back();\n\t\t\td2.pop_front();\n\t\t} else {\n\t\t\td1.pop_back();\n\t\t}\n\t} else if(len1) {\n\t\td1.pop_back();\n\t}\n\t\n}\n\nvoid fun2(){\n\tif(d2.size()){\n\t\td2.pop_front();\n\t}\n}\n\nvoid fun3(){\n\tif(d1.size()){\n\t\tchar c = d1.back();\n\t\td1.pop_back(); \n\t\td2.push_front(c);\n\t}\n}\n\nvoid fun4(){\n\tif(d2.size()){\n\t\tchar c = d2.front();\n\t\td2.pop_front();\n\t\td1.push_back(c);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tcin >> str;\n\tint idx = 0, len = a;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == 'I'){\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\td1.push_back(str[i]); \n\t}\n\tfor(int i = idx + 1; i < len; i++){\n\t\td2.push_back(str[i]);\n\t}\n\t\n\twhile(b --){\n\t\tcin >> s;\n\t\tif(s[0] == 'b'){\n\t\t\tfun1();\n\t\t} else if(s[0] == 'd'){\n\t\t\tfun2();\n\t\t} else if(s[0] == '<'){\n\t\t\tfun3();\n\t\t} else{\n\t\t\tfun4();\n\t\t}\n\t} \n\n\twhile(d1.size()){\n\t\tcout << d1.front();\n\t\td1.pop_front();\n\t}\n\tcout << \"I\";\n\twhile(d2.size()){\n\t\tcout << d2.front();\n\t\td2.pop_front();\n\t}\n\t\t\n\treturn 0;\n}\n```\n\n### 小苯的数组构造\n\n遍历每个数，找出每个数前的各个最大值（不断维护），相减即可\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<ll> v(a + 1);\n\tv[0] = -10e9 - 10;\n\tint flag = 1; \n\tfor(int i = 1; i <= a; i++) {\n\t\tcin >> v[i];\n\t\tif(i != 0 && v[i] < v[i - 1]){\n\t\t\tflag = 0;\n\t\t} \t\n\t}\n\tif(flag) {\n\t\tfor(int i = 1; i <= a; i++){\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tif(v[i] >= v[i - 1]) cout << 0 << \" \";\n\t\telse {\n\t\t\tcout << v[i - 1] - v[i] << \" \";\n\t\t\tv[i] = v[i - 1];\n\t\t}\n\t}\t\n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的数组切分\n\n思维题，分别考虑 & ^ | 这三种运算符\n\n- 对于 &，无论有多少个数相互 & 操作，结果都是越来越小\n- 对于 ^，若有两个相同的数进行 ^，则结果为0\n\n只要知道上面这两个，那么就可以确定右端点这一个数进行 &，剩下的 0, a - 1区间就用维护出 ^ 和 | 这两种操作的最大之和，加上右端点的值就是结果\n\n> 对于维护 0, a - 1这个区间，可以考虑先遍历 0 , a - 1，对每个数进行取 ^ 运算得到一个结果l，再反向遍历 a - 1, 0 若想不让这个数取 ^，可以对 l 对这个数进行取 ^ ，因为开始已经取过一边了，再取一边就是0相当于没取。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll res = 0;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++) cin >> v[i]; \n\tll l = v[0], r = v[a - 2];\n\tfor(int i = 1; i < a - 1; i++) l ^= v[i];\n\tfor(int i = a - 2; i >= 0; i--){\n\t\tl ^= v[i];\n\t\tr |= v[i];\n\t\tres = max(res, l + r);\n\t}\n\t\n\tcout << res + v[a - 1] << endl;\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛87\n","category":[" 算法\n"],"date":" 2024-04-25\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 小苯的石子游戏\n\n模拟两者选石头，判断最终结果\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tvector<int vb + 1;\n\t\tint l = 0, r = 0;\n\t\tforint i = 1; i <= b; i++ {\n\t\t\tcin  vi;\n\t\t} \n\t\tint idx = 1;\n\t\tforint i = b; i = 1; i {\n\t\t\tifidx % 2 == 1 l += vi;\n\t\t\telse r += vi;\n\t\t\tidx ++;\n\t\t}\n\t\tcout << l  r ? \"Alice\" : \"Bob\" << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n\n\n 小苯的排序疑惑\n\n思维题，只需对数组的两边值进行考虑\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tvector<int vb;\n\t\tint minn = INTMAX, maxx = 0; \n\t\tforint i = 0; i < b; i++ {\n\t\t\tcin  vi;\n\t\t\tifi = 0{\n\t\t\t\tminn = minminn, vi;\n\t\t\t}\n\t\t\tifi = b  1{\n\t\t\t\tmaxx = maxmaxx, vi;\n\t\t\t}\n\t\t} \n\t\tcout << v0 <= minn  vb  1 = maxx ? \"YES\" : \"NO\" << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n\n\n 小苯的IDE括号问题（easy）\n\n使用两字符数组分别模拟 I 前后两个字符串的操作\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\nstring str, s;\nchar vN, mN; \nint len1, len2, c1, c2;\n\nvoid fun1{\n\tiflen1 = 0 && len2 < c2{\n\t\tifvlen1 == '' && mlen2 == ''{\n\t\t\tlen1 ;\n\t\t\tlen2 ++;\n\t\t} else {\n\t\t\tlen1 ;\n\t\t}\t\n\t} else {\n\t\tlen1 ;\n\t}\n\t\n}\n\nvoid fun2{\n\tlen2 ++;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tcin  str;\n\tint idx = 0, len = str.size;\n\tforint i = 0; i < len; i++{\n\t\tifstri == 'I'{\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\tvi = stri;\n\t\tc1 ++;\n\t}\n\tforint i = idx + 1; i < len; i++{\n\t\tmi  idx  1 = stri;\n\t\tc2 ++;\n\t}\n\tlen1 = c1  1, len2 = 0;\n\twhileb {\n\t\tcin  s;\n\t\tifs0 == 'b'{\n\t\t\tfun1;\n\t\t} else {\n\t\t\tfun2;\n\t\t}\n\t} \n\n\tforint i = 0; i <= len1; i++ cout << vi;\n\tcout << \"I\";\n\tforint i = len2; i < c2; i++ cout << mi; \n\t\n\t\n\treturn 0;\n}\n\n\n 小苯的IDE括号问题（hard）\n\n这题与前一题的区别在于操作数增加了两个左移和右移，若再次使用数组的话不好模拟（需要遍历），于是采用两个双端队列进模拟（上一题也可以使用双端队列进行模拟）\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\nstring str, s;\ndeque<char d1, d2;\n\nvoid fun1{\n\tint len1 = d1.size, len2 = d2.size;\n\tiflen1 && len2{\n\t\tifd1.back == '' && d2.front == ''{\n\t\t\td1.popback;\n\t\t\td2.popfront;\n\t\t} else {\n\t\t\td1.popback;\n\t\t}\n\t} else iflen1 {\n\t\td1.popback;\n\t}\n\t\n}\n\nvoid fun2{\n\tifd2.size{\n\t\td2.popfront;\n\t}\n}\n\nvoid fun3{\n\tifd1.size{\n\t\tchar c = d1.back;\n\t\td1.popback; \n\t\td2.pushfrontc;\n\t}\n}\n\nvoid fun4{\n\tifd2.size{\n\t\tchar c = d2.front;\n\t\td2.popfront;\n\t\td1.pushbackc;\n\t}\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tcin  str;\n\tint idx = 0, len = a;\n\tforint i = 0; i < len; i++{\n\t\tifstri == 'I'{\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\td1.pushbackstri; \n\t}\n\tforint i = idx + 1; i < len; i++{\n\t\td2.pushbackstri;\n\t}\n\t\n\twhileb {\n\t\tcin  s;\n\t\tifs0 == 'b'{\n\t\t\tfun1;\n\t\t} else ifs0 == 'd'{\n\t\t\tfun2;\n\t\t} else ifs0 == '<'{\n\t\t\tfun3;\n\t\t} else{\n\t\t\tfun4;\n\t\t}\n\t} \n\n\twhiled1.size{\n\t\tcout << d1.front;\n\t\td1.popfront;\n\t}\n\tcout << \"I\";\n\twhiled2.size{\n\t\tcout << d2.front;\n\t\td2.popfront;\n\t}\n\t\t\n\treturn 0;\n}\n\n\n 小苯的数组构造\n\n遍历每个数，找出每个数前的各个最大值（不断维护），相减即可\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<ll va + 1;\n\tv0 = 10e9  10;\n\tint flag = 1; \n\tforint i = 1; i <= a; i++ {\n\t\tcin  vi;\n\t\tifi = 0 && vi < vi  1{\n\t\t\tflag = 0;\n\t\t} \t\n\t}\n\tifflag {\n\t\tforint i = 1; i <= a; i++{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\treturn 0;\n\t}\n\tforint i = 1; i <= a; i++{\n\t\tifvi = vi  1 cout << 0 << \" \";\n\t\telse {\n\t\t\tcout << vi  1  vi << \" \";\n\t\t\tvi = vi  1;\n\t\t}\n\t}\t\n\t\t\t\n\treturn 0;\n}\n\n\n 小苯的数组切分\n\n思维题，分别考虑 & ^  这三种运算符\n\n 对于 &，无论有多少个数相互 & 操作，结果都是越来越小\n 对于 ^，若有两个相同的数进行 ^，则结果为0\n\n只要知道上面这两个，那么就可以确定右端点这一个数进行 &，剩下的 0, a  1区间就用维护出 ^ 和  这两种操作的最大之和，加上右端点的值就是结果\n\n 对于维护 0, a  1这个区间，可以考虑先遍历 0 , a  1，对每个数进行取 ^ 运算得到一个结果l，再反向遍历 a  1, 0 若想不让这个数取 ^，可以对 l 对这个数进行取 ^ ，因为开始已经取过一边了，再取一边就是0相当于没取。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll res = 0;\n\tvector<int va;\n\tforint i = 0; i < a; i++ cin  vi; \n\tll l = v0, r = va  2;\n\tforint i = 1; i < a  1; i++ l ^= vi;\n\tforint i = a  2; i = 0; i{\n\t\tl ^= vi;\n\t\tr = vi;\n\t\tres = maxres, l + r;\n\t}\n\t\n\tcout << res + va  1 << endl;\n\t\n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-86","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛86\ncategory: 算法\ndate: 2024-04-23\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\nABC题能够轻松通过，后面的题就卡了\n\n### 水盐平衡\n\n简单模拟题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num;\n\tcin >> num;\n\twhile(num --){\n\t\tcin >> a >> b >> x >> y;\n\t\tdouble _1 = a * 1.0 / b, _2 = x * 1.0 / y;\n\t\tif(_1 > _2) cout << \"S\" << endl;\n\t\telse cout << \"Y\" << endl; \n\t} \n\t\t\n\treturn 0;\n}\n```\n\n### 水平考试\n\n这题有个巧妙的地方在于多选题不会出现得分为5的情况，因为不可能出现部分正确，只要有部分正确小灰灰就会把他修改为全部正确\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num;\n\tcin >> num;\n\twhile(num --){\n\t\tstring s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tint len1 = s1.size(), len2 = s2.size();\n\t\tif(len1 > len2){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(len2 == 1){\n\t\t\tif(s1[0] == s2[0]) cout << \"10\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tunordered_map<char, int> ump;\n\t\tfor(int i = 0; i < len2; i++){\n\t\t\tump[s2[i]] ++;\n\t\t}\n\t\tint flag = 0, flag2 = 1;\n\t\tfor(int i = 0; i < len1; i++){\n\t\t\tif(!ump[s1[i]]){\n\t\t\t\tflag2 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag2){\n\t\t\tcout << 10 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n//\t\tflag = 0, flag2 = 1;\n//\t\tfor(int i = 0; i < len1; i++){\n//\t\t\tif(ump[s1[i]]){\n//\t\t\t\tflag = 1;\t\n//\t\t\t} else {\n//\t\t\t\tflag2 = 0;\n//\t\t\t}\n//\t\t}\n//\t\tif(flag && !flag2){\n//\t\t\tcout << 0 << endl;\n//\t\t} else if(flag && flag2){\n//\t\t\tcout << 5 << endl;\n//\t\t} else cout << 0 << endl;\n\t} \n\t\n\t\t\n\treturn 0;\n}\n```\n\n### 数组段数 \n\n模拟题，需要注意的点是若是出现当前下标的和和上一位数的和一致的时候，就说明这段是相同，需要向前找到不一致的和\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<int> v(a + 1), m(a + 1);\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tif(i == 1){\n\t\t\tm[i] = 1;\n\t\t} else {\n\t\t\tif(v[i] == v[i - 1]){\n\t\t\t\tm[i] = m[i - 1];\t\n\t\t\t} else {\n\t\t\t\tm[i] = m[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i = 1; i <= a; i++) cout << m[i] << \" \";\n//\tcout << endl;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\twhile(v[x] == v[x - 1]){\n\t\t\tx --;\n\t\t}\n//\t\tcout << x << \" \" << y << \" \" << m[x] << \" \" << m[y] << endl;\n\t\tcout << m[y] - m[x - 1] << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 剪纸游戏\n\n这题我的思路是默认当前点位最小x和最小y的值，然后BFS遍历，找出最大x和最大y，然后计算这块区间的所有坐标是否都标记过了。但是后面看题解发现这样是不对的。若是出现 `_|` 这种的图形就会统计出错，我的思路会将其算成一个长方形，但显然不是。\n\n正解：BFS同时算出最小x，最小y，最大x，最大y，并统计标记过了的数量，通过计算这块区间数量是否等于BFS遍历标记的数量，若相同就说明是长方形，否则就不是。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nchar v[1010][1010];\nint st[1010][1010];\nint mmx, mmy, iix, iiy;\n\nint dfs(int x, int y){\n\tmmx = max(mmx, x);\n\tmmy = max(mmy, y);\n\tiix = min(iix, x);\n\tiiy = min(iiy, y);\n\tint cot = 0;\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = x + ix[i], yy = y + iy[i];\n\t\tif(xx >= 1 && xx <= a && yy >= 1 && yy <= b && !st[xx][yy] && v[xx][yy] == '.'){\n\t\t\tst[xx][yy] = 1;\n\t\t\tcot += dfs(xx, yy) + 1;\n\t\t}\n\t}\n\treturn cot;\n}\n\nint check(int x, int y, int ex, int ey){\n\tfor(int i = x; i <= ex; i++){\n\t\tfor(int j = y; j <= ey; j++){\n\t\t\tif(!st[i][j]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\t for(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tif(v[i][j] == '.' && !st[i][j]){\n\t\t\t\tmmx = 0, mmy = 0, iix = i, iiy = j;\n\t\t\t\tst[i][j] = 1;\n\t\t\t\tint cot = dfs(i, j) + 1;\n\t\t\t\tif(cot == (mmx - iix + 1) * (mmy - iiy + 1)){\n\t\t\t\t\tres ++; \n\t\t\t\t}\n//\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << \" \" << iix << \" \" << iiy << \" \" << cot << endl;\n//\t\t\t\tif(check(i, j, mmx, mmy)){\n//\t\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << endl;\n//\t\t\t\t\tres ++;\n//\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n```\n\n### 可口蛋糕\n\n前缀和+双指针+小贪心题\n\n用l，r代表两个双指针，先找出r（第一个出现大于W的下标），不断维护 v[r] - v[l] 大于等于W的区间，找出最小可口值的前缀和（贪心），用前缀和算出区间的饱腹值，得出最大的一个。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<ll> v(a + 1), m(a + 1);\n\tv[0] = 0, m[0] = 0;\n\tfor(int i = 1; i <= a; i++) cin >> v[i], v[i] += v[i - 1];\n\tfor(int i = 1; i <= a; i++) cin >> m[i], m[i] += m[i - 1];\n\tll l = 0, r = 0, minn = 1e18, res = -1e18;\n\tfor(int i = 1; i <= a; i++){\n\t\tif(v[i] >= b){\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(r <= a){\n//\t\tcout << v[r] << \" \" << v[l] << endl;\n\t\twhile(v[r] - v[l] >= b){\n\t\t\tminn = min(minn, m[l]); \n\t\t\tl ++;\n\t\t}\n//\t\tcout << minn << \" \" << m[r] << \" \" << m[r] - minn << endl;\n\t\tres = max(res, m[r] - minn);\n\t\tr ++;\n\t}\n\t\n\tcout << res << endl;\n\t\n\t\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛86\n","category":[" 算法\n"],"date":" 2024-04-23\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\nABC题能够轻松通过，后面的题就卡了\n\n 水盐平衡\n\n简单模拟题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint num;\n\tcin  num;\n\twhilenum {\n\t\tcin  a  b  x  y;\n\t\tdouble 1 = a  1.0 / b, 2 = x  1.0 / y;\n\t\tif1  2 cout << \"S\" << endl;\n\t\telse cout << \"Y\" << endl; \n\t} \n\t\t\n\treturn 0;\n}\n\n\n 水平考试\n\n这题有个巧妙的地方在于多选题不会出现得分为5的情况，因为不可能出现部分正确，只要有部分正确小灰灰就会把他修改为全部正确\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint num;\n\tcin  num;\n\twhilenum {\n\t\tstring s1, s2;\n\t\tcin  s1  s2;\n\t\tint len1 = s1.size, len2 = s2.size;\n\t\tiflen1  len2{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tiflen2 == 1{\n\t\t\tifs10 == s20 cout << \"10\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tunorderedmap<char, int ump;\n\t\tforint i = 0; i < len2; i++{\n\t\t\tumps2i ++;\n\t\t}\n\t\tint flag = 0, flag2 = 1;\n\t\tforint i = 0; i < len1; i++{\n\t\t\tifumps1i{\n\t\t\t\tflag2 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tifflag2{\n\t\t\tcout << 10 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n//\t\tflag = 0, flag2 = 1;\n//\t\tforint i = 0; i < len1; i++{\n//\t\t\tifumps1i{\n//\t\t\t\tflag = 1;\t\n//\t\t\t} else {\n//\t\t\t\tflag2 = 0;\n//\t\t\t}\n//\t\t}\n//\t\tifflag && flag2{\n//\t\t\tcout << 0 << endl;\n//\t\t} else ifflag && flag2{\n//\t\t\tcout << 5 << endl;\n//\t\t} else cout << 0 << endl;\n\t} \n\t\n\t\t\n\treturn 0;\n}\n\n\n 数组段数 \n\n模拟题，需要注意的点是若是出现当前下标的和和上一位数的和一致的时候，就说明这段是相同，需要向前找到不一致的和\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<int va + 1, ma + 1;\n\tforint i = 1; i <= a; i++{\n\t\tcin  vi;\n\t\tifi == 1{\n\t\t\tmi = 1;\n\t\t} else {\n\t\t\tifvi == vi  1{\n\t\t\t\tmi = mi  1;\t\n\t\t\t} else {\n\t\t\t\tmi = mi  1 + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tforint i = 1; i <= a; i++ cout << mi << \" \";\n//\tcout << endl;\n\twhileb {\n\t\tcin  x  y;\n\t\twhilevx == vx  1{\n\t\t\tx ;\n\t\t}\n//\t\tcout << x << \" \" << y << \" \" << mx << \" \" << my << endl;\n\t\tcout << my  mx  1 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n 剪纸游戏\n\n这题我的思路是默认当前点位最小x和最小y的值，然后BFS遍历，找出最大x和最大y，然后计算这块区间的所有坐标是否都标记过了。但是后面看题解发现这样是不对的。若是出现  这种的图形就会统计出错，我的思路会将其算成一个长方形，但显然不是。\n\n正解：BFS同时算出最小x，最小y，最大x，最大y，并统计标记过了的数量，通过计算这块区间数量是否等于BFS遍历标记的数量，若相同就说明是长方形，否则就不是。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nchar v10101010;\nint st10101010;\nint mmx, mmy, iix, iiy;\n\nint dfsint x, int y{\n\tmmx = maxmmx, x;\n\tmmy = maxmmy, y;\n\tiix = miniix, x;\n\tiiy = miniiy, y;\n\tint cot = 0;\n\tforint i = 0; i < 4; i++{\n\t\tint xx = x + ixi, yy = y + iyi;\n\t\tifxx = 1 && xx <= a && yy = 1 && yy <= b && stxxyy && vxxyy == '.'{\n\t\t\tstxxyy = 1;\n\t\t\tcot += dfsxx, yy + 1;\n\t\t}\n\t}\n\treturn cot;\n}\n\nint checkint x, int y, int ex, int ey{\n\tforint i = x; i <= ex; i++{\n\t\tforint j = y; j <= ey; j++{\n\t\t\tifstij{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcin  vij;\n\t\t}\n\t}\n\t forint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tifvij == '.' && stij{\n\t\t\t\tmmx = 0, mmy = 0, iix = i, iiy = j;\n\t\t\t\tstij = 1;\n\t\t\t\tint cot = dfsi, j + 1;\n\t\t\t\tifcot == mmx  iix + 1  mmy  iiy + 1{\n\t\t\t\t\tres ++; \n\t\t\t\t}\n//\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << \" \" << iix << \" \" << iiy << \" \" << cot << endl;\n//\t\t\t\tifchecki, j, mmx, mmy{\n//\t\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << endl;\n//\t\t\t\t\tres ++;\n//\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n\n\n 可口蛋糕\n\n前缀和+双指针+小贪心题\n\n用l，r代表两个双指针，先找出r（第一个出现大于W的下标），不断维护 vr  vl 大于等于W的区间，找出最小可口值的前缀和（贪心），用前缀和算出区间的饱腹值，得出最大的一个。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<ll va + 1, ma + 1;\n\tv0 = 0, m0 = 0;\n\tforint i = 1; i <= a; i++ cin  vi, vi += vi  1;\n\tforint i = 1; i <= a; i++ cin  mi, mi += mi  1;\n\tll l = 0, r = 0, minn = 1e18, res = 1e18;\n\tforint i = 1; i <= a; i++{\n\t\tifvi = b{\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhiler <= a{\n//\t\tcout << vr << \" \" << vl << endl;\n\t\twhilevr  vl = b{\n\t\t\tminn = minminn, ml; \n\t\t\tl ++;\n\t\t}\n//\t\tcout << minn << \" \" << mr << \" \" << mr  minn << endl;\n\t\tres = maxres, mr  minn;\n\t\tr ++;\n\t}\n\t\n\tcout << res << endl;\n\t\n\t\t\n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-85","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛85\ncategory: 算法\ndate: 2024-04-18\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本场比赛做下来大多都是思维题，就当是锻炼思维了\n\n### ACCEPT\n\n签到题，一开始想复杂了，想依次循环遍历来计算每个字母出现的次数，再取出最小的次数。在对于C的次数的取值上费了很长一段时间，后面灵光一线，几行代码搞定\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\nint check(unordered_map<char, int> ump){\n\treturn min(ump['A'], min(ump['C'] / 2, min(ump['E'], min(ump['P'], ump['T']))));\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tstring str;\n\t\tcin >> str;\n\t\tint res = INT_MAX, cot = 0;\n\t\tchar minc;\n\t\tunordered_map<char, int> ump; \n\t\tfor(int i = 0; i < b; i++){\n\t\t\tump[str[i]] ++;\n//\t\t\tif(ump[str[i]] == 1) cot ++;\n//\t\t\tif(ump[str[i]] == 2 && str[i] == 'C') cot ++;\n//\t\t\tif(ump[str[i]] > res){\n//\t\t\t\t\n//\t\t\t\tif(str[i] == 'C'){\n//\t\t\t\t\tif(str[i] == minc && ump[str[i]] % 2 == 0) res ++;\n//\t\t\t\t} else{\n//\t\t\t\t\tif(str[i] == minc) res ++; \n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t} else if(res > ump[str[i]]){\n//\t\t\t\tminc = str[i];\n//\t\t\t\tif(str[i] == 'C') res = 0;\n//\t\t\t\telse res = ump[str[i]];\t\n//\t\t\t}\n//\t\t\tif(str[i] == 'C'){\n//\t\t\t\tif(minc == 'C' && ump[str[i]] % 2 == 0) res ++;\n//\t\t\t\telse res = min(res, ump[str[i]] / 2);\n//\t\t\t} else {\n//\t\t\t\tres = min(ump[str[i]], res);\n//\t\t\t}\n//\t\t\tcout << res << \" \"<< ump[str[i]]<<\" \"<<minc << endl;\n\t\t}\n\t\tcout << check(ump) << endl;\n//\t\tif(cot < 6) cout << 0 << endl;\n//\t\telse cout << res << endl;\n\t}\n \n\treturn 0;\n}\t\n```\n\n### 咕呱蛙\n\n这题就是看思维了，从前几个满足条件的数中找出规律，只有 4i + 2 和 4i + 3的数满足条件，于是考虑这两个数出现位置\n\n对于 4i + 2，直接就是 2n，对于4i + 3，也是很快知道为 2n + 1\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n   \tll x;\n   \tcin >> x;\n\tif(x % 2 == 0) cout << 2 * x << endl;\n\telse cout << 2 * x  + 1 << endl; \n}\n```\n\n### 得分显示\n\n这题题意很简单，但是很难想到一点就是，因为是递增的，所以后面出现的数x对于前面出现n个数满足，每次增加都不能超过x/n。 \n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  \tcin >> a;\n  \tint num;\n  \tdouble res = 1e9 + 1;\n  \tfor(int i = 1; i <= a; i++){\n  \t\tcin >> num;\t\n  \t\tres = min(res, (num + 0.9999999999999) / i);\n\t}\n\tprintf(\"%.10lf\", res);\n}\n```\n\n### 阿里马马与四十大盗\n\n这题用了贪心的思想，对于某个0补充到最大值后，若后面的数之和都小于这个最大值，则后面的0就不用管了无需补充；于是这个某个0之前的0都需要补充到最大值\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\nint v[N];\nll m[N];\nll fun(int x){\n\treturn m[a] - m[x];\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tll res = 0, is = 0, cot = b, flag = 0;\n\tfor(int i = 1; i <= a; i ++){\n\t\tcin >> v[i]; \t\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tm[i] = m[i - 1] + v[i];\n\t}\n\tfor(int i = 1; i <= a - 1; i ++){ \n\t\tif(v[i] == 0){\n\t\t\tres += b - cot;\n\t\t\tcot = b; \t\n\t\t\tif(cot > fun(i)){\n\t\t\t\tcout << res + a - 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcot -= v[i];\n\t\t\tif(cot <= 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tcout << res + a - 1 << endl;\n\t\n    return 0;\n}\n```\n\n","title":" 牛客小白月赛85\n","category":[" 算法\n"],"date":" 2024-04-18\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n本场比赛做下来大多都是思维题，就当是锻炼思维了\n\n ACCEPT\n\n签到题，一开始想复杂了，想依次循环遍历来计算每个字母出现的次数，再取出最小的次数。在对于C的次数的取值上费了很长一段时间，后面灵光一线，几行代码搞定\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\nint checkunorderedmap<char, int ump{\n\treturn minump'A', minump'C' / 2, minump'E', minump'P', ump'T';\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tstring str;\n\t\tcin  str;\n\t\tint res = INTMAX, cot = 0;\n\t\tchar minc;\n\t\tunorderedmap<char, int ump; \n\t\tforint i = 0; i < b; i++{\n\t\t\tumpstri ++;\n//\t\t\tifumpstri == 1 cot ++;\n//\t\t\tifumpstri == 2 && stri == 'C' cot ++;\n//\t\t\tifumpstri  res{\n//\t\t\t\t\n//\t\t\t\tifstri == 'C'{\n//\t\t\t\t\tifstri == minc && umpstri % 2 == 0 res ++;\n//\t\t\t\t} else{\n//\t\t\t\t\tifstri == minc res ++; \n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t} else ifres  umpstri{\n//\t\t\t\tminc = stri;\n//\t\t\t\tifstri == 'C' res = 0;\n//\t\t\t\telse res = umpstri;\t\n//\t\t\t}\n//\t\t\tifstri == 'C'{\n//\t\t\t\tifminc == 'C' && umpstri % 2 == 0 res ++;\n//\t\t\t\telse res = minres, umpstri / 2;\n//\t\t\t} else {\n//\t\t\t\tres = minumpstri, res;\n//\t\t\t}\n//\t\t\tcout << res << \" \"<< umpstri<<\" \"<<minc << endl;\n\t\t}\n\t\tcout << checkump << endl;\n//\t\tifcot < 6 cout << 0 << endl;\n//\t\telse cout << res << endl;\n\t}\n \n\treturn 0;\n}\t\n\n\n 咕呱蛙\n\n这题就是看思维了，从前几个满足条件的数中找出规律，只有 4i + 2 和 4i + 3的数满足条件，于是考虑这两个数出现位置\n\n对于 4i + 2，直接就是 2n，对于4i + 3，也是很快知道为 2n + 1\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n   \tll x;\n   \tcin  x;\n\tifx % 2 == 0 cout << 2  x << endl;\n\telse cout << 2  x  + 1 << endl; \n}\n\n\n 得分显示\n\n这题题意很简单，但是很难想到一点就是，因为是递增的，所以后面出现的数x对于前面出现n个数满足，每次增加都不能超过x/n。 \n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n  \tcin  a;\n  \tint num;\n  \tdouble res = 1e9 + 1;\n  \tforint i = 1; i <= a; i++{\n  \t\tcin  num;\t\n  \t\tres = minres, num + 0.9999999999999 / i;\n\t}\n\tprintf\"%.10lf\", res;\n}\n\n\n 阿里马马与四十大盗\n\n这题用了贪心的思想，对于某个0补充到最大值后，若后面的数之和都小于这个最大值，则后面的0就不用管了无需补充；于是这个某个0之前的0都需要补充到最大值\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\nint vN;\nll mN;\nll funint x{\n\treturn ma  mx;\n}\n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tll res = 0, is = 0, cot = b, flag = 0;\n\tforint i = 1; i <= a; i ++{\n\t\tcin  vi; \t\n\t}\n\tforint i = 1; i <= a; i++{\n\t\tmi = mi  1 + vi;\n\t}\n\tforint i = 1; i <= a  1; i ++{ \n\t\tifvi == 0{\n\t\t\tres += b  cot;\n\t\t\tcot = b; \t\n\t\t\tifcot  funi{\n\t\t\t\tcout << res + a  1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcot = vi;\n\t\t\tifcot <= 0{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tcout << res + a  1 << endl;\n\t\n    return 0;\n}\n\n\n"},{"filename":"12th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十二届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-04-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 空间\n\n单位换算题\n\n1比特 = 8位\n\n256 * 1024 * 1024 / 4\n\n### 卡片\n\n模拟题\n\n需要注意的的是答案是输出能够拼到多少，而不是拼完的那个数，所以需要答案 - 1\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint n[10];\n\tfor(int i = 0; i <= 9; i++){\n\t\tn[i] = 2021;\n\t}\t\n\tint idx = 1;\n\twhile(true){\n\t\tint c = idx, flag = 0;\n\t\twhile(c){\n\t\t\tif(n[c % 10] == 0){\n\t\t\t\tcout << idx - 1 << endl;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn[c % 10] --;\n\t\t\tc /= 10;\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tidx ++;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 直线\n\n模拟、数学题\n\n需要注意直线的公式：y = kx + b\n\n斜率：k = (y1 - y2) / (x1 - x2)\n\n截距：b = (y1 * x2 - y2 * x1) / (x2 - x1)\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<double, double>, int> mp;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tfor(int i = 0; i < 20; i++){\n\t\tres ++;\n\t}\n\tfor(int i = 0; i < 21; i++){\n\t\tres ++;\n\t}\n\t\n\tfor(int i = 0; i < 20; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tfor(int x = i + 1; x < 20; x++){\n\t\t\t\tfor(int y = 0; y < 21; y++){\n\t\t\t\t\tif(i != x && j != y){\n\t\t\t\t\t\tdouble num = (j - y) * 1.0 / (i - x);\t\n\t\t\t\t\t\tdouble val = (i * y - j * x) * 1.0 / (i - x);\n\t\t\t\t\t\tif(mp.find({num, val}) == mp.end()){\n\t\t\t\t\t\t\tmp[{num, val}] = 1;\n\t\t\t\t\t\t\tres ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 货物摆放\n\n枚举、数学知识**因数**题\n\n找出2021041820210418所有的因数，从因数中找出满足条件的即可，极大的缩减了遍历范围\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<ll, ll>, ll> map;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t vector<ll> v;\n    \n    ll a = 2021041820210418;\n    ll res = 0;\n    \n    for(ll i = 1; i * i <= a; i++){\n        if(a % i == 0) {\n            v.push_back(i);    \n            if(i * i != a){\n                v.push_back(a / i);\n            }\n        }\n    }\n    \n    for(ll i = 0; i < v.size(); i++){\n        for(ll j = 0; j < v.size(); j++){\n            for(ll m = 0; m < v.size(); m++){    \n                if(v[i] * v[j] * v[m] == a) res++;\n            }\n        }\n        \n    }\n    cout << res;\n\treturn 0;\n}\n```\n\n### 路径\n\n图论、数学知识题\n\n迪杰斯特拉模板题，最小公倍数模板\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<ll, ll>, ll> map;\nint w[N], idx, h[N], ne[N], e[N], dis[N], st[N];\n\nvoid add(int x, int y, int z){\n\te[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++;\n}\n\nint fun1(int x, int y){\n\treturn y == 0 ? x : fun1(y, x % y);\n}\n\nint fun2(int x, int y){\n\treturn x / fun1(x, y) * y;\t\n}\n\nint dj(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tpriority_queue<PII, vector<PII>, greater<PII>> pq;\n\tpq.push({1, 0});\n\twhile(!pq.empty()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tint x = top.first, y = top.second;\n\t\tif(st[x]) continue;\n\t\tst[x] = 1;\n\t\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\tif(dis[j] > y + w[i]){\n\t\t\t\tdis[j] = y + w[i];\n\t\t\t\tpq.push({j, dis[j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2021] == 0x3f3f3f3f) return -1;\n    return dis[2021];\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tmemset(h, -1, sizeof h);\n\n\tfor(int i = 1; i <= 2021; i++){\n\t\tfor(int j = i + 1; j <= 2021; j++){\n\t\t\tif(j - i <= 21){\n\t\t\t\tint c = fun2(i, j);\n\t\t\t\tadd(i, j, c);\n\t\t\t\tadd(j, i, c);\t\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} \n\tcout << dj();\n\t\n\treturn 0;\n}\n```\n\n### 时间显示\n\n单位换算题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll num;\n\tcin >> num;\n\tint dv = 1000 * 3600 * 24;\n\tnum = num % dv;\n\tint sv = num / 1000;\n\tint h = sv / 3600;\n\tint m = sv % 3600 / 60;\n\tint s = sv % 3600 % 60;\n\tprintf(\"%02d:%02d:%02d\\n\", h, m, s);\n\t\n\treturn 0;\n}\n```\n\n### 砝码称重\n\nset模拟DFS遍历，巧解此题\n\n正解为动态规划\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a);\n\tset<int> s;\n\tfor(int i = 0; i < a; i++) cin >> v[i];\n\tfor(int i = 0; i < a; i++){\n\t\tset<int> ss;\n\t\tfor(int j: s){\n\t\t\tss.insert(j + v[i]);\n\t\t\tif(j - v[i] > 0) ss.insert(j - v[i]);\n\t\t\tif(v[i] - j > 0) ss.insert(v[i] - j);\n\t\t}\n\t\tfor(int j: ss){\n\t\t\ts.insert(j);\t\n\t\t}\n\t\ts.insert(v[i]);\n\t}\n\tcout << s.size() << endl;\n\n\treturn 0;\n}\n```\n\n### 杨辉三角形\n\n技巧、二分题\n\n暴力能够 40% 的分数\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nmap<PII, int> mp; \nmap<int, int> smp;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tif(a == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmp[{1, 1}] = 1;\n\tint flag = 0;\n\tll res = 1;\n\tfor(int i = 2; ;i++){\n\t\tfor(int j = 1; j <= i;j ++){\n\t\t\tint cot;\n\t\t\tif(j == 1){\n\t\t\t\tcot = 1; \n\t\t\t} else {\n\t\t\t\tcot = mp[{i - 1, j}] + mp[{i - 1, j - 1}];\n\t\t\t}\n\t\t\tres ++;\n\t\t\tmp[{i, j}] = cot;\n\t\t\tif(cot == a && smp.find(cot) == smp.end()){\n\t\t\t\tflag = 1;\n\t\t\t\tcout << res << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n### 双向排序\n\nsort暴力能够 60% 题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++) n[i] = i + 1;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tif(x == 0){\n\t\t\tsort(n, n + y, greater<int>());\n\t\t} else {\n\t\t\tsort(n + y - 1, n + a);\n\t\t}\n\n\t}\n\t\n\tfor(int i = 0; i < a; i++) cout << n[i] << \" \"; \n\treturn 0;\n}\n```\n\n","title":" 第十二届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-04-09\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 空间\n\n单位换算题\n\n1比特 = 8位\n\n256  1024  1024 / 4\n\n 卡片\n\n模拟题\n\n需要注意的的是答案是输出能够拼到多少，而不是拼完的那个数，所以需要答案  1\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint n10;\n\tforint i = 0; i <= 9; i++{\n\t\tni = 2021;\n\t}\t\n\tint idx = 1;\n\twhiletrue{\n\t\tint c = idx, flag = 0;\n\t\twhilec{\n\t\t\tifnc % 10 == 0{\n\t\t\t\tcout << idx  1 << endl;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc % 10 ;\n\t\t\tc /= 10;\n\t\t}\n\t\tifflag{\n\t\t\tbreak;\n\t\t}\n\t\tidx ++;\n\t}\n\t\n\treturn 0;\n}\n\n\n 直线\n\n模拟、数学题\n\n需要注意直线的公式：y = kx + b\n\n斜率：k = y1  y2 / x1  x2\n\n截距：b = y1  x2  y2  x1 / x2  x1\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nmap<pair<double, double, int mp;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0;\n\tforint i = 0; i < 20; i++{\n\t\tres ++;\n\t}\n\tforint i = 0; i < 21; i++{\n\t\tres ++;\n\t}\n\t\n\tforint i = 0; i < 20; i++{\n\t\tforint j = 0; j < 21; j++{\n\t\t\tforint x = i + 1; x < 20; x++{\n\t\t\t\tforint y = 0; y < 21; y++{\n\t\t\t\t\tifi = x && j = y{\n\t\t\t\t\t\tdouble num = j  y  1.0 / i  x;\t\n\t\t\t\t\t\tdouble val = i  y  j  x  1.0 / i  x;\n\t\t\t\t\t\tifmp.find{num, val} == mp.end{\n\t\t\t\t\t\t\tmp{num, val} = 1;\n\t\t\t\t\t\t\tres ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n 货物摆放\n\n枚举、数学知识因数题\n\n找出2021041820210418所有的因数，从因数中找出满足条件的即可，极大的缩减了遍历范围\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nmap<pair<ll, ll, ll map;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\t vector<ll v;\n    \n    ll a = 2021041820210418;\n    ll res = 0;\n    \n    forll i = 1; i  i <= a; i++{\n        ifa % i == 0 {\n            v.pushbacki;    \n            ifi  i = a{\n                v.pushbacka / i;\n            }\n        }\n    }\n    \n    forll i = 0; i < v.size; i++{\n        forll j = 0; j < v.size; j++{\n            forll m = 0; m < v.size; m++{    \n                ifvi  vj  vm == a res++;\n            }\n        }\n        \n    }\n    cout << res;\n\treturn 0;\n}\n\n\n 路径\n\n图论、数学知识题\n\n迪杰斯特拉模板题，最小公倍数模板\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nmap<pair<ll, ll, ll map;\nint wN, idx, hN, neN, eN, disN, stN;\n\nvoid addint x, int y, int z{\n\teidx = y, widx = z, neidx = hx, hx = idx ++;\n}\n\nint fun1int x, int y{\n\treturn y == 0 ? x : fun1y, x % y;\n}\n\nint fun2int x, int y{\n\treturn x / fun1x, y  y;\t\n}\n\nint dj{\n\tmemsetdis, 0x3f3f3f3f, sizeof dis;\n\tpriorityqueue<PII, vector<PII, greater<PII pq;\n\tpq.push{1, 0};\n\twhilepq.empty{\n\t\tauto top = pq.top;\n\t\tpq.pop;\n\t\tint x = top.first, y = top.second;\n\t\tifstx continue;\n\t\tstx = 1;\n\t\tforint i = hx; i = 1; i = nei{\n\t\t\tint j = ei;\n\t\t\tifdisj  y + wi{\n\t\t\t\tdisj = y + wi;\n\t\t\t\tpq.push{j, disj};\n\t\t\t}\n\t\t}\n\t}\n\tifdis2021 == 0x3f3f3f3f return 1;\n    return dis2021;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tmemseth, 1, sizeof h;\n\n\tforint i = 1; i <= 2021; i++{\n\t\tforint j = i + 1; j <= 2021; j++{\n\t\t\tifj  i <= 21{\n\t\t\t\tint c = fun2i, j;\n\t\t\t\taddi, j, c;\n\t\t\t\taddj, i, c;\t\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} \n\tcout << dj;\n\t\n\treturn 0;\n}\n\n\n 时间显示\n\n单位换算题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll num;\n\tcin  num;\n\tint dv = 1000  3600  24;\n\tnum = num % dv;\n\tint sv = num / 1000;\n\tint h = sv / 3600;\n\tint m = sv % 3600 / 60;\n\tint s = sv % 3600 % 60;\n\tprintf\"%02d:%02d:%02d\\n\", h, m, s;\n\t\n\treturn 0;\n}\n\n\n 砝码称重\n\nset模拟DFS遍历，巧解此题\n\n正解为动态规划\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<int va;\n\tset<int s;\n\tforint i = 0; i < a; i++ cin  vi;\n\tforint i = 0; i < a; i++{\n\t\tset<int ss;\n\t\tforint j: s{\n\t\t\tss.insertj + vi;\n\t\t\tifj  vi  0 ss.insertj  vi;\n\t\t\tifvi  j  0 ss.insertvi  j;\n\t\t}\n\t\tforint j: ss{\n\t\t\ts.insertj;\t\n\t\t}\n\t\ts.insertvi;\n\t}\n\tcout << s.size << endl;\n\n\treturn 0;\n}\n\n\n 杨辉三角形\n\n技巧、二分题\n\n暴力能够 40% 的分数\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nmap<PII, int mp; \nmap<int, int smp;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tifa == 1{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmp{1, 1} = 1;\n\tint flag = 0;\n\tll res = 1;\n\tforint i = 2; ;i++{\n\t\tforint j = 1; j <= i;j ++{\n\t\t\tint cot;\n\t\t\tifj == 1{\n\t\t\t\tcot = 1; \n\t\t\t} else {\n\t\t\t\tcot = mp{i  1, j} + mp{i  1, j  1};\n\t\t\t}\n\t\t\tres ++;\n\t\t\tmp{i, j} = cot;\n\t\t\tifcot == a && smp.findcot == smp.end{\n\t\t\t\tflag = 1;\n\t\t\t\tcout << res << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tifflag{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n 双向排序\n\nsort暴力能够 60% 题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\t\n\tcin  a  b;\n\tforint i = 0; i < a; i++ ni = i + 1;\n\twhileb {\n\t\tcin  x  y;\n\t\tifx == 0{\n\t\t\tsortn, n + y, greater<int;\n\t\t} else {\n\t\t\tsortn + y  1, n + a;\n\t\t}\n\n\t}\n\t\n\tforint i = 0; i < a; i++ cout << ni << \" \"; \n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-81","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛81\ncategory: 算法\ndate: 2024-04-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n做了几道练手题，感觉有一两道题颇有收获，于记一笔\n\n### 小辰打比赛\n\n贪心秒了\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t\n\tcin >> a >> b;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v[i];\n\t} \n\t\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < a; i++){\n\t\tif(v[i] < b) res += v[i];\n\t\telse break;\n\t} \n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### 小辰的圣剑\n\n这题卡了半天，后面发现数据范围很小，两个循环暴力拿下\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n//int a, b, x, y, res;\n//int n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll n, m, u, res = 0;\n\tcin >> n >> m >> u;\n\tvector<int> v(n), n1(n);\n\tfor(int i = 0; i < n; i++) cin >> v[i];\n\tfor(int i = 0; i < n; i++) cin >> n1[i];\n\tfor(int i = 0; i < n; i++){\n\t\tll cot = 0, lj = 0, ry = 0;\n\t\tfor(int j = i; j < n; j++){\n\t\t\tif(v[j] + lj <= m && n1[j] + ry <= u){\n\t\t\t\tcot ++;\n\t\t\t\tlj += v[j];\n\t\t\t\try += n1[j];\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = max(res, cot);\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### 陶陶学算术\n\n这题参考题解，数据范围很大，除的话会超出范围，~~我一直卡在这不知道范围问题~~\n\n我们需要对这个公式进行改变\n\nres1 = x1x2x3/y1y2y3 = A / B\n\nres2 = i1i2i3/j1j2j3 = C / D\n\n=> A * D = B * C ，将除法转为乘法并用long long存放\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot1 = 1, cot2 = 1;\n\twhile(a --){\n\t\tcin >> x >> y;\n\t\tif(x == 1) cot1 = cot1 * y % M;\n\t\telse cot2 = cot2 * y % M; \n\t}\n\tcin >> b;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tif(x == 1) cot2 = cot2 * y % M;\n\t\telse cot1 = cot1 * y % M; \n\t}\n\tcout << (cot1 == cot2 ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n```\n\n### 小辰的借钱计划\n\n这题用到数学期望，不会\n\n期望 = 1 / 符号条件的 * 符合条件的数\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> x >> y;\n\t\tint idx = 0;\n\t\tfor(int i = 1; i <= x - y; i++){\n\t\t\tif(y % i == 0 || i % y == 0){\n\t\t\t\tidx ++;\n\t\t\t}\n\t\t}\n\t\tdouble w = 0.0, ra = 1.0 / idx;\n\t\tfor(int i = 1; i <= x - y; i++){\n\t\t\tif(y % i == 0 || i % y == 0){\n\t\t\t\tw += i * ra;\n\t\t\t}\t\n\t\t}\n\t\tcout << (w > y ? \"YES\":\"NO\") << endl;\t\n\t}\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛81\n","category":[" 算法\n"],"date":" 2024-04-09\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n做了几道练手题，感觉有一两道题颇有收获，于记一笔\n\n 小辰打比赛\n\n贪心秒了\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\t\n\tcin  a  b;\n\tvector<int va;\n\tforint i = 0; i < a; i++{\n\t\tcin  vi;\n\t} \n\t\n\tsortv.begin, v.end;\n\tforint i = 0; i < a; i++{\n\t\tifvi < b res += vi;\n\t\telse break;\n\t} \n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n 小辰的圣剑\n\n这题卡了半天，后面发现数据范围很小，两个循环暴力拿下\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n//int a, b, x, y, res;\n//int nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll n, m, u, res = 0;\n\tcin  n  m  u;\n\tvector<int vn, n1n;\n\tforint i = 0; i < n; i++ cin  vi;\n\tforint i = 0; i < n; i++ cin  n1i;\n\tforint i = 0; i < n; i++{\n\t\tll cot = 0, lj = 0, ry = 0;\n\t\tforint j = i; j < n; j++{\n\t\t\tifvj + lj <= m && n1j + ry <= u{\n\t\t\t\tcot ++;\n\t\t\t\tlj += vj;\n\t\t\t\try += n1j;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = maxres, cot;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n 陶陶学算术\n\n这题参考题解，数据范围很大，除的话会超出范围，我一直卡在这不知道范围问题\n\n我们需要对这个公式进行改变\n\nres1 = x1x2x3/y1y2y3 = A / B\n\nres2 = i1i2i3/j1j2j3 = C / D\n\n= A  D = B  C ，将除法转为乘法并用long long存放\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll cot1 = 1, cot2 = 1;\n\twhilea {\n\t\tcin  x  y;\n\t\tifx == 1 cot1 = cot1  y % M;\n\t\telse cot2 = cot2  y % M; \n\t}\n\tcin  b;\n\twhileb {\n\t\tcin  x  y;\n\t\tifx == 1 cot2 = cot2  y % M;\n\t\telse cot1 = cot1  y % M; \n\t}\n\tcout << cot1 == cot2 ? \"YES\" : \"NO\" << endl;\n\treturn 0;\n}\n\n\n 小辰的借钱计划\n\n这题用到数学期望，不会\n\n期望 = 1 / 符号条件的  符合条件的数\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  x  y;\n\t\tint idx = 0;\n\t\tforint i = 1; i <= x  y; i++{\n\t\t\tify % i == 0  i % y == 0{\n\t\t\t\tidx ++;\n\t\t\t}\n\t\t}\n\t\tdouble w = 0.0, ra = 1.0 / idx;\n\t\tforint i = 1; i <= x  y; i++{\n\t\t\tify % i == 0  i % y == 0{\n\t\t\t\tw += i  ra;\n\t\t\t}\t\n\t\t}\n\t\tcout << w  y ? \"YES\":\"NO\" << endl;\t\n\t}\n\treturn 0;\n}\n\n\n"},{"filename":"13th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十三届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-04-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 九进制转十进制\n\n进制转换题\n\n2 + 2 * 9 + 2 * 9 * 9 + 2 * 9 *9 * 9\n\n### 顺子日期\n\n模拟、枚举题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \nint n[13] = {0, 31, 28, 31,30,31,30,31,31,30,31,30,31};\n\nbool fun(string kk){\n\tbool flag = 0;\n\tint idx = 1;\n\t\tfor(int j = 1; j < kk.size(); j++){\n\t\t\tif(kk[j] - '0' == kk[j - 1] - '0' + 1 ){\n\t\t\t\tidx ++;\n\t\t\t}else {\n\t\t\t\tif(idx == 3) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidx = 1;\n\t\t\t}\n\t\t}\n    \t// 注意没遍历完的也需要确认idx是否大于等于3\n\t\treturn idx >= 3 ? true : flag;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tfor(int i = 1; i <= 12; i++){\n\t\tint num = 20220000 + i * 100, idx = 0, flag = 0;\n\t\tfor(int j = 1; j <= n[i]; j++){\n\t\t\tint cot = num + j;\n\t\t\tstring kk = to_string(cot);\n\t\t\tif(fun(kk)){\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n```\n\n### 刷题统计\n\n模拟题，这题唯一需要注意的就是数据范围，需要long long类型\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll m, a, b;\n\tcin >> a >> b >> m;\n\tll kk = a * 5 + 2 * b; \n\tll kk3 = m % kk;\n\tll res = m / kk * 7;\n\tif(kk3 <= a * 5){\n\t\tres += (ll) ceil(kk3 * 1.0 / a);\n\t} else {\n\t\tres += 5 + (ll)ceil((kk3 - a * 5) * 1.0 / b);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 修剪灌木\n\n思维题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\tfor(int i = 1; i <= x; i++){\n\t\tcout << max(2 * (x - i), 2 * (i - 1)) << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 统计子矩阵\n\n前缀和、双指针题\n\n思路：先求出二维数组的前缀和，用双循环遍历每个数，此时我们需要用另一个数来比较出当前范围的和。\n\n我们可以发现若另一个数和遍历的数的范围和小于k，那么这个数的左边的数的范围和也是小于k的。于是就可以将另一个数设置在最右边，不断让这个数的列减少行增加来算出满足条件的个数，此时时间复杂度优化至O(n^3)，能过。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res = N;\nint v[501][501], n[501][501];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll k, res = 0;\n\tcin >> a >> b >> k;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> v[i][j];\t\n\t\t\tv[i][j] = v[i-1][j] + v[i][j-1] - v[i-1][j-1] + v[i][j];\n\t\t}\n\t} \n\t\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tint r = b;\n\t\t\tfor(int l = i; l <= a; l++){\n\t\t\t\twhile(r >= j && v[l][r] - v[i - 1][r] - v[l][j - 1] + v[i - 1][j - 1] > k){\n\t\t\t\t\tr --;\n\t\t\t\t}\n\t\t\t\tif(j > r){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += r - j + 1;\n\t\t\t}\n\t\t}\n\t} \n\tcout << res << endl;\t\n}\t\n```\n\n### 积木画\n\n动态规划题\n\n这题很难推出状态的转移方程\n\n假设当前点为i，用v[i]表示当前满足的个数\n\n- 若i-1全部铺满，则v[i] = v[i-1]\n- 若i-1一个都没有铺，则v[i] = v[i - 2]\n- 若i-1只铺满了一半，则v[i] = v[i - 3] * 2，同理也可以推出 v[i] = v[i - 4] * 2\n\n于是：\n\nv[i] = v[i - 1] + v[i - 2] + v[i - 3] * 2 + v[i - 4] * 2 + ... + 2 * v[1]\n\nv[i - 1] = v[i - 2] + v[i - 3] + v[i - 4] * 2 + ... + 2 * v[1]\n\n两式相减得出：**v[i] = v[i - 1] * 2 + v[i - 3]** \n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res = N;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a);\n\tv[1] = 1, v[2] = 2, v[3] = 5;  \n\tfor(int i = 4; i <= a; i++){\n\t\tv[i] = (2 * v[i - 1] % 1000000007  + v[i - 3] % 1000000007) % 1000000007;\n\t}\n\n\tcout << v[a] << endl;\n\t\n\treturn 0;\n}\t\n```\n\n### 扫雷\n\nBFS 暴力法能过 40% 的样例\n\n优化是在队列遍历的进行二分查找，~~我就不会了~~\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res;\nstruct p{\n\tint x, y, num;\n}n[N],v[N];\nint flag[N];\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    scanf(\"%d%d\",&a, &b);\n    queue<pair<int, int>> q;\n    for(int i = 0; i < a; i++){\n    \tscanf(\"%lld%lld%lld\",&n[i].x, &n[i].y, &n[i].num);\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tscanf(\"%lld%lld%lld\",&v[i].x, &v[i].y, &v[i].num);\n\t\tq.push({i, 1});\t\n\t}\n\twhile(!q.empty()){\n\t\tauto top = q.front();\n\t\tq.pop();\n\t\tint f = top.first, s = top.second;\n\t\tint xx, yy, rr;\n\t\tif(s == 1){\n\t\t\txx = v[f].x, yy = v[f].y, rr = v[f].num;\n\t\t} else {\n\t\t\txx = n[f].x, yy = n[f].y, rr = n[f].num;\n\t\t}\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tif(!flag[i] && (ll)(n[i].x - xx)*(n[i].x - xx) + (ll)(n[i].y - yy) * (n[i].y - yy) <= (ll)rr*rr){\n\t\t\t\tflag[i] = 1;\n\t\t\t\tq.push({i, 2});\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\tprintf(\"%d\", res);\n\t\t\n    return 0;\n}\n```\n\n\n\n### 李白打酒加强版\n\n记忆化搜索 + 剪枝\n\n此题不难想到用DFS，可是只用用DFS的话注意题干条件：**由于答案很大，输出模1000000007**，这时候就需要用其他条件辅助\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\nlong long res = 0;\nll n[101][101][101];\nint mod = 1000000007;\n\nint dfs(int x, int y, int num){\n    // num + a - x >  b - y 剪枝，满足当前剩余的数加上需要相乘的数必须小于需要相减的数\n    if(x > a || y > b || num < 0 || num + a - x > b - y){\n        return 0;\n    }\n    if(x == a && y == b - 1 && num == 1){\n        return 1;\n    }\n    if(n[x][y][num]){\n    \treturn n[x][y][num];\n\t}\n\tif(num > 0){\n\t\tn[x][y][num] = (dfs(x + 1, y, num * 2) % mod + dfs(x, y + 1, num - 1) % mod) % mod;\n\t} else {\n\t\tn[x][y][num] = dfs(x + 1, y, num * 2) % mod;\n\t}\n\treturn n[x][y][num];\n}\n\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> a >> b;\n    cout << dfs(0, 0, 2) << endl;\n    \n    return 0;\n}\n```\n\n","title":" 第十三届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-04-08\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 九进制转十进制\n\n进制转换题\n\n2 + 2  9 + 2  9  9 + 2  9 9  9\n\n 顺子日期\n\n模拟、枚举题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \nint n13 = {0, 31, 28, 31,30,31,30,31,31,30,31,30,31};\n\nbool funstring kk{\n\tbool flag = 0;\n\tint idx = 1;\n\t\tforint j = 1; j < kk.size; j++{\n\t\t\tifkkj  '0' == kkj  1  '0' + 1 {\n\t\t\t\tidx ++;\n\t\t\t}else {\n\t\t\t\tifidx == 3 {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidx = 1;\n\t\t\t}\n\t\t}\n    \t// 注意没遍历完的也需要确认idx是否大于等于3\n\t\treturn idx = 3 ? true : flag;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0;\n\tforint i = 1; i <= 12; i++{\n\t\tint num = 20220000 + i  100, idx = 0, flag = 0;\n\t\tforint j = 1; j <= ni; j++{\n\t\t\tint cot = num + j;\n\t\t\tstring kk = tostringcot;\n\t\t\tiffunkk{\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n\n 刷题统计\n\n模拟题，这题唯一需要注意的就是数据范围，需要long long类型\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll m, a, b;\n\tcin  a  b  m;\n\tll kk = a  5 + 2  b; \n\tll kk3 = m % kk;\n\tll res = m / kk  7;\n\tifkk3 <= a  5{\n\t\tres += ll ceilkk3  1.0 / a;\n\t} else {\n\t\tres += 5 + llceilkk3  a  5  1.0 / b;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n 修剪灌木\n\n思维题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\tforint i = 1; i <= x; i++{\n\t\tcout << max2  x  i, 2  i  1 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n 统计子矩阵\n\n前缀和、双指针题\n\n思路：先求出二维数组的前缀和，用双循环遍历每个数，此时我们需要用另一个数来比较出当前范围的和。\n\n我们可以发现若另一个数和遍历的数的范围和小于k，那么这个数的左边的数的范围和也是小于k的。于是就可以将另一个数设置在最右边，不断让这个数的列减少行增加来算出满足条件的个数，此时时间复杂度优化至On^3，能过。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res = N;\nint v501501, n501501;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll k, res = 0;\n\tcin  a  b  k;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcin  vij;\t\n\t\t\tvij = vi1j + vij1  vi1j1 + vij;\n\t\t}\n\t} \n\t\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tint r = b;\n\t\t\tforint l = i; l <= a; l++{\n\t\t\t\twhiler = j && vlr  vi  1r  vlj  1 + vi  1j  1  k{\n\t\t\t\t\tr ;\n\t\t\t\t}\n\t\t\t\tifj  r{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += r  j + 1;\n\t\t\t}\n\t\t}\n\t} \n\tcout << res << endl;\t\n}\t\n\n\n 积木画\n\n动态规划题\n\n这题很难推出状态的转移方程\n\n假设当前点为i，用vi表示当前满足的个数\n\n 若i1全部铺满，则vi = vi1\n 若i1一个都没有铺，则vi = vi  2\n 若i1只铺满了一半，则vi = vi  3  2，同理也可以推出 vi = vi  4  2\n\n于是：\n\nvi = vi  1 + vi  2 + vi  3  2 + vi  4  2 + ... + 2  v1\n\nvi  1 = vi  2 + vi  3 + vi  4  2 + ... + 2  v1\n\n两式相减得出：vi = vi  1  2 + vi  3 \n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res = N;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<int va;\n\tv1 = 1, v2 = 2, v3 = 5;  \n\tforint i = 4; i <= a; i++{\n\t\tvi = 2  vi  1 % 1000000007  + vi  3 % 1000000007 % 1000000007;\n\t}\n\n\tcout << va << endl;\n\t\n\treturn 0;\n}\t\n\n\n 扫雷\n\nBFS 暴力法能过 40% 的样例\n\n优化是在队列遍历的进行二分查找，我就不会了\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res;\nstruct p{\n\tint x, y, num;\n}nN,vN;\nint flagN;\n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n    scanf\"%d%d\",&a, &b;\n    queue<pair<int, int q;\n    forint i = 0; i < a; i++{\n    \tscanf\"%lld%lld%lld\",&ni.x, &ni.y, &ni.num;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tscanf\"%lld%lld%lld\",&vi.x, &vi.y, &vi.num;\n\t\tq.push{i, 1};\t\n\t}\n\twhileq.empty{\n\t\tauto top = q.front;\n\t\tq.pop;\n\t\tint f = top.first, s = top.second;\n\t\tint xx, yy, rr;\n\t\tifs == 1{\n\t\t\txx = vf.x, yy = vf.y, rr = vf.num;\n\t\t} else {\n\t\t\txx = nf.x, yy = nf.y, rr = nf.num;\n\t\t}\n\t\tforint i = 0; i < a; i++{\n\t\t\tifflagi && llni.x  xxni.x  xx + llni.y  yy  ni.y  yy <= llrrrr{\n\t\t\t\tflagi = 1;\n\t\t\t\tq.push{i, 2};\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\tprintf\"%d\", res;\n\t\t\n    return 0;\n}\n\n\n\n\n 李白打酒加强版\n\n记忆化搜索 + 剪枝\n\n此题不难想到用DFS，可是只用用DFS的话注意题干条件：由于答案很大，输出模1000000007，这时候就需要用其他条件辅助\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\nlong long res = 0;\nll n101101101;\nint mod = 1000000007;\n\nint dfsint x, int y, int num{\n    // num + a  x   b  y 剪枝，满足当前剩余的数加上需要相乘的数必须小于需要相减的数\n    ifx  a  y  b  num < 0  num + a  x  b  y{\n        return 0;\n    }\n    ifx == a && y == b  1 && num == 1{\n        return 1;\n    }\n    ifnxynum{\n    \treturn nxynum;\n\t}\n\tifnum  0{\n\t\tnxynum = dfsx + 1, y, num  2 % mod + dfsx, y + 1, num  1 % mod % mod;\n\t} else {\n\t\tnxynum = dfsx + 1, y, num  2 % mod;\n\t}\n\treturn nxynum;\n}\n\n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n    cin  a  b;\n    cout << dfs0, 0, 2 << endl;\n    \n    return 0;\n}\n\n\n"},{"filename":"2023-team-ladder-race","category":"aigorithm","md":{"topSummary":"\ntitle: 2023年团体程序设计天梯赛\ncategory: 算法\ndate: 2024-03-27\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### **L1-089 最好的文档**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    printf(\"Good code is its own best documentation.\"); \n    return 0;\n}\n```\n\n### **L1-090 什么是机器学习**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tres = a + b;\n\tcout << res - 16 << endl;\n\tcout << res - 3 << endl;\n\tcout << res - 1 << endl;\n\tcout << res << endl; \n\t\n\treturn 0;\n}\t\n```\n\n### **L1-091 程序员买包子**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring x;\n\tint n, m, k;\n\tcin >> n >> x >> m >> k;\n\tif(k == n){\n\t\tcout << \"mei you mai \" << x << \" de\" << endl;\n\t} else if(k == m){\n\t\tcout << \"kan dao le mai \" << x << \" de\" << endl;\n\t} else cout << \"wang le zhao mai \" << x << \" de\" << endl;\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-092 进化论**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\twhile(x--){\n\t\tint m, n, k;\n\t\tcin >> m >> n >> k;\n\t\tif(m * n == k) cout << \"Lv Yan\" << endl;\n\t\telse if(m + n == k) cout << \"Tu Dou\" << endl;\n\t\telse cout << \"zhe du shi sha ya!\" << endl; \n\t}\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-093 猜帽子游戏**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\tvector<int> v(x);\n\tfor(int i = 0; i < x; i++) cin >> v[i];\n\tint y;\n\tcin >> y;\n\twhile(y--){\n\t\tint cot = 0, flag = 1;\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tif(num == 0) cot ++;\n\t\t\tif(num != 0 && num != v[i]) flag = 0;\n\t\t}\n\t\tif(flag && cot != x) cout << \"Da Jiang!!!\" << endl;\n\t\t else cout << \"Ai Ya\" << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-094 剪切粘贴**\n\n这题是最花费时间的，难度不难，就是字符串的边界取值太折磨人了\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str;\n\tcin >> str >> a;\n\tint len = str.size();\n\twhile(a--){\n\t\tstring s1, s2;\n\t\tint m, n;\n\t\tcin >> m >> n >> s1 >> s2;\n\t\tstring sq = str.substr(m - 1, n - m + 1);\n\t\tstring res_ = str.substr(0, m - 1) + str.substr(n, len);\n\t\tstring all = s1 + s2;\n\t\tint f = res_.find(s1), s = res_.find(s2), fs = res_.find(all);\n\t\tif(fs == -1){\n\t\t\tstr = res_ + sq;\n\t\t} else {\n\t\t\tstring ss1 = res_.substr(0, fs), ss2 = res_.substr(fs + all.size(), res_.size());\n\t\t\tstr = ss1 + s1 + sq + s2 + ss2;\n\t\t}\n\t}\n\tcout << str << endl; \n    \n\treturn 0;\n}\t\n\n```\n\n### **L1-095 分寝室**\n\n这题没考虑到 `不允许单人住一间寝室` 这一条件和浮点数问题(分母为0了)。\n\n加个边界判断`i <= x - 1` 解决了浮点数问题，` a != i && b != x - i` 解决单人住一间的问题\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tres = 100010; \n\tint x, r = 0, l = 0;\n\tcin >> a >> b >> x;\n\tfor(int i = 1; i <= x - 1; i++){\n\t\tif(a % i == 0 && b % (x - i) == 0 && a != i && b != x - i){\n\t\t\tint cot = fabs(a / i - b / (x - i)); \n\t\t\tif(cot < res){\n\t\t\t\tres = cot;\n\t\t\t\tr = i, l = x - i;\n\t\t\t}\n\t\t}\n\t}\n\tif(l == 0 && r == 0) cout << \"No Solution\" << endl;\n\telse cout << r << \" \" << l << endl;\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-096 谁管谁叫爹**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\twhile(x --){\n\t\tchar res;\n\t\tint cot = 0, flag = 0;\n\t\tcin >> a >> b;\n\t\tint a_ = a, b_ = b;\n\t\twhile(a_){\n\t\t\tcot += a_ % 10;\n\t\t\ta_ /= 10;\n\t\t}\n\t\tif(b % cot == 0){\n\t\t\tres = 'B';\n\t\t\tflag ++;\n\t\t}\n\t\tcot = 0;\n\t\twhile(b_){\n\t\t\tcot += b_ % 10;\n\t\t\tb_ /= 10;\t\n\t\t}\n\t\tif(a % cot == 0){\n\t\t\tres = 'A';\n\t\t\tflag ++;\t\n\t\t} \n\t\tif(flag == 1){\n\t\t\tcout << res << endl;\n\t\t} else {\n\t\t\tcout <<  (a > b ? \"A\" : \"B\") << endl ; \n\t\t}\n\t}\n\t\n\treturn 0;\n}\t\n```\n\n### **L2-045 堆宝塔**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num = 0, maxx = 0;\n\tcin >> a;\n\tstack<int> s, s2;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++) cin >> v[i];\n\tfor(int i = 0; i < a; i++){\n\t\tif(!s.empty()){\n\t\t\tif(s.top() > v[i]) s.push(v[i]);\n\t\t\telse {\n\t\t\t\tif(s2.size()){\n\t\t\t\t\tif(s2.top() < v[i]){\n\t\t\t\t\t\ts2.push(v[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cot = 0;\n\t\t\t\t\t\twhile(s.size()){\n\t\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\t\tcot ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxx = max(maxx, cot);\n\t\t\t\t\t\tnum ++;\n\t\t\t\t\t\twhile(s2.size() && s2.top() > v[i]){\n\t\t\t\t\t\t\ts.push(s2.top());\n\t\t\t\t\t\t\ts2.pop();\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.push(v[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts2.push(v[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\tint cot = s.size();\n\tif(cot){\n\t\tnum ++;\n\t\tmaxx = max(maxx, cot);\n\t}\n\tcot = s2.size();\n\tif(cot){\n\t\tnum ++;\n\t\tmaxx = max(maxx, cot); \n\t}\n\tcout << num << \" \" << maxx << endl;\n\n \n\treturn 0;\n}\n```\n\n### **L2-046 天梯赛的赛场安排**\n\n理解题意还是能混点分的\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tint res = 0;\n\tpriority_queue<int> q;\n\tfor(int i = 0; i < a; i++){\n\t\tstring str;\n\t\tint num;\n\t\tcin >> str >> num;\n\t\tq.push(num % b);\n\t\tres += num / b;\n\t\tcout << str << \" \" << ceil(num * 1.0 / b) << endl;\n\t}\n\tint cot = 0, flag = 1;\n\twhile(q.size()){\n\t\tint num = q.top();\n\t\tq.pop();\n\t\tif(cot + num <= b){\n\t\t\tcot += num;\n\t\t\tflag = 1;\n\t\t} else {\n\t\t\tres ++;\n\t\t\tcot = num;\n\t\t\tflag = 0;\n\t\t}\n\t}\n\tif(!flag){\n\t\tres ++;\n\t}\n\tcout << res << endl;\n \n\treturn 0;\n}\n```\n\n### **L2-048 寻宝图**\n\ndfs模板题\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, flag; \nchar n[1000][1000];\nint st[1000][1000];\n\nvoid dfs(int x, int y){\n\tif(n[x][y] > '1'){\n\t\tflag = 1;\n\t}\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = ix[i] + x, yy = iy[i] + y;\n\t\tif(xx >= 0 && xx < a && yy >= 0 && yy < b && !st[xx][yy] && n[xx][yy] >= '1'){\n\t\t\tst[xx][yy] = 1;\n\t\t\tdfs(xx, yy);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tint res = 0, cot = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tfor(int j = 0; j < b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < a; i++){\n\t\tfor(int j = 0; j < b; j++){\n\t\t\tif(n[i][j] >= '1' && !st[i][j]){\n\t\t\t\tflag = 0;\n\t\t\t\tst[i][j] = 1;\n\t\t\t\tdfs(i, j);\n\t\t\t\tres ++;\n\t\t\t\tif(flag){\n\t\t\t\t\tcot ++;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\tcout << res << \" \" << cot << endl;\n\n \n\treturn 0;\n}\n```\n\n","title":" 2023年团体程序设计天梯赛\n","category":[" 算法\n"],"date":" 2024-03-27\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n L1089 最好的文档\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n    printf\"Good code is its own best documentation.\"; \n    return 0;\n}\n\n\n L1090 什么是机器学习\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tres = a + b;\n\tcout << res  16 << endl;\n\tcout << res  3 << endl;\n\tcout << res  1 << endl;\n\tcout << res << endl; \n\t\n\treturn 0;\n}\t\n\n\n L1091 程序员买包子\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring x;\n\tint n, m, k;\n\tcin  n  x  m  k;\n\tifk == n{\n\t\tcout << \"mei you mai \" << x << \" de\" << endl;\n\t} else ifk == m{\n\t\tcout << \"kan dao le mai \" << x << \" de\" << endl;\n\t} else cout << \"wang le zhao mai \" << x << \" de\" << endl;\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1092 进化论\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\twhilex{\n\t\tint m, n, k;\n\t\tcin  m  n  k;\n\t\tifm  n == k cout << \"Lv Yan\" << endl;\n\t\telse ifm + n == k cout << \"Tu Dou\" << endl;\n\t\telse cout << \"zhe du shi sha ya\" << endl; \n\t}\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1093 猜帽子游戏\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\tvector<int vx;\n\tforint i = 0; i < x; i++ cin  vi;\n\tint y;\n\tcin  y;\n\twhiley{\n\t\tint cot = 0, flag = 1;\n\t\tforint i = 0; i < x; i++{\n\t\t\tint num;\n\t\t\tcin  num;\n\t\t\tifnum == 0 cot ++;\n\t\t\tifnum = 0 && num = vi flag = 0;\n\t\t}\n\t\tifflag && cot = x cout << \"Da Jiang\" << endl;\n\t\t else cout << \"Ai Ya\" << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1094 剪切粘贴\n\n这题是最花费时间的，难度不难，就是字符串的边界取值太折磨人了\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str;\n\tcin  str  a;\n\tint len = str.size;\n\twhilea{\n\t\tstring s1, s2;\n\t\tint m, n;\n\t\tcin  m  n  s1  s2;\n\t\tstring sq = str.substrm  1, n  m + 1;\n\t\tstring res = str.substr0, m  1 + str.substrn, len;\n\t\tstring all = s1 + s2;\n\t\tint f = res.finds1, s = res.finds2, fs = res.findall;\n\t\tiffs == 1{\n\t\t\tstr = res + sq;\n\t\t} else {\n\t\t\tstring ss1 = res.substr0, fs, ss2 = res.substrfs + all.size, res.size;\n\t\t\tstr = ss1 + s1 + sq + s2 + ss2;\n\t\t}\n\t}\n\tcout << str << endl; \n    \n\treturn 0;\n}\t\n\n\n\n L1095 分寝室\n\n这题没考虑到 不允许单人住一间寝室 这一条件和浮点数问题分母为0了。\n\n加个边界判断i <= x  1 解决了浮点数问题， a = i && b = x  i 解决单人住一间的问题\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tres = 100010; \n\tint x, r = 0, l = 0;\n\tcin  a  b  x;\n\tforint i = 1; i <= x  1; i++{\n\t\tifa % i == 0 && b % x  i == 0 && a = i && b = x  i{\n\t\t\tint cot = fabsa / i  b / x  i; \n\t\t\tifcot < res{\n\t\t\t\tres = cot;\n\t\t\t\tr = i, l = x  i;\n\t\t\t}\n\t\t}\n\t}\n\tifl == 0 && r == 0 cout << \"No Solution\" << endl;\n\telse cout << r << \" \" << l << endl;\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1096 谁管谁叫爹\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\twhilex {\n\t\tchar res;\n\t\tint cot = 0, flag = 0;\n\t\tcin  a  b;\n\t\tint a = a, b = b;\n\t\twhilea{\n\t\t\tcot += a % 10;\n\t\t\ta /= 10;\n\t\t}\n\t\tifb % cot == 0{\n\t\t\tres = 'B';\n\t\t\tflag ++;\n\t\t}\n\t\tcot = 0;\n\t\twhileb{\n\t\t\tcot += b % 10;\n\t\t\tb /= 10;\t\n\t\t}\n\t\tifa % cot == 0{\n\t\t\tres = 'A';\n\t\t\tflag ++;\t\n\t\t} \n\t\tifflag == 1{\n\t\t\tcout << res << endl;\n\t\t} else {\n\t\t\tcout <<  a  b ? \"A\" : \"B\" << endl ; \n\t\t}\n\t}\n\t\n\treturn 0;\n}\t\n\n\n L2045 堆宝塔\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint num = 0, maxx = 0;\n\tcin  a;\n\tstack<int s, s2;\n\tvector<int va;\n\tforint i = 0; i < a; i++ cin  vi;\n\tforint i = 0; i < a; i++{\n\t\tifs.empty{\n\t\t\tifs.top  vi s.pushvi;\n\t\t\telse {\n\t\t\t\tifs2.size{\n\t\t\t\t\tifs2.top < vi{\n\t\t\t\t\t\ts2.pushvi;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cot = 0;\n\t\t\t\t\t\twhiles.size{\n\t\t\t\t\t\t\ts.pop;\n\t\t\t\t\t\t\tcot ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxx = maxmaxx, cot;\n\t\t\t\t\t\tnum ++;\n\t\t\t\t\t\twhiles2.size && s2.top  vi{\n\t\t\t\t\t\t\ts.pushs2.top;\n\t\t\t\t\t\t\ts2.pop;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.pushvi;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts2.pushvi;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pushvi;\n\t\t}\n\t}\n\tint cot = s.size;\n\tifcot{\n\t\tnum ++;\n\t\tmaxx = maxmaxx, cot;\n\t}\n\tcot = s2.size;\n\tifcot{\n\t\tnum ++;\n\t\tmaxx = maxmaxx, cot; \n\t}\n\tcout << num << \" \" << maxx << endl;\n\n \n\treturn 0;\n}\n\n\n L2046 天梯赛的赛场安排\n\n理解题意还是能混点分的\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tint res = 0;\n\tpriorityqueue<int q;\n\tforint i = 0; i < a; i++{\n\t\tstring str;\n\t\tint num;\n\t\tcin  str  num;\n\t\tq.pushnum % b;\n\t\tres += num / b;\n\t\tcout << str << \" \" << ceilnum  1.0 / b << endl;\n\t}\n\tint cot = 0, flag = 1;\n\twhileq.size{\n\t\tint num = q.top;\n\t\tq.pop;\n\t\tifcot + num <= b{\n\t\t\tcot += num;\n\t\t\tflag = 1;\n\t\t} else {\n\t\t\tres ++;\n\t\t\tcot = num;\n\t\t\tflag = 0;\n\t\t}\n\t}\n\tifflag{\n\t\tres ++;\n\t}\n\tcout << res << endl;\n \n\treturn 0;\n}\n\n\n L2048 寻宝图\n\ndfs模板题\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, flag; \nchar n10001000;\nint st10001000;\n\nvoid dfsint x, int y{\n\tifnxy  '1'{\n\t\tflag = 1;\n\t}\n\t\n\tforint i = 0; i < 4; i++{\n\t\tint xx = ixi + x, yy = iyi + y;\n\t\tifxx = 0 && xx < a && yy = 0 && yy < b && stxxyy && nxxyy = '1'{\n\t\t\tstxxyy = 1;\n\t\t\tdfsxx, yy;\n\t\t}\n\t}\n}\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tint res = 0, cot = 0;\n\tforint i = 0; i < a; i++{\n\t\tforint j = 0; j < b; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\n\tforint i = 0; i < a; i++{\n\t\tforint j = 0; j < b; j++{\n\t\t\tifnij = '1' && stij{\n\t\t\t\tflag = 0;\n\t\t\t\tstij = 1;\n\t\t\t\tdfsi, j;\n\t\t\t\tres ++;\n\t\t\t\tifflag{\n\t\t\t\t\tcot ++;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\tcout << res << \" \" << cot << endl;\n\n \n\treturn 0;\n}\n\n\n"},{"filename":"redis","category":"database","md":{"topSummary":"\r\ntitle: Redis知识点总结\r\ncategory: Redis,数据库\r\ndate: 2024-03-23\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n对 Redis 面试知识点进行总结，参考文章：[JavaGuide-Redis篇](https://javaguide.cn/database/redis/redis-questions-01.html)\r\n\r\n## Redis基础\r\n\r\nRedis 是一个基于内存的数据库，速写速度快，采用 KV 键值对的形式对数据进行存储。此外 Redis 还支持多种优化后的数据结构、内置了 Lua 脚本、消息队列、延时队列等强大功能\r\n\r\n### Redis 为什么访问怎么快\r\n\r\n- Redis 基于内存，内存比磁盘的访问速度快\r\n- Redis 内置多种优化后的数据结构\r\n- Redis 是单线路事件循环和 IO 多路复用\r\n- Redis 通信协议实现简单且解析高效\r\n\r\n### 分布式缓存技术选型有哪些\r\n\r\n1、Redis，生态丰富，资料齐全\r\n\r\n2、Memcached ，一开始兴起比较常用\r\n\r\n3、腾讯的 Tendis，没维护了，使用的少\r\n\r\n### Reids和Memcached的异同\r\n\r\n共同点：\r\n\r\n- 都是基于内存数据库，当作缓存使用\r\n- 都有过期策略\r\n- 性能都很高\r\n\r\n不同点：\r\n\r\n- Reids 含有多种数据结构和多种特性，能够适应更多复杂的场景\r\n- Redis 能够数据持久化\r\n- Redis 原生支持集群模式\r\n- Redis 过期数据删除采用惰性删除和定期删除，Memcached 采用惰性删除\r\n- Redis 采用单线路的多路 IO 复用模型，Memcached 采用多线程的非阻塞 IO 复用的网络模型\r\n\r\n### 为什么采用Redis\r\n\r\n1. 访问速度高：基于内存，访问速度比磁盘快\r\n2. 高并发：能够承受的请求数量远远大于数据库\r\n3. 功能全面：内置分布式锁、消息队列等功能\r\n\r\n### 常见的缓存策略\r\n\r\n1、旁路缓存\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：更新数据库，删除缓存\r\n\r\n2、 读写穿透\r\n\r\n以缓存为主要数据存储\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：先查询缓存，缓存中不存在就直接更新数据库，缓存存在就更新缓存再更新数据库（**同步更新**）\r\n\r\n3、异步缓存写入\r\n\r\n与读写穿透类似，不同之处是更新的时候只更新缓存，采用**异步批量**的方式更新数据库\r\n\r\n### Redis Module\r\n\r\n我们可以通过 Redis Module 开发自己的 Module，比如自定义分布式锁等\r\n\r\n## Redis应用\r\n\r\n### Redis 除了做缓存，还能做什么\r\n\r\n很多，比如：分布式锁、限流、消息队列、延时队列等\r\n\r\n### 如何用Redis实现一个分布式锁\r\n\r\n使用 Lua 脚本配合 Redis 实现，可结合项目说明一下\r\n\r\n### 如何用Redis实现一个消息队列\r\n\r\nRedis 2.0之前用 List 实现，缺点是实现的功能太简单了，消息确认机制等功能需要我们自己实现，更重要的是它没有广播机制，消息也只能背消费一次\r\n\r\nRedis 2.0之后用发布定于实现，解决了 List 没有广播机制的问题\r\n\r\n### 如何用Redis实现一个延时队列\r\n\r\n两种方法：Redis 过期时间监听和 Redisson 内置的延时队列\r\n\r\n第一种方法缺点：时效性差、消息会被丢失、多服务实例下消息会被重复消费\r\n\r\n## Redis数据类型\r\n\r\n### 常用数据类型有哪些\r\n\r\n五种基础数据类型：String、hash、set（集合）、list、zset（有序集合）\r\n\r\n三种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial （地理位置）\r\n\r\n### 数据类型底层实现\r\n\r\n- String：SDS（简单动态字符串）\r\n- Hash：哈希表或压缩列表\r\n- List：双向链表或压缩列表\r\n- Set：哈希表或整数集合\r\n- ZSet：压缩列表或跳表\r\n\r\n### String应用场景\r\n\r\n存放 Token、序列化对象、页面访问计数用来限流等\r\n\r\n### String与Hash存储对象对比\r\n\r\n1、String 存储的是整合对象数据，Hash 是各个字段单独存储，也可以单独修改或添加。若是需要经常修改或查询单个字段用 Hash 比较好\r\n\r\n2、String 存储比 Hash 存储更节省内存\r\n\r\n绝大部分情况下，都建议用 String 存放对象数据\r\n\r\n例如：购物车信息需要频繁改动就选用 Hash 存储比较好\r\n\r\n### Set的应用场景\r\n\r\n1、需要随机获取元素的场景：抽奖\r\n\r\n- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。\r\n\r\n- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\r\n\r\n- `SRANDMEMBER key count` : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景\r\n\r\n2、存放数据不能重复：统计文章点赞\r\n\r\n3、多个数据的交集、并集和差集：共同关注\r\n\r\n## Redis持久化机制\r\n\r\n有三种持久化方式：\r\n\r\n- 快照（RDB）\r\n- 只追加文件（AOF）\r\n- RDB 和 AOF 的混合持久化\r\n\r\n## Redis线程模型","title":" Redis知识点总结\r\n","category":[" Redis","数据库\r\n"],"date":" 2024-03-23\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n对 Redis 面试知识点进行总结，参考文章：JavaGuideRedis篇https://javaguide.cn/database/redis/redisquestions01.html\r\n\r\n Redis基础\r\n\r\nRedis 是一个基于内存的数据库，速写速度快，采用 KV 键值对的形式对数据进行存储。此外 Redis 还支持多种优化后的数据结构、内置了 Lua 脚本、消息队列、延时队列等强大功能\r\n\r\n Redis 为什么访问怎么快\r\n\r\n Redis 基于内存，内存比磁盘的访问速度快\r\n Redis 内置多种优化后的数据结构\r\n Redis 是单线路事件循环和 IO 多路复用\r\n Redis 通信协议实现简单且解析高效\r\n\r\n 分布式缓存技术选型有哪些\r\n\r\n1、Redis，生态丰富，资料齐全\r\n\r\n2、Memcached ，一开始兴起比较常用\r\n\r\n3、腾讯的 Tendis，没维护了，使用的少\r\n\r\n Reids和Memcached的异同\r\n\r\n共同点：\r\n\r\n 都是基于内存数据库，当作缓存使用\r\n 都有过期策略\r\n 性能都很高\r\n\r\n不同点：\r\n\r\n Reids 含有多种数据结构和多种特性，能够适应更多复杂的场景\r\n Redis 能够数据持久化\r\n Redis 原生支持集群模式\r\n Redis 过期数据删除采用惰性删除和定期删除，Memcached 采用惰性删除\r\n Redis 采用单线路的多路 IO 复用模型，Memcached 采用多线程的非阻塞 IO 复用的网络模型\r\n\r\n 为什么采用Redis\r\n\r\n1. 访问速度高：基于内存，访问速度比磁盘快\r\n2. 高并发：能够承受的请求数量远远大于数据库\r\n3. 功能全面：内置分布式锁、消息队列等功能\r\n\r\n 常见的缓存策略\r\n\r\n1、旁路缓存\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：更新数据库，删除缓存\r\n\r\n2、 读写穿透\r\n\r\n以缓存为主要数据存储\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：先查询缓存，缓存中不存在就直接更新数据库，缓存存在就更新缓存再更新数据库（同步更新）\r\n\r\n3、异步缓存写入\r\n\r\n与读写穿透类似，不同之处是更新的时候只更新缓存，采用异步批量的方式更新数据库\r\n\r\n Redis Module\r\n\r\n我们可以通过 Redis Module 开发自己的 Module，比如自定义分布式锁等\r\n\r\n Redis应用\r\n\r\n Redis 除了做缓存，还能做什么\r\n\r\n很多，比如：分布式锁、限流、消息队列、延时队列等\r\n\r\n 如何用Redis实现一个分布式锁\r\n\r\n使用 Lua 脚本配合 Redis 实现，可结合项目说明一下\r\n\r\n 如何用Redis实现一个消息队列\r\n\r\nRedis 2.0之前用 List 实现，缺点是实现的功能太简单了，消息确认机制等功能需要我们自己实现，更重要的是它没有广播机制，消息也只能背消费一次\r\n\r\nRedis 2.0之后用发布定于实现，解决了 List 没有广播机制的问题\r\n\r\n 如何用Redis实现一个延时队列\r\n\r\n两种方法：Redis 过期时间监听和 Redisson 内置的延时队列\r\n\r\n第一种方法缺点：时效性差、消息会被丢失、多服务实例下消息会被重复消费\r\n\r\n Redis数据类型\r\n\r\n 常用数据类型有哪些\r\n\r\n五种基础数据类型：String、hash、set（集合）、list、zset（有序集合）\r\n\r\n三种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial （地理位置）\r\n\r\n 数据类型底层实现\r\n\r\n String：SDS（简单动态字符串）\r\n Hash：哈希表或压缩列表\r\n List：双向链表或压缩列表\r\n Set：哈希表或整数集合\r\n ZSet：压缩列表或跳表\r\n\r\n String应用场景\r\n\r\n存放 Token、序列化对象、页面访问计数用来限流等\r\n\r\n String与Hash存储对象对比\r\n\r\n1、String 存储的是整合对象数据，Hash 是各个字段单独存储，也可以单独修改或添加。若是需要经常修改或查询单个字段用 Hash 比较好\r\n\r\n2、String 存储比 Hash 存储更节省内存\r\n\r\n绝大部分情况下，都建议用 String 存放对象数据\r\n\r\n例如：购物车信息需要频繁改动就选用 Hash 存储比较好\r\n\r\n Set的应用场景\r\n\r\n1、需要随机获取元素的场景：抽奖\r\n\r\n SADD key member1 member2 ...：向指定集合添加一个或多个元素。\r\n\r\n SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\r\n\r\n SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景\r\n\r\n2、存放数据不能重复：统计文章点赞\r\n\r\n3、多个数据的交集、并集和差集：共同关注\r\n\r\n Redis持久化机制\r\n\r\n有三种持久化方式：\r\n\r\n 快照（RDB）\r\n 只追加文件（AOF）\r\n RDB 和 AOF 的混合持久化\r\n\r\n Redis线程模型"},{"filename":"14th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十四届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-03-12\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 日期统计\n\n> 此题蓝桥杯官网没说清除，子序列按道理来说应该是连续的，而这个题却不是\n>\n> 思路：暴力法遍历8个数，找出符合条件的即可\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\nint a, b;\nint n[101];\n\nint v[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nset<int> s;\nint main(){\n\tint res = 0;\n\tfor(int i = 0; i < 100; i++) cin >> n[i];\n\tfor(int i = 0; i < 100; i++){\n\t\tif(n[i] == 2){\n\t\t\tfor(int i2 = i + 1; i2 < 100; i2++){\n\t\t\t\tif(n[i2] == 0){\n\t\t\t\t\tfor(int i3 = i2 + 1; i3 < 100; i3++){\n\t\t\t\t\t\tif(n[i3] == 2){\n\t\t\t\t\t\t\tfor(int i4 = i3 + 1; i4 < 100; i4++){\n\t\t\t\t\t\t\t\tif(n[i4] == 3){\n\t\t\t\t\t\t\t\t\tfor(int i5 = i4 + 1; i5 < 100; i5++){\n\t\t\t\t\t\t\t\t\t\tfor(int i6 = i5 + 1; i6 < 100; i6++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int i7 = i6 + 1; i7 < 100; i7++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int i8 = i7 + 1; i8 < 100; i8++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tint moth = n[i5] * 10 + n[i6], day = n[i7] * 10 + n[i8];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(moth >= 1 && moth <= 12 && day >= 1 && day <= v[moth]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(s.find(moth * 100 + day) == s.end()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts.insert(moth * 100 + day);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s.size() << endl;\n\t \n\n\treturn 0;\n}\n```\n\n### 01串的熵\n\n暴力枚举\n\n```c++\n#include<bits/stdc++.h>\n#include<math.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tint cot = 23333333;\n\tfor(int i = 1; i < cot; i++){\n\t\tint j = cot - i;\n\t\tdouble a = 1.0 * i / cot;\n\t\tdouble b = 1.0 * j / cot;\n\t\tdouble res = -a * log2(a) * i - b * log2(b) * j;  \t \n\t\tif(fabs(res - 11625907.5798) < 0.0001){\n\t\t\tcout << min(i, cot - i) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 冶炼金属\n\n> 唯一会做的简单题。。。\n>\n> 思路：每次循环都求出最大和最小的边界，注意考虑最大最小边界【根据题意笔画一下】\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\t\n\tint a, _max = 1e9, _min = 0;\n\tcin >> a;\n\twhile(a--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t_max = min(_max, x / y);\n\t\t_min = max(_min, x / (y + 1) + 1); \n\t}\n\tcout << _min << \" \" << _max << endl;\n\t\n\treturn 0;\n}\n```\n\n### 飞机降落\n\n> 原先第一看就使用贪心，后看题解需使用 DFS + 剪枝（原因是因为数据范围只有10）\n>\n> 思路：从下标0开始搜索，每次搜索都遍历一次数组，从第一个没遍历到的下标下手，继续搜索，这里需要用额外的数组标识是否已经遍历过了。当搜索的下标到最后时，也就是下标等于数组时，就说明能完成降落，因为如果无法完成降落，就不会进行下一次的搜索\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a, b;\nbool res = false;\nint flag[11];\n\nstruct p{\n\tint x, y, z;\n} n[11];\n\nvoid dfs(int x, int s){\n\tif(res){\n\t\treturn;\n\t}\n\tif(x == b){\n\t\tres = true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tif(!flag[i] && s <= n[i].x + n[i].y){\n\t\t\tflag[i] = 1;\n            // 此处用了一点点贪心，尽可能保证本次的开始是满足条件的\n            // 也就是必须都要满足时间是从上一次结束和这一次开始，取个最大值就行\n\t\t\tdfs(x + 1, max(s, n[i].x) + n[i].z);\n\t\t\tflag[i] = 0;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n   \tcin >> a;\n   \twhile(a--){\n   \t\tres = false;\n\t\tcin >> b;\n\t\tfor(int i = 0; i < b; i++) cin >> n[i].x >> n[i].y >> n[i].z;\n\t\tdfs(0, 0);\n\t\tif(res) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n```\n\n### 接龙数列\n\n> 最少删除数 = 总长度- 最长接龙数总长度  \n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \nint dp[10];\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tint res = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tstring num;\n\t\tcin >> num;\n\t\tint x = num[0] - '0', y = num[num.size() - 1] - '0';\n\t\tdp[y] = max(dp[x] + 1, dp[y]);\n\t\tres = max(res, dp[y]);\n\t}\n\tcout << a - res << endl;\n\n\n\treturn 0;\n}\n```\n\n### 子串简写\n\n此题唯一需要注意的是数据范围需要用 long long\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[9] = {1,-1,0,0}, iy[9] = {0,0,1,-1};\nint a, b;\nint n[5001][5001];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tstring str;\n\tchar x, y;\n\tcin >> str >> x >> y;\n\tll len = str.size(), cot = 0, res = 0;\n\tqueue<int> pq;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == x) pq.push(i);\n\t\telse if(str[i] == y){\n\t\t\tres += cot;\n\t\t\twhile(pq.size() && i - pq.front() + 1 >= a){\n\t\t\t\tcot ++;\n\t\t\t\tpq.pop();\n\t\t\t\tres ++;\n\t\t\t}\n\t\t\t\n\t\t} \n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 个人感受\n\n重温一下去年蓝桥杯省赛，依稀记得去年只做了一个C题，一些题用暴力骗分，填空题全军覆没\n\n现在任感觉难度颇高，技术有待提高\n","title":" 第十四届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-03-12\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 日期统计\n\n 此题蓝桥杯官网没说清除，子序列按道理来说应该是连续的，而这个题却不是\n\n 思路：暴力法遍历8个数，找出符合条件的即可\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\nint a, b;\nint n101;\n\nint v13 = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nset<int s;\nint main{\n\tint res = 0;\n\tforint i = 0; i < 100; i++ cin  ni;\n\tforint i = 0; i < 100; i++{\n\t\tifni == 2{\n\t\t\tforint i2 = i + 1; i2 < 100; i2++{\n\t\t\t\tifni2 == 0{\n\t\t\t\t\tforint i3 = i2 + 1; i3 < 100; i3++{\n\t\t\t\t\t\tifni3 == 2{\n\t\t\t\t\t\t\tforint i4 = i3 + 1; i4 < 100; i4++{\n\t\t\t\t\t\t\t\tifni4 == 3{\n\t\t\t\t\t\t\t\t\tforint i5 = i4 + 1; i5 < 100; i5++{\n\t\t\t\t\t\t\t\t\t\tforint i6 = i5 + 1; i6 < 100; i6++{\n\t\t\t\t\t\t\t\t\t\t\tforint i7 = i6 + 1; i7 < 100; i7++{\n\t\t\t\t\t\t\t\t\t\t\t\tforint i8 = i7 + 1; i8 < 100; i8++{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint moth = ni5  10 + ni6, day = ni7  10 + ni8;\n\t\t\t\t\t\t\t\t\t\t\t\t\tifmoth = 1 && moth <= 12 && day = 1 && day <= vmoth{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tifs.findmoth  100 + day == s.end{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts.insertmoth  100 + day;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s.size << endl;\n\t \n\n\treturn 0;\n}\n\n\n 01串的熵\n\n暴力枚举\n\nc++\ninclude<bits/stdc++.h\ninclude<math.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0;\n\tint cot = 23333333;\n\tforint i = 1; i < cot; i++{\n\t\tint j = cot  i;\n\t\tdouble a = 1.0  i / cot;\n\t\tdouble b = 1.0  j / cot;\n\t\tdouble res = a  log2a  i  b  log2b  j;  \t \n\t\tiffabsres  11625907.5798 < 0.0001{\n\t\t\tcout << mini, cot  i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n 冶炼金属\n\n 唯一会做的简单题。。。\n\n 思路：每次循环都求出最大和最小的边界，注意考虑最大最小边界【根据题意笔画一下】\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nint main{\n\t\n\tint a, max = 1e9, min = 0;\n\tcin  a;\n\twhilea{\n\t\tint x, y;\n\t\tcin  x  y;\n\t\tmax = minmax, x / y;\n\t\tmin = maxmin, x / y + 1 + 1; \n\t}\n\tcout << min << \" \" << max << endl;\n\t\n\treturn 0;\n}\n\n\n 飞机降落\n\n 原先第一看就使用贪心，后看题解需使用 DFS + 剪枝（原因是因为数据范围只有10）\n\n 思路：从下标0开始搜索，每次搜索都遍历一次数组，从第一个没遍历到的下标下手，继续搜索，这里需要用额外的数组标识是否已经遍历过了。当搜索的下标到最后时，也就是下标等于数组时，就说明能完成降落，因为如果无法完成降落，就不会进行下一次的搜索\n\nc++\ninclude<bits/stdc++.h\nusing namespace std;\nint a, b;\nbool res = false;\nint flag11;\n\nstruct p{\n\tint x, y, z;\n} n11;\n\nvoid dfsint x, int s{\n\tifres{\n\t\treturn;\n\t}\n\tifx == b{\n\t\tres = true;\n\t\treturn;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tifflagi && s <= ni.x + ni.y{\n\t\t\tflagi = 1;\n            // 此处用了一点点贪心，尽可能保证本次的开始是满足条件的\n            // 也就是必须都要满足时间是从上一次结束和这一次开始，取个最大值就行\n\t\t\tdfsx + 1, maxs, ni.x + ni.z;\n\t\t\tflagi = 0;\n\t\t}\n\t}\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n   \tcin  a;\n   \twhilea{\n   \t\tres = false;\n\t\tcin  b;\n\t\tforint i = 0; i < b; i++ cin  ni.x  ni.y  ni.z;\n\t\tdfs0, 0;\n\t\tifres cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n\n\n 接龙数列\n\n 最少删除数 = 总长度 最长接龙数总长度  \n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \nint dp10;\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tint res = 0;\n\tforint i = 0; i < a; i++{\n\t\tstring num;\n\t\tcin  num;\n\t\tint x = num0  '0', y = numnum.size  1  '0';\n\t\tdpy = maxdpx + 1, dpy;\n\t\tres = maxres, dpy;\n\t}\n\tcout << a  res << endl;\n\n\n\treturn 0;\n}\n\n\n 子串简写\n\n此题唯一需要注意的是数据范围需要用 long long\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix9 = {1,1,0,0}, iy9 = {0,0,1,1};\nint a, b;\nint n50015001;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tstring str;\n\tchar x, y;\n\tcin  str  x  y;\n\tll len = str.size, cot = 0, res = 0;\n\tqueue<int pq;\n\tforint i = 0; i < len; i++{\n\t\tifstri == x pq.pushi;\n\t\telse ifstri == y{\n\t\t\tres += cot;\n\t\t\twhilepq.size && i  pq.front + 1 = a{\n\t\t\t\tcot ++;\n\t\t\t\tpq.pop;\n\t\t\t\tres ++;\n\t\t\t}\n\t\t\t\n\t\t} \n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n 个人感受\n\n重温一下去年蓝桥杯省赛，依稀记得去年只做了一个C题，一些题用暴力骗分，填空题全军覆没\n\n现在任感觉难度颇高，技术有待提高\n"},{"filename":"nowcoder-month-88","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛88\ncategory: 算法\ndate: 2024-03-11\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n老年人康复训练第一场\n\n链接：https://ac.nowcoder.com/acm/contest/77299\n\n### 超级闪光牛可乐\n\n> 思路：只用根据最大值来判断即可\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\tint a, n;\n\tcin >> a >> n;\n\tif(n == 0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint max_ = 0;\n\tchar maxc;\n\tfor(int i = 0; i < n; i++){\n\t\tchar c;\n\t\tint x;\n\t\tcin >> c >> x;\n\t\tif(x > max_){\n\t\t\tmax_ = x;\n\t\t\tmaxc = c;\n\t\t}\n\t}\n\tint cc = ceil(a * 1.0 / max_);\n\tif(cc > 1000) cout << -1 << endl;\n\telse if (cc == 0){\n\t\tcout << maxc << endl;\n\t}\n\telse {\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < cc; i++) str += maxc;\n\t\tcout << str << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n### 人列计算机\n\n> 简单模拟\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\tchar n[6][11];\n\tfor(int i = 0; i < 5; i++){\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\tn[i][j] = str[j];\n\t\t}\n\t}\n\tif(n[2][5] == '&'){\n\t\tchar a = n[1][0], b = n[3][0];\n\t\tcout << ((a - '0') & (b - '0')) << endl;\n\t} else if(n[2][5] == '='){\n\t\tchar a = n[1][0], b = n[3][0];\n\t\tcout << ((a - '0') | (b - '0')) << endl;\n\t} else {\n\t\tchar a = n[2][0];\n\t\tcout << ((a - '0') == 1 ? 0 : 1) << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n### 时间管理大师\n\n> 简单模拟\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nstruct p{\n\tint x, y;\n}n[1001];\n\nset<pair<int, int>> s;\n\nint main(){\n\tint a, idx = 0;\n\tcin >> a;\n\twhile(a--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(y < 1){\n\t\t\ts.insert({x-1, 60 + (y - 1)});\n\t\t} else {\n\t\t\ts.insert({x, y-1});\n\t\t}\n\t\t\n\t\tif(y < 3){\n\t\t\ts.insert({x-1, 60 + (y - 3)});\n\t\t} else {\n\t\t\ts.insert({x, y-3});\n\t\t}\n\t\t\n\t\tif(y < 5){\n\t\t\ts.insert({x-1, 60 + (y - 5)});\n\t\t} else {\n\t\t\ts.insert({x, y-5});\n\t\t}\n\t\t\n\t}\n\t\n\tcout << s.size() << endl;\n\tfor(auto i: s){\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n### 我不是大富翁\n\n> 好家伙，从这就开始上强度了。一开始使用bfs和set模拟两种方法都超时；看题解需要使用二维dp。\n>\n> 思路：不断刷新数组v的状态\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\nint a, b;\n\nint main(){\n\tcin >> a >> b;\n\tvector<int> v(a), n[5001];\n\tfor(int i = 0; i < b; i++){\n\t\tcin >> n[i]; \n\t}\n\tv[0] = 1;\n\tfor(int i = 0; i < b; i++){\n\t\tvector<int> tmp(a);\n\t\tn[i] %= a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tif(v[j] == 1){\n\t\t\t\ttmp[(j + n[i]) % a] = 1;\n\t\t\t\ttmp[(j - n[i] + a) % a] = 1;\n\t\t\t}\n\t\t}\t\n\t\tv.swap(tmp);\n\t}\n\tif(v[0] == 1){\n\t\tcout << \"YES\" << endl;\n\t} else{\n\t\tcout << \"NO\" << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛88\n","category":[" 算法\n"],"date":" 2024-03-11\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n老年人康复训练第一场\n\n链接：https://ac.nowcoder.com/acm/contest/77299\n\n 超级闪光牛可乐\n\n 思路：只用根据最大值来判断即可\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nint main{\n\tint a, n;\n\tcin  a  n;\n\tifn == 0{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint max = 0;\n\tchar maxc;\n\tforint i = 0; i < n; i++{\n\t\tchar c;\n\t\tint x;\n\t\tcin  c  x;\n\t\tifx  max{\n\t\t\tmax = x;\n\t\t\tmaxc = c;\n\t\t}\n\t}\n\tint cc = ceila  1.0 / max;\n\tifcc  1000 cout << 1 << endl;\n\telse if cc == 0{\n\t\tcout << maxc << endl;\n\t}\n\telse {\n\t\tstring str = \"\";\n\t\tforint i = 0; i < cc; i++ str += maxc;\n\t\tcout << str << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n 人列计算机\n\n 简单模拟\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nint main{\n\tchar n611;\n\tforint i = 0; i < 5; i++{\n\t\tstring str;\n\t\tgetlinecin, str;\n\t\tforint j = 0; j < str.size; j++{\n\t\t\tnij = strj;\n\t\t}\n\t}\n\tifn25 == '&'{\n\t\tchar a = n10, b = n30;\n\t\tcout << a  '0' & b  '0' << endl;\n\t} else ifn25 == '='{\n\t\tchar a = n10, b = n30;\n\t\tcout << a  '0'  b  '0' << endl;\n\t} else {\n\t\tchar a = n20;\n\t\tcout << a  '0' == 1 ? 0 : 1 << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n 时间管理大师\n\n 简单模拟\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nstruct p{\n\tint x, y;\n}n1001;\n\nset<pair<int, int s;\n\nint main{\n\tint a, idx = 0;\n\tcin  a;\n\twhilea{\n\t\tint x, y;\n\t\tcin  x  y;\n\t\tify < 1{\n\t\t\ts.insert{x1, 60 + y  1};\n\t\t} else {\n\t\t\ts.insert{x, y1};\n\t\t}\n\t\t\n\t\tify < 3{\n\t\t\ts.insert{x1, 60 + y  3};\n\t\t} else {\n\t\t\ts.insert{x, y3};\n\t\t}\n\t\t\n\t\tify < 5{\n\t\t\ts.insert{x1, 60 + y  5};\n\t\t} else {\n\t\t\ts.insert{x, y5};\n\t\t}\n\t\t\n\t}\n\t\n\tcout << s.size << endl;\n\tforauto i: s{\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n 我不是大富翁\n\n 好家伙，从这就开始上强度了。一开始使用bfs和set模拟两种方法都超时；看题解需要使用二维dp。\n\n 思路：不断刷新数组v的状态\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\nint a, b;\n\nint main{\n\tcin  a  b;\n\tvector<int va, n5001;\n\tforint i = 0; i < b; i++{\n\t\tcin  ni; \n\t}\n\tv0 = 1;\n\tforint i = 0; i < b; i++{\n\t\tvector<int tmpa;\n\t\tni %= a;\n\t\tforint j = 0; j < a; j++{\n\t\t\tifvj == 1{\n\t\t\t\ttmpj + ni % a = 1;\n\t\t\t\ttmpj  ni + a % a = 1;\n\t\t\t}\n\t\t}\t\n\t\tv.swaptmp;\n\t}\n\tifv0 == 1{\n\t\tcout << \"YES\" << endl;\n\t} else{\n\t\tcout << \"NO\" << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n"},{"filename":"leetcode-hot-100","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode热题100\ncategory: 算法\ndate: 2024-02-25\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 哈希\n\n### 两数之和\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.find(target - nums[i]) != mp.end()){\n                int cc = mp[target - nums[i]];\n                if(cc == i) continue;\n                return {i, mp[target - nums[i]]};\n            }   \n        }\n        return {};\n    }\n};\n```\n\n### 字母异位词分组\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> res;\n        unordered_map<string, vector<string>> ump; \n        for(int i = 0; i < strs.size(); i ++){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            ump[str].push_back(strs[i]);\n        }\n        for (auto it = ump.begin(); it != ump.end(); it ++) {\n            res.push_back(it->second);\n        }\n        return res;\n    }\n};\n```\n\n### 最长连续序列\n\n> 思路：先存入set，再判断是否连续\n>\n> 知识点：set.count()用于判断set中是否存在某个值\n\n```java\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> s;\n        int res = 0, cot = 1;\n        for(int i: nums) s.insert(i);\n        for(int i: s){\n           if(s.count(i - 1)){\n               cot ++;\n           } else {\n               cot = 1;\n           }\n            res = max(res, cot);\n        }\n        return res;\n    }\n};\n```\n\n## 双指针\n\n### 移动零\n\n> 思路：一个指针指向0的下标，一个指向非0下标，不断向后移，遇到非0就交换标记的0的那个数\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int len = nums.size(), l = 0, r = 0;\n        while(r < len){\n            if(nums[r]){\n                swap(nums[l], nums[r]);\n                l ++;\n            }\n            r ++;\n        }\n    }\n};\n```\n\n### 盛最多水的容器\n\n> 思路：一个指针指向左端点，一个指针指向右端点，不断向中间靠拢，每次靠拢都计算一下左右圈起来的面积；若左端点长度小， 就+1，否则右端点就减一\n\n```c++\nclass Solution {\npublic:\n    int maxArea(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1, res = 0;\n        for(int i: nums){\n            int num = 0;\n            if(nums[l] < nums[r]){\n                num = (r - l) * nums[l];\n                l ++;\n            } else {\n                num = (r - l) * nums[r];\n                r --; \n            }\n            res = max(num, res);\n        }\n        return res;\n    }\n};\n```\n\n### 三数之和\n\n> 思路：先需要排序，再来两重循环，要使a+b+c=0，a,b已经确定了，就差c，让c从往前遍历，因为是不断递增的所以a<b<c ，第二次循环b1时，b1>b，所以c1必须小于c才能使得总和为0。满足这个特性，我们就可以用双指针解决。虽然第二重循环中有个for循环，但其实它的循环是对第二重循环遍历r生效的，所以并不影响总的时间复杂度为0(N^2)。\n\n```java\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> res;\n        int len = nums.size();\n        sort(nums.begin(), nums.end());\n        for(int i = 0; i < len; i++){\n            // 需要和上次不同\n            if(i > 0 && nums[i] == nums[i -1]){\n                continue;\n            }\n            int r = len - 1;\n            for(int j = i + 1; j < len; j ++){\n                // 需要和上次不同\n                if(j > i + 1 && nums[j] == nums[j - 1]){\n                    continue;\n                } \n                // 不断相减，找到满足和接近0的r下标\n                while(j < r && nums[i] + nums[j] + nums[r] > 0){\n                    r --;\n                }\n                // j和r下标重合了，说明后续的循环是无效的无需遍历了\n                if(r == j){\n                    break;\n                }\n                if(nums[i] + nums[j] + nums[r] == 0){\n                    res.push_back({nums[r], nums[i], nums[j]});\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 接雨水\n\n> 思路：先从左边考虑，从左往右不断遍历，维护一个左端最大值，若小于这个最大值，就用差算出需要接的雨水。但如果一直这样维护到右半端会出问题【因为可能不知道右端是否存在边，若右边根本就没有边就无需遍历了】，右半端需要维护右端的最大值。所以就左右一起维护往中间靠拢，期间不断维护左右端点的最大值。\n\n```java\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int l = 0, r = height.size() - 1, rmax = 0, lmax = 0, res = 0;\n        while(l < r){\n            lmax = max(lmax, height[l]);\n            rmax = max(rmax, height[r]);\n            if(height[l] < height[r]){\n                res += lmax - height[l];\n                l ++;\n            } else {\n                res += rmax - height[r];\n                r --;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 滑动窗口\n\n### 无重复字符的最长子串\n\n> 思路：依次向右遍历，遇到没出现过的字符写入map中，若出现过就不断弹出队列，直到弹出的字符与当前遍历到的字符一致未知，并且不断维护队列的最大值。最后也别忘了维护最大值，防止出现都是不一致的字符的情况\n\n```java\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        queue<char> q;\n        map<char, int> mp;\n        int res = 0;\n        for(int i = 0; i < s.size(); i++){\n            if(!mp[s[i]]){\n                mp[s[i]] = 1;\n                q.push(s[i]);\n            } else{\n                int len = q.size();\n                res = max(res, len);\n                while(q.size() && q.front() != s[i]){\n                    mp[q.front()] = 0;\n                    q.pop();\n                }\n                q.pop();\n                q.push(s[i]);\n            }\n        }\n        int len = q.size();\n        res = max(res, len);\n        return res;\n    }\n};\n```\n\n### 找到字符串中所有字母异位词\n\n> 思路：用vector来维护字符串中每个字符的个数，若确认两个字符串是一致，则vector也是一样的，用滑动窗口不断右遍历来维护vector\n>\n> 知识点：vector之间可以相等来判断是否一致；想用vector下标法之前必须指定vector个数【前提是该下标要存在】\n\n```java\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int len1 = s.size(), len2 = p.size();\n        if(len1 < len2){\n            return vector<int>();\n        }\n        vector<int> v1(26);\n        vector<int> v2(26);\n        vector<int> res;\n        for(int i = 0; i < len2; i++){\n            v1[s[i] - 'a'] ++;\n            v2[p[i] - 'a'] ++;\n        }\n        if(v1 == v2){\n            res.push_back(0);\n        }\n        for(int i = 0; i < len1 - len2; i++){\n            v1[s[i] - 'a'] --;\n            v1[s[i + len2] - 'a'] ++;\n            if(v1 == v2){\n                res.push_back(i + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 字串\n\n### 和为 K 的子数组\n\n> 思路：用map存放前缀和的各个值，循环遍历一次每次就判断当前的前缀和的值-k是否在map中存在，存在就加一\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int, int> ump;\n        ump[0] = 1;\n        int res = 0, cot = 0;\n        for(int i: nums){\n            cot += i;\n            if(ump.find(cot - k) != ump.end()){\n                res += ump[cot - k];\n            }\n            ump[cot] ++;\n        }\n        return res;\n    }\n};\n```\n\n### 滑动窗口最大值\n\n> 思路：用双端队列维护一个单调队列，每次都会判断队列的尾部是否比当前的nums[i]小，小的话就需要弹出，因为只要有这个元素在，前面的元素永远也不是最大的一个。\n>\n> 知识点：单调队列\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        // 存放下标\n        deque<int> q;\n        vector<int> v;\n        for(int i = 0; i < nums.size(); i++){\n            // 当队列最后一个值小于当前nums[i]时，需要弹出末尾的元素\n            // 因为只要有这个元素在，前面的元素永远也不是最大的一个\n            while(q.size() && nums[q.back()] < nums[i]) q.pop_back();\n            q.push_back(i);\n            // 当超过队列的元素的时候需要弹出队列头\n            if(i - q.front() >= k) q.pop_front();\n            // 当下标超过规定的k的时候就代表可以进行计算\n            if(i >= k - 1) v.push_back(nums[q.front()]);   \n        }\n        return v;\n    }\n};\n```\n\n## 普通数组\n\n### 最大子数组和\n\n> 思路：每次遍历都需要前缀和的值加上当前的值和当前的值进行比较，选出最大的值赋值给前缀和值\n>\n> 知识点：前缀和\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int res = nums[0], cot = nums[0];\n        for(int i = 1; i < nums.size(); i++){\n            cot = max(nums[i], cot + nums[i]);\n            res = max(res, cot);\n        }\n        return res;\n    }\n};\n```\n\n### 合并区间\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<vector<int>> res;\n        sort(intervals.begin(), intervals.end());\n        int len = intervals.size(), minL = intervals[0][0], minR = intervals[0][1];\n        for(int i = 1; i < len; i++){\n            int l = intervals[i][0], r = intervals[i][1];\n            if(l > minR){\n                res.push_back({minL, minR});\n                minL = l;\n            }\n            minR = max(minR, r);\n        }\n        res.push_back({minL, minR});\n        return res;\n    }\n};\n```\n\n### 轮转数组\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int len = nums.size();\n        unordered_map<int, int> mp;\n        for(int i = 0; i < len; i++){\n            mp[i] = nums[i];\n        }\n        for(int i = 0; i < len; i++){\n            nums[(i + k) % len] = mp[i];\n        }\n    }\n};\n```\n\n### 除自身以外数组的乘积\n\n```c++\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int all = nums[0], is = 0, len = nums.size();\n        vector<int> res;\n        if(all == 0){\n            is ++;\n            all = 1;\n        }\n        for(int i = 1; i < len; i++){\n            if(nums[i] == 0) {\n                is ++;\n                continue;\n            }\n            all *= nums[i];\n        }\n        for(int i: nums){\n            if(i == 0){\n                if(is > 1) res.push_back(0);\n                else res.push_back(all);\n            } else {\n                if(is == 1) res.push_back(0);\n                else if(is > 1) res.push_back(0);\n                else res.push_back(all / i);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 缺失的第一个正数\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int res = -100000000, minNum = 0;\n        unordered_map<int, int> ump;\n        priority_queue<int, vector<int>, greater<int>> pq;\n        set<int> s;\n        for(int i: nums) {\n           if(i > 0) s.insert(i);\n        }\n        for(int i: s) {\n            pq.push(i);\n        }\n        int idx = 1;\n        if(pq.size() && pq.top() == 1){\n            while(pq.size()){\n                pq.pop();\n                if(pq.top() != ++idx){\n                    break;\n                } \n            }\n        }\n        return idx;\n\n    }\n};\n```\n\n## 图论\n\n### 岛屿的数量\n\n> 思路：采用DFS遍历，将每个遍历到的为1的点设置标记，下次遍历的时候只遍历没标记的点；把标记的区域数量相加就是结果\n>\n> 知识点：DFS\n\n```c++\nclass Solution {\npublic:\n    vector<vector<char>> num;\n    int lenx, leny;\n    int flag[301][301];\n    int ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    void dfs(int x, int y){\n        if(num[x][y] == '0'){\n            return;\n        }\n        for(int i = 0; i < 4; i++){\n            int _x = ix[i] + x, _y = iy[i] + y;\n            if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && !flag[_x][_y]){\n                flag[_x][_y] = 1;\n                dfs(_x, _y);\n            }\n        }\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int cot = 0;\n        num = grid;\n        lenx = num.size(), leny = grid[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(!flag[i][j] && grid[i][j] == '1'){\n                    dfs(i, j);\n                    cot ++;\n                }\n            }\n        }\n        return cot;\n    }\n};\n```\n\n### 腐烂的橘子\n\n> 思路：先将每个腐烂的橘子加入到队列中，再进行BFS遍历；这里遍历有个关键点就是只遍历没有腐烂的句子，已腐烂的句子无需遍历，因为已经腐烂的句子也会进行传播，而且他的传播用时比现在的短\n>\n> 知识点：多源BFS\n\n```c++\nclass Solution {\npublic:\n    int lenx = 0, leny = 0, cot = 0;\n    int flag[11][11], ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    queue<pair<int, int>> q;\n    int bfs(vector<vector<int>>& grid){\n        int res = 0;\n        while(q.size()){\n            auto top = q.front();\n            q.pop();\n            int xx = top.first, yy = top.second;\n            for(int i = 0; i < 4; i++){\n                int _x = ix[i] + xx, _y = iy[i] + yy;\n                if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && grid[_x][_y] == 1 && !flag[_x][_y]){\n                    flag[_x][_y] = flag[xx][yy] + 1;\n                    q.push({_x, _y});\n                    if(grid[_x][_y] == 1){\n                        cot --;\n                        res = flag[_x][_y];\n                        if(!cot){\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return cot == 0 ? res : -1;\n    }\n    int orangesRotting(vector<vector<int>>& grid) {\n        lenx = grid.size(), leny = grid[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(grid[i][j] == 2){\n                    q.push({i, j});\n                    flag[i][j] = 0;\n                } else if(grid[i][j] == 1){\n                    cot ++;\n                }\n            }\n        }\n        return bfs(grid);\n    }\n};\n```\n\n### 课程表\n\n> 思路：用n来标志状态（0表示未选，1表示正在选，2表示已选），见注释\n>\n> 知识点：DFS\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> num;\n    vector<int> n;\n    bool flag = true;\n    void dfs(int x) {\n        // 标记正在选\n        n[x] = 1;\n        // 假设当前x已经正在选，遍历需要依赖它的课程编号\n        for(int i: num[x]){\n            // 未选就遍历\n            if(!n[i]){\n                dfs(i);\n                if(!flag){\n                    return;\n                }\n             // 正在选说明出现重复依赖，就直接return\n            } else if(n[i] == 1){\n                flag = false;\n                return;\n            }\n        }\n        // 标记已选\n        n[x] = 2;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int len = prerequisites.size();\n        num.resize(numCourses);\n        n.resize(numCourses);\n        for (int i = 0; i < len; i++) {\n            int _1 = prerequisites[i][0], _2 = prerequisites[i][1];\n            num[_2].push_back(_1);\n        }\n        for (int i = 0; i < numCourses; i++) {\n           \t// 只遍历未选的\n            if(!n[i]){\n                dfs(i);\n            }\n        }\n        return flag;\n    }\n};\n```\n\n## 回溯\n\n### 全排列\n\n> 知识点：回溯\n\n```c++\nclass Solution {\npublic:\n    vector<int> num;\n    vector<vector<int>> res;\n    int len = 0;\n    int n[7];\n    void dfs(int x, vector<int> v){\n        if(v.size() == len){\n            res.push_back(v);\n            return;\n        }\n        for(int i = 0; i < len; i++){\n            if(!n[i]){\n                n[i] = 1;\n                v.push_back(num[i]);\n                dfs(i, v);\n                n[i] = 0;\n                v.pop_back();\n            }\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        num = nums;\n        len = nums.size();\n        dfs(0, {});\n        return res;\n    }\n};\n```\n\n### 子集\n\n```c++\nclass Solution {\npublic:\n    vector<int> num;\n    int len = 0;\n    vector<vector<int>> res;\n    void dfs(int x, vector<int> v){\n        if(x == len){\n            res.push_back(v);\n            return;\n        }\n        dfs(x + 1, v);\n        v.push_back(num[x]);\n        dfs(x + 1, v);\n        v.pop_back();\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        num = nums;\n        len = nums.size();\n        dfs(0, {});\n        return res;\n    }\n};\n```\n\n### 电话号码的字母组合\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, vector<char>> ump;\n    vector<string> res;\n    int len = 0;\n    void init(){\n        ump['2'] = {'a','b','c'};\n        ump['3'] = {'d','e','f'};\n        ump['4'] = {'g','h','i'};\n        ump['5'] = {'j','k','l'};\n        ump['6'] = {'m','n','o'};\n        ump['7'] = {'p','q','r','s'};\n        ump['8'] = {'t','u','v'};\n        ump['9'] = {'w','x','y','z'};\n    }\n    void dfs(int x, string str, string digit){\n        if(x == len){\n            res.push_back(str);\n            return;\n        }\n        char c = digit[x];\n        for(int i = 0; i < ump[c].size(); i++){\n            dfs(x + 1, str + ump[c][i], digit);\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        len = digits.size();\n        if(len == 0){\n            return {};\n        }\n        init();\n        dfs(0, \"\", digits);\n\n        return res;\n    }\n};\n```\n\n### 组合总和\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> num;\n    int len = 0;\n    void dfs(int x, int n, vector<int> v, int total){\n        if(n > total){\n            return;\n        }\n        if(n == total){\n            res.push_back(v);\n            return;\n        }\n        v.push_back(num[x]);\n        dfs(x, n + num[x], v, total);\n        v.pop_back();\n        if(x + 1 < len){\n            dfs(x + 1, n, v, total);\n        }\n       \n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        len = candidates.size();\n        num = candidates;\n        dfs(0, 0, {}, target);\n        return res;\n    }\n};\n```\n\n### 括号生成\n\n```c++\nclass Solution {\npublic:\n    vector<string> res;\n    void dfs(int x, int y, string str, int n){\n        if(x > n || y > n){\n            return;\n        }\n        if(x == n){\n            res.push_back(str);\n            return;\n        }\n        dfs(x, y + 1, str + \"(\", n);\n        if(x < y){\n            dfs(x + 1, y, str + \")\", n);\n        }\n\n    }\n    vector<string> generateParenthesis(int n) {\n        dfs(0, 0, \"\", n);\n        return res;\n    }\n};\n```\n\n### 单词搜索\n\n```c++\nclass Solution {\npublic:\n    vector<vector<char>> num;\n    int lenx = 0, leny = 0;\n    bool flag = false;\n    int f[7][7];\n    int ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    bool find(string s, string w){\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] != w[i]) return false;\n        }\n        return true;\n    }\n    void dfs(int x, int y, string s, string w, int f[][7]){\n        if(s == w){\n            flag = true;\n            return;\n        }\n        for(int i = 0; i < 4; i++){\n            int _x = ix[i] + x, _y = iy[i] + y;\n            if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && !f[_x][_y] && find(s + num[_x][_y], w)){\n                f[_x][_y] = 1;\n                dfs(_x, _y, s + num[_x][_y], w, f);\n                f[_x][_y] = 0;\n            }\n        }\n        \n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        num = board;\n        lenx = board.size(), leny = board[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(board[i][j] == word[0]){\n                    memset(f, 0, sizeof f);\n                    string ss = \"\";\n                    ss.append(1, word[0]);\n                    f[i][j] = 1;\n                    dfs(i, j, ss, word, f);\n                    if(flag){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n### 分割回文串\n\n> 思路：用二维数组n来标记i，j是否是回文串，先将n全部赋值为1，找出不是回文串的区间。最后用BFS找出回文串\n>\n> 知识点：BFS，动态规划\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> res;\n    int n[17][17];\n    int len = 0;\n    void dfs(string s, int x, vector<string> v){\n        if(x > len) return;\n        if(x == len){\n            res.push_back(v);\n            return;\n        }\n        for(int i = x; i < len; i++){\n            if(n[x][i]){\n                v.push_back(s.substr(x, i - x + 1));\n                dfs(s, i + 1, v);\n                v.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> partition(string s) {\n        len = s.size();\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++){\n                n[i][j] = 1;\n            }\n        }\n        for(int i = 0; i < len; i++){\n            for(int j = i - 1; j >= 0; j--){\n                n[j][i] = s[i] == s[j] && n[j + 1][i - 1];\n            }\n        }\n        dfs(s, 0, {});\n        return res;\n    }\n};\n```\n\n### N 皇后\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> res;\n    vector<char> v;\n    // 分别表示45°，-45°，y轴标志数组，看是否已经存在\n    int fx[100], fy[100], line[100];\n    void dfs(int x, int n, vector<string> strv){\n        if(x == n){\n            res.push_back(strv);\n            return;\n        }\n        for(int i = 0; i < n; i++){\n            if(!line[i] && !fx[i - x + n] && !fy[i + x]){\n                fy[i + x] = 1;\n                fx[i - x + n] = 1;\n                line[i] = 1;\n                strv[x][i] = 'Q';\n                dfs(x + 1, n, strv);\n                fy[i + x] = 0;\n                fx[i - x + n] = 0;\n                line[i] = 0;\n                strv[x][i] = '.';\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<string> strv;\n        for(int i = 0; i < n; i++){\n            string str = \"\";\n            for(int j = 0; j < n; j++){\n                str += '.';\n            }\n            strv.push_back(str);\n        }\n        dfs(0, n, strv);\n        return res;\n    }\n};\n```\n\n### 零钱兑换\n\n> 知识点：BFS + 记忆化搜索 + 剪枝\n\n```c++\nclass Solution {\npublic:\n    int bfs(vector<int>& coins, int amount){\n        int len = coins.size(), res = INT_MAX;\n        queue<pair<long long, int>> q;\n        unordered_set<long long> s;\n        q.push({0, 0});\n        while(q.size()){\n            auto top = q.front();\n            q.pop();\n            long long x = top.first;\n            int y = top.second;\n            if(x > amount){\n                // 剪枝\n                continue;\n            } else if(x == amount){\n                res = min(res, y);\n                continue;\n            }\n            for(int i = 0; i < len; i++){\n                long long cc = x + coins[i];\n                // 记忆化搜索，已经搜索过了的不再重复记录\n                if(s.find(cc) == s.end()){\n                    s.insert(cc);\n                    q.push({cc, y + 1});\n                }\n            }\n        }\n        return res == INT_MAX ? -1 : res;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        return bfs(coins, amount);\n    }\n};\n```\n\n## 二分\n\n**二分模板**\n\n```c++\n// 左边距\nint get_l(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n        int mid = (l + r ) / 2;\n        if(n[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\nint get_r(int x){\n   int l = 0, r = a - 1;\n   while(l < r){\n   \tint mid = (l + r + 1) / 2;\n       if(n[mid] <= x) l = mid;\n       else r = mid - 1;\n   }\n   return r;\n}\n```\n\n### 搜索插入位置\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size();\n        while(l < r){\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n### 在排序数组中查找元素的第一个和最后一个位置\n\n> 左右边距模板题\n\n```c++\nclass Solution {\npublic:\n    int len = 0;\n    int left(vector<int>& nums, int target){\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l >= 0 && l < len && nums[l] == target ? l : -1;\n    }\n    int right(vector<int>& nums, int target){\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = l + r + 1 >> 1;\n            if(nums[mid] <= target) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return r >= 0 && r < len && nums[r] == target ? r : -1;\n    }\n    vector<int> searchRange(vector<int>& nums, int target) {\n        len = nums.size();\n        return {left(nums, target), right(nums, target)};\n    }\n};\n```\n\n### 搜索二维矩阵\n\n> 思路：将二维转为一维，再用二分查找\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int lenx = matrix.size(), leny = matrix[0].size();\n        vector<int> v;\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                v.push_back(matrix[i][j]);\n            }\n        }\n        int l = 0, r = v.size() - 1;\n        while(l < r){\n            int mid = l + r >> 1;\n            if(v[mid] >= target){\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return (l >= 0 && l < v.size() && v[l] == target) ? true : false;\n    }\n};\n```\n\n### 搜索旋转排序数组\n\n> 思路：中间值与第一个值比较便能知道在左区间还是在右区间，分别在区间内进行讨论即可\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1;\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] >= nums[0]){\n                if(nums[mid] > target && nums[0] <= target){\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else{\n                if(nums[mid] < target && nums[0] > target){\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```\n\n### 寻找旋转排序数组中的最小值\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] >= nums[0]){\n                if(nums[mid] > nums[len - 1]) l = mid + 1;\n                else r = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n\n## 栈\n\n### 有效的括号\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> ss;\n        bool flag = false;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '(' || s[i] == '[' || s[i] == '{') ss.push(s[i]);\n            else {\n                if(ss.size() && ss.top() == '(' && s[i] == ')') ss.pop();\n                else if(ss.size() && ss.top() == '{' && s[i] == '}') ss.pop();\n                else if(ss.size() && ss.top() == '[' && s[i] == ']') ss.pop();\n                else return false;\n            }\n        }\n        return ss.size() == 0 ? true: false;\n    }\n};\n```\n\n### 字符串解码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> ss;\n        stack<int> cc;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] >= '0' && s[i] <= '9') {\n               int q = i, num = 0;\n               while(s[q] >= '0' && s[q] <= '9'){\n                    num = num * 10 + s[q] - '0';\n                    q ++;\n               }\n               cc.push(num);\n               i = q - 1;\n            }\n            else {\n                if(s[i] == ']'){\n                    string str = \"\", rstr = \"\";\n                    while(ss.size()){\n                        if(ss.top() == \"[\") {\n                            ss.pop();\n                            break;\n                        }\n                        str = ss.top() + str;\n                        ss.pop();\n                    }\n                    int cot = cc.top();\n                    cc.pop();\n                    for(int j = 0; j < cot; j++) rstr += str;\n                    ss.push(rstr);\n\n                }\n                else{\n                    string cstr = \"\";\n                    cstr.append(1, s[i]);\n                    ss.push(cstr);\n                }\n            }\n        }\n        string res = \"\";\n        while(ss.size()){\n            res = ss.top() + res;\n            ss.pop();\n        }\n        return res;\n    }\n};\n```\n\n### 每日温度\n\n> 思路：维护一个递减的单调栈\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int len = temperatures.size();\n        stack<int> s;\n        vector<int> res(len, 0);\n        for(int i = 0; i < len; i++){\n            while(s.size() && temperatures[s.top()] < temperatures[i]){\n                res[s.top()] = i - s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n        return res;\n        \n    }\n};\n```\n\n## 堆\n\n### 数组中的第K个最大元素\n\n> 知识点：优先队列\n\n```c++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int idx = 0, res = 1;\n        priority_queue<int, vector<int>, less<int>> pq;\n        for(int i = 0; i < nums.size(); i++){\n            pq.push(nums[i]);\n        }\n        while(pq.size()){\n            int top = pq.top();\n            idx ++;\n            pq.pop();\n            if(idx == k){\n                res = top;\n                break;\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 前 K 个高频元素\n\n> 知识点：并查集\n\n```c++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n[100010];\n    unordered_map<int, int> mp;\n    static bool cmp(p a1, p b1){\n        return a1.y > b1.y;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        int len = nums.size();\n        vector<int> res;\n        for(int i = 0; i < len; i++){\n            int index = i;\n            if(mp.find(nums[i]) != mp.end()){\n                index = mp[nums[i]];\n            }\n            n[index].x = nums[index];\n            n[index].y ++;\n            mp[nums[i]] = index;\n        }\n        sort(n, n + len, cmp);\n        for(int i = 0; i < k; i++){\n            res.push_back(n[i].x);\n        }\n        return res;\n    }\n};\n```\n\n## 贪心\n\n### 买卖股票的最佳时机\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size(), maxx = 0, res = 0;\n        vector<int> v(len);\n        for(int i = len - 1; i >= 0; i--){\n            maxx = max(prices[i], maxx);\n            v[i] = maxx;\n        }\n        for(int i = 0; i < len; i++){\n            res = max(res, v[i] - prices[i]);\n        }\n        return res;\n    }\n};\n```\n\n### 跳跃游戏\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int len = nums.size(), maxx = 0;\n        vector<bool> v(len, false);\n        for(int i = 0; i < len; i++){\n            if(i > maxx){\n                return false;\n            }\n            maxx = max(maxx, i + nums[i]);\n            v[i] = true;\n        }\n        return v[len - 1];\n    }a\n};\n```\n\n### <u>* 跳跃游戏 II</u>\n\n```c++\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int len = nums.size(), maxx= 0, end = 0, res = 0;\n        // * 循环遍历到 len - 1\n        for(int i = 0; i < len - 1; i++){ \n            maxx = max(maxx, nums[i] + i);\n            if(end == i){\n                end = maxx;\n                res ++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 划分字母区间\n\n```c++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n[27];\n    vector<int> partitionLabels(string s) {\n        vector<int> res;\n        int len = s.size();\n        for(int i = 0; i < len; i++){\n            n[s[i] - 'a'].x = min(n[s[i] - 'a'].x, i);\n            n[s[i] - 'a'].y = max(n[s[i] - 'a'].y, i);\n        }\n        int minL = 0, maxL = 0;\n        for(int i = 0; i < len; i++){\n            maxL = max(n[s[i] - 'a'].y, maxL);\n            if(maxL == i){\n                res.push_back(maxL - minL + 1);\n                minL = i + 1;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 动态规划\n\n### 爬楼梯\n\n> 思路：斐波拉且数列\n\n```c++\nclass Solution {\npublic:\n    int nums[46];\n    int climbStairs(int n) {\n        nums[0] = 1;\n        nums[1] = 1;\n        for(int i = 2; i <= n; i++){\n            nums[i] = nums[i - 1] + nums[i - 2]; \n        }\n        return nums[n];\n    }\n};\n```\n\n### 杨辉三角\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> res(numRows);\n        res[0] = {1};\n        for(int i = 1; i < numRows; i++){\n            vector<int> v(i + 1, 1);\n            for(int j = 1; j <= i - 1; j++){\n                v[j] = res[i - 1][j] + res[i - 1][j - 1]; \n            }\n            res[i] = v;\n        }\n        return res;\n    }\n};\n```\n\n### 打家劫舍\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size(), res = 0;\n        vector<int> v(len + 1);\n        for(int i = 1; i <= len; i++){\n            v[i] = nums[i - 1];\n            res = max(v[i], res);\n        }\n        for(int i = 3; i <= len; i++){    \n            v[i] = v[i] + max(v[i - 2], v[i - 3]);\n            res = max(res, v[i]);\n        }\n        return res;\n\n    }\n};\n```\n\n### 完全平方数\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> v(n + 1);\n        v[1] = 1;\n        for(int i = 2; i <= n; i++){\n            int num = INT_MAX;\n            for(int j = 1; j * j <= i; j++){\n                // 此处为关键点，从完全平方数开始找，找出想要最小凑出完全平凡数的数的结果\n                num = min(num, v[i - j * j]);\n            }\n            // 最后加上完全平凡数的结果1\n            v[i] = num + 1;\n        }\n        return v[n];\n    }\n};\n```\n\n\n\n\n\n## 常用算法总结\n\n- 二分\n\n- 哈希\n\n- 双指针\n\n- 思维\n\n- 模拟\n\n- 贪心\n\n- 前缀和(一维、二维)，后缀和\n\n- 队列\n  - 滑动窗口[双端队列]\n  - 优先队列\n  \n- 栈\n  - 单调栈\n\n- 搜索\n  - DFS\n  - BFS\n  - 多源BFS\n\n- 动态规划\n\n- 数学知识\n\n  - 哈夫顿距离：d(i,j)=|xi-xj|+|yi-yj|\n\n    - 哈夫顿距离转为切比雪夫距离：|xi-xj| + |yi-yj| =  max(|x1'-x2'|, |y1'-y2'|)\n\n      原坐标(x, y)与(x', y')的关系：(x', y') = (x + y, y - x)\n\n  - 欧氏距离：d(i,j)=(xi-xj) ^ 2 + (yi - yj) ^ 2\n\n  - 直线公式：y = (y2-y1)/(x2-x1) * x - (x2 * y1 - x1 * y2)/(x2-x1)\n  \n  - 质数\n  \n  - 因数\n  \n  - 容斥原理\n  \n- 图论\n\n  - 迪杰斯特拉\n\n","title":" Leetcode热题100\n","category":[" 算法\n"],"date":" 2024-02-25\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 哈希\n\n 两数之和\n\nc++\nclass Solution {\npublic:\n    vector<int twoSumvector<int& nums, int target {\n        unorderedmap<int, int mp;\n        forint i = 0; i < nums.size; i++ mpnumsi = i;\n        forint i = 0; i < nums.size; i++{\n            ifmp.findtarget  numsi = mp.end{\n                int cc = mptarget  numsi;\n                ifcc == i continue;\n                return {i, mptarget  numsi};\n            }   \n        }\n        return {};\n    }\n};\n\n\n 字母异位词分组\n\nc++\nclass Solution {\npublic:\n    vector<vector<string groupAnagramsvector<string& strs {\n        vector<vector<string res;\n        unorderedmap<string, vector<string ump; \n        forint i = 0; i < strs.size; i ++{\n            string str = strsi;\n            sortstr.begin, str.end;\n            umpstr.pushbackstrsi;\n        }\n        for auto it = ump.begin; it = ump.end; it ++ {\n            res.pushbackitsecond;\n        }\n        return res;\n    }\n};\n\n\n 最长连续序列\n\n 思路：先存入set，再判断是否连续\n\n 知识点：set.count用于判断set中是否存在某个值\n\njava\nclass Solution {\npublic:\n    int longestConsecutivevector<int& nums {\n        set<int s;\n        int res = 0, cot = 1;\n        forint i: nums s.inserti;\n        forint i: s{\n           ifs.counti  1{\n               cot ++;\n           } else {\n               cot = 1;\n           }\n            res = maxres, cot;\n        }\n        return res;\n    }\n};\n\n\n 双指针\n\n 移动零\n\n 思路：一个指针指向0的下标，一个指向非0下标，不断向后移，遇到非0就交换标记的0的那个数\n\nc++\nclass Solution {\npublic:\n    void moveZeroesvector<int& nums {\n        int len = nums.size, l = 0, r = 0;\n        whiler < len{\n            ifnumsr{\n                swapnumsl, numsr;\n                l ++;\n            }\n            r ++;\n        }\n    }\n};\n\n\n 盛最多水的容器\n\n 思路：一个指针指向左端点，一个指针指向右端点，不断向中间靠拢，每次靠拢都计算一下左右圈起来的面积；若左端点长度小， 就+1，否则右端点就减一\n\nc++\nclass Solution {\npublic:\n    int maxAreavector<int& nums {\n        int l = 0, r = nums.size  1, res = 0;\n        forint i: nums{\n            int num = 0;\n            ifnumsl < numsr{\n                num = r  l  numsl;\n                l ++;\n            } else {\n                num = r  l  numsr;\n                r ; \n            }\n            res = maxnum, res;\n        }\n        return res;\n    }\n};\n\n\n 三数之和\n\n 思路：先需要排序，再来两重循环，要使a+b+c=0，a,b已经确定了，就差c，让c从往前遍历，因为是不断递增的所以a<b<c ，第二次循环b1时，b1b，所以c1必须小于c才能使得总和为0。满足这个特性，我们就可以用双指针解决。虽然第二重循环中有个for循环，但其实它的循环是对第二重循环遍历r生效的，所以并不影响总的时间复杂度为0N^2。\n\njava\nclass Solution {\npublic:\n    vector<vector<int threeSumvector<int& nums {\n        vector<vector<int res;\n        int len = nums.size;\n        sortnums.begin, nums.end;\n        forint i = 0; i < len; i++{\n            // 需要和上次不同\n            ifi  0 && numsi == numsi 1{\n                continue;\n            }\n            int r = len  1;\n            forint j = i + 1; j < len; j ++{\n                // 需要和上次不同\n                ifj  i + 1 && numsj == numsj  1{\n                    continue;\n                } \n                // 不断相减，找到满足和接近0的r下标\n                whilej < r && numsi + numsj + numsr  0{\n                    r ;\n                }\n                // j和r下标重合了，说明后续的循环是无效的无需遍历了\n                ifr == j{\n                    break;\n                }\n                ifnumsi + numsj + numsr == 0{\n                    res.pushback{numsr, numsi, numsj};\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n 接雨水\n\n 思路：先从左边考虑，从左往右不断遍历，维护一个左端最大值，若小于这个最大值，就用差算出需要接的雨水。但如果一直这样维护到右半端会出问题【因为可能不知道右端是否存在边，若右边根本就没有边就无需遍历了】，右半端需要维护右端的最大值。所以就左右一起维护往中间靠拢，期间不断维护左右端点的最大值。\n\njava\nclass Solution {\npublic:\n    int trapvector<int& height {\n        int l = 0, r = height.size  1, rmax = 0, lmax = 0, res = 0;\n        whilel < r{\n            lmax = maxlmax, heightl;\n            rmax = maxrmax, heightr;\n            ifheightl < heightr{\n                res += lmax  heightl;\n                l ++;\n            } else {\n                res += rmax  heightr;\n                r ;\n            }\n        }\n        return res;\n    }\n};\n\n\n 滑动窗口\n\n 无重复字符的最长子串\n\n 思路：依次向右遍历，遇到没出现过的字符写入map中，若出现过就不断弹出队列，直到弹出的字符与当前遍历到的字符一致未知，并且不断维护队列的最大值。最后也别忘了维护最大值，防止出现都是不一致的字符的情况\n\njava\nclass Solution {\npublic:\n    int lengthOfLongestSubstringstring s {\n        queue<char q;\n        map<char, int mp;\n        int res = 0;\n        forint i = 0; i < s.size; i++{\n            ifmpsi{\n                mpsi = 1;\n                q.pushsi;\n            } else{\n                int len = q.size;\n                res = maxres, len;\n                whileq.size && q.front = si{\n                    mpq.front = 0;\n                    q.pop;\n                }\n                q.pop;\n                q.pushsi;\n            }\n        }\n        int len = q.size;\n        res = maxres, len;\n        return res;\n    }\n};\n\n\n 找到字符串中所有字母异位词\n\n 思路：用vector来维护字符串中每个字符的个数，若确认两个字符串是一致，则vector也是一样的，用滑动窗口不断右遍历来维护vector\n\n 知识点：vector之间可以相等来判断是否一致；想用vector下标法之前必须指定vector个数【前提是该下标要存在】\n\njava\nclass Solution {\npublic:\n    vector<int findAnagramsstring s, string p {\n        int len1 = s.size, len2 = p.size;\n        iflen1 < len2{\n            return vector<int;\n        }\n        vector<int v126;\n        vector<int v226;\n        vector<int res;\n        forint i = 0; i < len2; i++{\n            v1si  'a' ++;\n            v2pi  'a' ++;\n        }\n        ifv1 == v2{\n            res.pushback0;\n        }\n        forint i = 0; i < len1  len2; i++{\n            v1si  'a' ;\n            v1si + len2  'a' ++;\n            ifv1 == v2{\n                res.pushbacki + 1;\n            }\n        }\n        return res;\n    }\n};\n\n\n 字串\n\n 和为 K 的子数组\n\n 思路：用map存放前缀和的各个值，循环遍历一次每次就判断当前的前缀和的值k是否在map中存在，存在就加一\n\nc++\nclass Solution {\npublic:\n    int subarraySumvector<int& nums, int k {\n        unorderedmap<int, int ump;\n        ump0 = 1;\n        int res = 0, cot = 0;\n        forint i: nums{\n            cot += i;\n            ifump.findcot  k = ump.end{\n                res += umpcot  k;\n            }\n            umpcot ++;\n        }\n        return res;\n    }\n};\n\n\n 滑动窗口最大值\n\n 思路：用双端队列维护一个单调队列，每次都会判断队列的尾部是否比当前的numsi小，小的话就需要弹出，因为只要有这个元素在，前面的元素永远也不是最大的一个。\n\n 知识点：单调队列\n\nc++\nclass Solution {\npublic:\n    vector<int maxSlidingWindowvector<int& nums, int k {\n        // 存放下标\n        deque<int q;\n        vector<int v;\n        forint i = 0; i < nums.size; i++{\n            // 当队列最后一个值小于当前numsi时，需要弹出末尾的元素\n            // 因为只要有这个元素在，前面的元素永远也不是最大的一个\n            whileq.size && numsq.back < numsi q.popback;\n            q.pushbacki;\n            // 当超过队列的元素的时候需要弹出队列头\n            ifi  q.front = k q.popfront;\n            // 当下标超过规定的k的时候就代表可以进行计算\n            ifi = k  1 v.pushbacknumsq.front;   \n        }\n        return v;\n    }\n};\n\n\n 普通数组\n\n 最大子数组和\n\n 思路：每次遍历都需要前缀和的值加上当前的值和当前的值进行比较，选出最大的值赋值给前缀和值\n\n 知识点：前缀和\n\nc++\nclass Solution {\npublic:\n    int maxSubArrayvector<int& nums {\n        int res = nums0, cot = nums0;\n        forint i = 1; i < nums.size; i++{\n            cot = maxnumsi, cot + numsi;\n            res = maxres, cot;\n        }\n        return res;\n    }\n};\n\n\n 合并区间\n\nc++\nclass Solution {\npublic:\n    vector<vector<int mergevector<vector<int& intervals {\n        vector<vector<int res;\n        sortintervals.begin, intervals.end;\n        int len = intervals.size, minL = intervals00, minR = intervals01;\n        forint i = 1; i < len; i++{\n            int l = intervalsi0, r = intervalsi1;\n            ifl  minR{\n                res.pushback{minL, minR};\n                minL = l;\n            }\n            minR = maxminR, r;\n        }\n        res.pushback{minL, minR};\n        return res;\n    }\n};\n\n\n 轮转数组\n\nc++\nclass Solution {\npublic:\n    void rotatevector<int& nums, int k {\n        int len = nums.size;\n        unorderedmap<int, int mp;\n        forint i = 0; i < len; i++{\n            mpi = numsi;\n        }\n        forint i = 0; i < len; i++{\n            numsi + k % len = mpi;\n        }\n    }\n};\n\n\n 除自身以外数组的乘积\n\nc++\nclass Solution {\npublic:\n    vector<int productExceptSelfvector<int& nums {\n        int all = nums0, is = 0, len = nums.size;\n        vector<int res;\n        ifall == 0{\n            is ++;\n            all = 1;\n        }\n        forint i = 1; i < len; i++{\n            ifnumsi == 0 {\n                is ++;\n                continue;\n            }\n            all = numsi;\n        }\n        forint i: nums{\n            ifi == 0{\n                ifis  1 res.pushback0;\n                else res.pushbackall;\n            } else {\n                ifis == 1 res.pushback0;\n                else ifis  1 res.pushback0;\n                else res.pushbackall / i;\n            }\n        }\n        return res;\n    }\n};\n\n\n 缺失的第一个正数\n\nc++\nclass Solution {\npublic:\n    int firstMissingPositivevector<int& nums {\n        int res = 100000000, minNum = 0;\n        unorderedmap<int, int ump;\n        priorityqueue<int, vector<int, greater<int pq;\n        set<int s;\n        forint i: nums {\n           ifi  0 s.inserti;\n        }\n        forint i: s {\n            pq.pushi;\n        }\n        int idx = 1;\n        ifpq.size && pq.top == 1{\n            whilepq.size{\n                pq.pop;\n                ifpq.top = ++idx{\n                    break;\n                } \n            }\n        }\n        return idx;\n\n    }\n};\n\n\n 图论\n\n 岛屿的数量\n\n 思路：采用DFS遍历，将每个遍历到的为1的点设置标记，下次遍历的时候只遍历没标记的点；把标记的区域数量相加就是结果\n\n 知识点：DFS\n\nc++\nclass Solution {\npublic:\n    vector<vector<char num;\n    int lenx, leny;\n    int flag301301;\n    int ix4 = {0,0,1,1}, iy4 = {1,1,0,0};\n    void dfsint x, int y{\n        ifnumxy == '0'{\n            return;\n        }\n        forint i = 0; i < 4; i++{\n            int x = ixi + x, y = iyi + y;\n            ifx = 0 && x < lenx && y = 0 && y < leny && flagxy{\n                flagxy = 1;\n                dfsx, y;\n            }\n        }\n    }\n    int numIslandsvector<vector<char& grid {\n        int cot = 0;\n        num = grid;\n        lenx = num.size, leny = grid0.size;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                ifflagij && gridij == '1'{\n                    dfsi, j;\n                    cot ++;\n                }\n            }\n        }\n        return cot;\n    }\n};\n\n\n 腐烂的橘子\n\n 思路：先将每个腐烂的橘子加入到队列中，再进行BFS遍历；这里遍历有个关键点就是只遍历没有腐烂的句子，已腐烂的句子无需遍历，因为已经腐烂的句子也会进行传播，而且他的传播用时比现在的短\n\n 知识点：多源BFS\n\nc++\nclass Solution {\npublic:\n    int lenx = 0, leny = 0, cot = 0;\n    int flag1111, ix4 = {0,0,1,1}, iy4 = {1,1,0,0};\n    queue<pair<int, int q;\n    int bfsvector<vector<int& grid{\n        int res = 0;\n        whileq.size{\n            auto top = q.front;\n            q.pop;\n            int xx = top.first, yy = top.second;\n            forint i = 0; i < 4; i++{\n                int x = ixi + xx, y = iyi + yy;\n                ifx = 0 && x < lenx && y = 0 && y < leny && gridxy == 1 && flagxy{\n                    flagxy = flagxxyy + 1;\n                    q.push{x, y};\n                    ifgridxy == 1{\n                        cot ;\n                        res = flagxy;\n                        ifcot{\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return cot == 0 ? res : 1;\n    }\n    int orangesRottingvector<vector<int& grid {\n        lenx = grid.size, leny = grid0.size;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                ifgridij == 2{\n                    q.push{i, j};\n                    flagij = 0;\n                } else ifgridij == 1{\n                    cot ++;\n                }\n            }\n        }\n        return bfsgrid;\n    }\n};\n\n\n 课程表\n\n 思路：用n来标志状态（0表示未选，1表示正在选，2表示已选），见注释\n\n 知识点：DFS\n\nc++\nclass Solution {\npublic:\n    vector<vector<int num;\n    vector<int n;\n    bool flag = true;\n    void dfsint x {\n        // 标记正在选\n        nx = 1;\n        // 假设当前x已经正在选，遍历需要依赖它的课程编号\n        forint i: numx{\n            // 未选就遍历\n            ifni{\n                dfsi;\n                ifflag{\n                    return;\n                }\n             // 正在选说明出现重复依赖，就直接return\n            } else ifni == 1{\n                flag = false;\n                return;\n            }\n        }\n        // 标记已选\n        nx = 2;\n    }\n    bool canFinishint numCourses, vector<vector<int& prerequisites {\n        int len = prerequisites.size;\n        num.resizenumCourses;\n        n.resizenumCourses;\n        for int i = 0; i < len; i++ {\n            int 1 = prerequisitesi0, 2 = prerequisitesi1;\n            num2.pushback1;\n        }\n        for int i = 0; i < numCourses; i++ {\n           \t// 只遍历未选的\n            ifni{\n                dfsi;\n            }\n        }\n        return flag;\n    }\n};\n\n\n 回溯\n\n 全排列\n\n 知识点：回溯\n\nc++\nclass Solution {\npublic:\n    vector<int num;\n    vector<vector<int res;\n    int len = 0;\n    int n7;\n    void dfsint x, vector<int v{\n        ifv.size == len{\n            res.pushbackv;\n            return;\n        }\n        forint i = 0; i < len; i++{\n            ifni{\n                ni = 1;\n                v.pushbacknumi;\n                dfsi, v;\n                ni = 0;\n                v.popback;\n            }\n        }\n    }\n    vector<vector<int permutevector<int& nums {\n        num = nums;\n        len = nums.size;\n        dfs0, {};\n        return res;\n    }\n};\n\n\n 子集\n\nc++\nclass Solution {\npublic:\n    vector<int num;\n    int len = 0;\n    vector<vector<int res;\n    void dfsint x, vector<int v{\n        ifx == len{\n            res.pushbackv;\n            return;\n        }\n        dfsx + 1, v;\n        v.pushbacknumx;\n        dfsx + 1, v;\n        v.popback;\n    }\n    vector<vector<int subsetsvector<int& nums {\n        num = nums;\n        len = nums.size;\n        dfs0, {};\n        return res;\n    }\n};\n\n\n 电话号码的字母组合\n\nc++\nclass Solution {\npublic:\n    unorderedmap<int, vector<char ump;\n    vector<string res;\n    int len = 0;\n    void init{\n        ump'2' = {'a','b','c'};\n        ump'3' = {'d','e','f'};\n        ump'4' = {'g','h','i'};\n        ump'5' = {'j','k','l'};\n        ump'6' = {'m','n','o'};\n        ump'7' = {'p','q','r','s'};\n        ump'8' = {'t','u','v'};\n        ump'9' = {'w','x','y','z'};\n    }\n    void dfsint x, string str, string digit{\n        ifx == len{\n            res.pushbackstr;\n            return;\n        }\n        char c = digitx;\n        forint i = 0; i < umpc.size; i++{\n            dfsx + 1, str + umpci, digit;\n        }\n    }\n    vector<string letterCombinationsstring digits {\n        len = digits.size;\n        iflen == 0{\n            return {};\n        }\n        init;\n        dfs0, \"\", digits;\n\n        return res;\n    }\n};\n\n\n 组合总和\n\nc++\nclass Solution {\npublic:\n    vector<vector<int res;\n    vector<int num;\n    int len = 0;\n    void dfsint x, int n, vector<int v, int total{\n        ifn  total{\n            return;\n        }\n        ifn == total{\n            res.pushbackv;\n            return;\n        }\n        v.pushbacknumx;\n        dfsx, n + numx, v, total;\n        v.popback;\n        ifx + 1 < len{\n            dfsx + 1, n, v, total;\n        }\n       \n    }\n    vector<vector<int combinationSumvector<int& candidates, int target {\n        len = candidates.size;\n        num = candidates;\n        dfs0, 0, {}, target;\n        return res;\n    }\n};\n\n\n 括号生成\n\nc++\nclass Solution {\npublic:\n    vector<string res;\n    void dfsint x, int y, string str, int n{\n        ifx  n  y  n{\n            return;\n        }\n        ifx == n{\n            res.pushbackstr;\n            return;\n        }\n        dfsx, y + 1, str + \"\", n;\n        ifx < y{\n            dfsx + 1, y, str + \"\", n;\n        }\n\n    }\n    vector<string generateParenthesisint n {\n        dfs0, 0, \"\", n;\n        return res;\n    }\n};\n\n\n 单词搜索\n\nc++\nclass Solution {\npublic:\n    vector<vector<char num;\n    int lenx = 0, leny = 0;\n    bool flag = false;\n    int f77;\n    int ix4 = {0,0,1,1}, iy4 = {1,1,0,0};\n    bool findstring s, string w{\n        forint i = 0; i < s.size; i++{\n            ifsi = wi return false;\n        }\n        return true;\n    }\n    void dfsint x, int y, string s, string w, int f7{\n        ifs == w{\n            flag = true;\n            return;\n        }\n        forint i = 0; i < 4; i++{\n            int x = ixi + x, y = iyi + y;\n            ifx = 0 && x < lenx && y = 0 && y < leny && fxy && finds + numxy, w{\n                fxy = 1;\n                dfsx, y, s + numxy, w, f;\n                fxy = 0;\n            }\n        }\n        \n    }\n    bool existvector<vector<char& board, string word {\n        num = board;\n        lenx = board.size, leny = board0.size;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                ifboardij == word0{\n                    memsetf, 0, sizeof f;\n                    string ss = \"\";\n                    ss.append1, word0;\n                    fij = 1;\n                    dfsi, j, ss, word, f;\n                    ifflag{\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n\n\n 分割回文串\n\n 思路：用二维数组n来标记i，j是否是回文串，先将n全部赋值为1，找出不是回文串的区间。最后用BFS找出回文串\n\n 知识点：BFS，动态规划\n\nc++\nclass Solution {\npublic:\n    vector<vector<string res;\n    int n1717;\n    int len = 0;\n    void dfsstring s, int x, vector<string v{\n        ifx  len return;\n        ifx == len{\n            res.pushbackv;\n            return;\n        }\n        forint i = x; i < len; i++{\n            ifnxi{\n                v.pushbacks.substrx, i  x + 1;\n                dfss, i + 1, v;\n                v.popback;\n            }\n        }\n    }\n    vector<vector<string partitionstring s {\n        len = s.size;\n        forint i = 0; i < len; i++{\n            forint j = 0; j < len; j++{\n                nij = 1;\n            }\n        }\n        forint i = 0; i < len; i++{\n            forint j = i  1; j = 0; j{\n                nji = si == sj && nj + 1i  1;\n            }\n        }\n        dfss, 0, {};\n        return res;\n    }\n};\n\n\n N 皇后\n\nc++\nclass Solution {\npublic:\n    vector<vector<string res;\n    vector<char v;\n    // 分别表示45°，45°，y轴标志数组，看是否已经存在\n    int fx100, fy100, line100;\n    void dfsint x, int n, vector<string strv{\n        ifx == n{\n            res.pushbackstrv;\n            return;\n        }\n        forint i = 0; i < n; i++{\n            iflinei && fxi  x + n && fyi + x{\n                fyi + x = 1;\n                fxi  x + n = 1;\n                linei = 1;\n                strvxi = 'Q';\n                dfsx + 1, n, strv;\n                fyi + x = 0;\n                fxi  x + n = 0;\n                linei = 0;\n                strvxi = '.';\n            }\n        }\n    }\n    vector<vector<string solveNQueensint n {\n        vector<string strv;\n        forint i = 0; i < n; i++{\n            string str = \"\";\n            forint j = 0; j < n; j++{\n                str += '.';\n            }\n            strv.pushbackstr;\n        }\n        dfs0, n, strv;\n        return res;\n    }\n};\n\n\n 零钱兑换\n\n 知识点：BFS + 记忆化搜索 + 剪枝\n\nc++\nclass Solution {\npublic:\n    int bfsvector<int& coins, int amount{\n        int len = coins.size, res = INTMAX;\n        queue<pair<long long, int q;\n        unorderedset<long long s;\n        q.push{0, 0};\n        whileq.size{\n            auto top = q.front;\n            q.pop;\n            long long x = top.first;\n            int y = top.second;\n            ifx  amount{\n                // 剪枝\n                continue;\n            } else ifx == amount{\n                res = minres, y;\n                continue;\n            }\n            forint i = 0; i < len; i++{\n                long long cc = x + coinsi;\n                // 记忆化搜索，已经搜索过了的不再重复记录\n                ifs.findcc == s.end{\n                    s.insertcc;\n                    q.push{cc, y + 1};\n                }\n            }\n        }\n        return res == INTMAX ? 1 : res;\n    }\n    int coinChangevector<int& coins, int amount {\n        return bfscoins, amount;\n    }\n};\n\n\n 二分\n\n二分模板\n\nc++\n// 左边距\nint getlint x{\n    int l = 0, r = a  1;\n    whilel < r{\n        int mid = l + r  / 2;\n        ifnmid = x r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\nint getrint x{\n   int l = 0, r = a  1;\n   whilel < r{\n   \tint mid = l + r + 1 / 2;\n       ifnmid <= x l = mid;\n       else r = mid  1;\n   }\n   return r;\n}\n\n\n 搜索插入位置\n\nc++\nclass Solution {\npublic:\n    int searchInsertvector<int& nums, int target {\n        int l = 0, r = nums.size;\n        whilel < r{\n            int mid = l + r  1;\n            ifnumsmid = target {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n\n\n 在排序数组中查找元素的第一个和最后一个位置\n\n 左右边距模板题\n\nc++\nclass Solution {\npublic:\n    int len = 0;\n    int leftvector<int& nums, int target{\n        int l = 0, r = len  1;\n        whilel < r{\n            int mid = l + r  1;\n            ifnumsmid = target {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l = 0 && l < len && numsl == target ? l : 1;\n    }\n    int rightvector<int& nums, int target{\n        int l = 0, r = len  1;\n        whilel < r{\n            int mid = l + r + 1  1;\n            ifnumsmid <= target {\n                l = mid;\n            } else {\n                r = mid  1;\n            }\n        }\n        return r = 0 && r < len && numsr == target ? r : 1;\n    }\n    vector<int searchRangevector<int& nums, int target {\n        len = nums.size;\n        return {leftnums, target, rightnums, target};\n    }\n};\n\n\n 搜索二维矩阵\n\n 思路：将二维转为一维，再用二分查找\n\nc++\nclass Solution {\npublic:\n    bool searchMatrixvector<vector<int& matrix, int target {\n        int lenx = matrix.size, leny = matrix0.size;\n        vector<int v;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                v.pushbackmatrixij;\n            }\n        }\n        int l = 0, r = v.size  1;\n        whilel < r{\n            int mid = l + r  1;\n            ifvmid = target{\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l = 0 && l < v.size && vl == target ? true : false;\n    }\n};\n\n\n 搜索旋转排序数组\n\n 思路：中间值与第一个值比较便能知道在左区间还是在右区间，分别在区间内进行讨论即可\n\nc++\nclass Solution {\npublic:\n    int searchvector<int& nums, int target {\n        int n = nums.size;\n        int l = 0, r = n  1;\n        whilel <= r{\n            int mid = l + r  1;\n            ifnumsmid == target return mid;\n            ifnumsmid = nums0{\n                ifnumsmid  target && nums0 <= target{\n                    r = mid  1;\n                } else {\n                    l = mid + 1;\n                }\n            } else{\n                ifnumsmid < target && nums0  target{\n                    l = mid + 1;\n                } else {\n                    r = mid  1;\n                }\n            }\n        }\n        return 1;\n    }\n};\n\n\n 寻找旋转排序数组中的最小值\n\nc++\nclass Solution {\npublic:\n    int findMinvector<int& nums {\n        int len = nums.size;\n        int l = 0, r = len  1;\n        whilel < r{\n            int mid = l + r  1;\n            ifnumsmid = nums0{\n                ifnumsmid  numslen  1 l = mid + 1;\n                else r = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return numsl;\n    }\n};\n\n\n 栈\n\n 有效的括号\n\nc++\nclass Solution {\npublic:\n    bool isValidstring s {\n        stack<char ss;\n        bool flag = false;\n        forint i = 0; i < s.size; i++{\n            ifsi == ''  si == ''  si == '{' ss.pushsi;\n            else {\n                ifss.size && ss.top == '' && si == '' ss.pop;\n                else ifss.size && ss.top == '{' && si == '}' ss.pop;\n                else ifss.size && ss.top == '' && si == '' ss.pop;\n                else return false;\n            }\n        }\n        return ss.size == 0 ? true: false;\n    }\n};\n\n\n 字符串解码\n\nc++\nclass Solution {\npublic:\n    string decodeStringstring s {\n        stack<string ss;\n        stack<int cc;\n        forint i = 0; i < s.size; i++{\n            ifsi = '0' && si <= '9' {\n               int q = i, num = 0;\n               whilesq = '0' && sq <= '9'{\n                    num = num  10 + sq  '0';\n                    q ++;\n               }\n               cc.pushnum;\n               i = q  1;\n            }\n            else {\n                ifsi == ''{\n                    string str = \"\", rstr = \"\";\n                    whiless.size{\n                        ifss.top == \"\" {\n                            ss.pop;\n                            break;\n                        }\n                        str = ss.top + str;\n                        ss.pop;\n                    }\n                    int cot = cc.top;\n                    cc.pop;\n                    forint j = 0; j < cot; j++ rstr += str;\n                    ss.pushrstr;\n\n                }\n                else{\n                    string cstr = \"\";\n                    cstr.append1, si;\n                    ss.pushcstr;\n                }\n            }\n        }\n        string res = \"\";\n        whiless.size{\n            res = ss.top + res;\n            ss.pop;\n        }\n        return res;\n    }\n};\n\n\n 每日温度\n\n 思路：维护一个递减的单调栈\n\nc++\nclass Solution {\npublic:\n    vector<int dailyTemperaturesvector<int& temperatures {\n        int len = temperatures.size;\n        stack<int s;\n        vector<int reslen, 0;\n        forint i = 0; i < len; i++{\n            whiles.size && temperaturess.top < temperaturesi{\n                ress.top = i  s.top;\n                s.pop;\n            }\n            s.pushi;\n        }\n        return res;\n        \n    }\n};\n\n\n 堆\n\n 数组中的第K个最大元素\n\n 知识点：优先队列\n\nc++\nclass Solution {\npublic:\n    int findKthLargestvector<int& nums, int k {\n        int idx = 0, res = 1;\n        priorityqueue<int, vector<int, less<int pq;\n        forint i = 0; i < nums.size; i++{\n            pq.pushnumsi;\n        }\n        whilepq.size{\n            int top = pq.top;\n            idx ++;\n            pq.pop;\n            ifidx == k{\n                res = top;\n                break;\n            }\n        }\n        return res;\n    }\n};\n\n\n 前 K 个高频元素\n\n 知识点：并查集\n\nc++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n100010;\n    unorderedmap<int, int mp;\n    static bool cmpp a1, p b1{\n        return a1.y  b1.y;\n    }\n    vector<int topKFrequentvector<int& nums, int k {\n        int len = nums.size;\n        vector<int res;\n        forint i = 0; i < len; i++{\n            int index = i;\n            ifmp.findnumsi = mp.end{\n                index = mpnumsi;\n            }\n            nindex.x = numsindex;\n            nindex.y ++;\n            mpnumsi = index;\n        }\n        sortn, n + len, cmp;\n        forint i = 0; i < k; i++{\n            res.pushbackni.x;\n        }\n        return res;\n    }\n};\n\n\n 贪心\n\n 买卖股票的最佳时机\n\nc++\nclass Solution {\npublic:\n    int maxProfitvector<int& prices {\n        int len = prices.size, maxx = 0, res = 0;\n        vector<int vlen;\n        forint i = len  1; i = 0; i{\n            maxx = maxpricesi, maxx;\n            vi = maxx;\n        }\n        forint i = 0; i < len; i++{\n            res = maxres, vi  pricesi;\n        }\n        return res;\n    }\n};\n\n\n 跳跃游戏\n\nc++\nclass Solution {\npublic:\n    bool canJumpvector<int& nums {\n        int len = nums.size, maxx = 0;\n        vector<bool vlen, false;\n        forint i = 0; i < len; i++{\n            ifi  maxx{\n                return false;\n            }\n            maxx = maxmaxx, i + numsi;\n            vi = true;\n        }\n        return vlen  1;\n    }a\n};\n\n\n <u 跳跃游戏 II</u\n\nc++\nclass Solution {\npublic:\n    int jumpvector<int& nums {\n        int len = nums.size, maxx= 0, end = 0, res = 0;\n        //  循环遍历到 len  1\n        forint i = 0; i < len  1; i++{ \n            maxx = maxmaxx, numsi + i;\n            ifend == i{\n                end = maxx;\n                res ++;\n            }\n        }\n        return res;\n    }\n};\n\n\n 划分字母区间\n\nc++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n27;\n    vector<int partitionLabelsstring s {\n        vector<int res;\n        int len = s.size;\n        forint i = 0; i < len; i++{\n            nsi  'a'.x = minnsi  'a'.x, i;\n            nsi  'a'.y = maxnsi  'a'.y, i;\n        }\n        int minL = 0, maxL = 0;\n        forint i = 0; i < len; i++{\n            maxL = maxnsi  'a'.y, maxL;\n            ifmaxL == i{\n                res.pushbackmaxL  minL + 1;\n                minL = i + 1;\n            }\n        }\n        return res;\n    }\n};\n\n\n 动态规划\n\n 爬楼梯\n\n 思路：斐波拉且数列\n\nc++\nclass Solution {\npublic:\n    int nums46;\n    int climbStairsint n {\n        nums0 = 1;\n        nums1 = 1;\n        forint i = 2; i <= n; i++{\n            numsi = numsi  1 + numsi  2; \n        }\n        return numsn;\n    }\n};\n\n\n 杨辉三角\n\nc++\nclass Solution {\npublic:\n    vector<vector<int generateint numRows {\n        vector<vector<int resnumRows;\n        res0 = {1};\n        forint i = 1; i < numRows; i++{\n            vector<int vi + 1, 1;\n            forint j = 1; j <= i  1; j++{\n                vj = resi  1j + resi  1j  1; \n            }\n            resi = v;\n        }\n        return res;\n    }\n};\n\n\n 打家劫舍\n\nc++\nclass Solution {\npublic:\n    int robvector<int& nums {\n        int len = nums.size, res = 0;\n        vector<int vlen + 1;\n        forint i = 1; i <= len; i++{\n            vi = numsi  1;\n            res = maxvi, res;\n        }\n        forint i = 3; i <= len; i++{    \n            vi = vi + maxvi  2, vi  3;\n            res = maxres, vi;\n        }\n        return res;\n\n    }\n};\n\n\n 完全平方数\n\nc++\nclass Solution {\npublic:\n    int numSquaresint n {\n        vector<int vn + 1;\n        v1 = 1;\n        forint i = 2; i <= n; i++{\n            int num = INTMAX;\n            forint j = 1; j  j <= i; j++{\n                // 此处为关键点，从完全平方数开始找，找出想要最小凑出完全平凡数的数的结果\n                num = minnum, vi  j  j;\n            }\n            // 最后加上完全平凡数的结果1\n            vi = num + 1;\n        }\n        return vn;\n    }\n};\n\n\n\n\n\n\n 常用算法总结\n\n 二分\n\n 哈希\n\n 双指针\n\n 思维\n\n 模拟\n\n 贪心\n\n 前缀和一维、二维，后缀和\n\n 队列\n   滑动窗口双端队列\n   优先队列\n  \n 栈\n   单调栈\n\n 搜索\n   DFS\n   BFS\n   多源BFS\n\n 动态规划\n\n 数学知识\n\n   哈夫顿距离：di,j=xixj+yiyj\n\n     哈夫顿距离转为切比雪夫距离：xixj + yiyj =  maxx1'x2', y1'y2'\n\n      原坐标x, y与x', y'的关系：x', y' = x + y, y  x\n\n   欧氏距离：di,j=xixj ^ 2 + yi  yj ^ 2\n\n   直线公式：y = y2y1/x2x1  x  x2  y1  x1  y2/x2x1\n  \n   质数\n  \n   因数\n  \n   容斥原理\n  \n 图论\n\n   迪杰斯特拉\n\n"},{"filename":"mallchat","category":"project","md":{"topSummary":"\ntitle: MallChat项目笔记\ncategory: SpringBoot,实战项目\ndate: 2024-02-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 微信扫码登录\n\n### 准备\n\n#### 工具\n\n> 误区：微信扫码登录每个人都可以，不是只有认证号才行。测试阶段可以用测试接口来进行测试，只不过项目部署后才需要认证使用\n>\n> 注意：微信回调接口需要开启内网穿透\n\n- 微信公众号的开发者账号：[点击此处进行注册](https://mp.weixin.qq.com/)\n- 内网穿透工具：[点击此处注册](https://natapp.cn/)\n\n#### 引入依赖\n\n```xml\n<dependency>\n    <groupId>com.github.binarywang</groupId>\n    <artifactId>weixin-java-mp</artifactId>\n    <version>4.4.0</version>\n</dependency>\n```\n\n#### 配置文件\n\n这里配置文件参考Binary Wang的代码\n\n```yml\nwx:\n  mp:\n    callback: ${mallchat.wx.callback} # 回调地址\n    configs:\n      - appId: ${mallchat.wx.appId} # 第一个公众号的appid\n        secret: ${mallchat.wx.secret} # 公众号的appsecret\n        token: ${mallchat.wx.token} # 接口配置里的Token值\n        aesKey: ${mallchat.wx.aesKey} # 接口配置里的EncodingAESKey值\n```\n\nWxMpProperties.java\n\n```java\n@Data\n@ConfigurationProperties(prefix = \"wx.mp\")\npublic class WxMpProperties {\n    /**\n     * 是否使用redis存储access token\n     */\n    private boolean useRedis;\n\n    /**\n     * redis 配置\n     */\n    private RedisConfig redisConfig;\n\n    @Data\n    public static class RedisConfig {\n        /**\n         * redis服务器 主机地址\n         */\n        private String host;\n\n        /**\n         * redis服务器 端口号\n         */\n        private Integer port;\n\n        /**\n         * redis服务器 密码\n         */\n        private String password;\n\n        /**\n         * redis 服务连接超时时间\n         */\n        private Integer timeout;\n    }\n\n    /**\n     * 多个公众号配置信息\n     */\n    private List<MpConfig> configs;\n\n    @Data\n    public static class MpConfig {\n        /**\n         * 设置微信公众号的appid\n         */\n        private String appId;\n\n        /**\n         * 设置微信公众号的app secret\n         */\n        private String secret;\n\n        /**\n         * 设置微信公众号的token\n         */\n        private String token;\n\n        /**\n         * 设置微信公众号的EncodingAESKey\n         */\n        private String aesKey;\n    }\n\n    @Override\n    public String toString() {\n        return JSONUtil.toJsonStr(this);\n    }\n}\n```\n\nWxMpConfiguration.java\n\n```java\n@AllArgsConstructor\n@Configuration\n@EnableConfigurationProperties(WxMpProperties.class)\npublic class WxMpConfiguration {\n    private final LogHandler logHandler;\n    private final MsgHandler msgHandler;\n    private final SubscribeHandler subscribeHandler;\n    private final ScanHandler scanHandler;\n    private final WxMpProperties properties;\n\n    @Bean\n    public WxMpService wxMpService() {\n        // 代码里 getConfigs()处报错的同学，请注意仔细阅读项目说明，你的IDE需要引入lombok插件！！！！\n        final List<WxMpProperties.MpConfig> configs = this.properties.getConfigs();\n        if (configs == null) {\n            throw new RuntimeException(\"大哥，拜托先看下项目首页的说明（readme文件），添加下相关配置，注意别配错了！\");\n        }\n\n        WxMpService service = new WxMpServiceImpl();\n        service.setMultiConfigStorages(configs\n                .stream().map(a -> {\n                    WxMpDefaultConfigImpl configStorage;\n                    configStorage = new WxMpDefaultConfigImpl();\n\n                    configStorage.setAppId(a.getAppId());\n                    configStorage.setSecret(a.getSecret());\n                    configStorage.setToken(a.getToken());\n                    configStorage.setAesKey(a.getAesKey());\n                    return configStorage;\n                }).collect(Collectors.toMap(WxMpDefaultConfigImpl::getAppId, a -> a, (o, n) -> o)));\n        return service;\n    }\n\n    @Bean\n    public WxMpMessageRouter messageRouter(WxMpService wxMpService) {\n        final WxMpMessageRouter newRouter = new WxMpMessageRouter(wxMpService);\n\n        // 记录所有事件的日志 （异步执行）\n        newRouter.rule().handler(this.logHandler).next();\n\n        // 关注事件\n        newRouter.rule().async(false).msgType(EVENT).event(SUBSCRIBE).handler(this.subscribeHandler).end();\n\n        // 扫码事件\n        newRouter.rule().async(false).msgType(EVENT).event(EventType.SCAN).handler(this.scanHandler).end();\n\n        // 默认\n        newRouter.rule().async(false).handler(this.msgHandler).end();\n\n        return newRouter;\n    }\n\n}\n```\n\n#### 配置消息处理器\n\nAbstractHandler.java\n\n```java\npublic abstract class AbstractHandler implements WxMpMessageHandler {\n    protected Logger logger = LoggerFactory.getLogger(getClass());\n}\n```\n\nLogHandler.java（日志）\n\n```java\n@Component\n@Slf4j\npublic class LogHandler extends AbstractHandler {\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,\n                                    Map<String, Object> context, WxMpService wxMpService,\n                                    WxSessionManager sessionManager) {\n        log.info(\"\\n接收到请求消息，内容：{}\", JSONUtil.toJsonStr(wxMessage));\n        return null;\n    }\n}\n```\n\nMsgHandler.java\n\n```java\n@Component\npublic class MsgHandler extends AbstractHandler {\n\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,\n                                    Map<String, Object> context, WxMpService weixinService,\n                                    WxSessionManager sessionManager) {\n\n        return null;\n    }\n}\n```\n\nScanHandler.java\n\n```java\n@Component\npublic class ScanHandler extends AbstractHandler {\n\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /**\n     * 处理用户扫码【不是第一次】\n     */\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMpXmlMessage, Map<String, Object> map,\n                                    WxMpService wxMpService, WxSessionManager wxSessionManager) throws WxErrorException {\n        // 扫码事件处理\n        return wxMsgService.scan(wxMpService, wxMpXmlMessage);\n    }\n}\n```\n\nSubscribeHandler.java\n\n```java\n@Component\npublic class SubscribeHandler extends AbstractHandler {\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /**\n     * 扫描登录二维码后第一次进入需要关注公众号\n     * @param wxMessage\n     * @param context\n     * @param weixinService\n     * @param sessionManager\n     * @return\n     * @throws WxErrorException\n     */\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,\n                                    Map<String, Object> context, WxMpService weixinService,\n                                    WxSessionManager sessionManager) throws WxErrorException {\n\n        this.logger.info(\"新关注用户 OPENID: \" + wxMessage.getFromUser());\n\n        WxMpXmlOutMessage responseResult = null;\n        try {\n            responseResult = this.handleSpecial(weixinService, wxMessage);\n        } catch (Exception e) {\n            this.logger.error(e.getMessage(), e);\n        }\n\n        if (responseResult != null) {\n            return responseResult;\n        }\n\n        try {\n            return new TextBuilder().build(\"感谢关注\", wxMessage, weixinService);\n        } catch (Exception e) {\n            this.logger.error(e.getMessage(), e);\n        }\n\n        return null;\n    }\n\n    /**\n     * 处理特殊请求，比如如果是扫码进来的，可以做相应处理\n     */\n    private WxMpXmlOutMessage handleSpecial(WxMpService weixinService, WxMpXmlMessage wxMessage)\n            throws Exception {\n        return wxMsgService.scan(weixinService, wxMessage);\n    }\n\n}\n```\n\n### 执行过程\n\n#### 1、获取登录二维码\n\n```java\npublic void handleLoginReq(Channel channel) {\n  // 生成登录随机码\n  Integer code = generateLoginCode(channel);\n  // 微信生成带参二维码\n  WxMpQrCodeTicket wxMpQrCodeTicket = null;\n  try {\n      wxMpQrCodeTicket = wxMpService.getQrcodeService().qrCodeCreateTmpTicket(code, (int) DURATION.getSeconds());\n  } catch (WxErrorException e) {\n      e.printStackTrace();\n  }\n  // 把二维码推送前端\n  sendMsg(channel, WebSocketAdapter.buildResp(wxMpQrCodeTicket));\n}\n```\n\n这里我是对二维码做了过期策略，`wxMpQrCodeTicket.getUrl()`就是带参二维码的地址，通过草料二维码生成器便能生成一个二维码\n\n#### 2、公众号返回登录授权\n\n在`ScanHandler`类的`handle`方法中写入，专门处理扫码登录事件\n\n```java\nString openid = wxMpXmlMessage.getFromUser();\nInteger code = getEventKey(wxMpXmlMessage);\nif (ObjectUtil.isNull(code)){\n    return null;\n}\n\n// 保存用户信息\nUser user = userDao.getByOpenId(openid);\nboolean registered = Objects.nonNull(user);\nboolean authorized = registered && StrUtil.isNotBlank(user.getName());\nif (registered && authorized){\n\t// 用户已经注册了，直接返回用户+token信息\n    webSocketService.scanLoginSuccess(code, user.getId());\n    return null;\n}\nif (!registered){\n    // 未写入数据库\n    User insert = UserAdapter.buildUserSave(openid);\n    userService.register(insert);\n}\nWAIT_AUTHORIZE_MAP.put(openid, code);\n// 通知前端正在等待认证\nwebSocketService.waitAuthorize(code);\n// 拼接URL，获取认证地址\nString authorizeUrl = String.format(URL, wxMpService.getWxMpConfigStorage().getAppId(), URLDecoder.decode(callback + \"wx/portal/public/callBack\"));\nreturn TextBuilder.build(\"请点击登录：<a href=\\\"\" + authorizeUrl + \"\\\">登录</a>\", wxMpXmlMessage, wxMpService);\n```\n\n当用户扫码并关注成功后，会自动弹出消息\n\n> 请点击登录：[登录]()\n\n用户点击登录后，会跳转到`\"https://open.weixin.qq.com/connect/oauth2/authorize?appid=%s&redirect_uri=%s&response_type=code&scope=snsapi_userinfo&state=STATE#wechat_redirect\"`微信授权页面，需要传入appid和回调接口地址，授权成功后将带着code参数访问给定的回调接口\n\n#### 3、微信调用给定的回调接口\n\n```java\n@GetMapping(\"/callBack\")\npublic RedirectView callBack(@RequestParam String code) {\n    try {\n        // 根据code获取token\n        WxOAuth2AccessToken accessToken = wxMpService.getOAuth2Service().getAccessToken(code);\n        // 根据token获取用户信息\n        WxOAuth2UserInfo userInfo = wxMpService.getOAuth2Service().getUserInfo(accessToken, \"zh_CN\");\n        wxMsgService.authorize(userInfo);\n    } catch (Exception e) {\n        log.error(\"callBack error\", e);\n    }\n    RedirectView redirectView = new RedirectView();\n    redirectView.setUrl(\"https://mp.weixin.qq.com/s/m1SRsBG96kLJW5mPe4AVGA\");\n    return redirectView;\n}\n```\n\n通过回调传来的code获取token，通过token来获取微信用户信息【只有昵称和头像】\n\n` wxMsgService.authorize(userInfo)`将用户不全的信息【用户头像，昵称】进行更新，并生成token进行返回\n\n就这样，前端就拿到了后端传来的token\n\n## 用户认证技术Token方案\n\nToken 的生成方式通常有以下几种：\n\n- **随机字符串**：可以使用一些随机数生成算法，如 **UUID**、**Snowflake(雪花算法)** 等来生成一个随机的字符串作为 Token。由于随机字符串本身就是随机分布的，因此具有很高的安全性。\n- **JWT**（JSON Web Token）：JWT 是一种基于 JSON 格式的开放标准（RFC 7519），用于在多方之间安全地传输信息。它将用户身份信息和权限等相关信息编码成一个 JSON 对象，并通过数字签名或者加密等方式进行验证和保护。JWT 除了可以用于 Token 登录外，还可以用于 API 认证、单点登录等场景。\n- **SessionID**。\n\n通常的Token在服务器端的实现方式有这几个：\n\n1. 用SessionID实现Token的功能\n2. 使用Json Web Token (JWT)\n3. 中心化存储Token\n\n下面分析一下各个存储方式的优缺点。\n\n### Cookie + Session 登录\n\nHTTP 是一种**无状态的协议**。\n\n无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求返回数据，但不会记录任何信息。\n\n为了解决 HTTP 无状态的问题，出现了 Cookie。\n\nCookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。\n\n![](https://s11.ax1x.com/2024/02/01/pFMooHx.png)\n\n**认证流程：**\n\n1. 前端输入账号密码，提交给后端\n2. 后端验证成功后，创建一个`Session`。`Session`是一种服务器端保存用户会话信息的机制，用于识别多次请求之间的逻辑关系。\n3. 后端将`Session ID`（通常是一个随机的字符串）返回给前端，并通过 `Cookie` 的方式将`Session ID`保存在浏览器中。这样就可以保证当用户再次发送请求时，后端可以通过该 `Session ID `来识别用户身份，并完成相关的操作。\n4. 在后续的请求中，浏览器会自动将保存的 `Cookie `信息发送到后端进行验证，如果` Session ID`有效，则返回相应的数据。如果 `Session ID `失效或者不存在，则需要重新登录获取新的 `Session ID`。\n5. 用户退出时，后端要删除对应的`Session`信息\n\n#### Cookie的设置原理\n\ncookie的简单之处，在于前端是无感知的，无需额外开发。这是http协议的约定，后端可以通过返回的报文，将cookie设置进网页，网页下次请求也会**自动携带**。`SetCookie` 命令\n\n![](https://s11.ax1x.com/2024/02/01/pFMoHUK.png)\n\n#### 缺点\n\n- 跨域问题：由于 Cookie 只能在同域名下共享，因此跨域访问时无法访问到对应的 Cookie 信息。这时，可能需要采用一些其他的跨域解决方案，如 JSONP、CORS 等。\n- 扩展性问题：由于 Session 信息存储在服务器端，当系统扩展到多台服务器时，需要采用一些集中式的 Session 管理方案，否则会出现 Session 不一致或者丢失等问题。\n- 一些移动设备和浏览器可能会禁用 Cookie 和 Session 机制，这会导致无法正常登录\n\n#### 总结\n\n- 给服务器的`sessionID`其实就相当于是一个`token`，只不过前端是无感知的设置进`cookie`的，这种方案 通常适用于后台。\n- 由于cookie的一些限制，这个token最好还是由前端**主动保存**比如保存到**localStorage**。登录的时候主动从**请求头**携带。\n- 由于现在都是集群部署，token的关系保存，最好又是**集中化管理**，或者**无状态化管理**\n\n### JWT实现token\n\n简单来说JWT就是通过可逆加密算法，生成一串包含用户、过期时间等关键信息的Token，每次请求服务器拿到这个Token解密出来就能得到用户信息，从而判断用户状态。\n\n![](https://s11.ax1x.com/2024/02/01/pFMob4O.png)\n\n#### 优点\n\n1. JWT的最大特点是**服务器不保存会话状态，**无论哪个服务器**解析**出来的Token信息都一样，而且不需要做任何查询操作，省掉了数据库/Redis的开销\n\n#### 缺点\n\n1. 正式因为JWT的特点，使用期间不可能取消令牌或更改令牌的权限，一旦JWT签发，在有效期内将会一直有效。\n2. 无法主动更新Token的有效性，只要用户传回来的Token没有过期，服务器就会认为这个用户操作是有效的。比如一下这个场景：某用户被封禁，此时该用户所有操作都应该被禁止，但是由于之前发给用户的JWT Token还没有过期，服务器仍然认为该用户操作合法。有一个解决方案是维护一张JWT黑名单表，只有没在表上的用户的JWT是有效的。**但是随之而来又有一个问题便是这个JWT黑名单表存在哪里。存在服务器，那么又要搞多服务器同步。存在关系数据库，那么查数据库效率又低。存在Redis，则又回到了Token丢失问题。** \n3. 其实解析JWT Token也是消耗服务器CPU的\n\n#### 总结\n\n1. 由于jwt是无状态的，它一发布开始，就意味着固定了过期时间。我们没法对他做**失效**，没法实现**续期**，它的好处也是显而易见的。不需要任何一个中心化的地方去保存它，管理它，查询它，比对它。\n\n### 双token方案\n\n双token是为了**解决jwt的续期**问题的。由于jwt一颁布，就意味着在指定时间内能够通行。\n\n1. 如果给的有**效期过长**，风险是比较大的，服务器失去了掌控力。在这期间如果想让用户失效，或者是有人盗取了token。都可以胡作非为好久。\n2. 如果给的有**效期过短**，用户经常需要重新登录，体验也很不好。\n3. 如果**中心化管理**用户状态，也就是每次解析jwt token之后，还需要去中心化比对能否通过。这样又违背了初衷。增加每次**认证的耗时**\n\n双token分为`access_token`和`refresh_token`。一般`access_token`的有效期可以设置为10分钟，`refresh_token`的有效期可以设置为7天。用户每次请求都用`access_token`，如果前端发现请求401，也就是过期了，就用`refresh_token`去重新申请一个`access_token`。继续请求。\n\n这里的关键在于，`refresh_token`申请`access_token`的时候，用户是无感知的，前后端的框架自动去更新这个新的`access_token`。\n\n还有一个点在申请`access_token`的时候，后端这时候会去校验用户的状态等问题，如果发现用户被禁用了，就申请不到token了。\n\n#### 总结\n\n双token是一个多方平衡的完美方案。它希望对用户的认证有所**掌控**，又不希望每次的检验会增加**耗时**。它不想给用户**过长的授权时间**，又不想用户因此**频繁登录**影响体验。因此变成了每隔一段`access_token`的过期时间，都会重新掌控局面，进行重新认证的复杂判断。\n\n### 中心管理token\n\nJWT碰巧有去中心化的特性，但为了能够控制它的**上下线**，**主动下线** ，**登录续期**等功能。我们依然可以对它进行中心化的管理。\n\n~~这也是抹茶当前采用的方式(参考的大佬文章)~~。依赖redis中心化管理uid-》token的信息。确保一个uid只有一个有效的token。用户登录后，每一次认证都会解析出uid，并请求redis进行token比对。并且异步判断有效期小于一天，进行续期。\n\n> 有人说为啥不用uuid做token呢，既然都是redis中心存储，用uuid还可以少一次解析。\n\n如果用uuid，前端每一次请求除了带上uuid还需要带上uid。\n\n因为单纯用uuid，黑客很有可能不断遍历uuid去撞库，碰巧撞到有关联的在线用户。而如果将uuid和uid一起比对，哪怕uuid碰巧撞到了登录的用户，还需要确保是相同的uid。这个概率会降低非常之多。\n\n用jwt的话，正好包含了uid，让前端传起来方便，所以就这么选择了。\n\n大家明白了其中的差别，到时候就懂得怎么去对线面试官的。其实我们用jwt，但是却没怎么用到它的特性。本质上这样的场景用个uuid就差不多了\n\n## 分布式锁\n\nRedisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。\n\n**依赖**\n\n```xml\n<dependency>\n      <groupId>org.redisson</groupId>\n      <artifactId>redisson-spring-boot-starter</artifactId>\n</dependency>\n```\n\n使用Redission实现分布式很简单\n\n比如就一个简单的发放物品\n\n```java\nRLock lock = redissonClient.getLock(\"acquireItem\" + idempotent);\nboolean b = lock.tryLock();\nAssertUtil.isTrue(b, \"请求太频繁了\");\ntry {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotent(idempotent);\n    if (Objects.nonNull(userBackpack)){\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpack(uid, itemId, idempotent);\n    userBackpackDao.save(insert);\n} finally {\n    lock.unlock();\n}\n```\n\n通过`redissonClient.getLock(key)`获取锁对象，用`lock.tryLock()`就能获取锁，用`lock.unlock()`就能释放锁\n\n现在对这个redisson的锁的部分进行封装，分别使用使用**编程式**的方法和**注解**方法进行改造，简化逻辑代码\n\n### 编程式\n\n新建一个`LockService`来实现分布式锁的公共部分\n\n```java\n@Service\npublic class LockService {\n\n    @Autowired\n    private RedissonClient redissonClient;\n\n    /**\n     *\n     * @param key\n     * @param waiteTime\n     * @param timeUnit\n     * @param supplier 只有出参没有入参, Function：既有出参又有入参\n     * @param <T>\n     * @return\n     */\n    @SneakyThrows\n    public <T> T executeWithLock(String key, int waiteTime, TimeUnit timeUnit, Supplier<T> supplier) {\n        RLock lock = redissonClient.getLock(key);\n        boolean b = lock.tryLock(waiteTime, timeUnit);\n        if (!b){\n            throw new BusinessException(CommonErrorEnum.LOCK_LIMIT);\n        }\n        try {\n            return supplier.get();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public <T> T executeWithLock(String key, Supplier<T> supplier) {\n        return executeWithLock(key, -1, TimeUnit.MILLISECONDS, supplier);\n    }\n\n    /**\n     *\n     * @param key\n     * @param runnable 既不传参，也不返参\n     * @param <T>\n     * @return\n     * @throws InterruptedException\n     */\n    public <T> T executeWithLock(String key, Runnable runnable) {\n        return executeWithLock(key, -1, TimeUnit.MILLISECONDS, () -> {\n            runnable.run();\n            return null;\n        });\n    }\n}\n```\n\n这里对`executeWithLock`方法进行了重载，能够适应多种加锁的场景【可以实现有返回值的，无返回值，既有出参又有入参的】\n\n说明一下`Supplier`：只有出参没有入参，`Function`：既有出参又有入参，`Runnable`：既不传参，也不返参\n\n`executeWithLock`方法实现了分布式的公共部分，具体的代码逻辑由`supplier.get()`实现，也就是通过参数传入，需要我们自己来写\n\n**编程式的修改代码如下**\n\n```java\nlockService.executeWithLock(\"acquireItem\" + idempotent, () -> {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotent(idempotent);\n    if (Objects.nonNull(userBackpack)){\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpack(uid, itemId, idempotent);\n    userBackpackDao.save(insert);\n});\n```\n\n比原先相比代码量减少了，可复用性提高了\n\n### 注解\n\n新建一个分布式注解`RedissonLock`\n\n```java\n@Retention(RetentionPolicy.RUNTIME) // 运行时生效\n@Target(ElementType.METHOD) // 作用在方法上\npublic @interface RedissonLock {\n\n    /**\n     * key的前缀\n     * @return\n     */\n    String prefixKey() default \"\";\n\n    /**\n     * EL表达式\n     * @return\n     */\n    String key();\n\n    /**\n     * 等待锁时间，默认不等待\n     * @return\n     */\n    int waitTime() default -1;\n\n    /**\n     * 时间单位，默认毫秒\n     * @return\n     */\n    TimeUnit timeUnit() default TimeUnit.MILLISECONDS;\n}\n```\n\n对这个注解进行切面\n\n```java\n@Component\n@Aspect\n@Order(0) // 确保在事务注解之前先执行，分布式在事务外\npublic class RedissonLockAspect {\n\n    @Autowired\n    private LockService lockService;\n\n    @Around(\"@annotation(redissonLock)\")\n    public Object around(ProceedingJoinPoint joinPoint, RedissonLock redissonLock) {\n        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n        String prefix = StrUtil.isBlank(redissonLock.prefixKey()) ? SpElUtils.getMethodKey(method) : redissonLock.prefixKey();\n        String key = SpElUtils.parseSpEl(method, joinPoint.getArgs(), redissonLock.key());\n        return lockService.executeWithLock(prefix + \":\" + key, redissonLock.waitTime(), redissonLock.timeUnit(), joinPoint::proceed);\n    }\n}\n```\n\nprefix为前缀，若没有给定，就需要通过`method.getDeclaringClass() + \"#\" + method.getName()`为默认的前缀\n\nkey为关键字，需要通过给定的**EL表达式**来进行匹配【会将给定的key和方法的参数名称进行匹配，若一致就写入`EvaluationContext（类似于map，键为方法参数名称，值为方法参数的值）`中】，用`parser.parseExpression`解析EL表达式，返回解析结果\n\n具体的匹配代码如下\n\nSpElUtils：EL表达式工具\n\n```java\npublic class SpElUtils {\n    private static final ExpressionParser parser = new SpelExpressionParser();\n    private static final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n    public static String parseSpEl(Method method, Object[] args, String spEl) {\n        String[] params = Optional.ofNullable(parameterNameDiscoverer.getParameterNames(method)).orElse(new String[]{});//解析参数名\n        EvaluationContext context = new StandardEvaluationContext();//el解析需要的上下文对象\n        for (int i = 0; i < params.length; i++) {\n            context.setVariable(params[i], args[i]);//所有参数都作为原材料扔进去\n        }\n        Expression expression = parser.parseExpression(spEl);\n        return expression.getValue(context, String.class);\n    }\n\n    public static String getMethodKey(Method method) {\n        return method.getDeclaringClass() + \"#\" + method.getName();\n    }\n}\n```\n\n注解切面的最后就是将解析出来的key，waitTime，timeUnit，joinPoint::proceed(自己写的逻辑)当作参数传入`lockService.executeWithLock()`自己写的编程式方法中\n\n**使用注解方法修改的代码如下**\n\n```java\n@Override\npublic void acquireItem(Long uid, Long itemId, IdempotentEnum idempotentEnum, String businessId) {\n    // 幂等号\n    String idempotent = getIdempotent(uid, itemId, businessId);\n\n    // 分布式注解方法\n    userBackpackService.doAcquire(uid, itemId, idempotent);\n}\n\n@Transactional\n@RedissonLock(key = \"#idempotent\", waitTime = 5000)\npublic void doAcquire(Long uid, Long itemId, String idempotent) {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotent(idempotent);\n    if (Objects.nonNull(userBackpack)) {\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpack(uid, itemId, idempotent);\n    userBackpackDao.save(insert);\n}\n```\n\n## IP归属地\n\n### 具体流程\n\nIP归属地是社交网站常用的功能，实现起来非常简单\n\n大致步骤：hutool工具类解析出ip地址 -> 通过淘宝的接口获取归属地 -> 更新数据库\n\n本项目是在**登录之后**，**带token请求http**，**带token连接ws**，这几处进行ip解析\n\n### 核心代码\n\n```java\nprivate void loginSuccess(Channel channel, User user, String token) {\n    // 保存用户channel和uid对应关系\n    WSChannelExtraDTO wsChannelExtraDTO = ONLINE_WS_MAP.get(channel);\n    wsChannelExtraDTO.setUid(user.getId());\n    // 给前端推送消息\n    sendMsg(channel, WebSocketAdapter.buildResp(user, token));\n    // 用户上线事件\n    user.setLastOptTime(LocalDateTime.now());\n    user.refreshIp(NettyUtil.getAttr(channel, NettyUtil.IP));\n    applicationEventPublisher.publishEvent(new UserOnlineEvent(this, user));\n}\n```\n\nUser实体\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = false)\n@TableName(value = \"user\", autoResultMap = true)\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 用户id\n     */\n      @TableId(value = \"id\", type = IdType.AUTO)\n    private Long id;\n\n    /**\n     * 用户昵称\n     */\n    @TableField(\"name\")\n    private String name;\n\n    /**\n     * 用户头像\n     */\n    @TableField(\"avatar\")\n    private String avatar;\n\n    /**\n     * 性别 1为男性，2为女性\n     */\n    @TableField(\"sex\")\n    private Integer sex;\n\n    /**\n     * 微信openid用户标识\n     */\n    @TableField(\"open_id\")\n    private String openId;\n\n    /**\n     * 在线状态 1在线 2离线\n     */\n    @TableField(\"active_status\")\n    private Integer activeStatus;\n\n    /**\n     * 最后上下线时间\n     */\n    @TableField(\"last_opt_time\")\n    private LocalDateTime lastOptTime;\n\n    /**\n     * ip信息\n     */\n    @TableField(value = \"ip_info\", typeHandler = JacksonTypeHandler.class)\n    private IpInfo ipInfo;\n\n    /**\n     * 佩戴的徽章id\n     */\n    @TableField(\"item_id\")\n    private Long itemId;\n\n    /**\n     * 使用状态 0.正常 1拉黑\n     */\n    @TableField(\"status\")\n    private Integer status;\n\n    /**\n     * 创建时间\n     */\n    @TableField(\"create_time\")\n    private LocalDateTime createTime;\n\n    /**\n     * 修改时间\n     */\n    @TableField(\"update_time\")\n    private LocalDateTime updateTime;\n\n\n    public void refreshIp(String attr) {\n        if (ipInfo == null){\n            ipInfo = new IpInfo();\n        }\n        ipInfo.refreshIp(attr);\n    }\n}\n```\n\nIpInfo实体\n\n```java\n@Data\npublic class IpInfo implements Serializable {\n\n    // 注册的ip\n    private String createIp;\n\n    // 注册时ip的详情\n    private IpDetail ipDetail;\n\n    // 更新的ip\n    private String updateIp;\n\n    // 更新时的ip详情\n    private IpDetail updateIpDetail;\n\n    public void refreshIp(String ip) {\n        if (StrUtil.isBlank(ip)){\n            return;\n        }\n        if (StrUtil.isBlank(createIp)){\n            createIp = ip;\n        }\n        updateIp = ip;\n    }\n\n    public String needRefreshIp() {\n        boolean needRefresh = Optional.ofNullable(updateIpDetail)\n                .map(IpDetail::getIp)\n                .filter(item -> Objects.equals(updateIp, item))\n                .isPresent(); // 判断结果是否是null\n\n        return needRefresh ? null : updateIp;\n    }\n\n    public void refreshIpDetail(IpDetail ipDetail) {\n        if (Objects.equals(ipDetail.getIp(), createIp)){\n            this.ipDetail = ipDetail;\n        }\n        if (Objects.equals(ipDetail.getIp(), updateIp)){\n            this.updateIpDetail = ipDetail;\n        }\n\n    }\n}\n```\n\n`refreshIp`是对当前登录的ip进行刷新，有个关键点就是先对注册ip进行判断，注册的ip无就需要对注册的ip进行赋值，其次在是更新的ip\n\n在用户登录成功后，通过` applicationEventPublisher.publishEvent(new UserOnlineEvent(this, user));`发送异步消息SpringEvent，通过一个事件监听来接受\n\n```java\n@Component\npublic class UserOnlineListener {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private IpService ipService;\n\n    @Async // 异步执行\n    @EventListener(classes = UserOnlineEvent.class)\n    public void userOnline(UserOnlineEvent event){\n        User user = event.getUser();\n        // 更新用户信息【Ip，是否登录等】\n        User update = new User();\n        update.setId(user.getId());\n        update.setLastOptTime(user.getLastOptTime());\n        update.setIpInfo(user.getIpInfo());\n        update.setActiveStatus(UserActiveStatusEnum.ONLINE.getType());\n        userDao.updateById(update);\n        // 用户IP解析\n        ipService.refreshDetailAsync(user.getId());\n\n    }\n}\n```\n\n这里是对用户的信息做了更新【最后一次登录事件，登录状态，IP信息】，用`ipService.refreshDetailAsync(user.getId())`实现对IP的异步刷新解析\n\n```java\n@Service\n@Slf4j\npublic class IpServiceImpl implements IpService {\n\n    private static ExecutorService executor = new ThreadPoolExecutor(1, 1,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(500), new NamedThreadFactory(\"refresh-ipDetail\", false));\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void refreshDetailAsync(Long id) {\n        executor.execute(() -> {\n            User user = userDao.getById(id);\n            IpInfo ipInfo = user.getIpInfo();\n            if (Objects.isNull(ipInfo)){\n                return;\n            }\n            // 判断是否需要刷新ip详情\n            String ip = ipInfo.needRefreshIp();\n            if (StrUtil.isBlank(ip)){\n                // 更新ip和更新ip一致无需刷新\n                return;\n            }\n\n            // 获取ip详情\n            IpDetail ipDetail = tryGetIpDetailOrNull(ip);\n            if (Objects.nonNull(ipDetail)){\n                // 刷新ipInfo的详情\n                ipInfo.refreshIpDetail(ipDetail);\n                // 更新ip详情\n                User update = new User();\n                update.setIpInfo(ipInfo);\n                update.setId(id);\n                userDao.updateById(update);\n            }\n        });\n    }\n\n    private IpDetail tryGetIpDetailOrNull(String ip) {\n        for (int i = 0; i < 3; i++){\n            IpDetail ipDetail = getIpDetailOrNull(ip);\n            if (Objects.nonNull(ipDetail)){\n                return ipDetail;\n            }\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e){\n                log.error(\"tryGetIpDetailOrNull InterruptedException\", e);\n            }\n        }\n        return null;\n    }\n\n    private IpDetail getIpDetailOrNull(String ip) {\n        String body = HttpUtil.get(\"https://ip.taobao.com/outGetIpInfo?ip=\" + ip + \"&accessKey=alibaba-inc\");\n        try {\n            ApiResult<IpDetail> result = JSONUtil.toBean(body, new TypeReference<ApiResult<IpDetail>>() {\n            }, false);\n            if (result.isSuccess()) {\n                return result.getData();\n            }\n        } catch (Exception e) {\n            return null;\n        }\n\n        return null;\n    }\n}\n```\n\n在实现方法`refreshDetailAsync`中，使用了线程池来进行异步排队处理，设置了最大容量为1个，并且设置了`refresh-ipDetail`线程前缀来便于排查出问题\n\n通过`needRefreshIp`判断是否需要刷新，若需要刷新就返回要刷新的ip地址，否则就返回null；是否刷新的判断依据是用用户当前数据库已经保存的IP解析的地址和当前登录的ip地址进行对比，若一致就返回null，否则就返回当前的登录的ip地址\n\n`tryGetIpDetailOrNull`方法是尝试获取ip解析信息，有3次机会，每次执行完有2秒的睡眠时间\n\n`refreshIpDetail`方法是刷新当前用户的ip解析信息，通过ip进行判断是注册ip还是更新ip，从而进行赋值\n\n## 黑名单功能\n\n### 具体流程\n\n实现黑名单功能就是将用户的ip和id放在黑名单数据库中，通过拦截器判断登陆的用户是否在名单中，从而决定是否拦截通过\n\n本项目中的黑名单功能需要用到权限，权限管理多用于b端项目，对于c端来说，权限没有到那么复杂的级别。因此权限设计只涉及到了用户身份\n\n![](https://cdn.nlark.com/yuque/0/2023/png/26318626/1686979132303-1934c4b2-943f-45d3-b892-a78a228e4821.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_109%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1280%2Climit_0)\n\n**流程**：登录的时候返回角色 -> 管理拉黑【判断权限】-> 推送给前端消息 -> 写入黑名单表， 修改状态【SpringEvent事件异步处理】 -> 拉黑用户拦截\n\n### **核心代码**\n\n判断用户是否具有某个权限，用来set巧妙处理\n\n```java\n@Service\npublic class RoleDao implements IRoleService {\n\n    @Autowired\n    private UserCache userCache;\n\n    @Override\n    public boolean isPower(Long uid, RoleEnum roleEnum) {\n        // 获取用户所有权限\n        Set<Long> roleSet = userCache.getRoleSet(uid);\n\n        return isAdmin(roleSet) || roleSet.contains(roleEnum.getId());\n    }\n\n    private boolean isAdmin(Set<Long> roleSet){\n        return roleSet.contains(RoleEnum.ADMIN.getId());\n    }\n}\n```\n\n将用户写入黑名单，并且通过SpringEvent发送异步事件处理黑名单事件\n\n```java\n @Override\n @Transactional(rollbackFor = Exception.class)\n public void black(BlackReq blackReq) {\n     // 将id写入黑名单\n     Long uid = blackReq.getUid();\n     Black black = new Black();\n     black.setType(BlackTypeEnum.UID.getId());\n     black.setTarget(uid.toString());\n     blackDao.save(black);\n    // 将ip写入黑名单\n    User user = userDao.getById(uid);\n    blackIp(Optional.ofNullable(user.getIpInfo().getCreateIp()).orElse(null));\n    blackIp(Optional.ofNullable(user.getIpInfo().getUpdateIp()).orElse(null));\n\n    applicationEventPublisher.publishEvent(new UserBlackEvent(this, user));\n}\n\n/**\n * 封禁IP\n *\n * @param ip\n */\nprivate void blackIp(String ip) {\n    if (StrUtil.isBlank(ip)) {\n        return;\n    }\n\n    try {\n        Black insert = new Black();\n        insert.setTarget(ip);\n        insert.setType(BlackTypeEnum.IP.getId());\n        blackDao.save(insert);\n    } catch (Exception e) {\n\n    }\n}\n```\n\n监听黑名单事件并作处理【推送前端消息，更新用户状态，清空黑名单缓存列表(拦截器处理的时候会用到)】\n\n```java\n@Component\npublic class UserBlackListener {\n\n    @Autowired\n    private WebSocketService webSocketService;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private UserCache userCache;\n\n    /**\n     * 推送前端消息\n     * @param event\n     */\n    @Async // 异步执行\n    @TransactionalEventListener(classes = UserBlackEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void sendMsg(UserBlackEvent event){\n        User user = event.getUser();\n        webSocketService.sendMsgToAll(WebSocketAdapter.buildBlack(user));\n    }\n\n    /**\n     * 更新用户状态\n     * @param event\n     */\n    @Async // 异步执行\n    @TransactionalEventListener(classes = UserBlackEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void changeActivity(UserBlackEvent event){\n        User user = event.getUser();\n        userDao.invalidUid(user.getId());\n    }\n\n    /**\n     * 清空黑名单缓存\n     * @param event\n     */\n    @Async // 异步执行\n    @TransactionalEventListener(classes = UserBlackEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void clearBlackList(UserBlackEvent event){\n        userCache.evictBlack();\n    }\n}\n```\n\n推送给前端所有用户这里用到了线程池，加快处理效率\n\n```java\n@Autowired\nprivate ThreadPoolTaskExecutor threadPoolTaskExecutor;\n\n@Override\npublic void sendMsgToAll(WSBaseResp<?> resp) {\n    ONLINE_WS_MAP.forEach(((channel, wsChannelExtraDTO) -> {\n        // 使用线程池，加快发送速度\n        threadPoolTaskExecutor.execute(() -> {\n            sendMsg(channel, resp);\n        });\n    }));\n}\n```\n\n## 游标翻页\n\n游标翻页更适用于一页一页跳转的场景，而对于跳页反转（例如第一页跳到第五页就不适用）\n\n本项目为聊天项目，适合适用游标翻页\n\n### 深翻页问题\n\n普通翻页前端一般会有个分页条。能够指定一页的**条数**，以及任意选择查看**第几页**。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685187350715-ec688988-ee5a-426e-88ea-dbb85f6aac22.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n对应的参数就是`pageNo`和`pageSize`\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685187427310-3e189d14-a215-4dbf-b86d-5badf5bd5a12.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n假设前端想要查看第11页的内容，传的值`pageNo`=11，`pageSize`=10\n\n其中`100`代表需要跳过的条数，`10`代表跳过指定条数后，往后需要再取的条数。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685188112380-ab4f8dec-f339-451b-87eb-2ae6ae1bfbe1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n对应图片就是这样的一个效果，需要在数据库的位置先读出100条，然后**丢弃**。丢弃完100条后，再继续取10条**选用**。\n\n如果我们翻页到了很深的地方，比如读到了第1000页，对应的sql语句就是`select * from table limit 10000,10`\n\n需要先查询10000条进行丢弃，再取那么个10条选用。这个效率也太低了，\n\n>  我们经常需要定时任务全量去跑一张表的数据，普通翻页去跑的话，到后面数据量大的时候，就会越跑越慢，这就是深翻页带来的问题。\n\n**解决办法**\n\n目前的问题在于每次翻页都需要花时间扫描一些不需要的记录，然后丢弃。那么是不是可以优化这个步骤呢？\n\n以后不论第几页，我们都不需要跳过一些值。直接取`limit 0,10`。这样语句变成了`select * from table limit 0,10`\n\n取到的是1-10这些记录，取不到我们想要的101-110，没关系，再加一个条件`select * from table where id>100 order by id limit 0,10`\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685188635346-68f634f3-3276-4f87-8788-4691ec990d83.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n只要id这个字段有索引，就能直接定位到101这个字段，然后去10条记录。以后无论翻页到多大，通过索引直接定位到读取的位置，效率基本是一样的。这个`id>100`就是我们的游标，这就是**游标翻页。**\n\n### 游标介绍\n\n游标翻页可以完美的解决深翻页问题，依赖的就是我们的游标，即`cursor`。针对mysql的游标翻页，我们需要通过`cursor`快速定位到指定记录，意味着游标必须添加索引。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685189222316-cf64fcf1-da85-46f0-b6b0-4088cd66b89e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n前端之前传的`pageNo`字段改成了`cursor`字段。`cursor`是上一次查询结果的位置，作为下一次查询的游标，由后端返回\n\n我们来模拟一次前后端的翻页交互\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685189899438-884c817d-0ee5-4b7d-a540-6be3bb135975.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n随着翻页的持续，游标不断往翻页的方向推进。\n\n**所以游标翻页不适合跳页，只能不断的往下翻。更适合C端的列表场景**\n\n### 总结\n\n游标翻页的`优点`：\n\n1.解决深翻页问题\n\n2.解决频繁变动的列表翻页问题。\n\n`缺点`：\n\n1.无法跳页，只能不断往下翻\n\n游标翻页更适合c端场景，用户只能不断下滑翻页。\n\n普通翻页更适合B端场景。用户能看见总页数，能随意跳页\n\n## 前后端资源懒加载\n\n### 选用原因\n\n#### 带宽占用\n\n对于项目中的个别请求，有时候会有大量冗余和重复的消息。特别是用户的`头像`，`名称`，`佩戴徽章`，这些东西，基本都是重复的，但是我们每一次的消息推送，成员上下线，都需要携带。\n\n对于这些数据，其实我们只想知道消息的拥有者是谁，也就是uid。其他的头像，徽章，这些我们之前都有，但是他们却占据了消息体的大部分内容，有效载荷太少。\n\n在压测的时候发现了很多时候我们的**瓶颈就在带宽**上。而带宽都被头像的url给占用了。\n\n#### 代码复杂度\n\n如果每次因为一个简单的消息推送，就要去写一套复杂的代码，去加载用户的名称，以及徽章相关的信息。都会增大后端代码的复杂度。\n\n每次组装vo数据，都得去查出用户的关联信息，进行组装。哪怕是可以复用这段代码，但是相应的性能损耗，也是不可避免的。\n\n### 解决办法\n\n#### 图片路径协议优化\n\n前后端可以将用户头像遵循一种固定的路径协议，比如`https://img.mallchat.cn/avatar/{uid}.png`;\n\n这样只给前端uid，他自己就能组装出用户头像了\n\n#### 懒加载时间点\n\n前端在什么场景下会请求后端进行信息懒加载，每次请求后端，需要更新自己库里的懒加载时间`lastModifyTime`\n\n- 没数据加载\n- 数据过期加载（校验）：`lastModifyTime`小于数据库存的`lastModifyTime`\n- 主动加载（校验）：例如用户主动点击头像查询信息\n\n### 总结\n\n了解到了项目的**瓶颈**，大多是来源带宽不足。为了**节省带宽**，同时简化后端的逻辑，我们设计了一套**前后端资源懒加载的交互框架**。他有三个懒加载的**时间点**，同时保证了**及时性**，以及**最终一致性**。这个框架的核心就是**lastModifyTime**字段的定义。有了它，只要没有变动，后端都可以不返回用户信息，又能节省一大部分带宽。并且为了不需要展示的字段不返回null。我们用了一个json的注解，又节省了一小部分带宽。\n\n## 批量缓存框架\n\n缓存通常有两种使用方式，一种是Cache-Aside，一种是cache-through。也就是旁路缓存和缓存即数据源。\n\n一般一种用于读，另一种用于读写。\n\n### 盘路缓存\n\n我们通常用的都是旁路缓存模式\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1696084655149-bf1c5c2b-3626-45b2-8b43-0d9268f5a6bc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\nGET缓存获取不到，就LOAD加载数据库，再将数据库写回redis缓存。\n\n盘路缓存也有很好用的框架，比如spring-cache。只需要写load逻辑。加上个注解，就能实现盘路缓存的效果。\n\n**缺点**：在极端情况下。我需要获取一批用户的信息，碰巧所有用户的缓存都失效了，都需全部重新加载。那么这样一个本来性能很高的循环，就等同于全部查了数据库，缓存一点儿作用都没了。\n\n### 批量缓存查询\n\n对于这种批量查询缓存的需求，传统的旁路缓存框架无法达到我们的需求。我们需要让他能够批量的get or load。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1696085632392-3b47a5e4-9700-4702-9ede-bef81682e82e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n类似这张图，批量的get。发现没有的数据，再批量的load一次，这样和redis以及数据库的交互都只会有一次。\n\n**具体代码**\n\n```java\n/**\n * 获取用户信息，盘路缓存模式\n */\npublic Map<Long, User> getUserInfoBatch(Set<Long> uids) {\n    //批量组装key\n    List<String> keys = uids.stream().map(a -> RedisKey.getKey(RedisKey.USER_INFO_STRING, a)).collect(Collectors.toList());\n    //批量get\n    List<User> mget = RedisUtils.mget(keys, User.class);\n    Map<Long, User> map = mget.stream().filter(Objects::nonNull).collect(Collectors.toMap(User::getId, Function.identity()));\n    //发现差集——还需要load更新的uid\n    List<Long> needLoadUidList = uids.stream().filter(a -> !map.containsKey(a)).collect(Collectors.toList());\n    if (CollUtil.isNotEmpty(needLoadUidList)) {\n        //批量load\n        List<User> needLoadUserList = userDao.listByIds(needLoadUidList);\n        Map<String, User> redisMap = needLoadUserList.stream().collect(Collectors.toMap(a -> RedisKey.getKey(RedisKey.USER_INFO_STRING, a.getId()), Function.identity()));\n        RedisUtils.mset(redisMap, 5 * 60);\n        //加载回redis\n        map.putAll(needLoadUserList.stream().collect(Collectors.toMap(User::getId, Function.identity())));\n    }\n    return map;\n}\n```\n\n我们在很多处都要用到这个接口，所以就需要对这个批量查询缓存进行封装\n\n这时候又要轮到我们的常规抽象环节了\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1696085827579-fa03f689-bdb1-476e-b53f-a291b3314660.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n黄色代表可复用的流程，红色代表个性化的代码。\n\n### 批量缓存框架\n\n先创建批量缓存框架的接口\n\n接口\n\n```java\npublic interface BatchCache<IN, OUT> {\n    /**\n     * 获取单个\n     */\n    OUT get(IN req);\n\n    /**\n     * 获取批量\n     */\n    Map<IN, OUT> getBatch(List<IN> req);\n\n    /**\n     * 修改删除单个\n     */\n    void delete(IN req);\n\n    /**\n     * 修改删除多个\n     */\n    void deleteBatch(List<IN> req);\n}\n```\n\n再通过抽象类，定义好骨架\n\n抽象类\n\n```java\npublic abstract class AbstractRedisStringCache<IN, OUT> implements BatchCache<IN, OUT> {\n\n    private Class<OUT> outClass;\n\n    protected AbstractRedisStringCache() {\n        ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass();\n        this.outClass = (Class<OUT>) genericSuperclass.getActualTypeArguments()[1];\n    }\n\n    protected abstract String getKey(IN req);\n\n    protected abstract Long getExpireSeconds();\n\n    protected abstract Map<IN, OUT> load(List<IN> req);\n\n    @Override\n    public OUT get(IN req) {\n        return getBatch(Collections.singletonList(req)).get(req);\n    }\n\n    @Override\n    public Map<IN, OUT> getBatch(List<IN> req) {\n        if (CollectionUtil.isEmpty(req)) {//防御性编程\n            return new HashMap<>();\n        }\n        //去重\n        req = req.stream().distinct().collect(Collectors.toList());\n        //组装key\n        List<String> keys = req.stream().map(this::getKey).collect(Collectors.toList());\n        //批量get\n        List<OUT> valueList = RedisUtils.mget(keys, outClass);\n        //差集计算\n        List<IN> loadReqs = new ArrayList<>();\n        for (int i = 0; i < valueList.size(); i++) {\n            if (Objects.isNull(valueList.get(i))) {\n                loadReqs.add(req.get(i));\n            }\n        }\n        Map<IN, OUT> load = new HashMap<>();\n        //不足的重新加载进redis\n        if (CollectionUtil.isNotEmpty(loadReqs)) {\n            //批量load\n            load = load(loadReqs);\n            Map<String, OUT> loadMap = load.entrySet().stream()\n                    .map(a -> Pair.of(getKey(a.getKey()), a.getValue()))\n                    .collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));\n            RedisUtils.mset(loadMap, getExpireSeconds());\n        }\n\n        //组装最后的结果\n        Map<IN, OUT> resultMap = new HashMap<>();\n        for (int i = 0; i < req.size(); i++) {\n            IN in = req.get(i);\n            OUT out = Optional.ofNullable(valueList.get(i))\n                    .orElse(load.get(in));\n            resultMap.put(in, out);\n        }\n        return resultMap;\n    }\n\n    @Override\n    public void delete(IN req) {\n        deleteBatch(Collections.singletonList(req));\n    }\n\n    @Override\n    public void deleteBatch(List<IN> req) {\n        List<String> keys = req.stream().map(this::getKey).collect(Collectors.toList());\n        RedisUtils.del(keys);\n    }\n}\n```\n\n这时候你就会发现，写一个批量的旁路缓存有多简单。\n\n具体实现\n\n```java\n@Component\npublic class UserInfoCache extends AbstractRedisStringCache<Long, User> {\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    protected String getKey(Long uid) {\n        return RedisKey.getKey(RedisKey.USER_INFO_STRING, uid);\n    }\n\n    @Override\n    protected Long getExpireSeconds() {\n        return 5 * 60L;\n    }\n\n    @Override\n    protected Map<Long, User> load(List<Long> uidList) {\n        List<User> needLoadUserList = userDao.listByIds(uidList);\n        return needLoadUserList.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n    }\n}\n```\n","title":" MallChat项目笔记\n","category":[" SpringBoot","实战项目\n"],"date":" 2024-02-08\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 微信扫码登录\n\n 准备\n\n 工具\n\n 误区：微信扫码登录每个人都可以，不是只有认证号才行。测试阶段可以用测试接口来进行测试，只不过项目部署后才需要认证使用\n\n 注意：微信回调接口需要开启内网穿透\n\n 微信公众号的开发者账号：点击此处进行注册https://mp.weixin.qq.com/\n 内网穿透工具：点击此处注册https://natapp.cn/\n\n 引入依赖\n\nxml\n<dependency\n    <groupIdcom.github.binarywang</groupId\n    <artifactIdweixinjavamp</artifactId\n    <version4.4.0</version\n</dependency\n\n\n 配置文件\n\n这里配置文件参考Binary Wang的代码\n\nyml\nwx:\n  mp:\n    callback: ${mallchat.wx.callback}  回调地址\n    configs:\n       appId: ${mallchat.wx.appId}  第一个公众号的appid\n        secret: ${mallchat.wx.secret}  公众号的appsecret\n        token: ${mallchat.wx.token}  接口配置里的Token值\n        aesKey: ${mallchat.wx.aesKey}  接口配置里的EncodingAESKey值\n\n\nWxMpProperties.java\n\njava\n@Data\n@ConfigurationPropertiesprefix = \"wx.mp\"\npublic class WxMpProperties {\n    /\n      是否使用redis存储access token\n     /\n    private boolean useRedis;\n\n    /\n      redis 配置\n     /\n    private RedisConfig redisConfig;\n\n    @Data\n    public static class RedisConfig {\n        /\n          redis服务器 主机地址\n         /\n        private String host;\n\n        /\n          redis服务器 端口号\n         /\n        private Integer port;\n\n        /\n          redis服务器 密码\n         /\n        private String password;\n\n        /\n          redis 服务连接超时时间\n         /\n        private Integer timeout;\n    }\n\n    /\n      多个公众号配置信息\n     /\n    private List<MpConfig configs;\n\n    @Data\n    public static class MpConfig {\n        /\n          设置微信公众号的appid\n         /\n        private String appId;\n\n        /\n          设置微信公众号的app secret\n         /\n        private String secret;\n\n        /\n          设置微信公众号的token\n         /\n        private String token;\n\n        /\n          设置微信公众号的EncodingAESKey\n         /\n        private String aesKey;\n    }\n\n    @Override\n    public String toString {\n        return JSONUtil.toJsonStrthis;\n    }\n}\n\n\nWxMpConfiguration.java\n\njava\n@AllArgsConstructor\n@Configuration\n@EnableConfigurationPropertiesWxMpProperties.class\npublic class WxMpConfiguration {\n    private final LogHandler logHandler;\n    private final MsgHandler msgHandler;\n    private final SubscribeHandler subscribeHandler;\n    private final ScanHandler scanHandler;\n    private final WxMpProperties properties;\n\n    @Bean\n    public WxMpService wxMpService {\n        // 代码里 getConfigs处报错的同学，请注意仔细阅读项目说明，你的IDE需要引入lombok插件！！！！\n        final List<WxMpProperties.MpConfig configs = this.properties.getConfigs;\n        if configs == null {\n            throw new RuntimeException\"大哥，拜托先看下项目首页的说明（readme文件），添加下相关配置，注意别配错了！\";\n        }\n\n        WxMpService service = new WxMpServiceImpl;\n        service.setMultiConfigStoragesconfigs\n                .stream.mapa  {\n                    WxMpDefaultConfigImpl configStorage;\n                    configStorage = new WxMpDefaultConfigImpl;\n\n                    configStorage.setAppIda.getAppId;\n                    configStorage.setSecreta.getSecret;\n                    configStorage.setTokena.getToken;\n                    configStorage.setAesKeya.getAesKey;\n                    return configStorage;\n                }.collectCollectors.toMapWxMpDefaultConfigImpl::getAppId, a  a, o, n  o;\n        return service;\n    }\n\n    @Bean\n    public WxMpMessageRouter messageRouterWxMpService wxMpService {\n        final WxMpMessageRouter newRouter = new WxMpMessageRouterwxMpService;\n\n        // 记录所有事件的日志 （异步执行）\n        newRouter.rule.handlerthis.logHandler.next;\n\n        // 关注事件\n        newRouter.rule.asyncfalse.msgTypeEVENT.eventSUBSCRIBE.handlerthis.subscribeHandler.end;\n\n        // 扫码事件\n        newRouter.rule.asyncfalse.msgTypeEVENT.eventEventType.SCAN.handlerthis.scanHandler.end;\n\n        // 默认\n        newRouter.rule.asyncfalse.handlerthis.msgHandler.end;\n\n        return newRouter;\n    }\n\n}\n\n\n 配置消息处理器\n\nAbstractHandler.java\n\njava\npublic abstract class AbstractHandler implements WxMpMessageHandler {\n    protected Logger logger = LoggerFactory.getLoggergetClass;\n}\n\n\nLogHandler.java（日志）\n\njava\n@Component\n@Slf4j\npublic class LogHandler extends AbstractHandler {\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMessage,\n                                    Map<String, Object context, WxMpService wxMpService,\n                                    WxSessionManager sessionManager {\n        log.info\"\\n接收到请求消息，内容：{}\", JSONUtil.toJsonStrwxMessage;\n        return null;\n    }\n}\n\n\nMsgHandler.java\n\njava\n@Component\npublic class MsgHandler extends AbstractHandler {\n\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMessage,\n                                    Map<String, Object context, WxMpService weixinService,\n                                    WxSessionManager sessionManager {\n\n        return null;\n    }\n}\n\n\nScanHandler.java\n\njava\n@Component\npublic class ScanHandler extends AbstractHandler {\n\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /\n      处理用户扫码【不是第一次】\n     /\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMpXmlMessage, Map<String, Object map,\n                                    WxMpService wxMpService, WxSessionManager wxSessionManager throws WxErrorException {\n        // 扫码事件处理\n        return wxMsgService.scanwxMpService, wxMpXmlMessage;\n    }\n}\n\n\nSubscribeHandler.java\n\njava\n@Component\npublic class SubscribeHandler extends AbstractHandler {\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /\n      扫描登录二维码后第一次进入需要关注公众号\n      @param wxMessage\n      @param context\n      @param weixinService\n      @param sessionManager\n      @return\n      @throws WxErrorException\n     /\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMessage,\n                                    Map<String, Object context, WxMpService weixinService,\n                                    WxSessionManager sessionManager throws WxErrorException {\n\n        this.logger.info\"新关注用户 OPENID: \" + wxMessage.getFromUser;\n\n        WxMpXmlOutMessage responseResult = null;\n        try {\n            responseResult = this.handleSpecialweixinService, wxMessage;\n        } catch Exception e {\n            this.logger.errore.getMessage, e;\n        }\n\n        if responseResult = null {\n            return responseResult;\n        }\n\n        try {\n            return new TextBuilder.build\"感谢关注\", wxMessage, weixinService;\n        } catch Exception e {\n            this.logger.errore.getMessage, e;\n        }\n\n        return null;\n    }\n\n    /\n      处理特殊请求，比如如果是扫码进来的，可以做相应处理\n     /\n    private WxMpXmlOutMessage handleSpecialWxMpService weixinService, WxMpXmlMessage wxMessage\n            throws Exception {\n        return wxMsgService.scanweixinService, wxMessage;\n    }\n\n}\n\n\n 执行过程\n\n 1、获取登录二维码\n\njava\npublic void handleLoginReqChannel channel {\n  // 生成登录随机码\n  Integer code = generateLoginCodechannel;\n  // 微信生成带参二维码\n  WxMpQrCodeTicket wxMpQrCodeTicket = null;\n  try {\n      wxMpQrCodeTicket = wxMpService.getQrcodeService.qrCodeCreateTmpTicketcode, int DURATION.getSeconds;\n  } catch WxErrorException e {\n      e.printStackTrace;\n  }\n  // 把二维码推送前端\n  sendMsgchannel, WebSocketAdapter.buildRespwxMpQrCodeTicket;\n}\n\n\n这里我是对二维码做了过期策略，wxMpQrCodeTicket.getUrl就是带参二维码的地址，通过草料二维码生成器便能生成一个二维码\n\n 2、公众号返回登录授权\n\n在ScanHandler类的handle方法中写入，专门处理扫码登录事件\n\njava\nString openid = wxMpXmlMessage.getFromUser;\nInteger code = getEventKeywxMpXmlMessage;\nif ObjectUtil.isNullcode{\n    return null;\n}\n\n// 保存用户信息\nUser user = userDao.getByOpenIdopenid;\nboolean registered = Objects.nonNulluser;\nboolean authorized = registered && StrUtil.isNotBlankuser.getName;\nif registered && authorized{\n\t// 用户已经注册了，直接返回用户+token信息\n    webSocketService.scanLoginSuccesscode, user.getId;\n    return null;\n}\nif registered{\n    // 未写入数据库\n    User insert = UserAdapter.buildUserSaveopenid;\n    userService.registerinsert;\n}\nWAITAUTHORIZEMAP.putopenid, code;\n// 通知前端正在等待认证\nwebSocketService.waitAuthorizecode;\n// 拼接URL，获取认证地址\nString authorizeUrl = String.formatURL, wxMpService.getWxMpConfigStorage.getAppId, URLDecoder.decodecallback + \"wx/portal/public/callBack\";\nreturn TextBuilder.build\"请点击登录：<a href=\\\"\" + authorizeUrl + \"\\\"登录</a\", wxMpXmlMessage, wxMpService;\n\n\n当用户扫码并关注成功后，会自动弹出消息\n\n 请点击登录：登录\n\n用户点击登录后，会跳转到\"https://open.weixin.qq.com/connect/oauth2/authorize?appid=%s&redirecturi=%s&responsetype=code&scope=snsapiuserinfo&state=STATEwechatredirect\"微信授权页面，需要传入appid和回调接口地址，授权成功后将带着code参数访问给定的回调接口\n\n 3、微信调用给定的回调接口\n\njava\n@GetMapping\"/callBack\"\npublic RedirectView callBack@RequestParam String code {\n    try {\n        // 根据code获取token\n        WxOAuth2AccessToken accessToken = wxMpService.getOAuth2Service.getAccessTokencode;\n        // 根据token获取用户信息\n        WxOAuth2UserInfo userInfo = wxMpService.getOAuth2Service.getUserInfoaccessToken, \"zhCN\";\n        wxMsgService.authorizeuserInfo;\n    } catch Exception e {\n        log.error\"callBack error\", e;\n    }\n    RedirectView redirectView = new RedirectView;\n    redirectView.setUrl\"https://mp.weixin.qq.com/s/m1SRsBG96kLJW5mPe4AVGA\";\n    return redirectView;\n}\n\n\n通过回调传来的code获取token，通过token来获取微信用户信息【只有昵称和头像】\n\n wxMsgService.authorizeuserInfo将用户不全的信息【用户头像，昵称】进行更新，并生成token进行返回\n\n就这样，前端就拿到了后端传来的token\n\n 用户认证技术Token方案\n\nToken 的生成方式通常有以下几种：\n\n 随机字符串：可以使用一些随机数生成算法，如 UUID、Snowflake雪花算法 等来生成一个随机的字符串作为 Token。由于随机字符串本身就是随机分布的，因此具有很高的安全性。\n JWT（JSON Web Token）：JWT 是一种基于 JSON 格式的开放标准（RFC 7519），用于在多方之间安全地传输信息。它将用户身份信息和权限等相关信息编码成一个 JSON 对象，并通过数字签名或者加密等方式进行验证和保护。JWT 除了可以用于 Token 登录外，还可以用于 API 认证、单点登录等场景。\n SessionID。\n\n通常的Token在服务器端的实现方式有这几个：\n\n1. 用SessionID实现Token的功能\n2. 使用Json Web Token JWT\n3. 中心化存储Token\n\n下面分析一下各个存储方式的优缺点。\n\n Cookie + Session 登录\n\nHTTP 是一种无状态的协议。\n\n无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求返回数据，但不会记录任何信息。\n\n为了解决 HTTP 无状态的问题，出现了 Cookie。\n\nCookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。\n\nhttps://s11.ax1x.com/2024/02/01/pFMooHx.png\n\n认证流程：\n\n1. 前端输入账号密码，提交给后端\n2. 后端验证成功后，创建一个Session。Session是一种服务器端保存用户会话信息的机制，用于识别多次请求之间的逻辑关系。\n3. 后端将Session ID（通常是一个随机的字符串）返回给前端，并通过 Cookie 的方式将Session ID保存在浏览器中。这样就可以保证当用户再次发送请求时，后端可以通过该 Session ID 来识别用户身份，并完成相关的操作。\n4. 在后续的请求中，浏览器会自动将保存的 Cookie 信息发送到后端进行验证，如果 Session ID有效，则返回相应的数据。如果 Session ID 失效或者不存在，则需要重新登录获取新的 Session ID。\n5. 用户退出时，后端要删除对应的Session信息\n\n Cookie的设置原理\n\ncookie的简单之处，在于前端是无感知的，无需额外开发。这是http协议的约定，后端可以通过返回的报文，将cookie设置进网页，网页下次请求也会自动携带。SetCookie 命令\n\nhttps://s11.ax1x.com/2024/02/01/pFMoHUK.png\n\n 缺点\n\n 跨域问题：由于 Cookie 只能在同域名下共享，因此跨域访问时无法访问到对应的 Cookie 信息。这时，可能需要采用一些其他的跨域解决方案，如 JSONP、CORS 等。\n 扩展性问题：由于 Session 信息存储在服务器端，当系统扩展到多台服务器时，需要采用一些集中式的 Session 管理方案，否则会出现 Session 不一致或者丢失等问题。\n 一些移动设备和浏览器可能会禁用 Cookie 和 Session 机制，这会导致无法正常登录\n\n 总结\n\n 给服务器的sessionID其实就相当于是一个token，只不过前端是无感知的设置进cookie的，这种方案 通常适用于后台。\n 由于cookie的一些限制，这个token最好还是由前端主动保存比如保存到localStorage。登录的时候主动从请求头携带。\n 由于现在都是集群部署，token的关系保存，最好又是集中化管理，或者无状态化管理\n\n JWT实现token\n\n简单来说JWT就是通过可逆加密算法，生成一串包含用户、过期时间等关键信息的Token，每次请求服务器拿到这个Token解密出来就能得到用户信息，从而判断用户状态。\n\nhttps://s11.ax1x.com/2024/02/01/pFMob4O.png\n\n 优点\n\n1. JWT的最大特点是服务器不保存会话状态，无论哪个服务器解析出来的Token信息都一样，而且不需要做任何查询操作，省掉了数据库/Redis的开销\n\n 缺点\n\n1. 正式因为JWT的特点，使用期间不可能取消令牌或更改令牌的权限，一旦JWT签发，在有效期内将会一直有效。\n2. 无法主动更新Token的有效性，只要用户传回来的Token没有过期，服务器就会认为这个用户操作是有效的。比如一下这个场景：某用户被封禁，此时该用户所有操作都应该被禁止，但是由于之前发给用户的JWT Token还没有过期，服务器仍然认为该用户操作合法。有一个解决方案是维护一张JWT黑名单表，只有没在表上的用户的JWT是有效的。但是随之而来又有一个问题便是这个JWT黑名单表存在哪里。存在服务器，那么又要搞多服务器同步。存在关系数据库，那么查数据库效率又低。存在Redis，则又回到了Token丢失问题。 \n3. 其实解析JWT Token也是消耗服务器CPU的\n\n 总结\n\n1. 由于jwt是无状态的，它一发布开始，就意味着固定了过期时间。我们没法对他做失效，没法实现续期，它的好处也是显而易见的。不需要任何一个中心化的地方去保存它，管理它，查询它，比对它。\n\n 双token方案\n\n双token是为了解决jwt的续期问题的。由于jwt一颁布，就意味着在指定时间内能够通行。\n\n1. 如果给的有效期过长，风险是比较大的，服务器失去了掌控力。在这期间如果想让用户失效，或者是有人盗取了token。都可以胡作非为好久。\n2. 如果给的有效期过短，用户经常需要重新登录，体验也很不好。\n3. 如果中心化管理用户状态，也就是每次解析jwt token之后，还需要去中心化比对能否通过。这样又违背了初衷。增加每次认证的耗时\n\n双token分为accesstoken和refreshtoken。一般accesstoken的有效期可以设置为10分钟，refreshtoken的有效期可以设置为7天。用户每次请求都用accesstoken，如果前端发现请求401，也就是过期了，就用refreshtoken去重新申请一个accesstoken。继续请求。\n\n这里的关键在于，refreshtoken申请accesstoken的时候，用户是无感知的，前后端的框架自动去更新这个新的accesstoken。\n\n还有一个点在申请accesstoken的时候，后端这时候会去校验用户的状态等问题，如果发现用户被禁用了，就申请不到token了。\n\n 总结\n\n双token是一个多方平衡的完美方案。它希望对用户的认证有所掌控，又不希望每次的检验会增加耗时。它不想给用户过长的授权时间，又不想用户因此频繁登录影响体验。因此变成了每隔一段accesstoken的过期时间，都会重新掌控局面，进行重新认证的复杂判断。\n\n 中心管理token\n\nJWT碰巧有去中心化的特性，但为了能够控制它的上下线，主动下线 ，登录续期等功能。我们依然可以对它进行中心化的管理。\n\n这也是抹茶当前采用的方式参考的大佬文章。依赖redis中心化管理uid》token的信息。确保一个uid只有一个有效的token。用户登录后，每一次认证都会解析出uid，并请求redis进行token比对。并且异步判断有效期小于一天，进行续期。\n\n 有人说为啥不用uuid做token呢，既然都是redis中心存储，用uuid还可以少一次解析。\n\n如果用uuid，前端每一次请求除了带上uuid还需要带上uid。\n\n因为单纯用uuid，黑客很有可能不断遍历uuid去撞库，碰巧撞到有关联的在线用户。而如果将uuid和uid一起比对，哪怕uuid碰巧撞到了登录的用户，还需要确保是相同的uid。这个概率会降低非常之多。\n\n用jwt的话，正好包含了uid，让前端传起来方便，所以就这么选择了。\n\n大家明白了其中的差别，到时候就懂得怎么去对线面试官的。其实我们用jwt，但是却没怎么用到它的特性。本质上这样的场景用个uuid就差不多了\n\n 分布式锁\n\nRedisson是架设在Redis基础上的一个Java驻内存数据网格（InMemory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。\n\n依赖\n\nxml\n<dependency\n      <groupIdorg.redisson</groupId\n      <artifactIdredissonspringbootstarter</artifactId\n</dependency\n\n\n使用Redission实现分布式很简单\n\n比如就一个简单的发放物品\n\njava\nRLock lock = redissonClient.getLock\"acquireItem\" + idempotent;\nboolean b = lock.tryLock;\nAssertUtil.isTrueb, \"请求太频繁了\";\ntry {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotentidempotent;\n    if Objects.nonNulluserBackpack{\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpackuid, itemId, idempotent;\n    userBackpackDao.saveinsert;\n} finally {\n    lock.unlock;\n}\n\n\n通过redissonClient.getLockkey获取锁对象，用lock.tryLock就能获取锁，用lock.unlock就能释放锁\n\n现在对这个redisson的锁的部分进行封装，分别使用使用编程式的方法和注解方法进行改造，简化逻辑代码\n\n 编程式\n\n新建一个LockService来实现分布式锁的公共部分\n\njava\n@Service\npublic class LockService {\n\n    @Autowired\n    private RedissonClient redissonClient;\n\n    /\n     \n      @param key\n      @param waiteTime\n      @param timeUnit\n      @param supplier 只有出参没有入参, Function：既有出参又有入参\n      @param <T\n      @return\n     /\n    @SneakyThrows\n    public <T T executeWithLockString key, int waiteTime, TimeUnit timeUnit, Supplier<T supplier {\n        RLock lock = redissonClient.getLockkey;\n        boolean b = lock.tryLockwaiteTime, timeUnit;\n        if b{\n            throw new BusinessExceptionCommonErrorEnum.LOCKLIMIT;\n        }\n        try {\n            return supplier.get;\n        } finally {\n            lock.unlock;\n        }\n    }\n\n    public <T T executeWithLockString key, Supplier<T supplier {\n        return executeWithLockkey, 1, TimeUnit.MILLISECONDS, supplier;\n    }\n\n    /\n     \n      @param key\n      @param runnable 既不传参，也不返参\n      @param <T\n      @return\n      @throws InterruptedException\n     /\n    public <T T executeWithLockString key, Runnable runnable {\n        return executeWithLockkey, 1, TimeUnit.MILLISECONDS,   {\n            runnable.run;\n            return null;\n        };\n    }\n}\n\n\n这里对executeWithLock方法进行了重载，能够适应多种加锁的场景【可以实现有返回值的，无返回值，既有出参又有入参的】\n\n说明一下Supplier：只有出参没有入参，Function：既有出参又有入参，Runnable：既不传参，也不返参\n\nexecuteWithLock方法实现了分布式的公共部分，具体的代码逻辑由supplier.get实现，也就是通过参数传入，需要我们自己来写\n\n编程式的修改代码如下\n\njava\nlockService.executeWithLock\"acquireItem\" + idempotent,   {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotentidempotent;\n    if Objects.nonNulluserBackpack{\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpackuid, itemId, idempotent;\n    userBackpackDao.saveinsert;\n};\n\n\n比原先相比代码量减少了，可复用性提高了\n\n 注解\n\n新建一个分布式注解RedissonLock\n\njava\n@RetentionRetentionPolicy.RUNTIME // 运行时生效\n@TargetElementType.METHOD // 作用在方法上\npublic @interface RedissonLock {\n\n    /\n      key的前缀\n      @return\n     /\n    String prefixKey default \"\";\n\n    /\n      EL表达式\n      @return\n     /\n    String key;\n\n    /\n      等待锁时间，默认不等待\n      @return\n     /\n    int waitTime default 1;\n\n    /\n      时间单位，默认毫秒\n      @return\n     /\n    TimeUnit timeUnit default TimeUnit.MILLISECONDS;\n}\n\n\n对这个注解进行切面\n\njava\n@Component\n@Aspect\n@Order0 // 确保在事务注解之前先执行，分布式在事务外\npublic class RedissonLockAspect {\n\n    @Autowired\n    private LockService lockService;\n\n    @Around\"@annotationredissonLock\"\n    public Object aroundProceedingJoinPoint joinPoint, RedissonLock redissonLock {\n        Method method = MethodSignature joinPoint.getSignature.getMethod;\n        String prefix = StrUtil.isBlankredissonLock.prefixKey ? SpElUtils.getMethodKeymethod : redissonLock.prefixKey;\n        String key = SpElUtils.parseSpElmethod, joinPoint.getArgs, redissonLock.key;\n        return lockService.executeWithLockprefix + \":\" + key, redissonLock.waitTime, redissonLock.timeUnit, joinPoint::proceed;\n    }\n}\n\n\nprefix为前缀，若没有给定，就需要通过method.getDeclaringClass + \"\" + method.getName为默认的前缀\n\nkey为关键字，需要通过给定的EL表达式来进行匹配【会将给定的key和方法的参数名称进行匹配，若一致就写入EvaluationContext（类似于map，键为方法参数名称，值为方法参数的值）中】，用parser.parseExpression解析EL表达式，返回解析结果\n\n具体的匹配代码如下\n\nSpElUtils：EL表达式工具\n\njava\npublic class SpElUtils {\n    private static final ExpressionParser parser = new SpelExpressionParser;\n    private static final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer;\n\n    public static String parseSpElMethod method, Object args, String spEl {\n        String params = Optional.ofNullableparameterNameDiscoverer.getParameterNamesmethod.orElsenew String{};//解析参数名\n        EvaluationContext context = new StandardEvaluationContext;//el解析需要的上下文对象\n        for int i = 0; i < params.length; i++ {\n            context.setVariableparamsi, argsi;//所有参数都作为原材料扔进去\n        }\n        Expression expression = parser.parseExpressionspEl;\n        return expression.getValuecontext, String.class;\n    }\n\n    public static String getMethodKeyMethod method {\n        return method.getDeclaringClass + \"\" + method.getName;\n    }\n}\n\n\n注解切面的最后就是将解析出来的key，waitTime，timeUnit，joinPoint::proceed自己写的逻辑当作参数传入lockService.executeWithLock自己写的编程式方法中\n\n使用注解方法修改的代码如下\n\njava\n@Override\npublic void acquireItemLong uid, Long itemId, IdempotentEnum idempotentEnum, String businessId {\n    // 幂等号\n    String idempotent = getIdempotentuid, itemId, businessId;\n\n    // 分布式注解方法\n    userBackpackService.doAcquireuid, itemId, idempotent;\n}\n\n@Transactional\n@RedissonLockkey = \"idempotent\", waitTime = 5000\npublic void doAcquireLong uid, Long itemId, String idempotent {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotentidempotent;\n    if Objects.nonNulluserBackpack {\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpackuid, itemId, idempotent;\n    userBackpackDao.saveinsert;\n}\n\n\n IP归属地\n\n 具体流程\n\nIP归属地是社交网站常用的功能，实现起来非常简单\n\n大致步骤：hutool工具类解析出ip地址  通过淘宝的接口获取归属地  更新数据库\n\n本项目是在登录之后，带token请求http，带token连接ws，这几处进行ip解析\n\n 核心代码\n\njava\nprivate void loginSuccessChannel channel, User user, String token {\n    // 保存用户channel和uid对应关系\n    WSChannelExtraDTO wsChannelExtraDTO = ONLINEWSMAP.getchannel;\n    wsChannelExtraDTO.setUiduser.getId;\n    // 给前端推送消息\n    sendMsgchannel, WebSocketAdapter.buildRespuser, token;\n    // 用户上线事件\n    user.setLastOptTimeLocalDateTime.now;\n    user.refreshIpNettyUtil.getAttrchannel, NettyUtil.IP;\n    applicationEventPublisher.publishEventnew UserOnlineEventthis, user;\n}\n\n\nUser实体\n\njava\n@Data\n@EqualsAndHashCodecallSuper = false\n@TableNamevalue = \"user\", autoResultMap = true\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /\n      用户id\n     /\n      @TableIdvalue = \"id\", type = IdType.AUTO\n    private Long id;\n\n    /\n      用户昵称\n     /\n    @TableField\"name\"\n    private String name;\n\n    /\n      用户头像\n     /\n    @TableField\"avatar\"\n    private String avatar;\n\n    /\n      性别 1为男性，2为女性\n     /\n    @TableField\"sex\"\n    private Integer sex;\n\n    /\n      微信openid用户标识\n     /\n    @TableField\"openid\"\n    private String openId;\n\n    /\n      在线状态 1在线 2离线\n     /\n    @TableField\"activestatus\"\n    private Integer activeStatus;\n\n    /\n      最后上下线时间\n     /\n    @TableField\"lastopttime\"\n    private LocalDateTime lastOptTime;\n\n    /\n      ip信息\n     /\n    @TableFieldvalue = \"ipinfo\", typeHandler = JacksonTypeHandler.class\n    private IpInfo ipInfo;\n\n    /\n      佩戴的徽章id\n     /\n    @TableField\"itemid\"\n    private Long itemId;\n\n    /\n      使用状态 0.正常 1拉黑\n     /\n    @TableField\"status\"\n    private Integer status;\n\n    /\n      创建时间\n     /\n    @TableField\"createtime\"\n    private LocalDateTime createTime;\n\n    /\n      修改时间\n     /\n    @TableField\"updatetime\"\n    private LocalDateTime updateTime;\n\n\n    public void refreshIpString attr {\n        if ipInfo == null{\n            ipInfo = new IpInfo;\n        }\n        ipInfo.refreshIpattr;\n    }\n}\n\n\nIpInfo实体\n\njava\n@Data\npublic class IpInfo implements Serializable {\n\n    // 注册的ip\n    private String createIp;\n\n    // 注册时ip的详情\n    private IpDetail ipDetail;\n\n    // 更新的ip\n    private String updateIp;\n\n    // 更新时的ip详情\n    private IpDetail updateIpDetail;\n\n    public void refreshIpString ip {\n        if StrUtil.isBlankip{\n            return;\n        }\n        if StrUtil.isBlankcreateIp{\n            createIp = ip;\n        }\n        updateIp = ip;\n    }\n\n    public String needRefreshIp {\n        boolean needRefresh = Optional.ofNullableupdateIpDetail\n                .mapIpDetail::getIp\n                .filteritem  Objects.equalsupdateIp, item\n                .isPresent; // 判断结果是否是null\n\n        return needRefresh ? null : updateIp;\n    }\n\n    public void refreshIpDetailIpDetail ipDetail {\n        if Objects.equalsipDetail.getIp, createIp{\n            this.ipDetail = ipDetail;\n        }\n        if Objects.equalsipDetail.getIp, updateIp{\n            this.updateIpDetail = ipDetail;\n        }\n\n    }\n}\n\n\nrefreshIp是对当前登录的ip进行刷新，有个关键点就是先对注册ip进行判断，注册的ip无就需要对注册的ip进行赋值，其次在是更新的ip\n\n在用户登录成功后，通过 applicationEventPublisher.publishEventnew UserOnlineEventthis, user;发送异步消息SpringEvent，通过一个事件监听来接受\n\njava\n@Component\npublic class UserOnlineListener {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private IpService ipService;\n\n    @Async // 异步执行\n    @EventListenerclasses = UserOnlineEvent.class\n    public void userOnlineUserOnlineEvent event{\n        User user = event.getUser;\n        // 更新用户信息【Ip，是否登录等】\n        User update = new User;\n        update.setIduser.getId;\n        update.setLastOptTimeuser.getLastOptTime;\n        update.setIpInfouser.getIpInfo;\n        update.setActiveStatusUserActiveStatusEnum.ONLINE.getType;\n        userDao.updateByIdupdate;\n        // 用户IP解析\n        ipService.refreshDetailAsyncuser.getId;\n\n    }\n}\n\n\n这里是对用户的信息做了更新【最后一次登录事件，登录状态，IP信息】，用ipService.refreshDetailAsyncuser.getId实现对IP的异步刷新解析\n\njava\n@Service\n@Slf4j\npublic class IpServiceImpl implements IpService {\n\n    private static ExecutorService executor = new ThreadPoolExecutor1, 1,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable500, new NamedThreadFactory\"refreshipDetail\", false;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void refreshDetailAsyncLong id {\n        executor.execute  {\n            User user = userDao.getByIdid;\n            IpInfo ipInfo = user.getIpInfo;\n            if Objects.isNullipInfo{\n                return;\n            }\n            // 判断是否需要刷新ip详情\n            String ip = ipInfo.needRefreshIp;\n            if StrUtil.isBlankip{\n                // 更新ip和更新ip一致无需刷新\n                return;\n            }\n\n            // 获取ip详情\n            IpDetail ipDetail = tryGetIpDetailOrNullip;\n            if Objects.nonNullipDetail{\n                // 刷新ipInfo的详情\n                ipInfo.refreshIpDetailipDetail;\n                // 更新ip详情\n                User update = new User;\n                update.setIpInfoipInfo;\n                update.setIdid;\n                userDao.updateByIdupdate;\n            }\n        };\n    }\n\n    private IpDetail tryGetIpDetailOrNullString ip {\n        for int i = 0; i < 3; i++{\n            IpDetail ipDetail = getIpDetailOrNullip;\n            if Objects.nonNullipDetail{\n                return ipDetail;\n            }\n            try {\n                Thread.sleep2000;\n            } catch InterruptedException e{\n                log.error\"tryGetIpDetailOrNull InterruptedException\", e;\n            }\n        }\n        return null;\n    }\n\n    private IpDetail getIpDetailOrNullString ip {\n        String body = HttpUtil.get\"https://ip.taobao.com/outGetIpInfo?ip=\" + ip + \"&accessKey=alibabainc\";\n        try {\n            ApiResult<IpDetail result = JSONUtil.toBeanbody, new TypeReference<ApiResult<IpDetail {\n            }, false;\n            if result.isSuccess {\n                return result.getData;\n            }\n        } catch Exception e {\n            return null;\n        }\n\n        return null;\n    }\n}\n\n\n在实现方法refreshDetailAsync中，使用了线程池来进行异步排队处理，设置了最大容量为1个，并且设置了refreshipDetail线程前缀来便于排查出问题\n\n通过needRefreshIp判断是否需要刷新，若需要刷新就返回要刷新的ip地址，否则就返回null；是否刷新的判断依据是用用户当前数据库已经保存的IP解析的地址和当前登录的ip地址进行对比，若一致就返回null，否则就返回当前的登录的ip地址\n\ntryGetIpDetailOrNull方法是尝试获取ip解析信息，有3次机会，每次执行完有2秒的睡眠时间\n\nrefreshIpDetail方法是刷新当前用户的ip解析信息，通过ip进行判断是注册ip还是更新ip，从而进行赋值\n\n 黑名单功能\n\n 具体流程\n\n实现黑名单功能就是将用户的ip和id放在黑名单数据库中，通过拦截器判断登陆的用户是否在名单中，从而决定是否拦截通过\n\n本项目中的黑名单功能需要用到权限，权限管理多用于b端项目，对于c端来说，权限没有到那么复杂的级别。因此权限设计只涉及到了用户身份\n\nhttps://cdn.nlark.com/yuque/0/2023/png/26318626/16869791323031934c4b2943f45d3b892a78a228e4821.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize109%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10%2Fresize%2Cw1280%2Climit0\n\n流程：登录的时候返回角色  管理拉黑【判断权限】 推送给前端消息  写入黑名单表， 修改状态【SpringEvent事件异步处理】  拉黑用户拦截\n\n 核心代码\n\n判断用户是否具有某个权限，用来set巧妙处理\n\njava\n@Service\npublic class RoleDao implements IRoleService {\n\n    @Autowired\n    private UserCache userCache;\n\n    @Override\n    public boolean isPowerLong uid, RoleEnum roleEnum {\n        // 获取用户所有权限\n        Set<Long roleSet = userCache.getRoleSetuid;\n\n        return isAdminroleSet  roleSet.containsroleEnum.getId;\n    }\n\n    private boolean isAdminSet<Long roleSet{\n        return roleSet.containsRoleEnum.ADMIN.getId;\n    }\n}\n\n\n将用户写入黑名单，并且通过SpringEvent发送异步事件处理黑名单事件\n\njava\n @Override\n @TransactionalrollbackFor = Exception.class\n public void blackBlackReq blackReq {\n     // 将id写入黑名单\n     Long uid = blackReq.getUid;\n     Black black = new Black;\n     black.setTypeBlackTypeEnum.UID.getId;\n     black.setTargetuid.toString;\n     blackDao.saveblack;\n    // 将ip写入黑名单\n    User user = userDao.getByIduid;\n    blackIpOptional.ofNullableuser.getIpInfo.getCreateIp.orElsenull;\n    blackIpOptional.ofNullableuser.getIpInfo.getUpdateIp.orElsenull;\n\n    applicationEventPublisher.publishEventnew UserBlackEventthis, user;\n}\n\n/\n  封禁IP\n \n  @param ip\n /\nprivate void blackIpString ip {\n    if StrUtil.isBlankip {\n        return;\n    }\n\n    try {\n        Black insert = new Black;\n        insert.setTargetip;\n        insert.setTypeBlackTypeEnum.IP.getId;\n        blackDao.saveinsert;\n    } catch Exception e {\n\n    }\n}\n\n\n监听黑名单事件并作处理【推送前端消息，更新用户状态，清空黑名单缓存列表拦截器处理的时候会用到】\n\njava\n@Component\npublic class UserBlackListener {\n\n    @Autowired\n    private WebSocketService webSocketService;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private UserCache userCache;\n\n    /\n      推送前端消息\n      @param event\n     /\n    @Async // 异步执行\n    @TransactionalEventListenerclasses = UserBlackEvent.class, phase = TransactionPhase.AFTERCOMMIT\n    public void sendMsgUserBlackEvent event{\n        User user = event.getUser;\n        webSocketService.sendMsgToAllWebSocketAdapter.buildBlackuser;\n    }\n\n    /\n      更新用户状态\n      @param event\n     /\n    @Async // 异步执行\n    @TransactionalEventListenerclasses = UserBlackEvent.class, phase = TransactionPhase.AFTERCOMMIT\n    public void changeActivityUserBlackEvent event{\n        User user = event.getUser;\n        userDao.invalidUiduser.getId;\n    }\n\n    /\n      清空黑名单缓存\n      @param event\n     /\n    @Async // 异步执行\n    @TransactionalEventListenerclasses = UserBlackEvent.class, phase = TransactionPhase.AFTERCOMMIT\n    public void clearBlackListUserBlackEvent event{\n        userCache.evictBlack;\n    }\n}\n\n\n推送给前端所有用户这里用到了线程池，加快处理效率\n\njava\n@Autowired\nprivate ThreadPoolTaskExecutor threadPoolTaskExecutor;\n\n@Override\npublic void sendMsgToAllWSBaseResp<? resp {\n    ONLINEWSMAP.forEachchannel, wsChannelExtraDTO  {\n        // 使用线程池，加快发送速度\n        threadPoolTaskExecutor.execute  {\n            sendMsgchannel, resp;\n        };\n    };\n}\n\n\n 游标翻页\n\n游标翻页更适用于一页一页跳转的场景，而对于跳页反转（例如第一页跳到第五页就不适用）\n\n本项目为聊天项目，适合适用游标翻页\n\n 深翻页问题\n\n普通翻页前端一般会有个分页条。能够指定一页的条数，以及任意选择查看第几页。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685187350715ec688988ee5a426e88eadbb85f6aac22.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize16%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n对应的参数就是pageNo和pageSize\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/16851874273103e189d14a2154dbfb86d5badf5bd5a12.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize14%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n假设前端想要查看第11页的内容，传的值pageNo=11，pageSize=10\n\n其中100代表需要跳过的条数，10代表跳过指定条数后，往后需要再取的条数。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685188112380ab4f8decf339451b87eb2ae6ae1bfbe1.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize12%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n对应图片就是这样的一个效果，需要在数据库的位置先读出100条，然后丢弃。丢弃完100条后，再继续取10条选用。\n\n如果我们翻页到了很深的地方，比如读到了第1000页，对应的sql语句就是select  from table limit 10000,10\n\n需要先查询10000条进行丢弃，再取那么个10条选用。这个效率也太低了，\n\n  我们经常需要定时任务全量去跑一张表的数据，普通翻页去跑的话，到后面数据量大的时候，就会越跑越慢，这就是深翻页带来的问题。\n\n解决办法\n\n目前的问题在于每次翻页都需要花时间扫描一些不需要的记录，然后丢弃。那么是不是可以优化这个步骤呢？\n\n以后不论第几页，我们都不需要跳过一些值。直接取limit 0,10。这样语句变成了select  from table limit 0,10\n\n取到的是110这些记录，取不到我们想要的101110，没关系，再加一个条件select  from table where id100 order by id limit 0,10\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/168518863534668f634f332764f8787884691ec990d83.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize13%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n只要id这个字段有索引，就能直接定位到101这个字段，然后去10条记录。以后无论翻页到多大，通过索引直接定位到读取的位置，效率基本是一样的。这个id100就是我们的游标，这就是游标翻页。\n\n 游标介绍\n\n游标翻页可以完美的解决深翻页问题，依赖的就是我们的游标，即cursor。针对mysql的游标翻页，我们需要通过cursor快速定位到指定记录，意味着游标必须添加索引。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685189222316cf64fcf1da8546f0b6b04088cd66b89e.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize15%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n前端之前传的pageNo字段改成了cursor字段。cursor是上一次查询结果的位置，作为下一次查询的游标，由后端返回\n\n我们来模拟一次前后端的翻页交互\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685189899438884c817d0ee54b7da5406be3bb135975.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize19%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n随着翻页的持续，游标不断往翻页的方向推进。\n\n所以游标翻页不适合跳页，只能不断的往下翻。更适合C端的列表场景\n\n 总结\n\n游标翻页的优点：\n\n1.解决深翻页问题\n\n2.解决频繁变动的列表翻页问题。\n\n缺点：\n\n1.无法跳页，只能不断往下翻\n\n游标翻页更适合c端场景，用户只能不断下滑翻页。\n\n普通翻页更适合B端场景。用户能看见总页数，能随意跳页\n\n 前后端资源懒加载\n\n 选用原因\n\n 带宽占用\n\n对于项目中的个别请求，有时候会有大量冗余和重复的消息。特别是用户的头像，名称，佩戴徽章，这些东西，基本都是重复的，但是我们每一次的消息推送，成员上下线，都需要携带。\n\n对于这些数据，其实我们只想知道消息的拥有者是谁，也就是uid。其他的头像，徽章，这些我们之前都有，但是他们却占据了消息体的大部分内容，有效载荷太少。\n\n在压测的时候发现了很多时候我们的瓶颈就在带宽上。而带宽都被头像的url给占用了。\n\n 代码复杂度\n\n如果每次因为一个简单的消息推送，就要去写一套复杂的代码，去加载用户的名称，以及徽章相关的信息。都会增大后端代码的复杂度。\n\n每次组装vo数据，都得去查出用户的关联信息，进行组装。哪怕是可以复用这段代码，但是相应的性能损耗，也是不可避免的。\n\n 解决办法\n\n 图片路径协议优化\n\n前后端可以将用户头像遵循一种固定的路径协议，比如https://img.mallchat.cn/avatar/{uid}.png;\n\n这样只给前端uid，他自己就能组装出用户头像了\n\n 懒加载时间点\n\n前端在什么场景下会请求后端进行信息懒加载，每次请求后端，需要更新自己库里的懒加载时间lastModifyTime\n\n 没数据加载\n 数据过期加载（校验）：lastModifyTime小于数据库存的lastModifyTime\n 主动加载（校验）：例如用户主动点击头像查询信息\n\n 总结\n\n了解到了项目的瓶颈，大多是来源带宽不足。为了节省带宽，同时简化后端的逻辑，我们设计了一套前后端资源懒加载的交互框架。他有三个懒加载的时间点，同时保证了及时性，以及最终一致性。这个框架的核心就是lastModifyTime字段的定义。有了它，只要没有变动，后端都可以不返回用户信息，又能节省一大部分带宽。并且为了不需要展示的字段不返回null。我们用了一个json的注解，又节省了一小部分带宽。\n\n 批量缓存框架\n\n缓存通常有两种使用方式，一种是CacheAside，一种是cachethrough。也就是旁路缓存和缓存即数据源。\n\n一般一种用于读，另一种用于读写。\n\n 盘路缓存\n\n我们通常用的都是旁路缓存模式\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1696084655149bf1c5c2b362645b28b430d9268f5a6bc.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize14%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\nGET缓存获取不到，就LOAD加载数据库，再将数据库写回redis缓存。\n\n盘路缓存也有很好用的框架，比如springcache。只需要写load逻辑。加上个注解，就能实现盘路缓存的效果。\n\n缺点：在极端情况下。我需要获取一批用户的信息，碰巧所有用户的缓存都失效了，都需全部重新加载。那么这样一个本来性能很高的循环，就等同于全部查了数据库，缓存一点儿作用都没了。\n\n 批量缓存查询\n\n对于这种批量查询缓存的需求，传统的旁路缓存框架无法达到我们的需求。我们需要让他能够批量的get or load。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/16960856323923b47a5e4970047029edebef81682e82e.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize12%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n类似这张图，批量的get。发现没有的数据，再批量的load一次，这样和redis以及数据库的交互都只会有一次。\n\n具体代码\n\njava\n/\n  获取用户信息，盘路缓存模式\n /\npublic Map<Long, User getUserInfoBatchSet<Long uids {\n    //批量组装key\n    List<String keys = uids.stream.mapa  RedisKey.getKeyRedisKey.USERINFOSTRING, a.collectCollectors.toList;\n    //批量get\n    List<User mget = RedisUtils.mgetkeys, User.class;\n    Map<Long, User map = mget.stream.filterObjects::nonNull.collectCollectors.toMapUser::getId, Function.identity;\n    //发现差集——还需要load更新的uid\n    List<Long needLoadUidList = uids.stream.filtera  map.containsKeya.collectCollectors.toList;\n    if CollUtil.isNotEmptyneedLoadUidList {\n        //批量load\n        List<User needLoadUserList = userDao.listByIdsneedLoadUidList;\n        Map<String, User redisMap = needLoadUserList.stream.collectCollectors.toMapa  RedisKey.getKeyRedisKey.USERINFOSTRING, a.getId, Function.identity;\n        RedisUtils.msetredisMap, 5  60;\n        //加载回redis\n        map.putAllneedLoadUserList.stream.collectCollectors.toMapUser::getId, Function.identity;\n    }\n    return map;\n}\n\n\n我们在很多处都要用到这个接口，所以就需要对这个批量查询缓存进行封装\n\n这时候又要轮到我们的常规抽象环节了\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1696085827579fa03f689bdb1476eb53fa291b3314660.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize34%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n黄色代表可复用的流程，红色代表个性化的代码。\n\n 批量缓存框架\n\n先创建批量缓存框架的接口\n\n接口\n\njava\npublic interface BatchCache<IN, OUT {\n    /\n      获取单个\n     /\n    OUT getIN req;\n\n    /\n      获取批量\n     /\n    Map<IN, OUT getBatchList<IN req;\n\n    /\n      修改删除单个\n     /\n    void deleteIN req;\n\n    /\n      修改删除多个\n     /\n    void deleteBatchList<IN req;\n}\n\n\n再通过抽象类，定义好骨架\n\n抽象类\n\njava\npublic abstract class AbstractRedisStringCache<IN, OUT implements BatchCache<IN, OUT {\n\n    private Class<OUT outClass;\n\n    protected AbstractRedisStringCache {\n        ParameterizedType genericSuperclass = ParameterizedType this.getClass.getGenericSuperclass;\n        this.outClass = Class<OUT genericSuperclass.getActualTypeArguments1;\n    }\n\n    protected abstract String getKeyIN req;\n\n    protected abstract Long getExpireSeconds;\n\n    protected abstract Map<IN, OUT loadList<IN req;\n\n    @Override\n    public OUT getIN req {\n        return getBatchCollections.singletonListreq.getreq;\n    }\n\n    @Override\n    public Map<IN, OUT getBatchList<IN req {\n        if CollectionUtil.isEmptyreq {//防御性编程\n            return new HashMap<;\n        }\n        //去重\n        req = req.stream.distinct.collectCollectors.toList;\n        //组装key\n        List<String keys = req.stream.mapthis::getKey.collectCollectors.toList;\n        //批量get\n        List<OUT valueList = RedisUtils.mgetkeys, outClass;\n        //差集计算\n        List<IN loadReqs = new ArrayList<;\n        for int i = 0; i < valueList.size; i++ {\n            if Objects.isNullvalueList.geti {\n                loadReqs.addreq.geti;\n            }\n        }\n        Map<IN, OUT load = new HashMap<;\n        //不足的重新加载进redis\n        if CollectionUtil.isNotEmptyloadReqs {\n            //批量load\n            load = loadloadReqs;\n            Map<String, OUT loadMap = load.entrySet.stream\n                    .mapa  Pair.ofgetKeya.getKey, a.getValue\n                    .collectCollectors.toMapPair::getFirst, Pair::getSecond;\n            RedisUtils.msetloadMap, getExpireSeconds;\n        }\n\n        //组装最后的结果\n        Map<IN, OUT resultMap = new HashMap<;\n        for int i = 0; i < req.size; i++ {\n            IN in = req.geti;\n            OUT out = Optional.ofNullablevalueList.geti\n                    .orElseload.getin;\n            resultMap.putin, out;\n        }\n        return resultMap;\n    }\n\n    @Override\n    public void deleteIN req {\n        deleteBatchCollections.singletonListreq;\n    }\n\n    @Override\n    public void deleteBatchList<IN req {\n        List<String keys = req.stream.mapthis::getKey.collectCollectors.toList;\n        RedisUtils.delkeys;\n    }\n}\n\n\n这时候你就会发现，写一个批量的旁路缓存有多简单。\n\n具体实现\n\njava\n@Component\npublic class UserInfoCache extends AbstractRedisStringCache<Long, User {\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    protected String getKeyLong uid {\n        return RedisKey.getKeyRedisKey.USERINFOSTRING, uid;\n    }\n\n    @Override\n    protected Long getExpireSeconds {\n        return 5  60L;\n    }\n\n    @Override\n    protected Map<Long, User loadList<Long uidList {\n        List<User needLoadUserList = userDao.listByIdsuidList;\n        return needLoadUserList.stream.collectCollectors.toMapUser::getId, Function.identity;\n    }\n}\n\n"},{"filename":"zhi-fu-bao","category":"middleware","md":{"topSummary":"\ntitle: SpringBoot整合支付宝支付\ncategory: SpringBoot,中间件\ndate: 2024-01-27\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 依赖\n\n```xml\n<alipay-easysdk.version>2.2.0</alipay-easysdk.version>\n\n<dependency>\n    <groupId>com.alipay.sdk</groupId>\n    <artifactId>alipay-easysdk</artifactId>\n    <version>${alipay-easysdk.version}</version>\n</dependency>\n```\n\n## 配置\n\n**yml配置文件**\n\n```yaml\nalipay:\n  appId: # AppID\n  appPrivateKey: # 密钥\n  alipayPublicKey: # 公钥\n  notifyUrl: # 回调地址【需要用到内网穿透】\n  gateway: openapi-sandbox.dl.alipaydev.com\n  returnUrl: http://localhost:8080  # 支付成功后返回的地址【我这里设置的是返回前端首页】\n```\n\n**配置类**\n\n```java\n@Data\n@Slf4j\n@Component\n@ConfigurationProperties(prefix = \"alipay\")\npublic class AliPayConfig {\n   private String appId;\n   private String appPrivateKey;\n   private String alipayPublicKey;\n   private String notifyUrl;\n   private String gateway;\n   private String returnUrl;\n\n   @PostConstruct\n   public void init() {\n      // 设置参数（全局只需设置一次）\n      Config config = new Config();\n      config.protocol = \"https\";\n      config.gatewayHost = this.gateway;\n      config.signType = \"RSA2\";\n      config.appId = this.appId;\n      config.merchantPrivateKey = this.appPrivateKey;\n      config.alipayPublicKey = this.alipayPublicKey;\n      config.notifyUrl = this.notifyUrl;\n      Factory.setOptions(config);\n      log.info(\"支付宝SDK初始化成功\");\n   }\n\n}\n```\n\n## 接口\n\n这里需要两个接口，一个是创建支付表单的接口，一个是支付结果异步回调的接口【必须是POST请求，而且返回值必须是success或者是failure字符串类型】\n\n>  说明一下：第一个接口的主要作用是返回具有html代码的支付宝支付表单页面，就这个功能；第二个接口的作用是对支付接口进行验签，看是否支付成功\n\n```java\n@Api(tags = \"支付接口\")\n@RestController\n@RequestMapping(\"/pay\")\npublic class PayController {\n\n    @Autowired\n    private PayService payService;\n\n    @ApiOperation(\"付款\")\n    @GetMapping(\"/payment/{orderId}\")\n    public Result<String> pay(@PathVariable(\"orderId\") Long orderId) {\n        String form = payService.pay(orderId);\n\n        return Result.success(form, \"付款成功\");\n    }\n\n    @ApiOperation(\"异步回调结果\")\n    @PostMapping(\"/callback\")\n    public String callback(HttpServletRequest request){\n        return payService.callback(request);\n    }\n\n}\n```\n\n## 方法\n\n第一个接口的实现方法\n\n```java\n@Override\npublic String pay(Long orderId) {\n    // 获取订单信息\n    CourseOrderEntity courseOrderEntity = courseOrderService.getById(orderId);\n    if (courseOrderEntity.getPaymentStatus() == 3){\n        throw new KunKeException(\"订单已经失效\");\n    } else if (courseOrderEntity.getPaymentStatus() == 2){\n        throw new KunKeException(\"订单已付款\");\n    }\n\n    // 支付标题\n    String subject = courseOrderEntity.getCourseTitle();\n    // 支付订单编号\n    String tradeNo = generateTradeNo();\n    // 价格\n    String price = courseOrderEntity.getResPrice().toString();\n    // 创建网页支付\n    AlipayTradePagePayResponse response;\n    String res = null;\n    try {\n        // 发起API调用（以创建当面付收款二维码为例）\n        // \"http://localhost:8080\"是返回前端的地址，为了方便我就直接写死了\n        response = Factory.Payment.Page()\n                .pay(subject, tradeNo, price, \"http://localhost:8080\");\n        if (ResponseChecker.success(response)) {\n            // 更新订单编号\n            courseOrderService.update(new LambdaUpdateWrapper<CourseOrderEntity>()\n                            .set(CourseOrderEntity::getPaymentId, tradeNo)\n                            .eq(CourseOrderEntity::getId, orderId));\n            res = response.getBody();\n        }\n    } catch (Exception e) {\n        log.error(\"支付出错：{}\", e.toString());\n        throw new KunKeException(\"支付出错\");\n    }\n    return res;\n}\n\n/**\n* 通过时间生成外部订单号 out_trade_no\n* @return\n*/\nprivate String generateTradeNo() {\n   DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmssSSS\");\n   String tradeNo = LocalDateTime.now(ZoneOffset.of(\"+8\")).format(formatter);\n   return tradeNo;\n}\n```\n\n第二个接口的实现方法\n\n```java\n@Override\npublic String callback(HttpServletRequest request) {\n    // 获取支付宝的请求信息\n    // 将Map<String, String[]>转为Map<String, String>\n    Map<String, String> params = new HashMap<>();\n    Map<String, String[]> requestParams = request.getParameterMap();\n    for (String name : requestParams.keySet()) {\n        params.put(name, request.getParameter(name));\n    }\n\n    try {\n        // 验签\n        boolean signVerified = Factory.Payment.Common().verifyNotify(params);\n        if (signVerified) {\n            // 验签通过\n            // 更新付款状态为已支付\n            Long paymentId = Long.valueOf(params.get(\"out_trade_no\"));\n            CourseOrderEntity one = courseOrderService.getOne(new LambdaQueryWrapper<CourseOrderEntity>().eq(CourseOrderEntity::getPaymentId, paymentId));\n            one.setPaymentStatus(2);\n            one.setPaymentTime(LocalDateTime.now());\n            courseOrderService.updateById(one);\n            // 存入redis\n            stringRedisTemplate.opsForValue().set(COURSE_USER_BUY + one.getUsername() + \":\" + one.getCourseId(), \"1\");\n            return \"success\";\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    // 验签失败\n    return \"failure\";\n}\n```\n\n## 使用\n\n前端调用`/pay/payment/${id}`就能够看到一个支付宝表单页面【如果配置没出错的情况下】，支付成功后会异步调用回调的接口进行验签\n","title":" SpringBoot整合支付宝支付\n","category":[" SpringBoot","中间件\n"],"date":" 2024-01-27\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 依赖\n\nxml\n<alipayeasysdk.version2.2.0</alipayeasysdk.version\n\n<dependency\n    <groupIdcom.alipay.sdk</groupId\n    <artifactIdalipayeasysdk</artifactId\n    <version${alipayeasysdk.version}</version\n</dependency\n\n\n 配置\n\nyml配置文件\n\nyaml\nalipay:\n  appId:  AppID\n  appPrivateKey:  密钥\n  alipayPublicKey:  公钥\n  notifyUrl:  回调地址【需要用到内网穿透】\n  gateway: openapisandbox.dl.alipaydev.com\n  returnUrl: http://localhost:8080   支付成功后返回的地址【我这里设置的是返回前端首页】\n\n\n配置类\n\njava\n@Data\n@Slf4j\n@Component\n@ConfigurationPropertiesprefix = \"alipay\"\npublic class AliPayConfig {\n   private String appId;\n   private String appPrivateKey;\n   private String alipayPublicKey;\n   private String notifyUrl;\n   private String gateway;\n   private String returnUrl;\n\n   @PostConstruct\n   public void init {\n      // 设置参数（全局只需设置一次）\n      Config config = new Config;\n      config.protocol = \"https\";\n      config.gatewayHost = this.gateway;\n      config.signType = \"RSA2\";\n      config.appId = this.appId;\n      config.merchantPrivateKey = this.appPrivateKey;\n      config.alipayPublicKey = this.alipayPublicKey;\n      config.notifyUrl = this.notifyUrl;\n      Factory.setOptionsconfig;\n      log.info\"支付宝SDK初始化成功\";\n   }\n\n}\n\n\n 接口\n\n这里需要两个接口，一个是创建支付表单的接口，一个是支付结果异步回调的接口【必须是POST请求，而且返回值必须是success或者是failure字符串类型】\n\n  说明一下：第一个接口的主要作用是返回具有html代码的支付宝支付表单页面，就这个功能；第二个接口的作用是对支付接口进行验签，看是否支付成功\n\njava\n@Apitags = \"支付接口\"\n@RestController\n@RequestMapping\"/pay\"\npublic class PayController {\n\n    @Autowired\n    private PayService payService;\n\n    @ApiOperation\"付款\"\n    @GetMapping\"/payment/{orderId}\"\n    public Result<String pay@PathVariable\"orderId\" Long orderId {\n        String form = payService.payorderId;\n\n        return Result.successform, \"付款成功\";\n    }\n\n    @ApiOperation\"异步回调结果\"\n    @PostMapping\"/callback\"\n    public String callbackHttpServletRequest request{\n        return payService.callbackrequest;\n    }\n\n}\n\n\n 方法\n\n第一个接口的实现方法\n\njava\n@Override\npublic String payLong orderId {\n    // 获取订单信息\n    CourseOrderEntity courseOrderEntity = courseOrderService.getByIdorderId;\n    if courseOrderEntity.getPaymentStatus == 3{\n        throw new KunKeException\"订单已经失效\";\n    } else if courseOrderEntity.getPaymentStatus == 2{\n        throw new KunKeException\"订单已付款\";\n    }\n\n    // 支付标题\n    String subject = courseOrderEntity.getCourseTitle;\n    // 支付订单编号\n    String tradeNo = generateTradeNo;\n    // 价格\n    String price = courseOrderEntity.getResPrice.toString;\n    // 创建网页支付\n    AlipayTradePagePayResponse response;\n    String res = null;\n    try {\n        // 发起API调用（以创建当面付收款二维码为例）\n        // \"http://localhost:8080\"是返回前端的地址，为了方便我就直接写死了\n        response = Factory.Payment.Page\n                .paysubject, tradeNo, price, \"http://localhost:8080\";\n        if ResponseChecker.successresponse {\n            // 更新订单编号\n            courseOrderService.updatenew LambdaUpdateWrapper<CourseOrderEntity\n                            .setCourseOrderEntity::getPaymentId, tradeNo\n                            .eqCourseOrderEntity::getId, orderId;\n            res = response.getBody;\n        }\n    } catch Exception e {\n        log.error\"支付出错：{}\", e.toString;\n        throw new KunKeException\"支付出错\";\n    }\n    return res;\n}\n\n/\n 通过时间生成外部订单号 outtradeno\n @return\n/\nprivate String generateTradeNo {\n   DateTimeFormatter formatter = DateTimeFormatter.ofPattern\"yyyyMMddHHmmssSSS\";\n   String tradeNo = LocalDateTime.nowZoneOffset.of\"+8\".formatformatter;\n   return tradeNo;\n}\n\n\n第二个接口的实现方法\n\njava\n@Override\npublic String callbackHttpServletRequest request {\n    // 获取支付宝的请求信息\n    // 将Map<String, String转为Map<String, String\n    Map<String, String params = new HashMap<;\n    Map<String, String requestParams = request.getParameterMap;\n    for String name : requestParams.keySet {\n        params.putname, request.getParametername;\n    }\n\n    try {\n        // 验签\n        boolean signVerified = Factory.Payment.Common.verifyNotifyparams;\n        if signVerified {\n            // 验签通过\n            // 更新付款状态为已支付\n            Long paymentId = Long.valueOfparams.get\"outtradeno\";\n            CourseOrderEntity one = courseOrderService.getOnenew LambdaQueryWrapper<CourseOrderEntity.eqCourseOrderEntity::getPaymentId, paymentId;\n            one.setPaymentStatus2;\n            one.setPaymentTimeLocalDateTime.now;\n            courseOrderService.updateByIdone;\n            // 存入redis\n            stringRedisTemplate.opsForValue.setCOURSEUSERBUY + one.getUsername + \":\" + one.getCourseId, \"1\";\n            return \"success\";\n        }\n    } catch Exception e {\n        e.printStackTrace;\n    }\n\n    // 验签失败\n    return \"failure\";\n}\n\n\n 使用\n\n前端调用/pay/payment/${id}就能够看到一个支付宝表单页面【如果配置没出错的情况下】，支付成功后会异步调用回调的接口进行验签\n"},{"filename":"minio","category":"middleware","md":{"topSummary":"\ntitle: SpringBoot整合Minio\ncategory: Minio,中间件\ndate: 2024-01-26\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 简介\n\n**MinIO** 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。\n\n## 安装\n\n采用docker拉取\n\n```bash\ndocker pull minio/minio\n```\n\n运行\n\n> 终端的端口在9001，java代码调用接口端口在9092\n\n```bash\ndocker run -d -p 9001:9000 -p 9092:9090 --name minio -e \"MINIO_ACCESS_KEY=minioadmin\" -e \"MINIO_SECRET_KEY=minioadmin\" -v /usr/bin/lijunxi/minio/data:/data -v /usr/bin/lijunxi/minio/config:/root/.minio minio/minio server /data --console-address \":9000\" -address \":9090\"\n```\n\n## 整合\n\n**引入jar包**\n\n```xml\n<minio-version>8.0.3</minio-version>\n<okhttp.version>4.8.1</okhttp.version>\n\n<dependency>\n    <groupId>io.minio</groupId>\n    <artifactId>minio</artifactId>\n    <version>${minio-version}</version>\n</dependency>\n<dependency>\n    <groupId>com.squareup.okhttp3</groupId>\n    <artifactId>okhttp</artifactId>\n    <version>${okhttp.version}</version>\n</dependency>\n```\n\n**yml配置文件**\n\n```yml\nminio:\n  endpoint: http://192.168.101.130:9092/  # minio的链接【需要用的Java连接端口】\n  accessKey: minioadmin # 默认账号\n  secretKey: minioadmin # 默认密码\n  bucket: xxxx\n```\n\n**minio配置类**\n\n用于进行minio配置，设置桶的链接对象\n\n```java\n@Configuration\npublic class MinioConfig {\n\n    @Value(\"${minio.endpoint}\")\n    private String endpoint;\n    @Value(\"${minio.accessKey}\")\n    private String accessKey;\n    @Value(\"${minio.secretKey}\")\n    private String secretKey;\n\n    @Bean\n    public MinioClient minioClient() {\n\n        MinioClient minioClient =\n                MinioClient.builder()\n                        .endpoint(endpoint)\n                        .credentials(accessKey, secretKey)\n                        .build();\n        return minioClient;\n    }\n}\n```\n\n### **上传文件**\n\n> localFilePath：本地文件路径\n> mimeType：文件的mineType\n> bucket：桶\n> objectName：需要上传到minio的文件名【可以自定义路径】\n\n```java\n@Autowired\nMinioClient minioClient;\n\n@Override\npublic boolean addFilesToMinIO(String localFilePath, String mimeType, String bucket, String objectName) {\n    try {\n        UploadObjectArgs testbucket = UploadObjectArgs.builder()\n                .bucket(bucket)\n                .object(objectName)\n                .filename(localFilePath)\n                .contentType(mimeType)\n                .build();\n        minioClient.uploadObject(testbucket);\n        log.debug(\"上传文件到minio成功,bucket:{},objectName:{}\", bucket, objectName);\n        return true;\n    } catch (Exception e) {\n        e.printStackTrace();\n        log.error(\"上传文件到minio出错,bucket:{},objectName:{},错误原因:{}\", bucket, objectName, e.getMessage(), e);\n        throw new KunKeException(\"上传文件到文件系统失败\");\n    }\n}\n```\n\n根据文件后缀获取mimeType\n\n```java\nprivate String getMimeType(String extension) {\n    if (extension == null)\n        extension = \"\";\n    // 根据扩展名取出mimeType\n    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(extension);\n    / /通用mimeType，字节流\n    String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;\n    if (extensionMatch != null) {\n        mimeType = extensionMatch.getMimeType();\n    }\n    return mimeType;\n}\n```\n\n### **下载文件**\n\n```java\n@Override\npublic File downloadFileFromMinIO(String bucket, String objectName) {\n    //临时文件\n    File minioFile = null;\n    FileOutputStream outputStream = null;\n    try {\n        InputStream stream = minioClient.getObject(GetObjectArgs.builder()\n                .bucket(bucket)\n                .object(objectName)\n                .build());\n        //创建临时文件\n        minioFile = File.createTempFile(\"minio\", \".merge\");\n        outputStream = new FileOutputStream(minioFile);\n        IOUtils.copy(stream, outputStream);\n        return minioFile;\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n```\n\n### **删除文件**\n\n删除单个文件：`RemoveObjectArgs`\n\n```java\n@Test\npublic void test_delete() throws Exception {\n    // RemoveObjectArgs\n    RemoveObjectArgs removeObjectArgs = RemoveObjectArgs.builder().bucket(\"testbucket\").object(\"qq.jpg\").build();\t \n    // 删除文件\n    minioClient.removeObject(removeObjectArgs);\n}\n```\n\n批量删除文件：`RemoveObjectsArgs`\n\n```java\nprivate void clearChunkFiles(String chunkFileFolderPath, int chunkTotal) {\n\n    try {\n        List<DeleteObject> deleteObjects = Stream.iterate(0, i -> ++i)\n                .limit(chunkTotal)\n                .map(i -> new DeleteObject(chunkFileFolderPath.concat(Integer.toString(i))))\n                .collect(Collectors.toList());\n\n        RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder().bucket(bucket).objects(deleteObjects).build();\n        Iterable<Result<DeleteError>> results = minioClient.removeObjects(removeObjectsArgs);\n        results.forEach(r -> {\n            DeleteError deleteError = null;\n            try {\n                deleteError = r.get();\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                log.error(\"清楚分块文件失败,objectname:{}\", deleteError.objectName(), e);\n            }\n        });\n    } catch (Exception e) {\n        e.printStackTrace();\n        log.error(\"清楚分块文件失败,chunkFileFolderPath:{}\", chunkFileFolderPath, e);\n    }\n}\n```\n\n### 访问\n\nMinio文件的访问都是通过yml配置中的 `endpoint + bucket + 自定义的objectName` 来进行访问\n\n例如我的一个图片访问路径：`http://192.168.101.130:9092/kunke/2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png`\n\n- `http://192.168.101.130:9092`：endpoint\n\n- `kunke`：bucket\n\n- `2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png`：自定义的文件路径【包含文件名】\n","title":" SpringBoot整合Minio\n","category":[" Minio","中间件\n"],"date":" 2024-01-26\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 简介\n\nMinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。\n\n 安装\n\n采用docker拉取\n\nbash\ndocker pull minio/minio\n\n\n运行\n\n 终端的端口在9001，java代码调用接口端口在9092\n\nbash\ndocker run d p 9001:9000 p 9092:9090 name minio e \"MINIOACCESSKEY=minioadmin\" e \"MINIOSECRETKEY=minioadmin\" v /usr/bin/lijunxi/minio/data:/data v /usr/bin/lijunxi/minio/config:/root/.minio minio/minio server /data consoleaddress \":9000\" address \":9090\"\n\n\n 整合\n\n引入jar包\n\nxml\n<minioversion8.0.3</minioversion\n<okhttp.version4.8.1</okhttp.version\n\n<dependency\n    <groupIdio.minio</groupId\n    <artifactIdminio</artifactId\n    <version${minioversion}</version\n</dependency\n<dependency\n    <groupIdcom.squareup.okhttp3</groupId\n    <artifactIdokhttp</artifactId\n    <version${okhttp.version}</version\n</dependency\n\n\nyml配置文件\n\nyml\nminio:\n  endpoint: http://192.168.101.130:9092/   minio的链接【需要用的Java连接端口】\n  accessKey: minioadmin  默认账号\n  secretKey: minioadmin  默认密码\n  bucket: xxxx\n\n\nminio配置类\n\n用于进行minio配置，设置桶的链接对象\n\njava\n@Configuration\npublic class MinioConfig {\n\n    @Value\"${minio.endpoint}\"\n    private String endpoint;\n    @Value\"${minio.accessKey}\"\n    private String accessKey;\n    @Value\"${minio.secretKey}\"\n    private String secretKey;\n\n    @Bean\n    public MinioClient minioClient {\n\n        MinioClient minioClient =\n                MinioClient.builder\n                        .endpointendpoint\n                        .credentialsaccessKey, secretKey\n                        .build;\n        return minioClient;\n    }\n}\n\n\n 上传文件\n\n localFilePath：本地文件路径\n mimeType：文件的mineType\n bucket：桶\n objectName：需要上传到minio的文件名【可以自定义路径】\n\njava\n@Autowired\nMinioClient minioClient;\n\n@Override\npublic boolean addFilesToMinIOString localFilePath, String mimeType, String bucket, String objectName {\n    try {\n        UploadObjectArgs testbucket = UploadObjectArgs.builder\n                .bucketbucket\n                .objectobjectName\n                .filenamelocalFilePath\n                .contentTypemimeType\n                .build;\n        minioClient.uploadObjecttestbucket;\n        log.debug\"上传文件到minio成功,bucket:{},objectName:{}\", bucket, objectName;\n        return true;\n    } catch Exception e {\n        e.printStackTrace;\n        log.error\"上传文件到minio出错,bucket:{},objectName:{},错误原因:{}\", bucket, objectName, e.getMessage, e;\n        throw new KunKeException\"上传文件到文件系统失败\";\n    }\n}\n\n\n根据文件后缀获取mimeType\n\njava\nprivate String getMimeTypeString extension {\n    if extension == null\n        extension = \"\";\n    // 根据扩展名取出mimeType\n    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatchextension;\n    / /通用mimeType，字节流\n    String mimeType = MediaType.APPLICATIONOCTETSTREAMVALUE;\n    if extensionMatch = null {\n        mimeType = extensionMatch.getMimeType;\n    }\n    return mimeType;\n}\n\n\n 下载文件\n\njava\n@Override\npublic File downloadFileFromMinIOString bucket, String objectName {\n    //临时文件\n    File minioFile = null;\n    FileOutputStream outputStream = null;\n    try {\n        InputStream stream = minioClient.getObjectGetObjectArgs.builder\n                .bucketbucket\n                .objectobjectName\n                .build;\n        //创建临时文件\n        minioFile = File.createTempFile\"minio\", \".merge\";\n        outputStream = new FileOutputStreamminioFile;\n        IOUtils.copystream, outputStream;\n        return minioFile;\n    } catch Exception e {\n        e.printStackTrace;\n    } finally {\n        if outputStream = null {\n            try {\n                outputStream.close;\n            } catch IOException e {\n                e.printStackTrace;\n            }\n        }\n    }\n    return null;\n}\n\n\n 删除文件\n\n删除单个文件：RemoveObjectArgs\n\njava\n@Test\npublic void testdelete throws Exception {\n    // RemoveObjectArgs\n    RemoveObjectArgs removeObjectArgs = RemoveObjectArgs.builder.bucket\"testbucket\".object\"qq.jpg\".build;\t \n    // 删除文件\n    minioClient.removeObjectremoveObjectArgs;\n}\n\n\n批量删除文件：RemoveObjectsArgs\n\njava\nprivate void clearChunkFilesString chunkFileFolderPath, int chunkTotal {\n\n    try {\n        List<DeleteObject deleteObjects = Stream.iterate0, i  ++i\n                .limitchunkTotal\n                .mapi  new DeleteObjectchunkFileFolderPath.concatInteger.toStringi\n                .collectCollectors.toList;\n\n        RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder.bucketbucket.objectsdeleteObjects.build;\n        Iterable<Result<DeleteError results = minioClient.removeObjectsremoveObjectsArgs;\n        results.forEachr  {\n            DeleteError deleteError = null;\n            try {\n                deleteError = r.get;\n\n            } catch Exception e {\n                e.printStackTrace;\n                log.error\"清楚分块文件失败,objectname:{}\", deleteError.objectName, e;\n            }\n        };\n    } catch Exception e {\n        e.printStackTrace;\n        log.error\"清楚分块文件失败,chunkFileFolderPath:{}\", chunkFileFolderPath, e;\n    }\n}\n\n\n 访问\n\nMinio文件的访问都是通过yml配置中的 endpoint + bucket + 自定义的objectName 来进行访问\n\n例如我的一个图片访问路径：http://192.168.101.130:9092/kunke/2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png\n\n http://192.168.101.130:9092：endpoint\n\n kunke：bucket\n\n 2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png：自定义的文件路径【包含文件名】\n"},{"filename":"hmdp","category":"project","md":{"topSummary":"\ntitle: 黑马点评项目笔记\ncategory: SpringBoot,Redis,实战项目\ndate: 2024-01-26\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## Session共享问题\n\n多台Tomcat并不共享session存储空间，当切换到不同的tomcat服务时导致数据丢失的问题\n\n## 缓存更新策略\n\n- 内存淘汰：reids自带的内存淘汰机制\n- 过期淘汰：利用exprie命令给数据设置过期时间\n- 主动更新：主动完成数据库与reids的同时更新\n\n### 策略选择\n\n- 低一致性需求：内存淘汰或过期淘汰\n- 高一致性需求：主动更新为主，过期淘汰为辅\n\n### 关于主动更新策略的思考\n\n1、**问题：是更新缓存还是删除缓存？**\n\n更新缓存：会产生无效更新，因为有可能你更新了，系统一直没用上。并且存在较大的线程安全问题\n\n删除缓存：本质是延迟更新，没有无效更新，线程安全问题相对较低\n\n经过思考得出的最佳策略：**删除缓存**\n\n2、**问题：先操作数据库还是缓存？**\n\n**方案一：先删除缓存，再更新数据库**\n\n正常情况：线程一先执行删除缓存，再更新数据库；线程二查询缓存有发现没有缓存，就查询数据库。\n\n异常情况：线程一先执行删除缓存，这时候线程二到了，查询缓存后发现无缓存，就去查询数据库，这时候数据库的数据是没更新的数据，就出现了异常，最后线程一才执行更新数据库。\n\n**方案二：先更新数据库，再删除缓存**\n\n正常情况：线程一先更新数据库，再删除缓存，线程二查询缓存发现没有缓存，就查询数据库。\n\n异常情况：线程二线查询缓存，发现有缓存，这时候线程一才到达，线程一就更新数据库，删除缓存，线程二就出现了异常，用的是没更新的数据。\n\n经过思考得出的最佳策略：**方案二**\n\n3、**如何确保数据库与缓存操作的原子性？**\n\n单体系统：利用事务机制\n\n分布式系统：利用分布式事务机制\n\n## 缓存穿透\n\n缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n**解决方案**\n\n- 缓存空对象：请求到了后缓存一个值为null的数据到redis中\n  - 优点：简单，容易维护\n  - 缺点：1、额外的内存消耗。2、可能造成短期的不一致\n- 布隆过滤：在客户端和redis之间加个过滤器，用二进制数组判断是否存在。注意这个方法并不是百分百准确\n  - 优先：内存占用少\n  - 缺点：1、实现复杂。2、存在误判可能\n\n## 缓存雪崩\n\n缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n\n**解决方案**\n\n- 给不同的key设置不同的的过期时间\n- 添加Redis集群提高服务可用性\n- 给缓存添加降级限流策略\n- 给业务添加多级缓存\n\n## 缓存击穿\n\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n**解决方案**\n\n- 给热点接口添加互斥锁\n- 逻辑过期【在redis中额外添加一个时间字段】\n\n## Redis全局唯一ID\n\n![](https://s11.ax1x.com/2024/01/17/pFkCTn1.png)\n\n- 符号位：1bit，永远为0\n- 时间戳：31bit，以秒为单位，可以用69年\n- 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同的ID\n\n## 优惠券秒杀\n\n### 超卖\n\n**解决办法**\n\n- 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取同步锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁\n  - 优点：简单粗暴\n  - 缺点：性能一般\n- 乐观锁：认为线程安全问题不一定会发生，因此不加锁，**只是在更新数据时去判断有没有其它线程对数据做了修改**。\n  - 如果没有修改则认为是安全的，自己才更新数据。\n  - 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。\n  - 优点：性能好\n  - 缺点：存在成功率低的问题（需要做处理）\n\n#### 悲观锁方法\n\n使用`synchronized`过于简单，采用乐观锁方法\n\n#### 乐观锁方法\n\n> 对于**乐观锁**的关键是判断之前查询得到的数据受否被修改过，常见的方法有两种：\n\n1、**版本号法**\n\n![](https://s11.ax1x.com/2024/01/17/pFkM5m8.png)\n\n2、**CAS法**\n\nCAS法和版本号法的区别在于CAS法是直接将库存和原来库做比较，而版本号法是比较的版本\n\n![](https://s11.ax1x.com/2024/01/17/pFkMOlq.png)\n\n**弊端**：出错率大大增加，100个库春，结果只有几十个成功卖出。为什么呢？\n\n解答：假设有100个线程同时请求，只有一个线程成功，其他99线程都在最后一步扣减库存的时候需要判断是否和之前的库存一致出错了，所以就大大提高了错误率。\n\n**怎么解决这个弊端？**\n\n解答：将最后判断是否和之前库存一致改为**只要库存大于0**就行了\n\n### 一人一单\n\n**解决办法**：使用乐观锁方法，添加同步代码`synchronized`，限制只有一个线程进入\n\n**存在的问题**：在单机模式下没问题，但在集群模式下就会出现问题，不同的SpringBoot服务中JVM使用的常量池、锁监视器是不一样，这导致了同一个用户两次请求都会进入到锁里，就出现了安全问题\n\n![](https://s11.ax1x.com/2024/01/18/pFkqadJ.png)\n\n**解决办法**：分布式锁，下面讲解分布式锁\n\n### 分布式锁\n\n**概念**：满足分布式系统或集群模式下多进程可见并且互斥的锁\n\n**满足的基本特性**：多进程可见、高可用、互斥、好性能、安全性\n\n**核心**：实现多进程之间的互斥，下面是常见的三种\n\n![](https://s11.ax1x.com/2024/01/18/pFkL2cV.png)\n\n**需要实现的两个基本方法**\n\n- 获取锁【通过`set lock name NX EX 10`来实现互斥锁并加上过期时间，NX是互斥，EX是设置超时时间】\n  - 互斥：确保只能有一个线程获取锁\n  - 非阻塞：尝试一次，成功返回true，失败返回false\n- 释放锁【`Del key`】\n  - 手动释放\n  - 超时释放\n\n**分布式锁误删问题**：因为线程一的某种原因导致阻塞，时间超过了Redis锁的过期时间，锁自动释放，线程二获取了线程一的锁，若此时线程一的业务执行完毕，就会手动调用释放锁，就把线程二的锁给释放了，出现了误删的情况\n\n![](https://s11.ax1x.com/2024/01/18/pFkjB7D.png)\n\n**误删情况解决办法**：获取锁的时候将value值设置为UUID+线程ID，每次释放锁的时候就拿redis中存放的值与这个值判断一下，相同才释放，否则不释放\n\n**采用上诉方法还是存在问题**\n\n释放锁的过程，是先判断reids中的值是否一致，再释放锁。可能出现在判断过后到是否锁之间出现阻塞的情况，因为在JVM中有个东西叫垃圾回收，它会阻塞代码。于是需要保证判断和释放这两部操作是原子操作，不可分割\n\n![](https://s11.ax1x.com/2024/01/18/pFAPylQ.png)\n\n**解决办法**：采用Lua脚本解决，编写Lua脚本，用Java调用\n\n#### 总结\n\n**实现Reids分布式锁的思路**\n\n- 利用`set nx ex`获取锁，并设置过期时间，保存现场标识\n- 释放锁先判断线程标识是否与自己一致，一致就删除锁【使用Lua脚本保证原子性】\n\n## Redisson\n\n**Redis的分布式锁是基于setnx实现的，存在一下问题**\n\n- 不可重入：同一个线程无法多次获取同一把锁\n- 不可重试：获取锁只尝试一次就返回false，没有重试机制\n- 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患\n- 主从一致性：如果Redis提供了主从集群,主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现\n\n**Redisson提供一系列分布式的Java常用对象和许多分布式服务**\n\n![](https://s11.ax1x.com/2024/01/18/pFAEp5t.png)\n\n### 可重入锁原理\n\n通过redis的hash结构进行锁的存储，同一个线程进入，会将value值加一，并设置有效期，每次释放锁就value值减一。若减后的值不为0，就重置有效期，否则就直接删除。实现代码通过Lua脚本进行。\n\n![](https://s11.ax1x.com/2024/01/18/pFAVqne.png)\n\n**流程图**\n\n![](https://s11.ax1x.com/2024/01/18/pFAZp1f.png)\n\n### 可重试锁原理\n\n利用信号量和PubSub功能实现等待、唤醒、获取锁失效的重试机制\n\n![](https://s11.ax1x.com/2024/01/18/pFAeYZQ.png)\n\n### 超时续约原理\n\n利用wathDog，每隔一段时间，重置超时时间\n\n### 主从一致性原理\n\n多个独立的Redis结点，必须所有的结点都获取重入锁，才算获取锁成功\n\n## 秒杀优化\n\n### 思路\n\n- 利用Reids Lua脚本完成库存余量、一人一单判断，完成抢单业务\n- 再将下单业务放入阻塞队列中，利用独立线程异步下单\n\n### 使用阻塞队列存在的问题\n\n- 内存限制问题：当队列的元素超过容量的时候会出现内存溢出\n- 数据安全问题：当队列的任务服务出现宕机，任务就会丢失\n\n## Reids消息队列\n\n### 基于List结构模拟消息队列\n\nReids中的List数据结构是一个双向链表，利用LPUSH结合RPOP，或者RPUSH结合LPOP来实现\n\n不过需要注意的是，当消息队列没有消息时RPOP和LPOP操作会返回NULL，并不像JVM阻塞队列那样会阻塞并等待消息。\n\n因此应该使用BRPOP或者BLPOP来实现阻塞效果\n\n#### 优点\n\n- 利用Reids存储，不受限于JVM内存上限\n- 基于Reidis的持久化机制，数据安全性有保证\n- 可以满足消息有序性\n\n#### 缺点\n\n- 无法避免消息丢失\n- 只支持单消费者\n\n### 基于PubSub的消息队列\n\n生产者向对应的cahnnel发送消息后，所有订阅者都能收到消息【一对多】\n\n- SUBSCRIBE channel [channel]：订阅一个或多个频道\n- PUSLISH channel msg：向一个频道发送消息\n- PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道\n\n#### 优点\n\n- 采用发布订阅模型，支持多生产、多消费\n\n#### 缺点\n\n- 不支持数据持久化\n- 无法避免消息丢失\n- 消息堆积有上限，超出时数据丢失\n\n### 基于Stream类型消息队列\n\nstream是一种数据类型，专门为消息队列设计的，相较于前面两种方式能够更加完美实现一个消息队列\n\n**生产消息**：用于向指定的Stream流中添加一个消息\n\n```\nXADD key *|ID value [value ...]\n\n# 创建名为 users 的队列，并向其中发送一个消息，内容是：{name=jack,age=21}，并且使用Redis自动生成ID\n127.0.0.1:6379> XADD users * name jack age 21\n\"1644805700523-0\n```\n\nkey就是消息队列，key不存(*)在会自动创建（默认），ID是消息表示，value是消息的内容\n\n**消费消息**：\n\n```\nXREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID ID\n\n# 读取XREAD中的第一条消息\nXREAD COUNT 1 STREAMS users 0\n# 阻塞1秒钟后从XREAD中读取的最新消息\nXREAD COUNT 1 BLOCK 1000 STREAMS users $\n```\n\n注意：当我们指定起始ID为`$`时代表读取最后一条消息（读取最新的消息）ID为`0`时代表读最开始的一条消息（读取最旧的消息），如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题\n\n#### 特点\n\n- 消息可回溯\n- 一个消息可以被多个消费者读取\n- 可以阻塞堆区\n- 有消息漏读风险\n\n#### 消费者组\n\n上面我们介绍的消费方式都是**单消费方式**，容易发生消息堆积导致消息丢失，所以我们需要改用消费者组的模式\n\n**消费者组**：将多个消费者划分到一个组，监听同一队列\n\n- **消息分流**：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度\n- **消息标识**：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费\n- **消息确认**：消费者获取消息后，消息处于`pending`（待处理）状态，并存入一个`pending-list`。当处理完成后需要通过`XACK`来确认消息，标记消息为已处理，才会从pending-list移除。\n\n```\n# 创建消费者组\nXGROUP CREATE key groupName ID\n# 删除指定的消费者组\nXGROUP DESTORY key groupName\n# 给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupName consumerName\n# 删除消费者组中指定消费者\nXGROUP DELCONSUMER key groupName consumerName\n# 从消费者组中读取消息\nXREADGROUP GROUP\n```\n\n![](https://img-blog.csdnimg.cn/img_convert/27039c5d7c9c137c15bab614293a63fe.png)\n\n![](https://img-blog.csdnimg.cn/img_convert/c1ffb0ac9d815f997953b1dfeae6768f.png)\n\n`stream`类型消息队列的`XREADGROUP`命令特点：\n\n- 消息可回溯\n- 可以多消费者争抢消息，加快消费速度\n- 可以阻塞读取\n- 没有消息漏读的风险\n- 有消息确认机制，保证消息至少被消费一次\n\n### 比较\n\n![](https://s21.ax1x.com/2024/03/11/pF6P3RK.png)\n\n## Feed流\n\n关注推送也叫投喂，为用户持续提供沉浸式体验，通过无限下拉刷新获取新的信息\n\n### 与传统模式的区别\n\n- 传统模式：用户寻找内容\n\n- Feed模式：内容匹配用户\n\n### Feed流常见的模式\n\n- TimeLine：不做内容筛选，简单的按照内容发布时间排序，常用于好友或者关注\n- 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容\n\n### Feed流实现方案\n\n![](https://s11.ax1x.com/2024/01/19/pFAoHxO.png)\n\n## HyperLogLog用法\n\n首先搞懂两个概念\n\n- UV：独立访客量，1天内一个用户多次访问该网站，只记录一次\n- PV：页面访问量：用户多次打开页面，记录多次PV\n\nUV统计\n\n- 优点：内存占用极小\n- 缺点：存在0.81%的误差【不过可以完全忽略】\n\n## 总结\n\n### 2024-1-16\n\n1、写了发短信验证码和登录接口，随机生成token，将用户信息存入redis中\n\n2、写了两个拦截器，一个拦截所有请求的token刷新拦截器【没有token直接放行，token中找不到数据直接放行，全部通过就存入UserHolder中】，一个是只拦截需要验证的登录拦截器【只需要检验UserHolder中是否有数据，有就通过，否则拦截】。\n\n3、对查询商品接口做了缓存，并且对**缓存击穿【互斥锁】**和**缓存穿透【缓存空对象】**做了处理，用jmeter进行检验\n\n### 2024-1-17\n\n1、 用逻辑过期时间解决缓存击穿【在shop中使用expire字段】，**使用这个方法需要将热点key提前预热**。通过比较当前时间和逻辑时间，而从决定是否需要重建数据。通过互斥锁来保证只有一个线程能够进入，通过独立线程来重构数据来减少响应时间\n\n2、创建了redis全局唯一ID生成器，通过符号位(1位)+时间错(31位)+序列号(32位)来形成一个唯一ID，但这样这个ID最大值并不满足总量的所需的范围要求，因此需要通过**不同的key来生成序列号**【通过加上`年:月:日`前缀】来保证每天的都有会不同的ID，这个最大值并不会超过一天所需的范围要求。\n\n3、写了优惠券秒杀功能，正常写法会出现超卖的情况，使用**乐观锁**优化后加上库存限制解决超卖问题【这里也可以用悲观锁解决，通过互斥锁或者同步代码】；使用**悲观锁**`synchronized`解决一人一单的问题，并用**代理事务【AopContext.currentProxy()】**解决事务\t\n\n### 2024-1-18\n\n1、一人一单集群模式下使用分布式锁解决，分布式锁带来了一系列问题，比如：两个服务的`synchronized (userId.toString().intern())`获取的对象不一致【**通过互斥锁解决**】，误删【**通过每次释放前判断存入锁的值是否一致解决**】，原子性问题【**释放锁的操作分为判断是否一致和释放锁，需要用Java调用写好的Lua脚本来确保原子性**】\n\n2、整合Redisson，了解其可重入的原理，可重试锁原理、超时续约原理、主从一致性原理\n\n3、新增查询笔记、点赞笔记\n\n### 2024-1-19\n\n1、点赞排行榜【采用redis的zSet存储，按照时间戳排序】、关注、共同关注【set集合取两个集合的并集】\n\n2、使用Feed流，在博文发布的时候推送给关注自己的人\n\n3、签到：使用二进制位`stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);`存储签到，签到了就是1，没签到就是0\n\n4、统计连续签到，通过`stringRedisTemplate.opsForValue().bitField`来获取 本月截至今天为止所有的签到记录\n\n### 2024-3-10\n\n1、优化优惠券秒杀逻辑，将原本对数据库的查询等判断条件全部放到Lua脚本中，改为从Reids中判断，极大的优化了查询的时间\n\n2、使用阻塞队列 + 线程池实现异步秒杀\n\n### 2024-3-11\n\n1、优化秒杀，使用Stream消息队列替换阻塞队列，能够弥补阻塞队列带来的问题，例如：内存上限，数据丢失等\n","title":" 黑马点评项目笔记\n","category":[" SpringBoot","Redis","实战项目\n"],"date":" 2024-01-26\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n Session共享问题\n\n多台Tomcat并不共享session存储空间，当切换到不同的tomcat服务时导致数据丢失的问题\n\n 缓存更新策略\n\n 内存淘汰：reids自带的内存淘汰机制\n 过期淘汰：利用exprie命令给数据设置过期时间\n 主动更新：主动完成数据库与reids的同时更新\n\n 策略选择\n\n 低一致性需求：内存淘汰或过期淘汰\n 高一致性需求：主动更新为主，过期淘汰为辅\n\n 关于主动更新策略的思考\n\n1、问题：是更新缓存还是删除缓存？\n\n更新缓存：会产生无效更新，因为有可能你更新了，系统一直没用上。并且存在较大的线程安全问题\n\n删除缓存：本质是延迟更新，没有无效更新，线程安全问题相对较低\n\n经过思考得出的最佳策略：删除缓存\n\n2、问题：先操作数据库还是缓存？\n\n方案一：先删除缓存，再更新数据库\n\n正常情况：线程一先执行删除缓存，再更新数据库；线程二查询缓存有发现没有缓存，就查询数据库。\n\n异常情况：线程一先执行删除缓存，这时候线程二到了，查询缓存后发现无缓存，就去查询数据库，这时候数据库的数据是没更新的数据，就出现了异常，最后线程一才执行更新数据库。\n\n方案二：先更新数据库，再删除缓存\n\n正常情况：线程一先更新数据库，再删除缓存，线程二查询缓存发现没有缓存，就查询数据库。\n\n异常情况：线程二线查询缓存，发现有缓存，这时候线程一才到达，线程一就更新数据库，删除缓存，线程二就出现了异常，用的是没更新的数据。\n\n经过思考得出的最佳策略：方案二\n\n3、如何确保数据库与缓存操作的原子性？\n\n单体系统：利用事务机制\n\n分布式系统：利用分布式事务机制\n\n 缓存穿透\n\n缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n解决方案\n\n 缓存空对象：请求到了后缓存一个值为null的数据到redis中\n   优点：简单，容易维护\n   缺点：1、额外的内存消耗。2、可能造成短期的不一致\n 布隆过滤：在客户端和redis之间加个过滤器，用二进制数组判断是否存在。注意这个方法并不是百分百准确\n   优先：内存占用少\n   缺点：1、实现复杂。2、存在误判可能\n\n 缓存雪崩\n\n缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n\n解决方案\n\n 给不同的key设置不同的的过期时间\n 添加Redis集群提高服务可用性\n 给缓存添加降级限流策略\n 给业务添加多级缓存\n\n 缓存击穿\n\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n解决方案\n\n 给热点接口添加互斥锁\n 逻辑过期【在redis中额外添加一个时间字段】\n\n Redis全局唯一ID\n\nhttps://s11.ax1x.com/2024/01/17/pFkCTn1.png\n\n 符号位：1bit，永远为0\n 时间戳：31bit，以秒为单位，可以用69年\n 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同的ID\n\n 优惠券秒杀\n\n 超卖\n\n解决办法\n\n 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取同步锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁\n   优点：简单粗暴\n   缺点：性能一般\n 乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。\n   如果没有修改则认为是安全的，自己才更新数据。\n   如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。\n   优点：性能好\n   缺点：存在成功率低的问题（需要做处理）\n\n 悲观锁方法\n\n使用synchronized过于简单，采用乐观锁方法\n\n 乐观锁方法\n\n 对于乐观锁的关键是判断之前查询得到的数据受否被修改过，常见的方法有两种：\n\n1、版本号法\n\nhttps://s11.ax1x.com/2024/01/17/pFkM5m8.png\n\n2、CAS法\n\nCAS法和版本号法的区别在于CAS法是直接将库存和原来库做比较，而版本号法是比较的版本\n\nhttps://s11.ax1x.com/2024/01/17/pFkMOlq.png\n\n弊端：出错率大大增加，100个库春，结果只有几十个成功卖出。为什么呢？\n\n解答：假设有100个线程同时请求，只有一个线程成功，其他99线程都在最后一步扣减库存的时候需要判断是否和之前的库存一致出错了，所以就大大提高了错误率。\n\n怎么解决这个弊端？\n\n解答：将最后判断是否和之前库存一致改为只要库存大于0就行了\n\n 一人一单\n\n解决办法：使用乐观锁方法，添加同步代码synchronized，限制只有一个线程进入\n\n存在的问题：在单机模式下没问题，但在集群模式下就会出现问题，不同的SpringBoot服务中JVM使用的常量池、锁监视器是不一样，这导致了同一个用户两次请求都会进入到锁里，就出现了安全问题\n\nhttps://s11.ax1x.com/2024/01/18/pFkqadJ.png\n\n解决办法：分布式锁，下面讲解分布式锁\n\n 分布式锁\n\n概念：满足分布式系统或集群模式下多进程可见并且互斥的锁\n\n满足的基本特性：多进程可见、高可用、互斥、好性能、安全性\n\n核心：实现多进程之间的互斥，下面是常见的三种\n\nhttps://s11.ax1x.com/2024/01/18/pFkL2cV.png\n\n需要实现的两个基本方法\n\n 获取锁【通过set lock name NX EX 10来实现互斥锁并加上过期时间，NX是互斥，EX是设置超时时间】\n   互斥：确保只能有一个线程获取锁\n   非阻塞：尝试一次，成功返回true，失败返回false\n 释放锁【Del key】\n   手动释放\n   超时释放\n\n分布式锁误删问题：因为线程一的某种原因导致阻塞，时间超过了Redis锁的过期时间，锁自动释放，线程二获取了线程一的锁，若此时线程一的业务执行完毕，就会手动调用释放锁，就把线程二的锁给释放了，出现了误删的情况\n\nhttps://s11.ax1x.com/2024/01/18/pFkjB7D.png\n\n误删情况解决办法：获取锁的时候将value值设置为UUID+线程ID，每次释放锁的时候就拿redis中存放的值与这个值判断一下，相同才释放，否则不释放\n\n采用上诉方法还是存在问题\n\n释放锁的过程，是先判断reids中的值是否一致，再释放锁。可能出现在判断过后到是否锁之间出现阻塞的情况，因为在JVM中有个东西叫垃圾回收，它会阻塞代码。于是需要保证判断和释放这两部操作是原子操作，不可分割\n\nhttps://s11.ax1x.com/2024/01/18/pFAPylQ.png\n\n解决办法：采用Lua脚本解决，编写Lua脚本，用Java调用\n\n 总结\n\n实现Reids分布式锁的思路\n\n 利用set nx ex获取锁，并设置过期时间，保存现场标识\n 释放锁先判断线程标识是否与自己一致，一致就删除锁【使用Lua脚本保证原子性】\n\n Redisson\n\nRedis的分布式锁是基于setnx实现的，存在一下问题\n\n 不可重入：同一个线程无法多次获取同一把锁\n 不可重试：获取锁只尝试一次就返回false，没有重试机制\n 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患\n 主从一致性：如果Redis提供了主从集群,主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现\n\nRedisson提供一系列分布式的Java常用对象和许多分布式服务\n\nhttps://s11.ax1x.com/2024/01/18/pFAEp5t.png\n\n 可重入锁原理\n\n通过redis的hash结构进行锁的存储，同一个线程进入，会将value值加一，并设置有效期，每次释放锁就value值减一。若减后的值不为0，就重置有效期，否则就直接删除。实现代码通过Lua脚本进行。\n\nhttps://s11.ax1x.com/2024/01/18/pFAVqne.png\n\n流程图\n\nhttps://s11.ax1x.com/2024/01/18/pFAZp1f.png\n\n 可重试锁原理\n\n利用信号量和PubSub功能实现等待、唤醒、获取锁失效的重试机制\n\nhttps://s11.ax1x.com/2024/01/18/pFAeYZQ.png\n\n 超时续约原理\n\n利用wathDog，每隔一段时间，重置超时时间\n\n 主从一致性原理\n\n多个独立的Redis结点，必须所有的结点都获取重入锁，才算获取锁成功\n\n 秒杀优化\n\n 思路\n\n 利用Reids Lua脚本完成库存余量、一人一单判断，完成抢单业务\n 再将下单业务放入阻塞队列中，利用独立线程异步下单\n\n 使用阻塞队列存在的问题\n\n 内存限制问题：当队列的元素超过容量的时候会出现内存溢出\n 数据安全问题：当队列的任务服务出现宕机，任务就会丢失\n\n Reids消息队列\n\n 基于List结构模拟消息队列\n\nReids中的List数据结构是一个双向链表，利用LPUSH结合RPOP，或者RPUSH结合LPOP来实现\n\n不过需要注意的是，当消息队列没有消息时RPOP和LPOP操作会返回NULL，并不像JVM阻塞队列那样会阻塞并等待消息。\n\n因此应该使用BRPOP或者BLPOP来实现阻塞效果\n\n 优点\n\n 利用Reids存储，不受限于JVM内存上限\n 基于Reidis的持久化机制，数据安全性有保证\n 可以满足消息有序性\n\n 缺点\n\n 无法避免消息丢失\n 只支持单消费者\n\n 基于PubSub的消息队列\n\n生产者向对应的cahnnel发送消息后，所有订阅者都能收到消息【一对多】\n\n SUBSCRIBE channel channel：订阅一个或多个频道\n PUSLISH channel msg：向一个频道发送消息\n PSUBSCRIBE pattern pattern：订阅与pattern格式匹配的所有频道\n\n 优点\n\n 采用发布订阅模型，支持多生产、多消费\n\n 缺点\n\n 不支持数据持久化\n 无法避免消息丢失\n 消息堆积有上限，超出时数据丢失\n\n 基于Stream类型消息队列\n\nstream是一种数据类型，专门为消息队列设计的，相较于前面两种方式能够更加完美实现一个消息队列\n\n生产消息：用于向指定的Stream流中添加一个消息\n\n\nXADD key ID value value ...\n\n 创建名为 users 的队列，并向其中发送一个消息，内容是：{name=jack,age=21}，并且使用Redis自动生成ID\n127.0.0.1:6379 XADD users  name jack age 21\n\"16448057005230\n\n\nkey就是消息队列，key不存在会自动创建（默认），ID是消息表示，value是消息的内容\n\n消费消息：\n\n\nXREAD COUNT count BLOCK milliseconds STREAMS key key ... ID ID\n\n 读取XREAD中的第一条消息\nXREAD COUNT 1 STREAMS users 0\n 阻塞1秒钟后从XREAD中读取的最新消息\nXREAD COUNT 1 BLOCK 1000 STREAMS users $\n\n\n注意：当我们指定起始ID为$时代表读取最后一条消息（读取最新的消息）ID为0时代表读最开始的一条消息（读取最旧的消息），如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题\n\n 特点\n\n 消息可回溯\n 一个消息可以被多个消费者读取\n 可以阻塞堆区\n 有消息漏读风险\n\n 消费者组\n\n上面我们介绍的消费方式都是单消费方式，容易发生消息堆积导致消息丢失，所以我们需要改用消费者组的模式\n\n消费者组：将多个消费者划分到一个组，监听同一队列\n\n 消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度\n 消息标识：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费\n 消息确认：消费者获取消息后，消息处于pending（待处理）状态，并存入一个pendinglist。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pendinglist移除。\n\n\n 创建消费者组\nXGROUP CREATE key groupName ID\n 删除指定的消费者组\nXGROUP DESTORY key groupName\n 给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupName consumerName\n 删除消费者组中指定消费者\nXGROUP DELCONSUMER key groupName consumerName\n 从消费者组中读取消息\nXREADGROUP GROUP\n\n\nhttps://imgblog.csdnimg.cn/imgconvert/27039c5d7c9c137c15bab614293a63fe.png\n\nhttps://imgblog.csdnimg.cn/imgconvert/c1ffb0ac9d815f997953b1dfeae6768f.png\n\nstream类型消息队列的XREADGROUP命令特点：\n\n 消息可回溯\n 可以多消费者争抢消息，加快消费速度\n 可以阻塞读取\n 没有消息漏读的风险\n 有消息确认机制，保证消息至少被消费一次\n\n 比较\n\nhttps://s21.ax1x.com/2024/03/11/pF6P3RK.png\n\n Feed流\n\n关注推送也叫投喂，为用户持续提供沉浸式体验，通过无限下拉刷新获取新的信息\n\n 与传统模式的区别\n\n 传统模式：用户寻找内容\n\n Feed模式：内容匹配用户\n\n Feed流常见的模式\n\n TimeLine：不做内容筛选，简单的按照内容发布时间排序，常用于好友或者关注\n 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容\n\n Feed流实现方案\n\nhttps://s11.ax1x.com/2024/01/19/pFAoHxO.png\n\n HyperLogLog用法\n\n首先搞懂两个概念\n\n UV：独立访客量，1天内一个用户多次访问该网站，只记录一次\n PV：页面访问量：用户多次打开页面，记录多次PV\n\nUV统计\n\n 优点：内存占用极小\n 缺点：存在0.81%的误差【不过可以完全忽略】\n\n 总结\n\n 2024116\n\n1、写了发短信验证码和登录接口，随机生成token，将用户信息存入redis中\n\n2、写了两个拦截器，一个拦截所有请求的token刷新拦截器【没有token直接放行，token中找不到数据直接放行，全部通过就存入UserHolder中】，一个是只拦截需要验证的登录拦截器【只需要检验UserHolder中是否有数据，有就通过，否则拦截】。\n\n3、对查询商品接口做了缓存，并且对缓存击穿【互斥锁】和缓存穿透【缓存空对象】做了处理，用jmeter进行检验\n\n 2024117\n\n1、 用逻辑过期时间解决缓存击穿【在shop中使用expire字段】，使用这个方法需要将热点key提前预热。通过比较当前时间和逻辑时间，而从决定是否需要重建数据。通过互斥锁来保证只有一个线程能够进入，通过独立线程来重构数据来减少响应时间\n\n2、创建了redis全局唯一ID生成器，通过符号位1位+时间错31位+序列号32位来形成一个唯一ID，但这样这个ID最大值并不满足总量的所需的范围要求，因此需要通过不同的key来生成序列号【通过加上年:月:日前缀】来保证每天的都有会不同的ID，这个最大值并不会超过一天所需的范围要求。\n\n3、写了优惠券秒杀功能，正常写法会出现超卖的情况，使用乐观锁优化后加上库存限制解决超卖问题【这里也可以用悲观锁解决，通过互斥锁或者同步代码】；使用悲观锁synchronized解决一人一单的问题，并用代理事务【AopContext.currentProxy】解决事务\t\n\n 2024118\n\n1、一人一单集群模式下使用分布式锁解决，分布式锁带来了一系列问题，比如：两个服务的synchronized userId.toString.intern获取的对象不一致【通过互斥锁解决】，误删【通过每次释放前判断存入锁的值是否一致解决】，原子性问题【释放锁的操作分为判断是否一致和释放锁，需要用Java调用写好的Lua脚本来确保原子性】\n\n2、整合Redisson，了解其可重入的原理，可重试锁原理、超时续约原理、主从一致性原理\n\n3、新增查询笔记、点赞笔记\n\n 2024119\n\n1、点赞排行榜【采用redis的zSet存储，按照时间戳排序】、关注、共同关注【set集合取两个集合的并集】\n\n2、使用Feed流，在博文发布的时候推送给关注自己的人\n\n3、签到：使用二进制位stringRedisTemplate.opsForValue.setBitkey, dayOfMonth  1, true;存储签到，签到了就是1，没签到就是0\n\n4、统计连续签到，通过stringRedisTemplate.opsForValue.bitField来获取 本月截至今天为止所有的签到记录\n\n 2024310\n\n1、优化优惠券秒杀逻辑，将原本对数据库的查询等判断条件全部放到Lua脚本中，改为从Reids中判断，极大的优化了查询的时间\n\n2、使用阻塞队列 + 线程池实现异步秒杀\n\n 2024311\n\n1、优化秒杀，使用Stream消息队列替换阻塞队列，能够弥补阻塞队列带来的问题，例如：内存上限，数据丢失等\n"},{"filename":"javaweb","category":"java","md":{"topSummary":"\ntitle: JavaWeb学习笔记\ncategory: Java,Servlet\ndate: 2024-01-17\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## JDBC\n\n介绍：java用来连接和操作数据库\n\n**注意：最后千万别忘掉关闭资源**\n\n### 快速上手\n\n前提需要导入mysql jar包\n\n```\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo {\n    public static void main(String[] args) throws Exception{\n//        注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n//        获取链接\n//        useServerPrepStmts=true开启预编译功能\n        String url = \"jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"123456\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n//        执行语句\n        String sql = \"update jdbc_test set password = 12121 where username = 1\";\n//        获取执行对象\n        Statement statement = conn.createStatement();\n//        返回影响行数\n        int count = statement.executeUpdate(sql);\n        System.out.println(count);\n//        释放资源\n        conn.close();\n        statement.close();\n    }\n}\n```\n\n### API\n\n#### DriverManager\n\n通过`DriverManager.getConnection(url, username, password)`来得到一个Connection对象，代表与数据库连接成功\n\n#### Connection\n\n获取执行sql对象\n\n- 通过调用`createStatemen()`方法获取一个Statement对象\n- 通过调用`prepareStatement()`方法获取一个PrepareStatement对象\n\n事务管理\n\n- 通过调用`setAutoCommit(false)`方法来来关闭自动提交事务\n- 通过调用`sqlSession.commit()`方法来回滚事务\n- 通过调用`rollback()`方法来回滚事务\n\n事务管理就是关闭自动提交事务过后，执行的语句中若出现错误就会立刻回滚事务，一个都不执行；若语句执行完后没有提交事务，他也会回滚事务；\n\n#### Statement\n\n代表执行对象\n\n- 通过调用`executeUpdate(sql)`来对数据进行增删改，返回受影响的行数（int）\n- 通过调用`executeQuery(sql)`来对数据进行查询,返回一个ResultSet对象\n\n#### PreparedStatement\n\n代表执行对象，可以防止sql注入\n\n需要在sql语句中传参的位置用?占位符代替，调用setInt/setString(出现的位置, 需要代替的字符或者数字)来替换?，这样做的原理是使敏感字符用\\\\带转义，让它变为一个字符，不参与sql作用。\n\n例如：\n\n```\nString name = \"1\";\nString pas = \"'or '1' ='1\"; // sql注入代码\n String sql = \"select * from jdbc_test where username = '\"+name+\"' and password = '\"+pas+\"'\";\nStatement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(sql);\n```\n\n这样写的sql语句为`select * from jdbc_test where username = '1' and passwor`d = ''or '1' ='1'，这样的sql语句一定为真，导致sql注入\n\n改进过后代码\n\n```\nString sql = \"select * from jdbc_test where username = ? and password = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setString(1, name);\npreparedStatement.setString(2, pas);\n```\n\n这样的sql为`select * from jdbc_test where username = '1' and password = '\\'or \\'1\\' =\\'1\\'`就不会出现sql注入问题\n\n#### ResultSet\n\n主要有两个重要的方法\n\n- 调用`next()`来判断是否下一行数据是否存在\n- 调用`getString(\"1\")/getInt(\"id\")`来输出改行数据的第1列或者列名为id的数据\n\n## Druid\n\ndruid使阿里巴巴开源的数据库连接池，可以进行多个用户连接，一开始就开了几个Connetion连接，用完并不会关闭而是返回连接池等待下一个用户；而不是用一个开一次连接，用完就关闭，导致浪费时间。\n\n需要引入druid和mysql jar包\n\n与jdbc不同的是这里需要一个Properties配置文件来配置数据库连接池信息\n\n```\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=123456\n# 初始化连接数量\ninitialSize=5\n# 最大连接数\nmaxActive=10\n# 最大等待时间\nmaxWait=3000\n```\n\n```\n// 加载配置文件\nProperties prop = new Properties();\n// System.out.println(System.getProperty(\"user.dir\"));  获取当前目录是src\nprop.load(new FileInputStream(\"jdbc_demo/src/druid.properties\"));\n```\n\n调用`DruidDataSourceFactory.createDataSource(prop)`返回一个DataSource对象，这个DataSource可以调用`getConnection()`来获取数据库连接返回一个Connection对象，拿到这个对象后的操作方法与上面一样\n\n## Mybaits\n\nMybats是JDBC框架，免除了几乎所有JDBC代码以及设置参数和获取结果集的工作\n\n**注意：别忘记关闭SqlSession开启的资源**\n\n### 目录\n\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/javaweb/QQ图片20230106061547.png)\n\njava下单UserMapper为接口文件，resource下的UserMapper为Mapper的xml文件（存放sql数据）。\n\n### **mybatis-config的配置**\n\n放在resources目录下\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n<!-- default为默认选取的数据库，这样写可以切换不同的数据库，对应environment的id-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n<!-- 事务管理方式，采用JDBC-->\n            <transactionManager type=\"JDBC\"/>\n<!-- 数据库连接池-->\n            <dataSource type=\"POOLED\">\n<!-- 数据库的连接信息-->\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql:///test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n<!-- 加载sql映射文件-->\n<!-- <mapper resource=\"com/ljx/mapper/UserMapper.xml\"/>-->\n\n<!-- mapper代理方式，扫包，若还有多个如BrandMapper,....不需要一个一个添加sql映射文件，-->\n        <package name=\"com.ljx.mapper\"/>\n    </mappers>\n</configuration>\n```\n\n加载配置文件，获取sqlSessionFactory对象\n\n```\nString resource = \"mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\n获取SqlSession对象，继承了Conntection的事务管理\n\n```\nSqlSession sqlSession = sqlSessionFactory.openSession();\n```\n\n获得UserMapper接口代理对象\n\n```\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n```\n\n接着就可以调用UserMapper的接口了（例如）\n\n```\nList<User> users = userMapper.selectAll();\n```\n\n**注意：除了查询，其他的增删改均需要事务提交**`sqlSession.commit();`\n\n### **XXXMapper的配置**\n\n放在resources/com/ljx/mapper目录下，与java里面的目录相对应\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace命名空间：为mapper的全限名，为java目录下mapper接口的地址，用来对应mapper-->\n<!--resultType返回类型，com.ljx.pojo.User是User类的文件地址-->\n<mapper namespace=\"com.ljx.mapper.UserMapper\"></mapper>\n```\n\n#### select标签\n\n普通查找\n\n```\n<select id=\"selectAll\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user;\n</select>\n```\n\n含有敏感字符查找\n\n```\n <!-- #{}占位符，会将其替换为?，为了防止sql注入，${}占位符，拼接sql，会存在sql注入问题-->\n<!-- 如遇到特殊字符如：<，则会报错，因为xml小于是一种开始的格式，需要处理\n        1.转移字符：&lt;\n        2.CDATA区：<![CDATA[ < ]]>，其中<![CDATA[内容]]>里可以写多个字符\n-->\n    <select id=\"selectId\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user\n        where id <![CDATA[ < ]]> #{id};\n    </select>\n```\n\n多条件查询\n\n```\n<select id=\"selectMore\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user\n        where id = #{id}\n           and gender = #{gender};\n</select>\n```\n\n动态查询\n\n```\n<!--动态条件查询sql-->\n<!-- 并不是所有的参数都需要传入-->\n<!-- if标签，存在问题：第一个if若不存在就会出错。-->\n<!-- 解决：1、添加 1=1  2、用where标签替换where语句，若条件存在就会自动去掉and-->\n<select id=\"selectNiu\" resultType=\"com.ljx.pojo.User\">\n    select * from tb_user\n    <where>\n        <if test=\"username != null and username != ''\">and username = #{username}</if>\n        <if test=\"id != null\">and id = #{id}</if>\n    </where>\n</select>\n```\n\n单条件查询\n\n```\n<!--单条件动态查询-->\n<!-- choose标签相当于switch，when标签相当于case，test里放的是条件-->\n<!-- otherwise相当于default，若没有满足的条件就执行这个语句，否则不执行-->\n<select id=\"selectDan\" resultType=\"com.ljx.pojo.User\">\n    select * from tb_user\n    where\n    <choose>\n        <when test=\"username != null and username != ''\">username = #{username}</when>\n        <when test=\"id != null\">id = #{id}</when>\n        <otherwise>1 = 1</otherwise>\n        </choose>\n</select>\n```\n\n#### insert标签\n\n```\n<!-- useGeneratedKeys=\"true\" keyProperty=\"id\" 返回添加数据id-->\n<insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into tb_user (username, password, gender, addr)\n    values (#{username}, #{password}, #{gender}, #{addr})\n</insert>\n```\n\n#### updated标签\n\n普通修改\n\n```\n<update id=\"updated\">\n    update tb_user\n    set username = #{username},\n        password = #{password},\n        gender = #{gender},\n        addr = #{addr}\n    where id = #{id}\n</update>\n```\n\n动态修改\n\n```\n<update id=\"updatedDong\">\n    update tb_user\n    <set>\n        <if test=\"username != null and username != ''\">username = #{username},</if>\n        <if test=\"password != null and password != ''\">password = #{password},</if>\n        <if test=\"gender != null and gender != ''\">gender = #{gender},</if>\n        <if test=\"addr != null and addr != ''\">addr = #{addr}</if>\n    </set>\n    where id = #{id}\n</update>\n```\n\n#### delete标签\n\n普通删除\n\n```\n<delete id=\"delete\">\n    delete from tb_user where id = #{id}\n</delete>\n```\n\n批量删除\n\n```\n<!-- 用foreach循环遍历，因为一开始并不知道数组有多少长度-->\n<!-- mybatis默认将collection参数为array，只能为这个，若想改变产生名字，则必须在传参的时候用@Params注解改变默认名字-->\n<!-- 例如：void deleteFor(@Param(\"ids\") int[] ids);-->\n<delete id=\"deleteFor\">\n    delete from tb_user where id in\n    <foreach collection=\"array\" item=\"id\" separator=\",\" open=\"(\" close=\")\">\n        #{id}\n    </foreach>\n</delete>\n```\n\n### 注解方式\n\n用注解方式就不用写xml文件，极大的方便了开发，所以简单的sql语句用注解，复杂的sql语句用xml文件\n\n```\n@Select(\"select * from tb_user\")\nList<User> userAll();\n```\n\n## Servlet\n\nServlet是Java web的核心\n\n### 快速入门\n\n需要重写Servlet api中的5个方法\n\n```\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n\n@WebServlet(\"/demo1\")\npublic class servletDemo1 implements Servlet {\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"123\");\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(21);\n    }\n}\n```\n\n### Api\n\n#### init\n\n- 调用时机：默认情况下Servlet第一访问的时候创建Servlet对象，实例化后被调用\n- 调用次数：1次\n\n#### service\n\n- 调用时机：Servlet每一次被访问的时候\n- 调用次数：多次\n\n#### destroy\n\n- 调用时机：内存释放或者服务器关闭时，Servlet对象会销毁\n- 调用次数：1次\n\n### WebServlet注解配置规则\n\n`@WebServlet(urlPatterns = \"/demo2\", loadOnStartup = 1)`\n\nurlPatterns = xx， xx为路由地址，参数只有urlPatterns时可以省略只写`@WebServlet(\"xxx\")`\n\n- 1、数组，可以放多个接口\n- 2、精确匹配：`/api/demo`\n- 3、目录匹配：`/api/demo/*`\n- 4、拓展名匹配：`.do`\n- 5、任意匹配：`/` 或者 `/*`\n\nloadOnStartup为-1表示第一次访问的时候初始化，为正整数或者为0表示Servlet对象创建的时候就调用\n\n### HttpServlet\n\nHttpServlet是对Http协议进行封装的Servlet实现类\n\n需要重写doGet和doPost方法\n\n```\npublic class ServletDemo_HttpServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n```\n\n封装的原理就是通过`ServletRequest`强制转为子类`HttpServletRequest`，在调用`getMethod()`方法获取调用方法，若是get方法就调用`doGet()`，post方法就调用`doPost()`\n\n### HttpServletRequest\n\n#### 请求行\n\n- 请求方法：post/get => `req.getMethod()`\n- 访问访问路径：/api => `req.getContextPath()`\n- 统一资源定位符：http://localhost:8080/api/demo5 => `req.getRequestURL()`\n- 统一资源标识符：/api/demo5 => `req.getRequestURI()`\n\n#### 请求参数\n\n`req.getQueryString()`\n\n#### 请求头\n\n`req.getHeader(\"xxx\")`\n\n#### 通用获取参数方法\n\n```\n// 若参数// 请求获得参数的通用方法, 键值对方法，底层用了getQueryString方法\nMap<String, String[]> map = req.getParameterMap();\nfor(String s: map.keySet()){\n    System.out.print(s + \":\");\n    for(String j: map.get(s)){\n        System.out.print(j + \"\");\n    }\n    System.out.println(\"\");\n}\n// 若参数有多个，根据key获取参数值，数组\nString[] sz = req.getParameterValues(\"username\");\n// 若参数只有一个，根据key获取值\nString sd = req.getParameter(\"password\");\n```\n\n#### 乱码问题\n\nget乱码问题：tomcat进行url解码的默认字符集为ISO-8859-1\n\n解决：1、对乱码进行解码，转为字节数组。2、解码\n\n```\nbyte ss[] = reqUsername.getBytes(StandardCharsets.ISO_8859_1);\nString endUsername = new String(ss, \"utf-8\");\n```\n\npost乱码问题解决：`req.setCharacterEncoding(\"UTF-8\");`\n\n#### 资源转发\n\n特点：1、浏览地址栏不变化；2、只能转发当前服务器内部资源；3、一次请求，转发资源间数据共享\n\n```\nreq.setAttribute(\"msg\", \"hello\");\nreq.getAttribute(\"msg\");\nreq.removeAttribute(\"msg\");\n```\n\n请求转发：`req.getRequestDispatcher(\"/demo\").forward(req, resp);`\n\n### HttpServletResponse\n\n#### **重定向**\n\n特点：1、路由器地址栏发送变化；2、可以重定向任意位置（服务器内部或者外部都可以）；3、两次请求，不能在多个资源中使用request共享数据\n\n```\n// 方法一\n// 设置状态码\nresponse.setStatus(302);\n//  设置响应头\nresponse.setHeader(\"Location\", \"/servlet_demo/demo1\");\n\n// 方法二\n// 重定向简化写法\n// request.getContextPath()：获取虚拟目录\nresponse.sendRedirect(request.getContextPath() + \"/demo1\");\n```\n\n#### response响应数据\n\n##### 字符输入流\n\n```\n// 设置请求头编码为utf-8并且支持html格式\nresponse.setHeader(\"content-type\", \"text/html;charset=utf-8\");\n//  获得字符输入流\nPrintWriter printWriter = response.getWriter();\nprintWriter.write(\"<h1>你好</h1>\");\n```\n\n##### 字节输入流\n\n```\nFileInputStream file = new FileInputStream(\"C:\\\\Users\\\\lenovo\\\\Pictures\\\\Saved Pictures\\\\qq.jpg\");\nServletOutputStream servletOutputStream = response.getOutputStream();\nbyte[] b = new byte[1024];\nint len = 0;\nwhile((len = file.read(b)) != -1){\n    servletOutputStream.write(b, 0, len);\n}\nfile.close(); // 这里需要关闭资源\n```\n\n##### JSON格式\n\n需要导入fastjson包\n\n```\n<dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.2.62</version>\n</dependency>\n```\n\n例子\n\n```\nint n[] = {1,2,3,6,4,5};\nString j = JSON.toJSONString(n);\nresponse.setContentType(\"text/html;charset=utf-8\");\nresponse.getWriter().write(j);\n```\n","title":" JavaWeb学习笔记\n","category":[" Java","Servlet\n"],"date":" 2024-01-17\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n JDBC\n\n介绍：java用来连接和操作数据库\n\n注意：最后千万别忘掉关闭资源\n\n 快速上手\n\n前提需要导入mysql jar包\n\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo {\n    public static void mainString args throws Exception{\n//        注册驱动\n        Class.forName\"com.mysql.jdbc.Driver\";\n//        获取链接\n//        useServerPrepStmts=true开启预编译功能\n        String url = \"jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"123456\";\n        Connection conn = DriverManager.getConnectionurl, username, password;\n//        执行语句\n        String sql = \"update jdbctest set password = 12121 where username = 1\";\n//        获取执行对象\n        Statement statement = conn.createStatement;\n//        返回影响行数\n        int count = statement.executeUpdatesql;\n        System.out.printlncount;\n//        释放资源\n        conn.close;\n        statement.close;\n    }\n}\n\n\n API\n\n DriverManager\n\n通过DriverManager.getConnectionurl, username, password来得到一个Connection对象，代表与数据库连接成功\n\n Connection\n\n获取执行sql对象\n\n 通过调用createStatemen方法获取一个Statement对象\n 通过调用prepareStatement方法获取一个PrepareStatement对象\n\n事务管理\n\n 通过调用setAutoCommitfalse方法来来关闭自动提交事务\n 通过调用sqlSession.commit方法来回滚事务\n 通过调用rollback方法来回滚事务\n\n事务管理就是关闭自动提交事务过后，执行的语句中若出现错误就会立刻回滚事务，一个都不执行；若语句执行完后没有提交事务，他也会回滚事务；\n\n Statement\n\n代表执行对象\n\n 通过调用executeUpdatesql来对数据进行增删改，返回受影响的行数（int）\n 通过调用executeQuerysql来对数据进行查询,返回一个ResultSet对象\n\n PreparedStatement\n\n代表执行对象，可以防止sql注入\n\n需要在sql语句中传参的位置用?占位符代替，调用setInt/setString出现的位置, 需要代替的字符或者数字来替换?，这样做的原理是使敏感字符用\\\\带转义，让它变为一个字符，不参与sql作用。\n\n例如：\n\n\nString name = \"1\";\nString pas = \"'or '1' ='1\"; // sql注入代码\n String sql = \"select  from jdbctest where username = '\"+name+\"' and password = '\"+pas+\"'\";\nStatement statement = connection.createStatement;\nResultSet resultSet = statement.executeQuerysql;\n\n\n这样写的sql语句为select  from jdbctest where username = '1' and password = ''or '1' ='1'，这样的sql语句一定为真，导致sql注入\n\n改进过后代码\n\n\nString sql = \"select  from jdbctest where username = ? and password = ?\";\nPreparedStatement preparedStatement = connection.prepareStatementsql;\npreparedStatement.setString1, name;\npreparedStatement.setString2, pas;\n\n\n这样的sql为select  from jdbctest where username = '1' and password = '\\'or \\'1\\' =\\'1\\'就不会出现sql注入问题\n\n ResultSet\n\n主要有两个重要的方法\n\n 调用next来判断是否下一行数据是否存在\n 调用getString\"1\"/getInt\"id\"来输出改行数据的第1列或者列名为id的数据\n\n Druid\n\ndruid使阿里巴巴开源的数据库连接池，可以进行多个用户连接，一开始就开了几个Connetion连接，用完并不会关闭而是返回连接池等待下一个用户；而不是用一个开一次连接，用完就关闭，导致浪费时间。\n\n需要引入druid和mysql jar包\n\n与jdbc不同的是这里需要一个Properties配置文件来配置数据库连接池信息\n\n\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=123456\n 初始化连接数量\ninitialSize=5\n 最大连接数\nmaxActive=10\n 最大等待时间\nmaxWait=3000\n\n\n\n// 加载配置文件\nProperties prop = new Properties;\n// System.out.printlnSystem.getProperty\"user.dir\";  获取当前目录是src\nprop.loadnew FileInputStream\"jdbcdemo/src/druid.properties\";\n\n\n调用DruidDataSourceFactory.createDataSourceprop返回一个DataSource对象，这个DataSource可以调用getConnection来获取数据库连接返回一个Connection对象，拿到这个对象后的操作方法与上面一样\n\n Mybaits\n\nMybats是JDBC框架，免除了几乎所有JDBC代码以及设置参数和获取结果集的工作\n\n注意：别忘记关闭SqlSession开启的资源\n\n 目录\n\nhttps://gitee.com/lijunxi666/picturebed/raw/master/javaweb/QQ图片20230106061547.png\n\njava下单UserMapper为接口文件，resource下的UserMapper为Mapper的xml文件（存放sql数据）。\n\n mybatisconfig的配置\n\n放在resources目录下\n\n\n<?xml version=\"1.0\" encoding=\"UTF8\" ?\n<DOCTYPE configuration\n        PUBLIC \"//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis3config.dtd\"\n<configuration\n\n< default为默认选取的数据库，这样写可以切换不同的数据库，对应environment的id\n    <environments default=\"development\"\n        <environment id=\"development\"\n< 事务管理方式，采用JDBC\n            <transactionManager type=\"JDBC\"/\n< 数据库连接池\n            <dataSource type=\"POOLED\"\n< 数据库的连接信息\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\n                <property name=\"url\" value=\"jdbc:mysql:///test\"/\n                <property name=\"username\" value=\"root\"/\n                <property name=\"password\" value=\"123456\"/\n            </dataSource\n        </environment\n    </environments\n    <mappers\n< 加载sql映射文件\n< <mapper resource=\"com/ljx/mapper/UserMapper.xml\"/\n\n< mapper代理方式，扫包，若还有多个如BrandMapper,....不需要一个一个添加sql映射文件，\n        <package name=\"com.ljx.mapper\"/\n    </mappers\n</configuration\n\n\n加载配置文件，获取sqlSessionFactory对象\n\n\nString resource = \"mybatisconfig.xml\";\nInputStream inputStream = Resources.getResourceAsStreamresource;\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.buildinputStream;\n\n\n获取SqlSession对象，继承了Conntection的事务管理\n\n\nSqlSession sqlSession = sqlSessionFactory.openSession;\n\n\n获得UserMapper接口代理对象\n\n\nUserMapper userMapper = sqlSession.getMapperUserMapper.class;\n\n\n接着就可以调用UserMapper的接口了（例如）\n\n\nList<User users = userMapper.selectAll;\n\n\n注意：除了查询，其他的增删改均需要事务提交sqlSession.commit;\n\n XXXMapper的配置\n\n放在resources/com/ljx/mapper目录下，与java里面的目录相对应\n\n\n<?xml version=\"1.0\" encoding=\"UTF8\" ?\n<DOCTYPE mapper\n        PUBLIC \"//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis3mapper.dtd\"\n<namespace命名空间：为mapper的全限名，为java目录下mapper接口的地址，用来对应mapper\n<resultType返回类型，com.ljx.pojo.User是User类的文件地址\n<mapper namespace=\"com.ljx.mapper.UserMapper\"</mapper\n\n\n select标签\n\n普通查找\n\n\n<select id=\"selectAll\" resultType=\"com.ljx.pojo.User\"\n        select \n        from tbuser;\n</select\n\n\n含有敏感字符查找\n\n\n < {}占位符，会将其替换为?，为了防止sql注入，${}占位符，拼接sql，会存在sql注入问题\n< 如遇到特殊字符如：<，则会报错，因为xml小于是一种开始的格式，需要处理\n        1.转移字符：&lt;\n        2.CDATA区：<CDATA < ，其中<CDATA内容里可以写多个字符\n\n    <select id=\"selectId\" resultType=\"com.ljx.pojo.User\"\n        select \n        from tbuser\n        where id <CDATA <  {id};\n    </select\n\n\n多条件查询\n\n\n<select id=\"selectMore\" resultType=\"com.ljx.pojo.User\"\n        select \n        from tbuser\n        where id = {id}\n           and gender = {gender};\n</select\n\n\n动态查询\n\n\n<动态条件查询sql\n< 并不是所有的参数都需要传入\n< if标签，存在问题：第一个if若不存在就会出错。\n< 解决：1、添加 1=1  2、用where标签替换where语句，若条件存在就会自动去掉and\n<select id=\"selectNiu\" resultType=\"com.ljx.pojo.User\"\n    select  from tbuser\n    <where\n        <if test=\"username = null and username = ''\"and username = {username}</if\n        <if test=\"id = null\"and id = {id}</if\n    </where\n</select\n\n\n单条件查询\n\n\n<单条件动态查询\n< choose标签相当于switch，when标签相当于case，test里放的是条件\n< otherwise相当于default，若没有满足的条件就执行这个语句，否则不执行\n<select id=\"selectDan\" resultType=\"com.ljx.pojo.User\"\n    select  from tbuser\n    where\n    <choose\n        <when test=\"username = null and username = ''\"username = {username}</when\n        <when test=\"id = null\"id = {id}</when\n        <otherwise1 = 1</otherwise\n        </choose\n</select\n\n\n insert标签\n\n\n< useGeneratedKeys=\"true\" keyProperty=\"id\" 返回添加数据id\n<insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\"\n    insert into tbuser username, password, gender, addr\n    values {username}, {password}, {gender}, {addr}\n</insert\n\n\n updated标签\n\n普通修改\n\n\n<update id=\"updated\"\n    update tbuser\n    set username = {username},\n        password = {password},\n        gender = {gender},\n        addr = {addr}\n    where id = {id}\n</update\n\n\n动态修改\n\n\n<update id=\"updatedDong\"\n    update tbuser\n    <set\n        <if test=\"username = null and username = ''\"username = {username},</if\n        <if test=\"password = null and password = ''\"password = {password},</if\n        <if test=\"gender = null and gender = ''\"gender = {gender},</if\n        <if test=\"addr = null and addr = ''\"addr = {addr}</if\n    </set\n    where id = {id}\n</update\n\n\n delete标签\n\n普通删除\n\n\n<delete id=\"delete\"\n    delete from tbuser where id = {id}\n</delete\n\n\n批量删除\n\n\n< 用foreach循环遍历，因为一开始并不知道数组有多少长度\n< mybatis默认将collection参数为array，只能为这个，若想改变产生名字，则必须在传参的时候用@Params注解改变默认名字\n< 例如：void deleteFor@Param\"ids\" int ids;\n<delete id=\"deleteFor\"\n    delete from tbuser where id in\n    <foreach collection=\"array\" item=\"id\" separator=\",\" open=\"\" close=\"\"\n        {id}\n    </foreach\n</delete\n\n\n 注解方式\n\n用注解方式就不用写xml文件，极大的方便了开发，所以简单的sql语句用注解，复杂的sql语句用xml文件\n\n\n@Select\"select  from tbuser\"\nList<User userAll;\n\n\n Servlet\n\nServlet是Java web的核心\n\n 快速入门\n\n需要重写Servlet api中的5个方法\n\n\nimport javax.servlet.;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n\n@WebServlet\"/demo1\"\npublic class servletDemo1 implements Servlet {\n\n    @Override\n    public void initServletConfig servletConfig throws ServletException {\n\n    }\n\n    @Override\n    public void serviceServletRequest servletRequest, ServletResponse servletResponse throws ServletException, IOException {\n        System.out.println\"123\";\n    }\n\n    @Override\n    public ServletConfig getServletConfig {\n        return null;\n    }\n\n    @Override\n    public String getServletInfo {\n        return null;\n    }\n\n    @Override\n    public void destroy {\n        System.out.println21;\n    }\n}\n\n\n Api\n\n init\n\n 调用时机：默认情况下Servlet第一访问的时候创建Servlet对象，实例化后被调用\n 调用次数：1次\n\n service\n\n 调用时机：Servlet每一次被访问的时候\n 调用次数：多次\n\n destroy\n\n 调用时机：内存释放或者服务器关闭时，Servlet对象会销毁\n 调用次数：1次\n\n WebServlet注解配置规则\n\n@WebServleturlPatterns = \"/demo2\", loadOnStartup = 1\n\nurlPatterns = xx， xx为路由地址，参数只有urlPatterns时可以省略只写@WebServlet\"xxx\"\n\n 1、数组，可以放多个接口\n 2、精确匹配：/api/demo\n 3、目录匹配：/api/demo/\n 4、拓展名匹配：.do\n 5、任意匹配：/ 或者 /\n\nloadOnStartup为1表示第一次访问的时候初始化，为正整数或者为0表示Servlet对象创建的时候就调用\n\n HttpServlet\n\nHttpServlet是对Http协议进行封装的Servlet实现类\n\n需要重写doGet和doPost方法\n\n\npublic class ServletDemoHttpServlet extends HttpServlet {\n    @Override\n    protected void doGetHttpServletRequest req, HttpServletResponse resp throws ServletException, IOException {\n        super.doGetreq, resp;\n    }\n\n    @Override\n    protected void doPostHttpServletRequest req, HttpServletResponse resp throws ServletException, IOException {\n        super.doPostreq, resp;\n    }\n}\n\n\n封装的原理就是通过ServletRequest强制转为子类HttpServletRequest，在调用getMethod方法获取调用方法，若是get方法就调用doGet，post方法就调用doPost\n\n HttpServletRequest\n\n 请求行\n\n 请求方法：post/get = req.getMethod\n 访问访问路径：/api = req.getContextPath\n 统一资源定位符：http://localhost:8080/api/demo5 = req.getRequestURL\n 统一资源标识符：/api/demo5 = req.getRequestURI\n\n 请求参数\n\nreq.getQueryString\n\n 请求头\n\nreq.getHeader\"xxx\"\n\n 通用获取参数方法\n\n\n// 若参数// 请求获得参数的通用方法, 键值对方法，底层用了getQueryString方法\nMap<String, String map = req.getParameterMap;\nforString s: map.keySet{\n    System.out.prints + \":\";\n    forString j: map.gets{\n        System.out.printj + \"\";\n    }\n    System.out.println\"\";\n}\n// 若参数有多个，根据key获取参数值，数组\nString sz = req.getParameterValues\"username\";\n// 若参数只有一个，根据key获取值\nString sd = req.getParameter\"password\";\n\n\n 乱码问题\n\nget乱码问题：tomcat进行url解码的默认字符集为ISO88591\n\n解决：1、对乱码进行解码，转为字节数组。2、解码\n\n\nbyte ss = reqUsername.getBytesStandardCharsets.ISO88591;\nString endUsername = new Stringss, \"utf8\";\n\n\npost乱码问题解决：req.setCharacterEncoding\"UTF8\";\n\n 资源转发\n\n特点：1、浏览地址栏不变化；2、只能转发当前服务器内部资源；3、一次请求，转发资源间数据共享\n\n\nreq.setAttribute\"msg\", \"hello\";\nreq.getAttribute\"msg\";\nreq.removeAttribute\"msg\";\n\n\n请求转发：req.getRequestDispatcher\"/demo\".forwardreq, resp;\n\n HttpServletResponse\n\n 重定向\n\n特点：1、路由器地址栏发送变化；2、可以重定向任意位置（服务器内部或者外部都可以）；3、两次请求，不能在多个资源中使用request共享数据\n\n\n// 方法一\n// 设置状态码\nresponse.setStatus302;\n//  设置响应头\nresponse.setHeader\"Location\", \"/servletdemo/demo1\";\n\n// 方法二\n// 重定向简化写法\n// request.getContextPath：获取虚拟目录\nresponse.sendRedirectrequest.getContextPath + \"/demo1\";\n\n\n response响应数据\n\n 字符输入流\n\n\n// 设置请求头编码为utf8并且支持html格式\nresponse.setHeader\"contenttype\", \"text/html;charset=utf8\";\n//  获得字符输入流\nPrintWriter printWriter = response.getWriter;\nprintWriter.write\"<h1你好</h1\";\n\n\n 字节输入流\n\n\nFileInputStream file = new FileInputStream\"C:\\\\Users\\\\lenovo\\\\Pictures\\\\Saved Pictures\\\\qq.jpg\";\nServletOutputStream servletOutputStream = response.getOutputStream;\nbyte b = new byte1024;\nint len = 0;\nwhilelen = file.readb = 1{\n    servletOutputStream.writeb, 0, len;\n}\nfile.close; // 这里需要关闭资源\n\n\n JSON格式\n\n需要导入fastjson包\n\n\n<dependency\n      <groupIdcom.alibaba</groupId\n      <artifactIdfastjson</artifactId\n      <version1.2.62</version\n</dependency\n\n\n例子\n\n\nint n = {1,2,3,6,4,5};\nString j = JSON.toJSONStringn;\nresponse.setContentType\"text/html;charset=utf8\";\nresponse.getWriter.writej;\n\n"},{"filename":"python","category":"python","md":{"topSummary":"\ntitle: Python学习笔记\ncategory: Python\ndate: 2024-01-17\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n**_注意：建议配合Python教程书本来结合学习_**\n\n### 一.Python的安装与环境搭建\n\n Python官网下载：[https://www.python.org/](https://www.python.org/)\n\n安装与环境搭建请看教程：[https://cloud.tencent.com/developer/article/1580729](https://cloud.tencent.com/developer/article/1580729)\n\n**_注意：必须是在cmd中输入python有输出显示才算的上是环境搭建成功_**\n\n### 二.第一个Python程序\n\n```\nprint(\"Hello World!\")\n```\n\n简简单单输出：Hello World!\n\n### 三.Python的基础语法\n\n#### 1.**Python的标识符**\n\n- 第一个字符必须是字母表中字母或下划线\n- 标识符的其他的部分由字母、数字和下划线组成\n- 标识符对大小写敏感\n\n#### 2.**Python的关键字**\n\n- 关键词：保留字，我们不能用它来做任何表示符名称\n- Python的关键字：如下\n\n```\nTrue，False，None，and，as，asset ，def ，class ，continue ，break ，else ，finally ，elif ，del ，except ，global ，for ，if ，from ，import ，raise ，try ，or ，return ，pass ，nonlocal ，in ，not ，is ，lambda\n```\n\n#### 3.**Python的注释**\n\n- 注释：编译器不执行此语句\n- 单行注释：用 # 来表示\n\n```\n#print(\"此处是单行注释\")\n```\n\n-   多行注释：用 ' 或者 \" 来表示\n\n```\n'print(\"此处是多行注释\")' \n\"print(\"此处也是多行注释\")\"\n```\n\n####  4.**Python的缩进**\n\n-   Python的缩进与其他编程语言不同，它是强制性的，必须通过Tab来与语句对齐,否则会报错!\n\n### 四.Python的基本数据类型\n\n#### 1.**Python中的数据类型**\n\n- 整型：整数\n- 字符型：字符串\n- 浮点型：小数\n- 列表：\\[\\], list()\n- 元组：(), tuple()\n- 集合：set()\n- 字典：{}, dict()\n\n#### 2. **每个数据类型之间能相互转换**\n\n- int(x)--->x转为整型\n- str(x)--->x转为字符型\n- float(x)--->x转为浮点型\n- list(x)--->x转为列表\n- tuple(x)--->x转为元组\n- set(x)--->x转为集合\n- dict(x)--->x转为字典\n\n_注意：有的转换必须符合转换的要求！不想这么转就怎么转_\n\n### 五.条件判断语句（比较简单就不再过多叙述）\n\n#### **格式：**\n\n```\n if (条件一):\n      (表达式一)\n elif (条件二):\n      (表达式二)\n else:\n      (表达式三)\n```\n\n### 六.循环语句（比较简单就不再过多叙述）\n\n#### 1.while循环\n\n```\n while (满足循环进行的条件):\n        (表达式一)\n```\n\n#### 2.for循环\n\n```\nfor i in x:    #此处的x可以为列表，字典，字符换等, i为自变量\n       (表达式一)\nfor i in range(0,x):  #表示循环x次，x必须为整数\n       (表达式二)  \n```\n\n### 七.列表\n\n#### 1.**列表的创建**\n\n```\na = list()   #两种方法都可以\na = []\n```\n\n#### 2.**列表的操作**\n\n- 访问\n\n```\na[0]    #代表列表a的下标为1的元素\n```\n\n- 增加\n\n```\na.append(x)   #x代表增加的元素\n```\n\n- 删除\n\n```\ndel a[x]   #x代表元素下标的索引\n```\n\n- 更新\n\n```\na[5] = 6   #把下标索引为5的元素改为整数6\n```\n\n- 列表的长度\n\n```\nlen(a)\n```\n\n- 列表的最大值\n\n```\nmax(a)\n```\n\n- 列表的最小值\n\n```\nmin(a)\n```\n\n- 某元素出现的次数\n\n```\na.count(x) #x为某一元素\n```\n\n- 列表排序\n\n```\na.sort(key=None,reverse=False)   #对列表从小到大排序,reverse=True为降序\n```\n\n- 列表反转\n\n```\na.reverse()  #反向列表中元素\n```\n\n- 清空列表\n\n```\na.clear()\n```\n\n- 复制列表\n\n```\na.copy()\n```\n\n- 取出第i位并删除\n\n```\na.pop(i)\n```\n\n- 在列表第i位插入x\n\n```\na.insert(i,x)\n```\n\n- 将列表出现的第一个元素x删除\n\n```\na.remove(x)\n```\n\n- 将列表b添加到列表a中\n\n```\na.extend(b)\n```\n\n### 八.元组\n\n#### **1.元组的创建**\n\n```\na = tuple()\na = ()\n```\n\n#### 2.**元组的操作**\n\n- 访问\n\n```\na[0]   #代表元组a的下标为1的元素\n```\n\n- 增加：元组无法实现a\\[1\\] = 5增加操作，**元组的元素值是不能修改的**\n\n- 删除\n\n```\ndel a[x] #x代表元素下标的索引\n```\n\n- 修改：元组修改可以通过两个元组拼接来实现，元组的元素值是不能修改的\n\n- 元组的个数\n\n```\nlen(a)\n```\n\n- 元组的最大值\n\n```\nmax(a)\n```\n\n- 元组的最小值\n\n```\nmin(a)\n```\n\n**_注意：元组的元素值是不能修改的_**\n\n### 九.集合\n\n#### 1.**集合的创建**\n\n```\na = set()\n```\n\n#### 2.**集合的操作**\n\n- 访问：集合无法访问单独元素\n- 增加\n\n```\na.add(x) 或者 a.update(x)   #x为增加的元素\n```\n\n- 删除\n\n```\na.remove(x)\na.discard(x)\na.pop()     \n#x代表移除的元素，第二种若元素不存在会出错，所以建议使用第一种方法,第三种为随机删除\n```\n\n- 修改：集合修改可以通过两个集合 &|^+- 来实现\n- 集合的个数\n\n```\nlen(a)\n```\n\n- 复制集合\n\n```\na.copy()\n```\n\n- 判断元素x是否在集合存在\n\n```\nx in s   #为存在返回True,否则False\n```\n\n- 清空集合\n\n```\na.clear()\n```\n\n### 十.字典\n\n#### 1.**字典的组成：a = {'键':值}，由一个个键值对组成**\n\n#### 2.**字典的创建**\n\n```\na = dict()\na = {}\n```\n\n#### 3.**字典的操作**\n\n- 读取\n\n```\na['x']   #x代表读取元素的键，返回其值\n```\n\n- 增加\n\n```\na['x'] = y   #x代表增加的元素的键，y代表增加元素的值\n```\n\n- 删除\n\n```\ndel a['x']   #x代表删除元素的键\n```\n\n- 修改\n\n```\na['x'] = y   #把x的值修改成y\n```\n\n- 字典的长度\n\n```\nlen(a)\n```\n\n- 清空字典\n\n```\na.clear()\n```\n\n- 复制字典\n\n```\na.copy()\n```\n\n- 随机返回字典某一键值对\n\n```\na.item()\n```\n\n- 返回某一元素对应的值\n\n```\na.get('x')   # x为改元素的键\n```\n\n- 返回所有元素对应的值\n\n```\na.values()\n```\n\n- 返回所有元素对应的键\n\n```\na.keys()\n```\n\n- 随机返回并删除该键值对\n\n```\na.popitem()\n```\n\n**注_意：键值对的键是唯一的，不能出现两个相同的键，值是可变的_**\n\n### 十一.函数\n\n#### 1.**格式：**\n\n```\n    def 变量名(参数一,参数二):\n        (表达式一)\n```\n\n****_注意：在Python中可以有返回值，也可以不有返回值，还可以只有 return_****\n\n#### 2.**函数的调用**\n\n```\ndef count(a,b):    #定义函数count，参数为a，b\n   return a+b    #返回a+b的值\n\nm = count(1,2)   #此处进行了函数的调用\nprint(m)\n\n>>3\n```\n\n### 十二.类\n\n#### 1.**关键字：class**\n\n#### 2.**格式**\n\n```\nclass (变量名1):\n      def __init__(self,参数一,参数二...):\n         self.变量名2 = 参数一    #此处的变量名2为实列变量\n      def __del__(self):    #不常用，再出现结束前一部进行\n         表达式1\n      def __str__(self):    #必须返回字符串\n         return \"此处为一个字符串\"\n      def 变量名3(self):    #实列方法\n         表达式2\n```\n\n#### 3.**类调用**\n\n```\n  a = 变量名1(参数一,参数二...)\n```\n\n完毕，后续有待补充，欢迎各位大佬指出错误，多谢！\n","title":" Python学习笔记\n","category":[" Python\n"],"date":" 2024-01-17\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n注意：建议配合Python教程书本来结合学习\n\n 一.Python的安装与环境搭建\n\n Python官网下载：https://www.python.org/https://www.python.org/\n\n安装与环境搭建请看教程：https://cloud.tencent.com/developer/article/1580729https://cloud.tencent.com/developer/article/1580729\n\n注意：必须是在cmd中输入python有输出显示才算的上是环境搭建成功\n\n 二.第一个Python程序\n\n\nprint\"Hello World\"\n\n\n简简单单输出：Hello World\n\n 三.Python的基础语法\n\n 1.Python的标识符\n\n 第一个字符必须是字母表中字母或下划线\n 标识符的其他的部分由字母、数字和下划线组成\n 标识符对大小写敏感\n\n 2.Python的关键字\n\n 关键词：保留字，我们不能用它来做任何表示符名称\n Python的关键字：如下\n\n\nTrue，False，None，and，as，asset ，def ，class ，continue ，break ，else ，finally ，elif ，del ，except ，global ，for ，if ，from ，import ，raise ，try ，or ，return ，pass ，nonlocal ，in ，not ，is ，lambda\n\n\n 3.Python的注释\n\n 注释：编译器不执行此语句\n 单行注释：用  来表示\n\n\nprint\"此处是单行注释\"\n\n\n   多行注释：用 ' 或者 \" 来表示\n\n\n'print\"此处是多行注释\"' \n\"print\"此处也是多行注释\"\"\n\n\n  4.Python的缩进\n\n   Python的缩进与其他编程语言不同，它是强制性的，必须通过Tab来与语句对齐,否则会报错\n\n 四.Python的基本数据类型\n\n 1.Python中的数据类型\n\n 整型：整数\n 字符型：字符串\n 浮点型：小数\n 列表：\\\\, list\n 元组：, tuple\n 集合：set\n 字典：{}, dict\n\n 2. 每个数据类型之间能相互转换\n\n intxx转为整型\n strxx转为字符型\n floatxx转为浮点型\n listxx转为列表\n tuplexx转为元组\n setxx转为集合\n dictxx转为字典\n\n注意：有的转换必须符合转换的要求！不想这么转就怎么转\n\n 五.条件判断语句（比较简单就不再过多叙述）\n\n 格式：\n\n\n if 条件一:\n      表达式一\n elif 条件二:\n      表达式二\n else:\n      表达式三\n\n\n 六.循环语句（比较简单就不再过多叙述）\n\n 1.while循环\n\n\n while 满足循环进行的条件:\n        表达式一\n\n\n 2.for循环\n\n\nfor i in x:    此处的x可以为列表，字典，字符换等, i为自变量\n       表达式一\nfor i in range0,x:  表示循环x次，x必须为整数\n       表达式二  \n\n\n 七.列表\n\n 1.列表的创建\n\n\na = list   两种方法都可以\na = \n\n\n 2.列表的操作\n\n 访问\n\n\na0    代表列表a的下标为1的元素\n\n\n 增加\n\n\na.appendx   x代表增加的元素\n\n\n 删除\n\n\ndel ax   x代表元素下标的索引\n\n\n 更新\n\n\na5 = 6   把下标索引为5的元素改为整数6\n\n\n 列表的长度\n\n\nlena\n\n\n 列表的最大值\n\n\nmaxa\n\n\n 列表的最小值\n\n\nmina\n\n\n 某元素出现的次数\n\n\na.countx x为某一元素\n\n\n 列表排序\n\n\na.sortkey=None,reverse=False   对列表从小到大排序,reverse=True为降序\n\n\n 列表反转\n\n\na.reverse  反向列表中元素\n\n\n 清空列表\n\n\na.clear\n\n\n 复制列表\n\n\na.copy\n\n\n 取出第i位并删除\n\n\na.popi\n\n\n 在列表第i位插入x\n\n\na.inserti,x\n\n\n 将列表出现的第一个元素x删除\n\n\na.removex\n\n\n 将列表b添加到列表a中\n\n\na.extendb\n\n\n 八.元组\n\n 1.元组的创建\n\n\na = tuple\na = \n\n\n 2.元组的操作\n\n 访问\n\n\na0   代表元组a的下标为1的元素\n\n\n 增加：元组无法实现a\\1\\ = 5增加操作，元组的元素值是不能修改的\n\n 删除\n\n\ndel ax x代表元素下标的索引\n\n\n 修改：元组修改可以通过两个元组拼接来实现，元组的元素值是不能修改的\n\n 元组的个数\n\n\nlena\n\n\n 元组的最大值\n\n\nmaxa\n\n\n 元组的最小值\n\n\nmina\n\n\n注意：元组的元素值是不能修改的\n\n 九.集合\n\n 1.集合的创建\n\n\na = set\n\n\n 2.集合的操作\n\n 访问：集合无法访问单独元素\n 增加\n\n\na.addx 或者 a.updatex   x为增加的元素\n\n\n 删除\n\n\na.removex\na.discardx\na.pop     \nx代表移除的元素，第二种若元素不存在会出错，所以建议使用第一种方法,第三种为随机删除\n\n\n 修改：集合修改可以通过两个集合 &^+ 来实现\n 集合的个数\n\n\nlena\n\n\n 复制集合\n\n\na.copy\n\n\n 判断元素x是否在集合存在\n\n\nx in s   为存在返回True,否则False\n\n\n 清空集合\n\n\na.clear\n\n\n 十.字典\n\n 1.字典的组成：a = {'键':值}，由一个个键值对组成\n\n 2.字典的创建\n\n\na = dict\na = {}\n\n\n 3.字典的操作\n\n 读取\n\n\na'x'   x代表读取元素的键，返回其值\n\n\n 增加\n\n\na'x' = y   x代表增加的元素的键，y代表增加元素的值\n\n\n 删除\n\n\ndel a'x'   x代表删除元素的键\n\n\n 修改\n\n\na'x' = y   把x的值修改成y\n\n\n 字典的长度\n\n\nlena\n\n\n 清空字典\n\n\na.clear\n\n\n 复制字典\n\n\na.copy\n\n\n 随机返回字典某一键值对\n\n\na.item\n\n\n 返回某一元素对应的值\n\n\na.get'x'    x为改元素的键\n\n\n 返回所有元素对应的值\n\n\na.values\n\n\n 返回所有元素对应的键\n\n\na.keys\n\n\n 随机返回并删除该键值对\n\n\na.popitem\n\n\n注意：键值对的键是唯一的，不能出现两个相同的键，值是可变的\n\n 十一.函数\n\n 1.格式：\n\n\n    def 变量名参数一,参数二:\n        表达式一\n\n\n注意：在Python中可以有返回值，也可以不有返回值，还可以只有 return\n\n 2.函数的调用\n\n\ndef counta,b:    定义函数count，参数为a，b\n   return a+b    返回a+b的值\n\nm = count1,2   此处进行了函数的调用\nprintm\n\n3\n\n\n 十二.类\n\n 1.关键字：class\n\n 2.格式\n\n\nclass 变量名1:\n      def initself,参数一,参数二...:\n         self.变量名2 = 参数一    此处的变量名2为实列变量\n      def delself:    不常用，再出现结束前一部进行\n         表达式1\n      def strself:    必须返回字符串\n         return \"此处为一个字符串\"\n      def 变量名3self:    实列方法\n         表达式2\n\n\n 3.类调用\n\n\n  a = 变量名1参数一,参数二...\n\n\n完毕，后续有待补充，欢迎各位大佬指出错误，多谢！\n"},{"filename":"acwing-basic","category":"aigorithm","md":{"topSummary":"\ntitle: Acwing基础课\ncategory: 算法\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 基础算法\n\n### 快速排序\n\n#### AcWing 785. 快速排序\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> v;\n    int a;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    for(int i = 0; i < a; i++){\n        cout << v[i] << \" \";\n    }\n\n  return 0;\n}\n```\n\n#### 第k个数\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    vector<int> v;\n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    cout << v[b-1];\n\n  return 0;\n}\n```\n\n### 归并排序\n\n#### AcWing 787. 归并排序\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> v;\n    int a;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    for(int i = 0; i < a; i++){\n        cout << v[i] << \" \";\n    }\n\n  return 0;\n}\n```\n\n### 二分\n\n可以直接用STL中的lower\\_bound和upper\\_bound\n\n- lower\\_bound(n, n+a, target)\n- upper\\_bound(n, n+a, target)\n\n**举例**（转载：[博客链接](https://blog.csdn.net/qq_40160605/article/details/80150252)）\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100000+10;\nconst int INF=2*int(1e9)+10;\n#define LL long long\nint cmd(int a,int b){\n\treturn a>b;\n}\nint main(){\n\tint num[6]={1,2,4,7,15,34}; \n\tsort(num,num+6);                           //按从小到大排序 \n\tint pos1=lower_bound(num,num+6,7)-num;    //返回数组中第一个大于或等于被查数的值 \n\tint pos2=upper_bound(num,num+6,7)-num;    //返回数组中第一个大于被查数的值\n\tcout<<pos1<<\" \"<<num[pos1]<<endl;\n\tcout<<pos2<<\" \"<<num[pos2]<<endl;\n\tsort(num,num+6,cmd);                      //按从大到小排序\n\tint pos3=lower_bound(num,num+6,7,greater<int>())-num;  //返回数组中第一个小于或等于被查数的值 \n\tint pos4=upper_bound(num,num+6,7,greater<int>())-num;  //返回数组中第一个小于被查数的值 \n\tcout<<pos3<<\" \"<<num[pos3]<<endl;\n\tcout<<pos4<<\" \"<<num[pos4]<<endl;\n\treturn 0;\t\n} \n```\n\n#### AcWing 789. 数的范围\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint n[100010];\nint a, b;\n\n// 左边距\nint get_l(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n        int mid = (l + r ) / 2;\n        if(n[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\n int get_r(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n    \tint mid = (l + r + 1) / 2;\n        if(n[mid] <= x) l = mid;\n        else r = mid - 1;\n    }\n    return r;\n }\n\nint main(){\n    \n    cin >> a >> b;\n    for(int i = 0; i < a; i++) cin >> n[i];\n    for(int i = 0; i < b; i++){\n        int m;\n        cin >> m;\n        int l = get_l(m);\n        if(n[l] != m) cout << -1 << \" \" << -1 << endl;\n\t\telse {\n\t\t\tint r = get_r(m);\n\t\t\tif(n[r] != m) cout << -1 << \" \" << -1 << endl;\n\t\t\telse cout << l << \" \" << r << endl; \n\t\t} \n    }\n\t\n    return 0;\n}\n```\n\n#### AcWing 790. 数的三次方根  \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\ndouble getS(double x){\n    return x * x * x;\n}\n\ndouble fun(double x){\n    double l = -10000, r = 10000;\n    while(l < r){\n        double mid = (l + r) / 2;\n        double res = getS(mid);\n        if(fabs(res - x) < 0.0000000001){\n        \treturn mid;\n\t\t}\n        if(res <= x) l = mid;\n        else r = mid;\n    }\n}\n\nint main(){\n    double a;\n    cin >> a;\n\tprintf(\"%.6lf\", fun(a));\n    \n    return 0;\n}\n```\n\n### 高精度\n\n#### AcWing 791. 高精度加法\n\n```\na = int(input())\nb = int(input())\nprint(a + b)\n```\n\n#### AcWing 792. 高精度减法\n\n```\na = int(input())\nb = int(input())\nprint(a - b)\n```\n\n#### AcWing 793. 高精度乘法\n\n```\na = int(input())\nb = int(input())\nprint(a * b)\n```\n\n#### AcWing 794. 高精度除法\n\n```\na = int(input())\nb = int(input())\nprint(a // b)\nprint(a % b)\n```\n\n### 前缀和与差分\n\n#### AcWing 795. 前缀和\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\n\nint main(){\n    \n    int a, b;\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++){\n       cin >> n[i];\n       m[i] = n[i] + m[i - 1];\n    }\n    \n    while(b--){\n        int x, y;\n        cin >> x >> y;\n        cout << m[y] - m[x - 1] << endl;\n    }\n    \n    return 0;\n}\n```\n\n#### AcWing 796. 子矩阵的和 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[1001][1001], m[1001][1001];\n\nint main(){\n    \n    int a, b, c;\n    cin >> a >> b >> c;\n    for(int i = 1; i <= a; i++){\n        for(int j = 1; j <= b; j++){\n            cin >> n[i][j];\n            m[i][j] = n[i][j] + m[i-1][j] + m[i][j-1] - m[i-1][j-1];\n        }\n    }\n    while(c--){\n        int q, w, e, r;\n        cin >> q >> w >> e >> r;\n        cout << m[e][r] + m[q-1][w-1] - m[q-1][r] - m[e][w-1] << endl;\n    }\n    \n\n    return 0;\n}\n```\n\n#### AcWing 797. 差分 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\n\nint main(){\n   int a, b;\n   cin >> a >> b;\n   for(int i = 1; i <= a; i++){\n       cin >> n[i];\n       m[i] = n[i] - n[i-1];\n   }\n   while(b--){\n       int x, y ,z;\n       cin >> x >> y >> z;\n       m[x] += z;\n       m[y+1] -= z;\n   }\n   for(int i = 1; i <= a; i++){\n       n[i] = m[i] + n[i-1];\n       cout << n[i] << \" \";\n   }\n   \n   return 0;\n}\n```\n\n#### AcWing 798. 差分矩阵\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[1010][1010], m[1010][1010];\n\nint main(){\n  \n   int a, b, c;\n   cin >> a >> b >> c;\n   for(int i = 1; i <= a; i++){\n       for(int j = 1; j <= b; j++){\n           cin >> n[i][j];\n           m[i][j] = n[i][j] - n[i-1][j] - n[i][j-1] + n[i-1][j-1];\n       }\n   }\n   while(c--){\n       int q, w, e, r, t;\n       cin >> q >> w >> e >> r >> t;\n       m[q][w] += t;\n       m[e+1][r+1] += t;\n       m[e+1][w] -= t;\n       m[q][r+1] -= t;\n   }\n  for(int i = 1; i <= a; i++){\n      for(int j = 1; j <= b; j++){\n          n[i][j] = n[i-1][j] + n[i][j-1] - n[i-1][j-1] + m[i][j];\n          cout << n[i][j] << \" \";\n      }\n      cout << endl;\n  }\n   \n   return 0;\n}\n```\n\n### 双指针算法\n\n#### AcWing 799. 最长连续不重复子序列 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N];\n\nint main(){\n    \n    int a, l, r, res = 0;\n    map<int, int> is;\n    cin >> a;\n    for(int i = 0, j = 0; i < a; i++){\n        cin >> n[i];\n        is[n[i]] ++;\n        while(is[n[i]] > 1){\n            is[n[j]] --;\n            j ++;\n        }\n        res = max(res, i - j + 1);\n    }\n    cout << res << endl;\n  \n    return 0;\n}\n```\n\n#### AcWing 800. 数组元素的目标和\n\n哈希方法\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\nunordered_map<int, int> ump;\n\nint main(){\n    \n    int a, b, c, r1 = 0, r2 = 0;\n    cin >> a >> b >> c;\n    for(int i = 0; i < a; i++) {\n        cin >> n[i];\n        ump[n[i]] = i;\n    }\n    for(int j = 0; j < b; j++) {\n        cin >> m[j];\n        if(ump.count(c - m[j])){\n            r1 = ump[c - m[j]], r2 = j;\n        }\n    }\n\n    cout << r1 << \" \" << r2 << endl;\n  \n    return 0;\n}\n```\n\n#### AcWing 2816. 判断子序列\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\nunordered_map<int, int> ump;\n\nint main(){\n    \n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++) cin >> n[i];\n    for(int j = 0; j < b; j++) cin >> m[j];\n   \n    int x = 0, y = 0;\n    while(x < a && y < b){\n        if(n[x] == m[y]) x ++;\n        y ++;\n    }\n    \n    if(x == a) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  \n    return 0;\n}\n```\n\n### 位运算\n\n#### AcWing 801. 二进制中1的个数\n\n> 小知识：n的二进制表示中第k位是几？  \n> 答案：n >> k & 1  \n> n右移k位&1后得出二进制数的最后一位\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// 返回x的最后一位1\n// 比如10010的最后一位就是10\nint lowbit(int x){\n    return x & -x;    \n}\n\nint main(){\n        \n    int a, b, res;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        cin >> b;\n        res = 0;\n        while(b){\n            b -= lowbit(b);\n            res ++;\n        }\n        cout << res << \" \";\n    }\n        \n    return 0;\n}\n```\n\n### 离散化\n\n#### AcWing 802. 区间和  \n\n> 小知识  \n> 离散化：将100，2000，30000，4000000映射为1，2，3，4的过程\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n// 此处不是1e5+10\n// 极端情况下第一排输入会有1e5的数据，第二排会有2e5的数据\nconst int N = 3e5 + 10 ;\n\nint s[N], f[N];\n\nvector<int> v;\nvector<pair<int, int> > q, w;\n// 二分查找元素下标\nint find(int x){\n    int l = 0, r = v.size() - 1;\n    while(l < r){\n        int mid = l + r >> 1;\n        if(v[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l + 1;\n}\n\nint main(){\n    \n    int a, b, m, n;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++){\n        cin >> m >> n;\n        q.push_back({m, n});\n        v.push_back(m);\n    }\n    for(int j = 0; j < b; j++){\n        cin >> m >> n;\n        w.push_back({m, n});\n        v.push_back(m);\n        v.push_back(n);\n    }\n    sort(v.begin(), v.end());\n    // 去重\n    v.erase(unique(v.begin(), v.end()), v.end());\n    // 离散化处理\n    for(auto i: q){\n        int x = find(i.first);\n        s[x] += i.second;\n    }\n    // 预处理前缀和\n    for(int i = 1; i <= v.size(); i++){\n        f[i] = f[i-1] + s[i];\n    }\n    // 查询结果\n    for(auto i: w){\n        int l = find(i.first), r = find(i.second);\n        cout << f[r] - f[l-1] << endl;\n    }\n    \n    return 0;\n}\n```\n\n![图片描述](http://www.lijunxi.site:4000/api/file/download/6261dfbb-afd5-42b9-bcdf-46091f5b8e0f.jpg)\n\n数据范围分析\n\n### 区间合并\n\n#### AcWing 803. 区间合并\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ; \n\nstruct point{\n    int x, y;\n} n[N];\n\nbool cmp(point a, point b){\n    if(a.x == b.x) return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main(){\n    \n    int a, idx = 0;\n    cin >> a;\n    for(int i = 0; i < a; i++) cin >> n[i].x >> n[i].y;\n    sort(n, n+a, cmp);\n    int langm = n[0].y;\n    for(int i = 1; i < a; i++){\n        langm = max(langm, n[i-1].y);\n        if(langm < n[i].x) idx++;\n    }\n    cout << idx + 1 << endl;\n  \n    return 0;\n}\n```\n\n## 数据结构\n\n### 单链表\n\n#### AcWing 826. 单链表\n\n数组模拟单链表\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\n// 头指针（用下表指针辅助），下标指针\nint hidx = -1, idx = 0;\n// 元素值，元素下表\nint n[N], ne[N];\n\nvoid insert(int k, int x){\n    // 新节点值赋值\n    n[idx] = x;\n    // 将新结点下一个结点赋值为插入位置的下一个结点\n    ne[idx] = ne[k];\n    // 将插入位置的一下个节点指向新节点\n    ne[k] = idx;\n    idx++;\n}\n\nvoid addHead(int x){\n    // 头节点赋值\n    n[idx] = x;\n    // 指向头指针\n    ne[idx] = hidx;\n    // 更改头指针为当前下表\n    hidx = idx;\n    idx++;\n}\n\nvoid del(int idx){\n    ne[idx] = ne[ne[idx]];   \n}\n\nint main(){\n    \n    int x, k, num; \n    char s;\n    cin >> x;\n    while(x--){\n        cin >> s;\n        if(s == 'H'){\n            cin >> num;\n            addHead(num);\n        }\n        else if(s == 'D'){\n            cin >> k;\n            //判断是否删除的为头节点\n            if(!k) hidx = ne[hidx];  \n            del(k-1);\n        }\n        else{\n            cin >> k >> num;\n            insert(k-1, num);\n        }\n    }\n    while(hidx != -1){\n        cout << n[hidx] << \" \";\n        hidx = ne[hidx];\n    }\n    \n    return 0;\n}\n```\n\n### 双链表\n\n### 栈\n\n#### AcAcWing 3302. 表达式求值\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nstack<int> s;\nstack<char> f;\nunordered_map<char, int> ump;\n\nvoid init_map(){\n\tump['*'] = 2;\n\tump['/'] = 2;\n\tump['+'] = 1;\n\tump['-'] = 1;\n}\n\nvoid eval(){\n\tint num = 0;\n\tint x = s.top(); s.pop();\n\tint y = s.top(); s.pop();\n\tchar op = f.top(); f.pop();\n\tif(op == '+') num = x + y;\n\telse if(op == '-') num = y - x;\n\telse if(op == '*') num = x * y;\n\telse num = y / x;\n\ts.push(num);\n}\n\nint main(){\n    init_map();\n    string str;\n    int num, idx = 0;\n    char c;\n    cin >> str;\n    int len = str.size();\n    for(int i = 0; i < len; i++){\n        if(str[i] >= '0' && str[i] <= '9'){\n            idx = i;\n            num = 0;\n            while(str[idx] >= '0' && str[idx] <= '9' && idx < len){\n                num = num * 10 + str[idx] - '0';\n                idx++; \n            }\n            s.push(num);\n            i = idx - 1;\n        }\n        else if(str[i] == '(') f.push(str[i]);\n        else if(str[i] == ')'){\n       \t\twhile(f.size() && s.size() >= 2 && ump[str[i]] <= ump[f.top()] && f.top() != '(') eval();\n       \t\tf.pop();\n        }\n        else{\n        \twhile(f.size() && s.size() >= 2 && ump[str[i]] <= ump[f.top()]) eval();\n            f.push(str[i]);\n        }\n    }\n    while(f.size()) eval();\n\tcout << s.top() << endl; \n    \n    return 0;\n}\n```\n\n### 队列\n\n#### AcWing 829. 模拟队列\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nqueue<int> q;\n\nint main(){\n    int a, num;\n    string s;\n    cin >> a;\n    while(a--){\n        cin >> s;\n        if(s == \"push\"){\n            cin >> num;\n            q.push(num);\n        }\n        else if(s == \"pop\"){\n            q.pop();\n        }\n        else if(s == \"empty\"){\n            if(q.empty()) cout <<\"YES\"<<endl;\n            else cout <<\"NO\" << endl;\n        }\n        else{\n            cout << q.front() << endl;\n        }\n    }\n   \n    return 0;\n}\n```\n\n### 单调栈\n\n#### AcWing 830. 单调栈\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nstack<int> s;\n\nint main(){\n    \n    int a, num;\n    cin >> a;\n    for(int i = 0; i < a; i++) {\n        cin >> num;\n        while(s.size() && s.top() >= num) s.pop();\n        if(!s.size()) cout << -1 << \" \";\n        else cout << s.top() << \" \";\n        s.push(num);\n    }\n    \n    return 0;\n}\n```\n\n### 单调队列\n\n#### AcWing 154. 滑动窗口\n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10 ;\n\n// deque没法直接获取下表的元素值，所以需要用一个数组来维护 \nint n[N];\ndeque<int> dq; \n\nint main(){\n  \n    int a, b, num;\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++) cin >> n[i];\n    for(int i = 1; i <= a; i++){\n    \t// 当尾元素比n[i]大时，需要弹出 \n    \twhile(dq.size() && n[dq.back()] > n[i]) dq.pop_back();\n    \tdq.push_back(i);\n    \t// 当队列的个数满足b时们需要弹出首元素\n\t\t// 这里不能用dq.size()来判断是否满足个数，因为可能出现首元素到i之间有些元素已经弹出了但size总数任然小于b情况 \n    \tif(dq.size() && i - dq.front() >= b) dq.pop_front();\n    \t// 当i大于b时候就能开始输出了，这里也不能用dq.size()来判断，因为存在整个过程都小于b的情况，这样就没有输出了 \n\t\tif(i >= b) cout << n[dq.front()] << \" \";\n\t}\n\tdq.clear();\n\tputs(\"\");\n      for(int i = 1; i <= a; i++){\n    \twhile(dq.size() && n[dq.back()] < n[i]) dq.pop_back();\n    \tdq.push_back(i);\n    \tif(dq.size() && i - dq.front() >= b) dq.pop_front();\n\t\tif(i >= b) cout << n[dq.front()] << \" \";\n\t}\n    \n    return 0;\n}\n```\n\n### KMP\n\n### Tire\n\n#### AcWing 835. Trie字符串统计\n\n> Trie树（字典树）：高效存储和查找字符串集合的数据结合\n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// son[][]存储子节点的位置，分支最多26条\n// cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）\n// idx表示当前要插入的节点是第几个,每创建一个节点值+1\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(string str){\n\t// 类似指针，指向当前节点\n\tint p = 0;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tint s = str[i] - 'a';\n\t\t// 该字符不存在就创建一个 \n\t\tif(!son[p][s]) son[p][s] = ++idx;\n\t\t// \tp指向下一个节点\n\t\tp = son[p][s];\n\t}\n\t// 统计字符串个数 \n\tcnt[p] ++;\n} \n\nint query(string str){\n\tint p = 0;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tint s = str[i] - 'a';\n\t\tif(!son[p][s]) return 0;\n\t\tp = son[p][s]; \n\t}\n\treturn cnt[p];\n}\n\n\nint main(){\n \n\tint a;\n\tchar c;\n\tstring str;\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> c;\n\t\tcin >> str;\n\t\tif(c == 'I') insert(str);\n\t\telse cout << query(str) << endl;\n\t}\n    \n    return 0;\n}\n```\n\n#### AcWing 143. 最大异或对  \n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n// 最多有1e5个数，每个数的二进制数有31位，极限情况下就1e5 * 31\nconst int N = 31e5 + 10 ;\n\nint son[N][2], n[N], idx = 0;\n\n// 将数字插入trie树中 \nvoid insert(int x){\n\tint p = 0;\n\t// 数的范围为小于2e31次方 \n\tfor(int i = 30; i >= 0; i --){\n\t\tint s = x >> i & 1;\n\t\tif(!son[p][s]) son[p][s] = ++idx;\n\t\tp = son[p][s];\n\t}\n}\n\nint query(int x){\n\tint p = 0, res = 0;\n\tfor(int i = 30; i >= 0; i--){\n\t\t// x二进制第i位上的数 \n\t\tint s = x >> i & 1;\n\t\t// 若存在相反的数 \n\t\tif(son[p][!s]){\n\t\t\tp = son[p][!s];\n\t\t\t// 1左移i位就是2^(30-i)次方 \n\t\t\tres += 1 << i;\n\t\t}\n\t\telse{\n\t\t\tp = son[p][s];\n\t\t\tres += 0 << i;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint a, res = 0;\n\tcin >> a;\n\tfor(int i = 0; i < a; i++) {\n\t\tcin >> n[i];\n\t\tinsert(n[i]);\n\t}\n\tfor(int i = 0; i < a; i++) res = max(res, query(n[i]));\n\tcout << res << endl;\n\t\n    return 0;\n}\n```\n\n### 并查集\n\n#### AcWing 836. 合并集合\n\n```\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\nint n[N];\n\n// 找到祖宗结点\nint find(int x){\n    // 修改结点，避免重复查找\n   if(n[x] != x) n[x] = find(n[x]);\n   return n[x];\n}\n\nint main(){\n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++) n[i] = i;\n    for(int i = 0; i < b; i++){\n        char x;\n        int o, p;\n        cin >> x >> o >> p;\n        if(x == 'M'){\n            n[find(o)] = find(p);\n        }\n        else{\n            if(find(o) == find(p)) cout << \"Yes\" << endl;\n            else cout << \"No\" << endl;\n        }\n    }\n     \n    return 0;\n}\n```\n\n### 堆\n\n> 堆：优先队列\n\n#### AcWing 838. 堆排序\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint n[N];\n// 从小到大排序，从大到小就为less<int>，与sort相反\npriority_queue<int, vector<int>, greater<int>> pq;\nint main(){\n    \n    int a, b, num;\n    cin>> a >> b;\n    for(int i = 0; i < a; i++){\n        cin >> num;\n        pq.push(num);\n    }\n    int idx = 0;\n    while(idx != b){\n        idx ++;\n        cout << pq.top() << \" \";\n        pq.pop();\n    }\n    \n    return 0;\n}\n```\n\n### 哈希表\n\n## 搜索与图论\n\n### DFS\n\n#### AcWing 842. 排列数字 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nint is[N];\nvector<int> v;\n\nvoid dfs(int x){\n    if(x == 0) return; \n    if(v.size() == a){\n    \tfor(int i = 0; i < a; i++) cout << v[i] << \" \";\n    \tcout << endl;\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tif(!is[i]){\n\t\t\tis[i] = 1;\n\t\t\tv.push_back(i);\n\t\t\tdfs(i);\n\t\t\tv.pop_back();\n\t\t\tis[i] = 0;\n\t\t}\n\t}\n}\n\nint main(){\n    cin >> a;\n    dfs(a);\n    return 0;\n}\n```\n\n#### AcWing 843. n-皇后问题\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nchar n[11][11];\nint l[11], xie[11], fx[11];\n\nvoid print(){\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= a; j++){\n\t\t\tcout << n[i][j];\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n} \n\nvoid dfs(int x){\n\tif(x == a + 1){\n\t\tprint();\n\t\treturn;\n\t}\n    for(int i = 1; i <= a; i++){\n    \t// \ti - x + a是为了避免出现下标是负数的情况 \n    \tif(!l[i] && !xie[i - x + a] && !fx[i + x]){\n    \t\tn[x][i] = 'Q';\n    \t\txie[i - x + a] = 1;\n    \t\tfx[i + x] = 1;\n    \t\tl[i] = 1;\n    \t\tdfs(x + 1);\n    \t\tn[x][i] = '.';\n    \t\txie[i - x + a] = 0;\n    \t\tfx[i + x] = 0;\n    \t\tl[i] = 0;\n\t\t}\n\t\n\t}\n\n}\n\nint main(){\n  \t\n\tcin >> a;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= a; j++){\n\t\t\tn[i][j] = '.';\n\t\t}\n\t}\n    dfs(1);\n    \n    return 0;\n}\n```\n\n### BFS\n\n#### AcWing 844. 走迷宫 \n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint a, b;\nint n[1010][1010], is[1001][1001];\nint ix[4] = {1, -1, 0 ,0}, iy[4] = {0, 0, 1, -1};\n\nvoid bfs(int x, int y){\n    queue<pair<int, int>> q;\n    map<pair<int, int>, int> mp;\n    q.push({0, 0});\n    mp[{0, 0}] = 0;\n    while(!q.empty()){\n    \tauto top = q.front();\n    \tq.pop();\n    \tint xx = top.first, yy = top.second;\n    \tif(xx == a - 1 && yy == b - 1){\n    \t\tcout << mp[{xx, yy}] << endl;\n    \t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint x = xx + ix[i], y = yy + iy[i];\n\t\t\tif(!n[x][y] && !is[x][y] && x >= 0 && x < a && y >= 0 && y < b){\n\t\t\t\tis[x][y] = 1;\n\t\t\t\tq.push({x, y});\n\t\t\t\tmp[{x, y}] = mp[{xx, yy}] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n  \t\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++){\n\t    for(int j = 0; j < b; j++){\n\t        cin >> n[i][j];\n\t    }\n\t}\n\tbfs(0, 0);\n    \n    return 0;\n}\n```\n\n### 树与图的深度优先遍历\n\n#### AcWing 846. 树的重心\n\n图的存储采用数组模拟邻接表\n\n思路：邻接表dfs\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint h[N];\n// 存储元素 \nint e[N];\n// 下个节点值\nint ne[N];\n// 结点是否访问过\nint st[N]; \n// 单链表指针 \nint idx = 0; \nint a, ans = N; \n\nvoid add(int x, int y){\n\te[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nint dfs(int x){\n\tint res = 0, sum = 1;\n\tst[x] = 1;\t\n\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\tint j = e[i];\n\t\tif(!st[j]){\n\t\t\tint s = dfs(j);\n\t\t\t// 子图最大结点数 \n\t\t\tres = max(res, s);\n\t\t\t// j为根的节点总数 \n\t\t\tsum += s;\t\t\n\t\t}\n\t}\n\t// a - sum：另一部分的节点总数 \n\tres = max(res, a - sum);\n\t// 选取最小的最大结点数 \n\tans = min(ans, res);\n\treturn sum;\n}\n\n\nint main(){\n  \t//初始化h数组 -1表示尾节\n\tmemset(h, -1, sizeof h); \n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n    cin >> a;\n    // 创建邻接表 \n    for(int i = 0; i < a - 1; i++){\n    \tint m, n;\n    \tcin >> m >> n;\n    \tadd(m, n);\n    \tadd(n, m);\n\t}\n    dfs(1);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n### 树与图的广度优先遍历\n\n#### AcWing 847. 图中点的层次\n\n思路：邻接表bfs\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint h[N];\n// 存储元素 \nint e[N];\n// 下个节点值\nint ne[N];\n// 结点是否访问过\nint st[N]; \n// 单链表指针 \nint idx = 0; \nint a, b, ans = N; \n\nvoid add(int x, int y){\n\te[idx] = y, ne[idx] = h[x], h[x] = idx, idx ++;\n}\n\nvoid dfs(int x){\n    queue<pair<int, int>> q;\n    map<pair<int, int>, int> ump;\n    q.push({1, 1});\n    ump[{1, 1}] = 0;\n    while(!q.empty()){\n        auto top = q.front();\n        q.pop();\n        int xx = top.first, yy = top.second;\n        if(yy == a){\n        \tcout << ump[{xx, yy}] << endl;\n        \treturn;\n\t\t}\n\t\tfor(int i = h[yy]; i != -1; i = ne[i]){\n\t\t\tif(ump.find({yy, e[i]}) == ump.end()){\n\t\t\t\tq.push({yy, e[i]});\n\t\t\t\tump[{yy, e[i]}] = ump[{xx, yy}] + 1;\n\t\t\t}\n\t\t}\n    }   \n\tcout << -1 << endl; \n \n}\n\nint main(){\n  \t//初始化h数组 -1表示尾节\n\tmemset(h, -1, sizeof h); \n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n    cin >> a >> b;\n    // 创建邻接表 \n    for(int i = 0; i < b; i++){\n    \tint m, n;\n    \tcin >> m >> n;\n    \tadd(m, n);\n\t}\n    dfs(1);\n\n    return 0;\n}\n```\n\n### 拓扑排序\n\n#### AcWing 848. 有向图的拓扑序列\n\n思路：邻接表找入度为0的结点\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint h[N], e[N], ne[N], idx, a, b;\nqueue<int> q;\n// 保存各个点的入度\nint d[N]; \n// v存放答案\nvector<int> v;\n\nvoid add(int x, int y){\n    e[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nbool topsort(){\n    // 找出入读为0的点\n    for(int i = 1; i <= a; i++){\n    \tif(!d[i]) q.push(i); \n\t}\t\n\twhile(q.size()){\n\t\tint top = q.front();\n\t\tq.pop();\n\t\tv.push_back(top);\n\t\t// 每次循环减去一条边\n\t\tfor(int i = h[top]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\td[j] --;\n\t\t\t// 当减去后的入读为0则入队列\n\t\t\tif(!d[j]) q.push(j);\n\t\t}\n\t}\n\treturn v.size() == a;\n}\n\nint main(){\n  \t\n  \tmemset(h, -1, sizeof h);\n  \tcin >> a >> b;\n  \twhile(b--){\n  \t    int x, y;\n  \t    cin >> x >> y;\n  \t    add(x, y);\n  \t    d[y] ++;\n  \t}\n  \tif(topsort()){\n  \t\tfor(int i = 0; i < v.size(); i++) cout << v[i] << \" \";\n\t}\n\telse puts(\"-1\");\n  \t\n    return 0;\n}\n```\n\n### Dijkstra\n\n稠密图：临界矩阵（点较少）  \n稀疏图：邻接表（点较多）\n\n#### AcWing 849. Dijkstra求最短路 I\n\n**朴素版（暴力）**\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint m, n;\n// 为稠密阵所以用邻接矩阵存储\nint num[501][501];\n// 用于记录每一个点距离第一个点的距离\nint dis[N];\n// 用于记录该点的最短距离是否已经确定\nint st[N];\n\nint dijkstra(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tdis[1] = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tint t = -1;\n\t\t// 找到没有确定最短路径的节点中距离源点最近的点t \n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tif(!st[j] && (t == -1 || dis[t] > dis[j])){\n\t\t\t\tt = j;\n\t\t\t}\n\t\t}\n\t\tst[t] = 1;\n\t\t// 更新到其他点的距离 \n\t\tfor(int k = 1; k <= m; k++){\n\t\t\tdis[k] = min(dis[k], dis[t] + num[t][k]);\n\t\t}\n\t}\n\tif(dis[m]==0x3f3f3f3f) return -1;\n    return dis[m];\n}\n\nint main(){\n\tmemset(num, 0x3f3f3f3f, sizeof num);\n\tcin >> m >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tnum[x][y] = min(num[x][y], z);\n\t}\n  \tcout << dijkstra() << endl;\n    return 0;\n}\n```\n\n#### AcWing 850. Dijkstra求最短路 II \n\n**临界表法**\n\n```\n#include<bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\ntypedef pair<int, int> PII;\n\nint e[N], ne[N], idx, h[N], dis[N], st[N];\nint w[N]; // 存放权重 \nint a, b;\n\nvoid add(int x, int y, int z){\n\tw[idx] = z, e[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nint dj(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tpriority_queue<PII, vector<PII>, greater<PII>> heap;\n\t// 插入距离和结点编号 \n\theap.push({0, 1});\n\twhile(!heap.empty()){\n\t\tauto top = heap.top();\n\t\theap.pop();\n\t\tint x = top.second, y = top.first;\n\t\tif(st[x]) continue;\n\t\tst[x] = 1;\n\t\t// 遍历该节点的每个临界结点，给每个选出最短距离 \n\t\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\tif(dis[j] > dis[x] + w[i]){\n\t\t\t\tdis[j] = dis[x] + w[i];\n\t\t\t\theap.push({dis[j], j});\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[a] == 0x3f3f3f3f) return -1;\n\treturn dis[a];\n}\n\nint main(){\n\tmemset(h, -1, sizeof h);\n\tcin >> a >> b;\n\twhile(b--){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t}\n\tcout << dj() << endl;\n\n    return 0;\n}\n```\n\n### Floyd\n\n与迪杰斯特拉的区别：\n\n- 迪杰斯特拉算法适用于非负权，用于查找1到n 的最短距离，数据范围大\n- 弗洛伊德算法适用于含有负权，用于查找每个点之间的最短距离，数据范围较少\n\n#### AcWing 854. Floyd求最短路\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int> PII;\n\nint n, m, k;\nint e[201][201];\n\nvoid floyd(){\n\t//  f[i, j, k]表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]。\n    // 因此在计算第k层的f[i, j]的时候必须先将第k - 1层的所有状态计算出来，所以需要把k放在最外层。 \n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\te[i][j] = min(e[i][j], e[i][k] + e[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> n >> m >> k; \n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i == j) e[i][j] = 0;\n\t\t\telse e[i][j] = INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\te[x][y] = min(e[x][y], z);\n\t}\n\tfloyd();\n\twhile(k--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t// 不能e[x][y] == INF，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可 \n\t\tif(e[x][y] > INF / 2) cout << \"impossible\"<<endl;\n\t\telse cout << e[x][y] <<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 数学知识\n\n### 质数\n\n#### AcWing 867. 分解质因数\n\n主要需要开方来避免超时\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main(){\n\t\n\tint n, m;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> m;\n\t\tint mm = m, flag = 0;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\tint idx = 0;\n\t\t\twhile(mm % i == 0){\n\t\t\t\tidx ++;\n\t\t\t\tmm /= i;\n\t\t\t}\n\t\t\tif(idx != 0){\n\t\t\t    flag = 1;\n\t\t\t    cout << i << \" \" << idx << endl;\n\t\t\t} \n\t\t}\n\t\tif(flag){\n\t        if(mm != 1) cout << mm << \" \" << 1 << endl;\n\t        cout << endl;\n\t\t}\n\t\telse {\n\t\t    cout << m << \" \" << 1 << endl;\n\t\t    cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n#### AcWing 868. 筛质数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nint n[N], st[N], idx;\n\nvoid init(){\n\tfor(int i = 2; i <= N; i++){\n\t\tif(!st[i]) n[idx++] = i;\n\t\tfor(int j = 0; n[j] <= N / i; j++){\n\t\t\tst[n[j] * i] = 1;\n\t\t\tif(i % n[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nint main(){\n\tinit();\n\tint a, res = 0;\n\tcin >> a;\n\tfor(int i = 2; i <= a; i++){\n\t\tif(!st[i]){\n\t\t\tres ++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 约数\n\n![图片描述](http://www.lijunxi.site:4000/api/file/download/bd17a18c-0c3c-475c-87f2-30830d333ee3.png)\n\n#### AcWing 870. 约数个数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\tset<int> s;\n\tmap<int, int> mp;\n\tll a, b, res = 1;\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> b;\n\t\tint xx = b;\n\t\tfor(int i = 2; i <= b / i; i++){\n\t\t\twhile(xx % i == 0){\n\t\t\t\txx /= i; \n\t\t\t\tmp[i] ++;\n\t\t\t}\n\t\t}\n                // x的最大公约数可能大于sqrt(x);\n\t\tif(xx > 1) mp[xx] ++;\n\t}\n\tfor(auto i: mp){\n\t\tres = (res * (i.second + 1)) % M; \n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n```\n\n#### AcWing 871. 约数之和\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\tmap<ll, ll> mp;\n\tint a;\n\tll res = 1;\n\tcin >> a;\n\twhile(a--){\n\t\tint m;\n\t\tcin >> m;\n\t\tint c = m;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\tll cot = 0;\n\t\t\twhile(c % i == 0){\n\t\t\t\tc /= i;\n\t\t\t\tmp[i] ++;\n\t\t\t}\n\t\t}\n\t\tif(c > 1) mp[c] ++;\t\n\t}\n\tfor(auto i: mp){\n\t\tll x = i.first, y = i.second, cot1 = 1, cot2 = 1;\n\t\twhile(y--){ \n\t\t\tcot2 = cot2 * x % M;\n\t\t\tcot1 = (cot1 + cot2) % M;\n\t\t}\n\t\tres = (res * cot1) % M;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n#### AcWing 872. 最大公约数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n// 最大公约数\nll fun1(int x, int y){\n\treturn y ? fun1(y, x % y) : x;\n}\n// 最小公倍数\nll fun2(int x, int y){\n\treturn x * fun1(x, y) / y;\n}\n\nint main(){\n\t\n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tcout << fun1(m, n) << endl;\n\t}\n\n\n\treturn 0;\n}\n```\n\n### 欧拉函数\n\n> 1∼N 中与 N 互质的数的个数被称为欧拉函数，称为O(n)  \n> 若N = p1^a\\*p2^b\\*p3^c\\*.....  \n> 则O(N) = N \\* (p1-1)/p1 \\* (p2-1)/p2 \\* (p3-1)/p3 \\*.....\n\n#### AcWing 873. 欧拉函数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\t\n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m;\n\t\tcin >> m;\n\t\tll res = m; \n\t\tmap<int, ll> mp;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\twhile(m % i == 0){\n\t\t\t\tm /= i;\n\t\t\t\tmp[i] ++;\n\t\t\t} \n\t\t}\n\t\tif(m > 1) mp[m] ++;\n\t\tfor(auto i: mp){\n\t\t\tint x = i.first;\n\t\t\tres = res * (x - 1) / x;\n\t\t} \n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n### 组合数\n\n#### AcWing 885. 求组合数 I\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10, M = 1e9 + 7;\n\nint e[2010][2010];\n\nvoid init(){\n    // 类似于DP\n    // e[i][j]就代表的是Cij\n\tfor(int i = 0; i < 2010; i++){\n\t\tfor(int j = 0; j <= i; j++){\n\t\t    // Ci0为1\n\t\t\tif(!j) e[i][j] = 1;\n\t\t\telse e[i][j] = (e[i-1][j-1] + e[i-1][j]) % M;\n\t\t}\n\t}\n} \n\nint main(){\n\t\n\tinit(); \n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tcout << e[m][n] << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n### 容斥原理\n\n#### AcWing 890. 能被整除的数\n\n若给出的待求的数组都是互质\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint v[20];\nint main(){\n\n    int a, b, res = 0;\n    cin >> a >> b;\n    for(int i = 0; i < b; i ++){\n        cin >> v[i];\n    }\n    for(int i = 1; i < 1 << b; i ++){\n        int cot = 0, t = 1;\n        for(int j = 0; j < b; j ++){\n            if(i >> j & 1){\n                cot ++;\n                if((ll) t * v[j] > a){\n                    t = -1;\n                    break;\n                }\n                t *= v[j];\n            }\n        }\n        if(t != -1){\n            if(cot % 2 == 0){\n                res -= a / t;\n            } else {\n                res += a / t;\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n```\n\n否则，修改乘积为求最小公倍数\n\n参考Leetcode：[单面值组合的第 K 小金额](https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/)\n\n```c++\nclass Solution {\npublic:\n    int len;\n    long long fun(long long x, vector<int>& v){\n        long long res = 0;\n        for(int i = 1; i < 1 << len; i++){\n            long long cot = 0, t = 1;\n            for(int j = 0; j < len; j++){\n                if(i >> j & 1){\n                    long long ccc = t / gcd(t, v[j]) * v[j]; //《-------------修改这里\n                    if(ccc > x){\n                        t = -1;\n                        break;\n                    }\n                    cot ++;\n                    t = ccc;\n                }\n            }\n            if(t != -1){\n                if(cot % 2 == 1) res += x / t;\n                else res -= x / t;\n            }\n        }\n        return res;\n    }\n    long long findKthSmallest(vector<int>& coins, int k) {\n        len = coins.size();\n        long long l = 1, r = 1e12;\n        while(l < r){\n            long long mid = (l + r) >> 1;\n            if(fun(mid, coins) >= k) r = mid;\n            else l = mid + 1;\n        }\n\n        return l;\n\n    }\n};\n```\n\n\n\n## 动态规划\n\n### 记忆化搜索\n\n#### AcWing 901. 滑雪\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint a, b;\nint n[310][310], cot[310][310];\nint ix[4] = {-1,0,1,0};\nint iy[4] = {0,1,0,-1};\n\nint dfs(int x, int y){\n\tif(cot[x][y] != -1) return cot[x][y];\n\tcot[x][y] = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = ix[i] + x, yy = iy[i] + y;\n\t\tif(xx >= 1 && xx <= a && yy >= 1 && yy <= b && n[x][y] > n[xx][yy]){\n\t\t\tcot[x][y] = max(cot[x][y], dfs(xx, yy) + 1);\n\t\t}\n\t}\n\treturn cot[x][y];\n}\n\n\nint main(){\n    memset(cot, -1, sizeof cot);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tans = max(ans, dfs(i, j));\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n```\n\n### 线性DP\n\n#### AcWing 898. 数字三角形\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 510, M = 1e5 + 10;\t\nint n[N][N]; \nint cot[N][N];\nint a;\n\nint dfs(int x, int y){\n\tif(x < 1 || x > a || y < 1 || y > a) return 0;\n\tif(cot[x][y] != -1) return cot[x][y];\n\tint _1 = dfs(x + 1, y), _2 = dfs(x + 1, y + 1);\n\tcot[x][y] = max(_1, _2) + n[x][y]; \n\treturn cot[x][y]; \n}\n\nint main(){\n\tmemset(cot, -1, sizeof cot);\n\tcin >> a;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= i; j++){\n\t\t\tcin >> n[i][j];\t\n\t\t}\n\t}\n\tcout << dfs(1, 1) << endl;\n\t\n\treturn 0;\n}\n```\n\n#### AcWing 896. 最长上升子序列\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\nint n[N];\nint a;\nvector<int> v; \n\nint main(){\n\n\tint a;\n\tcin >> a;\n\tfor(int i = 0; i < a; i++) cin >> n[i];\n\tfor(int i = 0; i < a; i++){\n\t\tif(v.empty() || n[i] > v.back()){\n\t\t\tv.push_back(n[i]);\n\t\t}\n\t\telse{\n\t\t\t*lower_bound(v.begin(), v.end(), n[i]) = n[i];\n\t\t}\n\t}\n\tcout << v.size() << endl;\n\t\n\treturn 0;\n}\n```\n\n#### AcWing 897. 最长公共子序列\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\n\nchar n1[N], n2[N];\n// n[i][j]记录前i个n1和前j个n2的公共子串的最大长度\nint n[1010][1010];\n \nint main(){\n\t\n\tint a, b;\n\tcin >> a >> b >> n1 + 1 >> n2 + 1;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tif(n1[i] == n2[j]){\n\t\t\t\tn[i][j] = n[i-1][j-1] + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tn[i][j] = max(n[i-1][j], n[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcout << n[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << n[a][b] << endl;\n\t\n\treturn 0;\n}\n```","title":" Acwing基础课\n","category":[" 算法\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 基础算法\n\n 快速排序\n\n AcWing 785. 快速排序\n\n\ninclude <bits/stdc++.h\nusing namespace std;\n\nint main\n{\n\tvector<int v;\n    int a;\n    cin  a;\n    forint i = 0; i < a; i++{\n        int m;\n        cin  m;\n        v.pushbackm;\n    }\n    sortv.begin, v.end;\n    forint i = 0; i < a; i++{\n        cout << vi << \" \";\n    }\n\n  return 0;\n}\n\n\n 第k个数\n\n\ninclude <bits/stdc++.h\nusing namespace std;\n\nint main\n{\n    vector<int v;\n    int a, b;\n    cin  a  b;\n    forint i = 0; i < a; i++{\n        int m;\n        cin  m;\n        v.pushbackm;\n    }\n    sortv.begin, v.end;\n    cout << vb1;\n\n  return 0;\n}\n\n\n 归并排序\n\n AcWing 787. 归并排序\n\n\ninclude <bits/stdc++.h\nusing namespace std;\n\nint main\n{\n\tvector<int v;\n    int a;\n    cin  a;\n    forint i = 0; i < a; i++{\n        int m;\n        cin  m;\n        v.pushbackm;\n    }\n    sortv.begin, v.end;\n    forint i = 0; i < a; i++{\n        cout << vi << \" \";\n    }\n\n  return 0;\n}\n\n\n 二分\n\n可以直接用STL中的lower\\bound和upper\\bound\n\n lower\\boundn, n+a, target\n upper\\boundn, n+a, target\n\n举例（转载：博客链接https://blog.csdn.net/qq40160605/article/details/80150252）\n\n\ninclude<bits/stdc++.h\nusing namespace std;\nconst int maxn=100000+10;\nconst int INF=2int1e9+10;\ndefine LL long long\nint cmdint a,int b{\n\treturn ab;\n}\nint main{\n\tint num6={1,2,4,7,15,34}; \n\tsortnum,num+6;                           //按从小到大排序 \n\tint pos1=lowerboundnum,num+6,7num;    //返回数组中第一个大于或等于被查数的值 \n\tint pos2=upperboundnum,num+6,7num;    //返回数组中第一个大于被查数的值\n\tcout<<pos1<<\" \"<<numpos1<<endl;\n\tcout<<pos2<<\" \"<<numpos2<<endl;\n\tsortnum,num+6,cmd;                      //按从大到小排序\n\tint pos3=lowerboundnum,num+6,7,greater<intnum;  //返回数组中第一个小于或等于被查数的值 \n\tint pos4=upperboundnum,num+6,7,greater<intnum;  //返回数组中第一个小于被查数的值 \n\tcout<<pos3<<\" \"<<numpos3<<endl;\n\tcout<<pos4<<\" \"<<numpos4<<endl;\n\treturn 0;\t\n} \n\n\n AcWing 789. 数的范围\n\n\ninclude <bits/stdc++.h\nusing namespace std;\nint n100010;\nint a, b;\n\n// 左边距\nint getlint x{\n    int l = 0, r = a  1;\n    whilel < r{\n        int mid = l + r  / 2;\n        ifnmid = x r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\n int getrint x{\n    int l = 0, r = a  1;\n    whilel < r{\n    \tint mid = l + r + 1 / 2;\n        ifnmid <= x l = mid;\n        else r = mid  1;\n    }\n    return r;\n }\n\nint main{\n    \n    cin  a  b;\n    forint i = 0; i < a; i++ cin  ni;\n    forint i = 0; i < b; i++{\n        int m;\n        cin  m;\n        int l = getlm;\n        ifnl = m cout << 1 << \" \" << 1 << endl;\n\t\telse {\n\t\t\tint r = getrm;\n\t\t\tifnr = m cout << 1 << \" \" << 1 << endl;\n\t\t\telse cout << l << \" \" << r << endl; \n\t\t} \n    }\n\t\n    return 0;\n}\n\n\n AcWing 790. 数的三次方根  \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\ndouble getSdouble x{\n    return x  x  x;\n}\n\ndouble fundouble x{\n    double l = 10000, r = 10000;\n    whilel < r{\n        double mid = l + r / 2;\n        double res = getSmid;\n        iffabsres  x < 0.0000000001{\n        \treturn mid;\n\t\t}\n        ifres <= x l = mid;\n        else r = mid;\n    }\n}\n\nint main{\n    double a;\n    cin  a;\n\tprintf\"%.6lf\", funa;\n    \n    return 0;\n}\n\n\n 高精度\n\n AcWing 791. 高精度加法\n\n\na = intinput\nb = intinput\nprinta + b\n\n\n AcWing 792. 高精度减法\n\n\na = intinput\nb = intinput\nprinta  b\n\n\n AcWing 793. 高精度乘法\n\n\na = intinput\nb = intinput\nprinta  b\n\n\n AcWing 794. 高精度除法\n\n\na = intinput\nb = intinput\nprinta // b\nprinta % b\n\n\n 前缀和与差分\n\n AcWing 795. 前缀和\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\n\nint main{\n    \n    int a, b;\n    cin  a  b;\n    forint i = 1; i <= a; i++{\n       cin  ni;\n       mi = ni + mi  1;\n    }\n    \n    whileb{\n        int x, y;\n        cin  x  y;\n        cout << my  mx  1 << endl;\n    }\n    \n    return 0;\n}\n\n\n AcWing 796. 子矩阵的和 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n10011001, m10011001;\n\nint main{\n    \n    int a, b, c;\n    cin  a  b  c;\n    forint i = 1; i <= a; i++{\n        forint j = 1; j <= b; j++{\n            cin  nij;\n            mij = nij + mi1j + mij1  mi1j1;\n        }\n    }\n    whilec{\n        int q, w, e, r;\n        cin  q  w  e  r;\n        cout << mer + mq1w1  mq1r  mew1 << endl;\n    }\n    \n\n    return 0;\n}\n\n\n AcWing 797. 差分 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\n\nint main{\n   int a, b;\n   cin  a  b;\n   forint i = 1; i <= a; i++{\n       cin  ni;\n       mi = ni  ni1;\n   }\n   whileb{\n       int x, y ,z;\n       cin  x  y  z;\n       mx += z;\n       my+1 = z;\n   }\n   forint i = 1; i <= a; i++{\n       ni = mi + ni1;\n       cout << ni << \" \";\n   }\n   \n   return 0;\n}\n\n\n AcWing 798. 差分矩阵\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n10101010, m10101010;\n\nint main{\n  \n   int a, b, c;\n   cin  a  b  c;\n   forint i = 1; i <= a; i++{\n       forint j = 1; j <= b; j++{\n           cin  nij;\n           mij = nij  ni1j  nij1 + ni1j1;\n       }\n   }\n   whilec{\n       int q, w, e, r, t;\n       cin  q  w  e  r  t;\n       mqw += t;\n       me+1r+1 += t;\n       me+1w = t;\n       mqr+1 = t;\n   }\n  forint i = 1; i <= a; i++{\n      forint j = 1; j <= b; j++{\n          nij = ni1j + nij1  ni1j1 + mij;\n          cout << nij << \" \";\n      }\n      cout << endl;\n  }\n   \n   return 0;\n}\n\n\n 双指针算法\n\n AcWing 799. 最长连续不重复子序列 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN;\n\nint main{\n    \n    int a, l, r, res = 0;\n    map<int, int is;\n    cin  a;\n    forint i = 0, j = 0; i < a; i++{\n        cin  ni;\n        isni ++;\n        whileisni  1{\n            isnj ;\n            j ++;\n        }\n        res = maxres, i  j + 1;\n    }\n    cout << res << endl;\n  \n    return 0;\n}\n\n\n AcWing 800. 数组元素的目标和\n\n哈希方法\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\nunorderedmap<int, int ump;\n\nint main{\n    \n    int a, b, c, r1 = 0, r2 = 0;\n    cin  a  b  c;\n    forint i = 0; i < a; i++ {\n        cin  ni;\n        umpni = i;\n    }\n    forint j = 0; j < b; j++ {\n        cin  mj;\n        ifump.countc  mj{\n            r1 = umpc  mj, r2 = j;\n        }\n    }\n\n    cout << r1 << \" \" << r2 << endl;\n  \n    return 0;\n}\n\n\n AcWing 2816. 判断子序列\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\nunorderedmap<int, int ump;\n\nint main{\n    \n    int a, b;\n    cin  a  b;\n    forint i = 0; i < a; i++ cin  ni;\n    forint j = 0; j < b; j++ cin  mj;\n   \n    int x = 0, y = 0;\n    whilex < a && y < b{\n        ifnx == my x ++;\n        y ++;\n    }\n    \n    ifx == a cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  \n    return 0;\n}\n\n\n 位运算\n\n AcWing 801. 二进制中1的个数\n\n 小知识：n的二进制表示中第k位是几？  \n 答案：n  k & 1  \n n右移k位&1后得出二进制数的最后一位\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// 返回x的最后一位1\n// 比如10010的最后一位就是10\nint lowbitint x{\n    return x & x;    \n}\n\nint main{\n        \n    int a, b, res;\n    cin  a;\n    forint i = 0; i < a; i++{\n        cin  b;\n        res = 0;\n        whileb{\n            b = lowbitb;\n            res ++;\n        }\n        cout << res << \" \";\n    }\n        \n    return 0;\n}\n\n\n 离散化\n\n AcWing 802. 区间和  \n\n 小知识  \n 离散化：将100，2000，30000，4000000映射为1，2，3，4的过程\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\n// 此处不是1e5+10\n// 极端情况下第一排输入会有1e5的数据，第二排会有2e5的数据\nconst int N = 3e5 + 10 ;\n\nint sN, fN;\n\nvector<int v;\nvector<pair<int, int  q, w;\n// 二分查找元素下标\nint findint x{\n    int l = 0, r = v.size  1;\n    whilel < r{\n        int mid = l + r  1;\n        ifvmid = x r = mid;\n        else l = mid + 1;\n    }\n    return l + 1;\n}\n\nint main{\n    \n    int a, b, m, n;\n    cin  a  b;\n    forint i = 0; i < a; i++{\n        cin  m  n;\n        q.pushback{m, n};\n        v.pushbackm;\n    }\n    forint j = 0; j < b; j++{\n        cin  m  n;\n        w.pushback{m, n};\n        v.pushbackm;\n        v.pushbackn;\n    }\n    sortv.begin, v.end;\n    // 去重\n    v.eraseuniquev.begin, v.end, v.end;\n    // 离散化处理\n    forauto i: q{\n        int x = findi.first;\n        sx += i.second;\n    }\n    // 预处理前缀和\n    forint i = 1; i <= v.size; i++{\n        fi = fi1 + si;\n    }\n    // 查询结果\n    forauto i: w{\n        int l = findi.first, r = findi.second;\n        cout << fr  fl1 << endl;\n    }\n    \n    return 0;\n}\n\n\n图片描述http://www.lijunxi.site:4000/api/file/download/6261dfbbafd542b9bcdf46091f5b8e0f.jpg\n\n数据范围分析\n\n 区间合并\n\n AcWing 803. 区间合并\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ; \n\nstruct point{\n    int x, y;\n} nN;\n\nbool cmppoint a, point b{\n    ifa.x == b.x return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main{\n    \n    int a, idx = 0;\n    cin  a;\n    forint i = 0; i < a; i++ cin  ni.x  ni.y;\n    sortn, n+a, cmp;\n    int langm = n0.y;\n    forint i = 1; i < a; i++{\n        langm = maxlangm, ni1.y;\n        iflangm < ni.x idx++;\n    }\n    cout << idx + 1 << endl;\n  \n    return 0;\n}\n\n\n 数据结构\n\n 单链表\n\n AcWing 826. 单链表\n\n数组模拟单链表\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\n// 头指针（用下表指针辅助），下标指针\nint hidx = 1, idx = 0;\n// 元素值，元素下表\nint nN, neN;\n\nvoid insertint k, int x{\n    // 新节点值赋值\n    nidx = x;\n    // 将新结点下一个结点赋值为插入位置的下一个结点\n    neidx = nek;\n    // 将插入位置的一下个节点指向新节点\n    nek = idx;\n    idx++;\n}\n\nvoid addHeadint x{\n    // 头节点赋值\n    nidx = x;\n    // 指向头指针\n    neidx = hidx;\n    // 更改头指针为当前下表\n    hidx = idx;\n    idx++;\n}\n\nvoid delint idx{\n    neidx = neneidx;   \n}\n\nint main{\n    \n    int x, k, num; \n    char s;\n    cin  x;\n    whilex{\n        cin  s;\n        ifs == 'H'{\n            cin  num;\n            addHeadnum;\n        }\n        else ifs == 'D'{\n            cin  k;\n            //判断是否删除的为头节点\n            ifk hidx = nehidx;  \n            delk1;\n        }\n        else{\n            cin  k  num;\n            insertk1, num;\n        }\n    }\n    whilehidx = 1{\n        cout << nhidx << \" \";\n        hidx = nehidx;\n    }\n    \n    return 0;\n}\n\n\n 双链表\n\n 栈\n\n AcAcWing 3302. 表达式求值\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nstack<int s;\nstack<char f;\nunorderedmap<char, int ump;\n\nvoid initmap{\n\tump'' = 2;\n\tump'/' = 2;\n\tump'+' = 1;\n\tump'' = 1;\n}\n\nvoid eval{\n\tint num = 0;\n\tint x = s.top; s.pop;\n\tint y = s.top; s.pop;\n\tchar op = f.top; f.pop;\n\tifop == '+' num = x + y;\n\telse ifop == '' num = y  x;\n\telse ifop == '' num = x  y;\n\telse num = y / x;\n\ts.pushnum;\n}\n\nint main{\n    initmap;\n    string str;\n    int num, idx = 0;\n    char c;\n    cin  str;\n    int len = str.size;\n    forint i = 0; i < len; i++{\n        ifstri = '0' && stri <= '9'{\n            idx = i;\n            num = 0;\n            whilestridx = '0' && stridx <= '9' && idx < len{\n                num = num  10 + stridx  '0';\n                idx++; \n            }\n            s.pushnum;\n            i = idx  1;\n        }\n        else ifstri == '' f.pushstri;\n        else ifstri == ''{\n       \t\twhilef.size && s.size = 2 && umpstri <= umpf.top && f.top = '' eval;\n       \t\tf.pop;\n        }\n        else{\n        \twhilef.size && s.size = 2 && umpstri <= umpf.top eval;\n            f.pushstri;\n        }\n    }\n    whilef.size eval;\n\tcout << s.top << endl; \n    \n    return 0;\n}\n\n\n 队列\n\n AcWing 829. 模拟队列\n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nqueue<int q;\n\nint main{\n    int a, num;\n    string s;\n    cin  a;\n    whilea{\n        cin  s;\n        ifs == \"push\"{\n            cin  num;\n            q.pushnum;\n        }\n        else ifs == \"pop\"{\n            q.pop;\n        }\n        else ifs == \"empty\"{\n            ifq.empty cout <<\"YES\"<<endl;\n            else cout <<\"NO\" << endl;\n        }\n        else{\n            cout << q.front << endl;\n        }\n    }\n   \n    return 0;\n}\n\n\n 单调栈\n\n AcWing 830. 单调栈\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nstack<int s;\n\nint main{\n    \n    int a, num;\n    cin  a;\n    forint i = 0; i < a; i++ {\n        cin  num;\n        whiles.size && s.top = num s.pop;\n        ifs.size cout << 1 << \" \";\n        else cout << s.top << \" \";\n        s.pushnum;\n    }\n    \n    return 0;\n}\n\n\n 单调队列\n\n AcWing 154. 滑动窗口\n\n\ninclude<iostream\ninclude<algorithm\ninclude<deque\ninclude<vector\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10 ;\n\n// deque没法直接获取下表的元素值，所以需要用一个数组来维护 \nint nN;\ndeque<int dq; \n\nint main{\n  \n    int a, b, num;\n    cin  a  b;\n    forint i = 1; i <= a; i++ cin  ni;\n    forint i = 1; i <= a; i++{\n    \t// 当尾元素比ni大时，需要弹出 \n    \twhiledq.size && ndq.back  ni dq.popback;\n    \tdq.pushbacki;\n    \t// 当队列的个数满足b时们需要弹出首元素\n\t\t// 这里不能用dq.size来判断是否满足个数，因为可能出现首元素到i之间有些元素已经弹出了但size总数任然小于b情况 \n    \tifdq.size && i  dq.front = b dq.popfront;\n    \t// 当i大于b时候就能开始输出了，这里也不能用dq.size来判断，因为存在整个过程都小于b的情况，这样就没有输出了 \n\t\tifi = b cout << ndq.front << \" \";\n\t}\n\tdq.clear;\n\tputs\"\";\n      forint i = 1; i <= a; i++{\n    \twhiledq.size && ndq.back < ni dq.popback;\n    \tdq.pushbacki;\n    \tifdq.size && i  dq.front = b dq.popfront;\n\t\tifi = b cout << ndq.front << \" \";\n\t}\n    \n    return 0;\n}\n\n\n KMP\n\n Tire\n\n AcWing 835. Trie字符串统计\n\n Trie树（字典树）：高效存储和查找字符串集合的数据结合\n\n\ninclude<iostream\ninclude<algorithm\ninclude<deque\ninclude<vector\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// son存储子节点的位置，分支最多26条\n// cnt存储以某节点结尾的字符串个数（同时也起标记作用）\n// idx表示当前要插入的节点是第几个,每创建一个节点值+1\nint sonN26, cntN, idx = 0;\n\nvoid insertstring str{\n\t// 类似指针，指向当前节点\n\tint p = 0;\n\tforint i = 0; i < str.size; i++{\n\t\tint s = stri  'a';\n\t\t// 该字符不存在就创建一个 \n\t\tifsonps sonps = ++idx;\n\t\t// \tp指向下一个节点\n\t\tp = sonps;\n\t}\n\t// 统计字符串个数 \n\tcntp ++;\n} \n\nint querystring str{\n\tint p = 0;\n\tforint i = 0; i < str.size; i++{\n\t\tint s = stri  'a';\n\t\tifsonps return 0;\n\t\tp = sonps; \n\t}\n\treturn cntp;\n}\n\n\nint main{\n \n\tint a;\n\tchar c;\n\tstring str;\n\tcin  a;\n\twhilea{\n\t\tcin  c;\n\t\tcin  str;\n\t\tifc == 'I' insertstr;\n\t\telse cout << querystr << endl;\n\t}\n    \n    return 0;\n}\n\n\n AcWing 143. 最大异或对  \n\n\ninclude<iostream\ninclude<algorithm\ninclude<deque\ninclude<vector\nusing namespace std;\ntypedef long long ll;\n// 最多有1e5个数，每个数的二进制数有31位，极限情况下就1e5  31\nconst int N = 31e5 + 10 ;\n\nint sonN2, nN, idx = 0;\n\n// 将数字插入trie树中 \nvoid insertint x{\n\tint p = 0;\n\t// 数的范围为小于2e31次方 \n\tforint i = 30; i = 0; i {\n\t\tint s = x  i & 1;\n\t\tifsonps sonps = ++idx;\n\t\tp = sonps;\n\t}\n}\n\nint queryint x{\n\tint p = 0, res = 0;\n\tforint i = 30; i = 0; i{\n\t\t// x二进制第i位上的数 \n\t\tint s = x  i & 1;\n\t\t// 若存在相反的数 \n\t\tifsonps{\n\t\t\tp = sonps;\n\t\t\t// 1左移i位就是2^30i次方 \n\t\t\tres += 1 << i;\n\t\t}\n\t\telse{\n\t\t\tp = sonps;\n\t\t\tres += 0 << i;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main{\n\n\tint a, res = 0;\n\tcin  a;\n\tforint i = 0; i < a; i++ {\n\t\tcin  ni;\n\t\tinsertni;\n\t}\n\tforint i = 0; i < a; i++ res = maxres, queryni;\n\tcout << res << endl;\n\t\n    return 0;\n}\n\n\n 并查集\n\n AcWing 836. 合并集合\n\n\ninclude<iostream\ninclude<algorithm\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\nint nN;\n\n// 找到祖宗结点\nint findint x{\n    // 修改结点，避免重复查找\n   ifnx = x nx = findnx;\n   return nx;\n}\n\nint main{\n    int a, b;\n    cin  a  b;\n    forint i = 0; i < a; i++ ni = i;\n    forint i = 0; i < b; i++{\n        char x;\n        int o, p;\n        cin  x  o  p;\n        ifx == 'M'{\n            nfindo = findp;\n        }\n        else{\n            iffindo == findp cout << \"Yes\" << endl;\n            else cout << \"No\" << endl;\n        }\n    }\n     \n    return 0;\n}\n\n\n 堆\n\n 堆：优先队列\n\n AcWing 838. 堆排序\n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint nN;\n// 从小到大排序，从大到小就为less<int，与sort相反\npriorityqueue<int, vector<int, greater<int pq;\nint main{\n    \n    int a, b, num;\n    cin a  b;\n    forint i = 0; i < a; i++{\n        cin  num;\n        pq.pushnum;\n    }\n    int idx = 0;\n    whileidx = b{\n        idx ++;\n        cout << pq.top << \" \";\n        pq.pop;\n    }\n    \n    return 0;\n}\n\n\n 哈希表\n\n 搜索与图论\n\n DFS\n\n AcWing 842. 排列数字 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nint isN;\nvector<int v;\n\nvoid dfsint x{\n    ifx == 0 return; \n    ifv.size == a{\n    \tforint i = 0; i < a; i++ cout << vi << \" \";\n    \tcout << endl;\n\t}\n\tforint i = 1; i <= a; i++{\n\t\tifisi{\n\t\t\tisi = 1;\n\t\t\tv.pushbacki;\n\t\t\tdfsi;\n\t\t\tv.popback;\n\t\t\tisi = 0;\n\t\t}\n\t}\n}\n\nint main{\n    cin  a;\n    dfsa;\n    return 0;\n}\n\n\n AcWing 843. n皇后问题\n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nchar n1111;\nint l11, xie11, fx11;\n\nvoid print{\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= a; j++{\n\t\t\tcout << nij;\n\t\t}\n\t\tputs\"\";\n\t}\n\tputs\"\";\n} \n\nvoid dfsint x{\n\tifx == a + 1{\n\t\tprint;\n\t\treturn;\n\t}\n    forint i = 1; i <= a; i++{\n    \t// \ti  x + a是为了避免出现下标是负数的情况 \n    \tifli && xiei  x + a && fxi + x{\n    \t\tnxi = 'Q';\n    \t\txiei  x + a = 1;\n    \t\tfxi + x = 1;\n    \t\tli = 1;\n    \t\tdfsx + 1;\n    \t\tnxi = '.';\n    \t\txiei  x + a = 0;\n    \t\tfxi + x = 0;\n    \t\tli = 0;\n\t\t}\n\t\n\t}\n\n}\n\nint main{\n  \t\n\tcin  a;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= a; j++{\n\t\t\tnij = '.';\n\t\t}\n\t}\n    dfs1;\n    \n    return 0;\n}\n\n\n BFS\n\n AcWing 844. 走迷宫 \n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint a, b;\nint n10101010, is10011001;\nint ix4 = {1, 1, 0 ,0}, iy4 = {0, 0, 1, 1};\n\nvoid bfsint x, int y{\n    queue<pair<int, int q;\n    map<pair<int, int, int mp;\n    q.push{0, 0};\n    mp{0, 0} = 0;\n    whileq.empty{\n    \tauto top = q.front;\n    \tq.pop;\n    \tint xx = top.first, yy = top.second;\n    \tifxx == a  1 && yy == b  1{\n    \t\tcout << mp{xx, yy} << endl;\n    \t\treturn;\n\t\t}\n\t\tforint i = 0; i < 4; i++{\n\t\t\tint x = xx + ixi, y = yy + iyi;\n\t\t\tifnxy && isxy && x = 0 && x < a && y = 0 && y < b{\n\t\t\t\tisxy = 1;\n\t\t\t\tq.push{x, y};\n\t\t\t\tmp{x, y} = mp{xx, yy} + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main{\n  \t\n\tcin  a  b;\n\tforint i = 0; i < a; i++{\n\t    forint j = 0; j < b; j++{\n\t        cin  nij;\n\t    }\n\t}\n\tbfs0, 0;\n    \n    return 0;\n}\n\n\n 树与图的深度优先遍历\n\n AcWing 846. 树的重心\n\n图的存储采用数组模拟邻接表\n\n思路：邻接表dfs\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint hN;\n// 存储元素 \nint eN;\n// 下个节点值\nint neN;\n// 结点是否访问过\nint stN; \n// 单链表指针 \nint idx = 0; \nint a, ans = N; \n\nvoid addint x, int y{\n\teidx = y, neidx = hx, hx = idx++;\n}\n\nint dfsint x{\n\tint res = 0, sum = 1;\n\tstx = 1;\t\n\tforint i = hx; i = 1; i = nei{\n\t\tint j = ei;\n\t\tifstj{\n\t\t\tint s = dfsj;\n\t\t\t// 子图最大结点数 \n\t\t\tres = maxres, s;\n\t\t\t// j为根的节点总数 \n\t\t\tsum += s;\t\t\n\t\t}\n\t}\n\t// a  sum：另一部分的节点总数 \n\tres = maxres, a  sum;\n\t// 选取最小的最大结点数 \n\tans = minans, res;\n\treturn sum;\n}\n\n\nint main{\n  \t//初始化h数组 1表示尾节\n\tmemseth, 1, sizeof h; \n    cin.tie0;cout.tie0;ios::syncwithstdiofalse;\n    cin  a;\n    // 创建邻接表 \n    forint i = 0; i < a  1; i++{\n    \tint m, n;\n    \tcin  m  n;\n    \taddm, n;\n    \taddn, m;\n\t}\n    dfs1;\n    cout << ans << endl;\n    return 0;\n}\n\n\n 树与图的广度优先遍历\n\n AcWing 847. 图中点的层次\n\n思路：邻接表bfs\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint hN;\n// 存储元素 \nint eN;\n// 下个节点值\nint neN;\n// 结点是否访问过\nint stN; \n// 单链表指针 \nint idx = 0; \nint a, b, ans = N; \n\nvoid addint x, int y{\n\teidx = y, neidx = hx, hx = idx, idx ++;\n}\n\nvoid dfsint x{\n    queue<pair<int, int q;\n    map<pair<int, int, int ump;\n    q.push{1, 1};\n    ump{1, 1} = 0;\n    whileq.empty{\n        auto top = q.front;\n        q.pop;\n        int xx = top.first, yy = top.second;\n        ifyy == a{\n        \tcout << ump{xx, yy} << endl;\n        \treturn;\n\t\t}\n\t\tforint i = hyy; i = 1; i = nei{\n\t\t\tifump.find{yy, ei} == ump.end{\n\t\t\t\tq.push{yy, ei};\n\t\t\t\tump{yy, ei} = ump{xx, yy} + 1;\n\t\t\t}\n\t\t}\n    }   \n\tcout << 1 << endl; \n \n}\n\nint main{\n  \t//初始化h数组 1表示尾节\n\tmemseth, 1, sizeof h; \n    cin.tie0;cout.tie0;ios::syncwithstdiofalse;\n    cin  a  b;\n    // 创建邻接表 \n    forint i = 0; i < b; i++{\n    \tint m, n;\n    \tcin  m  n;\n    \taddm, n;\n\t}\n    dfs1;\n\n    return 0;\n}\n\n\n 拓扑排序\n\n AcWing 848. 有向图的拓扑序列\n\n思路：邻接表找入度为0的结点\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint hN, eN, neN, idx, a, b;\nqueue<int q;\n// 保存各个点的入度\nint dN; \n// v存放答案\nvector<int v;\n\nvoid addint x, int y{\n    eidx = y, neidx = hx, hx = idx++;\n}\n\nbool topsort{\n    // 找出入读为0的点\n    forint i = 1; i <= a; i++{\n    \tifdi q.pushi; \n\t}\t\n\twhileq.size{\n\t\tint top = q.front;\n\t\tq.pop;\n\t\tv.pushbacktop;\n\t\t// 每次循环减去一条边\n\t\tforint i = htop; i = 1; i = nei{\n\t\t\tint j = ei;\n\t\t\tdj ;\n\t\t\t// 当减去后的入读为0则入队列\n\t\t\tifdj q.pushj;\n\t\t}\n\t}\n\treturn v.size == a;\n}\n\nint main{\n  \t\n  \tmemseth, 1, sizeof h;\n  \tcin  a  b;\n  \twhileb{\n  \t    int x, y;\n  \t    cin  x  y;\n  \t    addx, y;\n  \t    dy ++;\n  \t}\n  \tiftopsort{\n  \t\tforint i = 0; i < v.size; i++ cout << vi << \" \";\n\t}\n\telse puts\"1\";\n  \t\n    return 0;\n}\n\n\n Dijkstra\n\n稠密图：临界矩阵（点较少）  \n稀疏图：邻接表（点较多）\n\n AcWing 849. Dijkstra求最短路 I\n\n朴素版（暴力）\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint m, n;\n// 为稠密阵所以用邻接矩阵存储\nint num501501;\n// 用于记录每一个点距离第一个点的距离\nint disN;\n// 用于记录该点的最短距离是否已经确定\nint stN;\n\nint dijkstra{\n\tmemsetdis, 0x3f3f3f3f, sizeof dis;\n\tdis1 = 0;\n\tforint i = 0; i < m; i++{\n\t\tint t = 1;\n\t\t// 找到没有确定最短路径的节点中距离源点最近的点t \n\t\tforint j = 1; j <= m; j++{\n\t\t\tifstj && t == 1  dist  disj{\n\t\t\t\tt = j;\n\t\t\t}\n\t\t}\n\t\tstt = 1;\n\t\t// 更新到其他点的距离 \n\t\tforint k = 1; k <= m; k++{\n\t\t\tdisk = mindisk, dist + numtk;\n\t\t}\n\t}\n\tifdism==0x3f3f3f3f return 1;\n    return dism;\n}\n\nint main{\n\tmemsetnum, 0x3f3f3f3f, sizeof num;\n\tcin  m  n;\n\tforint i = 0; i < n; i++{\n\t\tint x, y, z;\n\t\tcin  x  y  z;\n\t\tnumxy = minnumxy, z;\n\t}\n  \tcout << dijkstra << endl;\n    return 0;\n}\n\n\n AcWing 850. Dijkstra求最短路 II \n\n临界表法\n\n\ninclude<bits/stdc++.h\n \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\ntypedef pair<int, int PII;\n\nint eN, neN, idx, hN, disN, stN;\nint wN; // 存放权重 \nint a, b;\n\nvoid addint x, int y, int z{\n\twidx = z, eidx = y, neidx = hx, hx = idx++;\n}\n\nint dj{\n\tmemsetdis, 0x3f3f3f3f, sizeof dis;\n\tpriorityqueue<PII, vector<PII, greater<PII heap;\n\t// 插入距离和结点编号 \n\theap.push{0, 1};\n\twhileheap.empty{\n\t\tauto top = heap.top;\n\t\theap.pop;\n\t\tint x = top.second, y = top.first;\n\t\tifstx continue;\n\t\tstx = 1;\n\t\t// 遍历该节点的每个临界结点，给每个选出最短距离 \n\t\tforint i = hx; i = 1; i = nei{\n\t\t\tint j = ei;\n\t\t\tifdisj  disx + wi{\n\t\t\t\tdisj = disx + wi;\n\t\t\t\theap.push{disj, j};\n\t\t\t}\n\t\t}\n\t}\n\tifdisa == 0x3f3f3f3f return 1;\n\treturn disa;\n}\n\nint main{\n\tmemseth, 1, sizeof h;\n\tcin  a  b;\n\twhileb{\n\t\tint x, y, z;\n\t\tcin  x  y  z;\n\t\taddx, y, z;\n\t\taddy, x, z;\n\t}\n\tcout << dj << endl;\n\n    return 0;\n}\n\n\n Floyd\n\n与迪杰斯特拉的区别：\n\n 迪杰斯特拉算法适用于非负权，用于查找1到n 的最短距离，数据范围大\n 弗洛伊德算法适用于含有负权，用于查找每个点之间的最短距离，数据范围较少\n\n AcWing 854. Floyd求最短路\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int PII;\n\nint n, m, k;\nint e201201;\n\nvoid floyd{\n\t//  fi, j, k表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么fi, j, k = minfi, j, k  1, fi, k, k  1 + fk, j, k  1。\n    // 因此在计算第k层的fi, j的时候必须先将第k  1层的所有状态计算出来，所以需要把k放在最外层。 \n\tforint k = 1; k <= n; k++{\n\t\tforint i = 1; i <= n; i++{\n\t\t\tforint j = 1; j <= n; j++{\n\t\t\t\teij = mineij, eik + ekj;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main{\n\tcin  n  m  k; \n\tforint i = 1; i <= n; i++{\n\t\tforint j = 1; j <= n; j++{\n\t\t\tifi == j eij = 0;\n\t\t\telse eij = INF;\n\t\t}\n\t}\n\tforint i = 0; i < m; i++{\n\t\tint x, y, z;\n\t\tcin  x  y  z;\n\t\texy = minexy, z;\n\t}\n\tfloyd;\n\twhilek{\n\t\tint x, y;\n\t\tcin  x  y;\n\t\t// 不能exy == INF，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可 \n\t\tifexy  INF / 2 cout << \"impossible\"<<endl;\n\t\telse cout << exy <<endl;\n\t}\n\treturn 0;\n}\n\n\n 数学知识\n\n 质数\n\n AcWing 867. 分解质因数\n\n主要需要开方来避免超时\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main{\n\t\n\tint n, m;\n\tcin  n;\n\twhilen{\n\t\tcin  m;\n\t\tint mm = m, flag = 0;\n\t\tforint i = 2; i <= m / i; i++{\n\t\t\tint idx = 0;\n\t\t\twhilemm % i == 0{\n\t\t\t\tidx ++;\n\t\t\t\tmm /= i;\n\t\t\t}\n\t\t\tifidx = 0{\n\t\t\t    flag = 1;\n\t\t\t    cout << i << \" \" << idx << endl;\n\t\t\t} \n\t\t}\n\t\tifflag{\n\t        ifmm = 1 cout << mm << \" \" << 1 << endl;\n\t        cout << endl;\n\t\t}\n\t\telse {\n\t\t    cout << m << \" \" << 1 << endl;\n\t\t    cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n AcWing 868. 筛质数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nint nN, stN, idx;\n\nvoid init{\n\tforint i = 2; i <= N; i++{\n\t\tifsti nidx++ = i;\n\t\tforint j = 0; nj <= N / i; j++{\n\t\t\tstnj  i = 1;\n\t\t\tifi % nj == 0 break;\n\t\t}\n\t}\n}\n\n\nint main{\n\tinit;\n\tint a, res = 0;\n\tcin  a;\n\tforint i = 2; i <= a; i++{\n\t\tifsti{\n\t\t\tres ++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n 约数\n\n图片描述http://www.lijunxi.site:4000/api/file/download/bd17a18c0c3c475c87f230830d333ee3.png\n\n AcWing 870. 约数个数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main{\n\tset<int s;\n\tmap<int, int mp;\n\tll a, b, res = 1;\n\tcin  a;\n\twhilea{\n\t\tcin  b;\n\t\tint xx = b;\n\t\tforint i = 2; i <= b / i; i++{\n\t\t\twhilexx % i == 0{\n\t\t\t\txx /= i; \n\t\t\t\tmpi ++;\n\t\t\t}\n\t\t}\n                // x的最大公约数可能大于sqrtx;\n\t\tifxx  1 mpxx ++;\n\t}\n\tforauto i: mp{\n\t\tres = res  i.second + 1 % M; \n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n\n AcWing 871. 约数之和\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main{\n\tmap<ll, ll mp;\n\tint a;\n\tll res = 1;\n\tcin  a;\n\twhilea{\n\t\tint m;\n\t\tcin  m;\n\t\tint c = m;\n\t\tforint i = 2; i <= m / i; i++{\n\t\t\tll cot = 0;\n\t\t\twhilec % i == 0{\n\t\t\t\tc /= i;\n\t\t\t\tmpi ++;\n\t\t\t}\n\t\t}\n\t\tifc  1 mpc ++;\t\n\t}\n\tforauto i: mp{\n\t\tll x = i.first, y = i.second, cot1 = 1, cot2 = 1;\n\t\twhiley{ \n\t\t\tcot2 = cot2  x % M;\n\t\t\tcot1 = cot1 + cot2 % M;\n\t\t}\n\t\tres = res  cot1 % M;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n AcWing 872. 最大公约数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n// 最大公约数\nll fun1int x, int y{\n\treturn y ? fun1y, x % y : x;\n}\n// 最小公倍数\nll fun2int x, int y{\n\treturn x  fun1x, y / y;\n}\n\nint main{\n\t\n\tint a;\n\tcin  a;\n\twhilea{\n\t\tint m, n;\n\t\tcin  m  n;\n\t\tcout << fun1m, n << endl;\n\t}\n\n\n\treturn 0;\n}\n\n\n 欧拉函数\n\n 1∼N 中与 N 互质的数的个数被称为欧拉函数，称为On  \n 若N = p1^a\\p2^b\\p3^c\\.....  \n 则ON = N \\ p11/p1 \\ p21/p2 \\ p31/p3 \\.....\n\n AcWing 873. 欧拉函数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main{\n\t\n\tint a;\n\tcin  a;\n\twhilea{\n\t\tint m;\n\t\tcin  m;\n\t\tll res = m; \n\t\tmap<int, ll mp;\n\t\tforint i = 2; i <= m / i; i++{\n\t\t\twhilem % i == 0{\n\t\t\t\tm /= i;\n\t\t\t\tmpi ++;\n\t\t\t} \n\t\t}\n\t\tifm  1 mpm ++;\n\t\tforauto i: mp{\n\t\t\tint x = i.first;\n\t\t\tres = res  x  1 / x;\n\t\t} \n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}\n\n\n 组合数\n\n AcWing 885. 求组合数 I\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10, M = 1e9 + 7;\n\nint e20102010;\n\nvoid init{\n    // 类似于DP\n    // eij就代表的是Cij\n\tforint i = 0; i < 2010; i++{\n\t\tforint j = 0; j <= i; j++{\n\t\t    // Ci0为1\n\t\t\tifj eij = 1;\n\t\t\telse eij = ei1j1 + ei1j % M;\n\t\t}\n\t}\n} \n\nint main{\n\t\n\tinit; \n\tint a;\n\tcin  a;\n\twhilea{\n\t\tint m, n;\n\t\tcin  m  n;\n\t\tcout << emn << endl;\n\t}\n\n\treturn 0;\n}\n\n\n 容斥原理\n\n AcWing 890. 能被整除的数\n\n若给出的待求的数组都是互质\n\nc++\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint v20;\nint main{\n\n    int a, b, res = 0;\n    cin  a  b;\n    forint i = 0; i < b; i ++{\n        cin  vi;\n    }\n    forint i = 1; i < 1 << b; i ++{\n        int cot = 0, t = 1;\n        forint j = 0; j < b; j ++{\n            ifi  j & 1{\n                cot ++;\n                ifll t  vj  a{\n                    t = 1;\n                    break;\n                }\n                t = vj;\n            }\n        }\n        ift = 1{\n            ifcot % 2 == 0{\n                res = a / t;\n            } else {\n                res += a / t;\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n\n\n否则，修改乘积为求最小公倍数\n\n参考Leetcode：单面值组合的第 K 小金额https://leetcode.cn/problems/kthsmallestamountwithsingledenominationcombination/\n\nc++\nclass Solution {\npublic:\n    int len;\n    long long funlong long x, vector<int& v{\n        long long res = 0;\n        forint i = 1; i < 1 << len; i++{\n            long long cot = 0, t = 1;\n            forint j = 0; j < len; j++{\n                ifi  j & 1{\n                    long long ccc = t / gcdt, vj  vj; //《修改这里\n                    ifccc  x{\n                        t = 1;\n                        break;\n                    }\n                    cot ++;\n                    t = ccc;\n                }\n            }\n            ift = 1{\n                ifcot % 2 == 1 res += x / t;\n                else res = x / t;\n            }\n        }\n        return res;\n    }\n    long long findKthSmallestvector<int& coins, int k {\n        len = coins.size;\n        long long l = 1, r = 1e12;\n        whilel < r{\n            long long mid = l + r  1;\n            iffunmid, coins = k r = mid;\n            else l = mid + 1;\n        }\n\n        return l;\n\n    }\n};\n\n\n\n\n 动态规划\n\n 记忆化搜索\n\n AcWing 901. 滑雪\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint a, b;\nint n310310, cot310310;\nint ix4 = {1,0,1,0};\nint iy4 = {0,1,0,1};\n\nint dfsint x, int y{\n\tifcotxy = 1 return cotxy;\n\tcotxy = 1;\n\tforint i = 0; i < 4; i++{\n\t\tint xx = ixi + x, yy = iyi + y;\n\t\tifxx = 1 && xx <= a && yy = 1 && yy <= b && nxy  nxxyy{\n\t\t\tcotxy = maxcotxy, dfsxx, yy + 1;\n\t\t}\n\t}\n\treturn cotxy;\n}\n\n\nint main{\n    memsetcot, 1, sizeof cot;\n\tcin  a  b;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\n\tint ans = 0;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tans = maxans, dfsi, j;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n\n 线性DP\n\n AcWing 898. 数字三角形\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 510, M = 1e5 + 10;\t\nint nNN; \nint cotNN;\nint a;\n\nint dfsint x, int y{\n\tifx < 1  x  a  y < 1  y  a return 0;\n\tifcotxy = 1 return cotxy;\n\tint 1 = dfsx + 1, y, 2 = dfsx + 1, y + 1;\n\tcotxy = max1, 2 + nxy; \n\treturn cotxy; \n}\n\nint main{\n\tmemsetcot, 1, sizeof cot;\n\tcin  a;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= i; j++{\n\t\t\tcin  nij;\t\n\t\t}\n\t}\n\tcout << dfs1, 1 << endl;\n\t\n\treturn 0;\n}\n\n\n AcWing 896. 最长上升子序列\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\nint nN;\nint a;\nvector<int v; \n\nint main{\n\n\tint a;\n\tcin  a;\n\tforint i = 0; i < a; i++ cin  ni;\n\tforint i = 0; i < a; i++{\n\t\tifv.empty  ni  v.back{\n\t\t\tv.pushbackni;\n\t\t}\n\t\telse{\n\t\t\tlowerboundv.begin, v.end, ni = ni;\n\t\t}\n\t}\n\tcout << v.size << endl;\n\t\n\treturn 0;\n}\n\n\n AcWing 897. 最长公共子序列\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\n\nchar n1N, n2N;\n// nij记录前i个n1和前j个n2的公共子串的最大长度\nint n10101010;\n \nint main{\n\t\n\tint a, b;\n\tcin  a  b  n1 + 1  n2 + 1;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tifn1i == n2j{\n\t\t\t\tnij = ni1j1 + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnij = maxni1j, nij1;\n\t\t\t}\n\t\t}\n\t}\n\t\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcout << nij << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << nab << endl;\n\t\n\treturn 0;\n}\n"},{"filename":"springcloud-learn","category":"java","md":{"topSummary":"\ntitle: SpringCloud学习笔记\ncategory: Java,SpringCloud\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n笔记参考博客：\n\n- https://blog.csdn.net/u011863024/article/details/114298270\n- https://blog.csdn.net/u011863024/article/details/114298282\n- [https://blog.csdn.net/u011863024/article/details/114298288](https://blog.csdn.net/u011863024/article/details/114298288)\n\n## 环境搭建\n\n约定 > 配置 > 编码\n\n创建微服务cloud整体聚合父工程Project，有8个关键步骤：\n\n1、New Project - maven工程 - create from archetype: maven-archetype-site\n2、聚合总父工程名字\n3、Maven选版本\n4、工程名字\n5、字符编码 - Settings - File encoding\n6、注解生效激活 - Settings - Annotation Processors\n7、Java编译版本选8\n8、File Type过滤 - Settings - File Type\n\n### 复习\n\n#### DependencyManagement和Dependencies\n\nMaven使用`dependencyManagement`元素来提供了一种管理依赖版本号的方式。\n\n通常会在一个组织或者项目的最顶层的父POM 中看到`dependencyManagement`元素。\n\n使用pom.xml中的`dependencyManagement`元素能让所有在子项目中引用个依赖而不用显式的列出版本量。\n\nMaven会沿着父子层次向上走，直到找到一个拥有`dependencyManagement`元素的项目，然后它就会使用这个`dependencyManagement`元素中指定的版本号。\n\n说白了就是父项目用了版本号，子项目就可以不需要写版本号，便于维护\n\n**注意**\n\n- `dependencyManagement`里只是**声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖***。\n- 如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。\n- 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。\n\n#### Maven跳过单元测试\n\nIDEA右侧旁的Maven插件有`Toggle ' Skip Tests' Mode`按钮，这样maven可以跳过单元测试\n\n父工程创建完成执行`mvn : install`将父工程发布到仓库方便子工程 继承\n\n## Dashboard窗口\n\n1. 打开工程路径下的.idea文件夹的workspace.xml\n2. 在`<component name=\"RunDashboard\">`中修改或添加以下代码：重启即可\n\n```xml\n<option name=\"configurationTypes\">\n\t<set>\n\t\t<option value=\"SpringBootApplicationConfigurationType\"/>\n    </set>\n</option>\n```\n\n\n\n## 支付模块构建\n\n创建微服务模块套路：\n\n1. 建Module\n2. 改POM\n3. 写YML\n4. 主启动\n5. 业务类\n\n[![pPSszzn.png](https://s1.ax1x.com/2023/07/29/pPSszzn.png)](https://imgse.com/i/pPSszzn)\n\n## 消费模块构建\n\n[![pPSyCLV.png](https://s1.ax1x.com/2023/07/29/pPSyCLV.png)](https://imgse.com/i/pPSyCLV)\n\n## Restemplate\n\nRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集\n\n使用：\n\n- 使用restTemplate访问restful接口非常的简单粗暴无脑。\n- `(url, requestMap, ResponseBean.class)`这三个参数分别代表。\n- REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。\n\n```java\n// 消费模块调用支付模块接口\nrestTemplate.postForObject(\"http://localhost:8001/payment/create\", payment, CommonResult.class);\n```\n\n- getForObject() / getForEntity() - GET请求方法\n\n- getForObject()：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。\n\n- getForEntity()：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。\n\n## 工程重构\n\n观察cloud-consumer-order80与cloud-provider-payment8001两工程有重复代码（entities包下的实体）\n\n1、新建cloud-api-commons来存放公共代码和一些配置类等等\n\n2、添加pom文件\n\n3、将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移至cloud-api-commons工程下\n\n4、maven clean、install \n\n5、将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移除\n\n6、两个工程引入cloud-api-commons依赖\n\n```xml\n<dependency>\n    <groupId>com.ljx.springcloud</groupId>\n    <artifactId>cloud-api-commons</artifactId>\n    <version>${project.version}</version>\n</dependency>\n```\n\n## 知识点\n\n[![pPSgBTK.png](https://s1.ax1x.com/2023/07/29/pPSgBTK.png)](https://imgse.com/i/pPSgBTK)\n\n最终需要在上述项目基础上一点点添加这些组件\n\n## 服务注册中心\n\n### Eureka\n\n#### 基础知识\n\nEureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。\n\n![aaa.png](https://img-blog.csdnimg.cn/img_convert/3956561052b9dc3909f16f1ff26d01bb.png)\n\n**Eureka包含两个组件:Eureka Server和Eureka Client**\n\n**Eureka Server提供服务注册服务**\n\n各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n\n**EurekaClient通过注册中心进行访问**\n\n它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)\n\n#### EurekaServer服务端安装\n\neurekaServer端服务注册中心，类似物业公司\n\n1.创建名为cloud-eureka-server7001的Maven工程\n\n2.修改pom.xml\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n3.添加application.yml\n\n```yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n4.主启动\n\n```java\n@EnableEurekaServer\n```\n\n5.测试运行`EurekaMain7001`，浏览器输入`http://localhost:7001/`回车，会查看到Spring Eureka服务主页。\n\n#### 支付微服务8001入驻进EurekaServer\n\nEurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。\n\n1.创建名为cloud-eureka-server7001的Maven工程\n\n2.修改pom.xml\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n3.添加application.yml\n\n```yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n4.主启动\n\n```java\n@EnableEurekaClient\n```\n\n5.测试\n\n- 启动cloud-provider-payment8001和cloud-eureka-server7001工程（先启动）。\n\n- 浏览器输入 - http://localhost:7001/ 主页内的Instances currently registered with Eureka会显示cloud-provider-payment8001的配置文件application.yml设置的应用名`cloud-payment-service`\n\n6.自我保护机制\n\nEMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.\n\n紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。\n\n#### 订单微服务80入驻进EurekaServer\n\nEurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer，类似来上课消费的同学\n\n1.cloud-consumer-order80\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-order-service\n\neureka:\n  client:\n    #表示是否将自己注册进Eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n\n4.主启动\n\n```java\n@EnableEurekaClient\n```\n\n5.测试\n\n- 启动cloud-provider-payment8001、cloud-eureka-server7001（先启动）和cloud-consumer-order80这三工程。\n- 浏览器输入 http://localhost:7001 , 在主页的Instances currently registered with Eureka将会看到cloud-provider-payment8001、cloud-consumer-order80两个工程名。\n\n#### Eureka集群原理说明\n\n![img.png](https://img-blog.csdnimg.cn/img_convert/14570c4b7c4dd8653be6211da2675e45.png)\n\n问题：微服务RPC远程服务调用最核心的是什么？\n高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。\n\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。\n\n**互相注册，相互守望**。\n\n#### Eureka集群环境构建\n\n创建cloud-eureka-server7002工程\n\n- 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件，修改映射配置添加进hosts文件\n\n```\n127.0.0.1 eureka7001.com\n127.0.0.1 eureka7002.com\n```\n\n- 修改cloud-eureka-server7001配置文件\n\n```yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: eureka7001.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n    #集群指向其它eureka\n      defaultZone: http://eureka7002.com:7002/eureka/\n    #单机就是7001自己\n      #defaultZone: http://eureka7001.com:7001/eureka/\n```\n\n- 修改cloud-eureka-server7002配置文件\n\n```yml\nserver:\n  port: 7002\n\neureka:\n  instance:\n    hostname: eureka7002.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n    #集群指向其它eureka\n      defaultZone: http://eureka7001.com:7001/eureka/\n    #单机就是7002自己\n      #defaultZone: http://eureka7002.com:7002/eureka/\n```\n\n#### 订单支付两微服务注册进Eureka集群\n\n将它们的配置文件的eureka.client.service-url.defaultZone进行修改\n\n```yml\neureka:\n  client:\n    #表示是否将自己注册进Eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #注册到集群中\n      defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka\n```\n\n1. 先要启动EurekaServer，7001/7002服务\n2. 再要启动服务提供者provider，8001\n3. 再要启动消费者，80\n4. 浏览器输入 - http://localhost/consumer/payment/get/1\n\n#### 支付微服务集群配置\n\n新建cloud-provider-payment8002参考cloud-provicer-payment8001\n\n**负载均衡**\n\ncloud-consumer-order80订单服务访问地址不能写死\n\n```java\npublic static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\";\n```\n\n使用`@LoadBalanced`注解赋予RestTemplate负载均衡的能力\n\n```java\n@Configuration\npublic class ApplicationContextConfig {\n    @Bean\n    @LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n}\n```\n\n#### actuator微服务信息完善\n\n主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）\n\n修改cloud-provider-payment8001，cloud-provider-payment8002\n\n修改部分 - YML - eureka.instance.instance-id\n\n```yml\neureka:\n  ...\n  instance:\n    instance-id: payment8001 #显示名称\n    prefer-ip-address: true #显示ip地址\n```\n\n修改之后\n\neureka主页将显示payment8001，payment8002代替原来显示的IP地址。\n\n#### 服务发现Discovery\n\n对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n#### Eureka自我保护理论知识\n\n保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n\n如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:\n\n>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE\n\n**导致原因**\n\n一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。\n\n属于CAP里面的AP分支。\n\n**为什么会产生Eureka自我保护机制?**\n\n为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除\n\n**什么是自我保护模式?**\n\n认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。\n\n![b.png](https://img-blog.csdnimg.cn/img_convert/264b66e8099a3761beaea2ba44b8fc5e.png)\n\n**在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例**\n\n它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：**好死不如赖活着**。\n\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。\n\n**禁止自我保护**\n\n出厂默认，自我保护机制是开启的\n\n```yml\neureka:\n  ...\n  server:\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    enable-self-preservation: false\n    eviction-interval-timer-in-ms: 2000\n```\n\n关闭效果：spring-eureka主页会显示出一句：\n\n**THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.**\n\n### Zookeeper\n\nLinux下载\n\n```sh\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1-bin.tar.gz\n```\n\n解压\n\n```sh\ntar -zxvf apache-zookeeper-3.7.1-bin.tar.gz\n```\n\n启动\n\n```sh\n./zkServer.sh start\n```\n\n关闭防火墙\n\n```sh\nsudo systemctl stop ufw.service\n```\n\n#### 支付服务注册进zookeeper\n\n1.新建名为cloud-provider-payment8004的Maven工程。\n\n2.POM\n\n```xml\n      <!-- SpringBoot整合zookeeper客户端 -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n            <!--先排除自带的zookeeper3.5.3 防止与3.4.9起冲突-->\n            <exclusions>\n                <exclusion>\n                    <groupId>org.apache.zookeeper</groupId>\n                    <artifactId>zookeeper</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <!--添加zookeeper3.4.9版本-->\n        <dependency>\n            <groupId>org.apache.zookeeper</groupId>\n            <artifactId>zookeeper</artifactId>\n            <version>3.4.9</version>\n        </dependency>\n```\n\n3.YML\n\n```yml\n#8004表示注册到zookeeper服务器的支付服务提供者端口号\nserver:\n  port: 8004\n\n#服务别名----注册zookeeper到注册中心名称\nspring:\n  application:\n    name: cloud-provider-payment\n  cloud:\n    zookeeper:\n      connect-string: 127.0.0.1:2181 # 192.168.111.144:2181 #\n```\n\n4.主启动类\n\n```java\n@EnableDiscoveryClient//该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n```\n\n5.Controller\n\n```JAVA\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @RequestMapping(value = \"/payment/zk\")\n    public String paymentzk()\n    {\n        return \"springcloud with zookeeper: \"+serverPort+\"\\t\"+ UUID.randomUUID().toString();\n    }\n}\n```\n\n#### 订单服务注册进zookeeper\n\n1.新建cloud-consumerzk-order80（与上面类似）\n\n2.POM\n\n3.YML\n\n4.主启动\n\n5.配置类\n\n```java\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n```\n\n6.业务类\n\n```java\n@RestController\n@Slf4j\npublic class OrderZKController\n{\n    public static final String INVOKE_URL = \"http://cloud-provider-payment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(value = \"/consumer/payment/zk\")\n    public String paymentInfo()\n    {\n        String result = restTemplate.getForObject(INVOKE_URL+\"/payment/zk\",String.class);\n        return result;\n    }\n}\n```\n\n7.访问测试地址 - http://localhost/consumer/payment/zk\n\n### Consul\n\n官网链接：https://www.consul.io/\n\nConsul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。\n\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\n\n它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。\n\n**能干嘛？**\n\n- 服务发现 - 提供HTTP和DNS两种发现方式。\n- 健康监测 - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化\n- KV存储 - Key、Value的存储方式\n- 多数据中心 - Consul支持多数据中心\n- 可视化Web界面\n\n**相关命令**\n\n- 查看版本：`consul -v`\n- 开发模式启动`consul agent -dev`\n\n浏览器输入 - http://localhost:8500/ - 打开Consul控制页。\n\n#### 服务提供者注册进Consul\n\n1.新建Module支付服务provider8006\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yaml\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n```\n\n4.主启动类\n\n```java\n@EnableDiscoveryClient\n```\n\n5.业务类Controller\n\n```java\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @RequestMapping(value = \"/payment/consul\")\n    public String paymentConsul()\n    {\n        return \"springcloud with consul: \"+serverPort+\"\\t   \"+ UUID.randomUUID().toString();\n    }\n}\n```\n\n6.验证测试\n\n- http://localhost:8006/payment/consul\n- http://localhost:8500 - 会显示provider8006\n\n#### 服务消费者注册进Consul\n\n1.新建Module消费服务order80 - cloud-consumerconsul-order80\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n</dependency>\n```\n\n3.YML\n\n```java\n###consul服务端口号\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-consumer-order\n####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n```\n\n4.主启动类\n\n```java\n@EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n```\n\n5.配置Bean\n\n```java\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n```\n\n6.业务类\n\n```java\n@RestController\n@Slf4j\npublic class OrderConsulController\n{\n    public static final String INVOKE_URL = \"http://consul-provider-payment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(value = \"/consumer/payment/consul\")\n    public String paymentInfo()\n    {\n        String result = restTemplate.getForObject(INVOKE_URL+\"/payment/consul\",String.class);\n        return result;\n    }\n}\n```\n\n7.验证测试\n\n运行consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80\n\nhttp://localhost:8500/ 主页会显示出consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80三服务。\n\n8.访问测试地址 - http://localhost/consumer/payment/consul\n\n### 三个注册中心异同点\n\n| 组件名    | 语言CAP | 服务健康检查 | 对外暴露接口 | Spring Cloud集成 |\n| --------- | ------- | ------------ | ------------ | ---------------- |\n| Eureka    | Java    | AP           | 可配支持     | HTTP             |\n| Consul    | Go      | CP           | 支持         | HTTP/DNS         |\n| Zookeeper | Java    | CP           | 支持客户端   | 已集成           |\n\nCAP：\n\n- C：Consistency (强一致性)\n- A：Availability (可用性)\n- P：Partition tolerance （分区容错性)\n\n![111.png](https://img-blog.csdnimg.cn/img_convert/b41e0791c9652955dd3a2bc9d2d60983.png)\n\n**最多只能同时较好的满足两个。**\n\nCAP理论的核心是：**一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求**。\n\n因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:\n\nCA - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。\nCP - 满足一致性，分区容忍必的系统，通常性能不是特别高。\nAP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n#### AP架构（Eureka）\n\n当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\n\n结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n\n![123.png](https://img-blog.csdnimg.cn/img_convert/2d07748539300b9c466eb1d9bac5cd1b.png)\n\n#### CP架构（ZooKeeper/Consul）\n\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。\n\n结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。\n\n![e21x.png](https://img-blog.csdnimg.cn/img_convert/c6f2926a97420015fcebc89b094c5598.png)\n\nCP 与 AP 对立同一的矛盾关系。\n\n## 服务调用\n\n### Ribbon\n\nSpring Cloud Ribbon是基于Netflix Ribbon实现的一套**客户端负载均衡的工具**。\n\n简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供**客户端的软件负载均衡算法和服务调用**。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。\n\nRibbon未来可能被Spring Cloud LoadBalacer替代。\n\n**LB负载均衡(Load Balance)是什么**\n\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。\n\n常见的负载均衡有软件Nginx，LVS，硬件F5等。\n\n**Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别**\n\nNginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\nRibbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\n\n**集中式LB**\n\n即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方;\n\n**进程内LB**\n\n将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\nRibbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n一句话\n\n**负载均衡 + RestTemplate调用**\n\n#### Ribbon的负载均衡和Rest调用\n\n总结：Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。\n\n![1dc.png](https://img-blog.csdnimg.cn/img_convert/145b915e56a85383b3ad40f0bb2256e0.png)\n\nRibbon在工作时分成两步：\n\n- 第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。\n- 第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。\n\n其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。\n\n**`spring-cloud-starter-netflix-eureka-client`自带了`spring-cloud-starter-ribbon`引用**\n\n#### Ribbon默认自带的负载规则\n\nlRule：根据特定算法中从服务列表中选取一个要访问的服务\n\n![asdacg2.png](https://img-blog.csdnimg.cn/img_convert/87243c00c0aaea211819c0d8fc97e445.png)\n\n- RoundRobinRule 轮询\n- RandomRule 随机\n- RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重\n- WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择\n- BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n- AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例\n- ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器\n\n**Ribbon负载规则替换**\n\n1.修改cloud-consumer-order80\n\n2.注意配置细节\n\n官方文档明确给出了警告：**这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了（也就是说不要将Ribbon配置类与主启动类同包**）\n\n3.新建package - com.lun.myrule\n\n4.在com.ljx.myrule下新建MySelfRule规则类\n\n```java\n@Configuration\npublic class MySelfRule {\n\n    @Bean\n    public IRule myRule(){\n        return new RandomRule();\n    }\n}\n```\n\n5.主启动类添加\n\n```java\n@RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\", configuration = MySelfRule.class)\n```\n\n### OpenFeign\n\nFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。\n\n前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\n\n**Feign集成了Ribbon**\n\n利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，**通过feign只需要定义服务绑定接口且以声明式的方法**，优雅而简单的实现了服务调用。\n\n#### Feign和OpenFeign两者区别\n\n**Feign**是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-feign</artifactId>\n</dependency>\n```\n\npenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVc的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n#### OpenFeign服务调用\n\n接口+注解：微服务调用接口 + @FeignClient\n\n1.新建cloud-consumer-feign-order80\n\n2.POM\n\n```xml\n<dependency>\n     <groupId>org.springframework.cloud</groupId>\n     <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n```\n\n4.主启动\n\n```java\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderFeignMain80.class, args);\n    }\n}\n```\n\n5.业务类\n\n业务逻辑接口+@FeignClient配置调用provider服务\n\n新建PaymentFeignService接口并新增注解@FeignClient\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")\npublic interface PaymentFeignService\n{\n    @GetMapping(value = \"/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\n}\n```\n\n**注意：**若有公共前缀api的请求，需要修改为`@FeignClient(value = \"xx\", path=\"/api\")`\n\nController类\n\n```java\n@RestController\n@Slf4j\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n\n    @GetMapping(value = \"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    {\n        return paymentFeignService.getPaymentById(id);\n    }\n}\n```\n\n6.测试\n\n先启动2个eureka集群7001/7002，再启动2个微服务8001/8002，最后启动OpenFeign启动\n\n访问http://localhost/consumer/payment/get/1\n\n**Feign自带负载均衡配置项**\n\n#### OpenFeign超时控制\n\n**超时设置，故意设置超时演示出错情况**\n\n1.服务提供方8001/8002故意写暂停程序\n\n```java\n    @GetMapping(value = \"/payment/feign/timeout\")\n    public String paymentFeignTimeout()\n    {\n        // 业务逻辑处理正确，但是需要耗费3秒钟\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return serverPort;\n    }\n```\n\n2.服务消费方80添加超时方法PaymentFeignService\n\n```java\n@GetMapping(value = \"/payment/feign/timeout\")\npublic String paymentFeignTimeout();\n```\n\n3.服务消费方80添加超时方法OrderFeignController\n\n```java\n@GetMapping(value = \"/consumer/payment/feign/timeout\")\npublic String paymentFeignTimeout()\n{\n    // OpenFeign客户端一般默认等待1秒钟\n    return paymentFeignService.paymentFeignTimeout();\n}\n```\n\n4.测试：\n\n多次刷新http://localhost/consumer/payment/feign/timeout\n\n将会跳出错误Spring Boot默认错误页面，主要异常：`feign.RetryableException:Read timed out executing GET http://CLOUD-PAYMENT-SERVCE/payment/feign/timeout。`\n\n**OpenFeign默认等待1秒钟，超过后报错**\n\n**YML文件里需要开启OpenFeign客户端超时控制**\n\n```yml\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n```\n\n#### OpenFeign日志增强\n\n**日志打印功能**\n\nFeign提供了日志打印功能，我们可以通过配置来调整日恙级别，从而了解Feign 中 Http请求的细节。\n\n说白了就是对Feign接口的调用情况进行监控和输出\n\n**日志级别**\n\n- NONE：默认的，不显示任何日志;\n- BASIC：仅记录请求方法、URL、响应状态码及执行时间;\n- HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;\n- FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。\n\n**配置日志bean**\n\n```java\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel()\n    {\n        return Logger.Level.FULL;\n    }\n}\n```\n\n**YML文件里需要开启日志的Feign客户端**\n\n```yml\nlogging:\n  level:\n    # feign日志以什么级别监控哪个接口\n    com.ljx.springcloud.service.PaymentFeignService: debug\n```\n\n**后台日志查看**\n\n得到更多日志信息\n\n## 服务降级\n\n**分布式系统面临的问题**\n\n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n\n**服务雪崩**\n\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\n对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n\n所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n\n### Hystrix\n\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n\n\"断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n**主要功能**\n\n- 服务降级\n- 服务熔断\n- 接近实对的监控\n\n**服务降级**\n\n服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback\n\n哪些情况会出发降级？\n\n- 程序运行导常\n\n- 超时\n- 服务熔断触发服务降级\n- 线程池/信号量打满也会导致服务降级\n\n**服务熔断**\n\n类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。\n\n服务的降级 -> 进而熔断 -> 恢复调用链路\n\n**服务限流**\n\n秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。\n\n#### Hystrix支付微服务构建\n\n1.新建cloud-provider-hygtrix-payment8001\n\n2.POM\n\n```xml\n<dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-provider-hystrix-payment\n\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n4.主启动\n\n```java\n@EnableEurekaClient\n```\n\n5.业务类\n\nservice\n\n```java\n@Service\npublic class PaymentService {\n    /**\n     */\n    public String paymentInfo_OK(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  paymentInfo_OK,id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\";\n    }\n\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        try { TimeUnit.MILLISECONDS.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 3\";\n    }\n}\n```\n\ncontroller\n\n```java\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Resource\n    private PaymentService paymentService;\n\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentInfo_OK(id);\n        log.info(\"*****result: \"+result);\n        return result;\n    }\n\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentInfo_TimeOut(id);\n        log.info(\"*****result: \"+result);\n        return result;\n    }\n}\n```\n\n6.正常测试\n\n以上述为根基平台，从正确 -> 错误 -> 降级熔断 -> 恢复。\n\n#### JMeter高并发压测后卡顿\n\n**上述在非高并发情形下，还能勉强满足**\n\n**Jmeter压测结论**\n\n上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢\n\n#### Hystrix订单微服务\n\n1.新建 - cloud-consumer-feign-hystrix-order80\n\n2.POM\n\n```xml\n<dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n4.主启动\n\n5.业务类\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\" /*,fallback = PaymentFallbackService.class*/)\npublic interface PaymentHystrixService\n{\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\n\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\n}\n```\n\n```java\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    }\n\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n}\n```\n\n6.正常测试\n\n7.高并发测试\n\n2W个线程压8001，消费端80微服务再去访问正常的Ok微服务8001地址，消费者80被拖慢\n\n原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。\n\n正因为有上述故障或不佳表现才有我们的降级/容错/限流等技术诞生。\n\n#### 降级容错解决的维度要求\n\n超时导致服务器变慢(转圈) ---》超时不再等待\n\n出错(宕机或程序运行出错) ---》 出错要有兜底\n\n解决：\n\n- 对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。\n- 对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。\n- 对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。\n\n#### Hystrix服务降级支付fallback\n\n降级配置 - `@HystrixCommand`\n\n**设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback**。\n\n—旦调用服务方法失败并抛出了错误信息后，会自动调用`@HystrixCommand`标注好的`fallbackMethod`调用类中的指定方法\n\n```java\n@Service\npublic class PaymentService{\n\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\", commandProperties = {\n            @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")\n    })\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        //int age = 10/0;\n        try { TimeUnit.MILLISECONDS.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): \";\n    }\n\n    //用来善后的方法\n    public String paymentInfo_TimeOutHandler(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o(╥﹏╥)o\";\n    }\n    \n}\n```\n\n上面故意制造两种异常:\n\n1. int age = 10/0，计算异常\n2. 我们能接受3秒钟，它运行5秒钟，超时异常。\n\n当前服务不可用了，做服务降级，兜底的方案都是`paymentInfo_TimeOutHandler`\n\n**主启动类激活**\n\n添加新注解`@EnableCircuitBreaker`\n\n#### Hystrix服务降级订单fallback\n\n1.YML\n\n```yml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n#开启\nfeign:\n  hystrix:\n    enabled: true\n```\n\n2.主启动添加`@EnableHystrix`\n\n3.业务类\n\n```java\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\",commandProperties = {\n            @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"1500\")\n    })\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        //int age = 10/0;\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n    \n    //善后方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\n    }\n}\n```\n\n#### Hystrix全局服务降级DefaultProperties\n\n**前问题1** 每个业务方法对应一个兜底的方法，代码膨胀\n\n**解决方法**\n\n1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明\n\n1:N除了个别重要核心业务有专属，其它普通的可以通过`@DefaultProperties(defaultFallback = “xxx”)`统一跳转到统一处理结果页面\n\n通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量\n\n```java\n@RestController\n@Slf4j\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\npublic class OrderHystirxController {\n\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    }\n\n//    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\", commandProperties = {\n//            @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")\n//    })\n    @HystrixCommand//用全局的fallback方法\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n\n    //善后方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\n    }\n\n    // 下面是全局fallback方法\n    public String payment_Global_FallbackMethod()\n    {\n        return \"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~\";\n    }\n}\n```\n\n#### Hystrix通配服务降级FeignFallback\n\n**目前问题2** 统一和自定义的分开，代码混乱\n\n**服务降级，客户端去调用服务端，碰上服务端宕机或关闭**\n\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为[Feign](https://so.csdn.net/so/search?q=Feign&spm=1001.2101.3001.7020)客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n\n**未来我们要面对的异常**\n\n- 运行\n- 超时\n- 宕机\n\n1.新建PaymentFallbackService类实现PaymentHystrixService接口\n\n```java\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackService implements PaymentHystrixService\n{\n    @Override\n    public String paymentInfo_OK(Integer id)\n    {\n        return \"-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o\";\n    }\n\n    @Override\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        return \"-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o\";\n    }\n}\n```\n\n2.YML\n\n```yml\nfeign:\n  hystrix:\n    enabled: true\n```\n\n3.PaymentHystrixService接口\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\" ,\n             fallback = PaymentFallbackService.class)//指定PaymentFallbackService类\npublic interface PaymentHystrixService\n{\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\n\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\n}\n```\n\n4.测试\n\n单个eureka先启动7001，PaymentHystrixMain8001启动\n\n正常访问测试 - http://localhost/consumer/payment/hystrix/ok/1，故意关闭微服务8001\n\n客户端自己调用提示 - 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。\n\n#### Hystrix服务熔断理论\n\n断路器，相当于保险丝。\n\n**熔断机制概述**\n\n熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，只有当成功率挺高到一定阈值才会关闭。熔断机制的注解是`@HystrixCommand`。\n\n#### Hystrix之服务熔断案例\n\n[Hutool国产工具类](https://hutool.cn/)\n\n修改cloud-provider-hystrix-payment8001\n\nservice层\n\n```java\n@Service\npublic class PaymentService{    \n   \n    //=====服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n            @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),// 是否开启断路器\n            @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),// 请求次数\n            @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"), // 时间窗口期\n            @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),// 失败率达到多少后跳闸\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id) {\n        if(id < 0) {\n            throw new RuntimeException(\"******id 不能负数\");\n        }\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id) {\n        return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\n    }\n\n}\n```\n\ncontroller层\n\n```java\n@GetMapping(\"/payment/circuit/{id}\")\npublic String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n{\n    String result = paymentService.paymentCircuitBreaker(id);\n    log.info(\"****result: \"+result);\n    return result;\n}\n```\n\n**测试**\n\n多次错误，再来次正确，但错误得显示\n\n重点测试 - 多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行\n\n#### Hystrix服务熔断总结\n\n**熔断类型**\n\n- 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。\n- 熔断关闭：熔断关闭不会对服务进行熔断。\n- 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。\n\n**断路器开启或者关闭的条件**\n\n- 到达以下阀值，断路器将会开启：\n  - 当满足一定的阀值的时候（默认10秒内超过20个请求次数)\n  - 当失败率达到一定的时候（默认10秒内超过50%的请求失败)\n- 当开启的时候，所有请求都不会进行转发\n- 一段时间之后（默认是5秒)，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。\n\n**断路器打开之后**\n\n1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n\n2：原来的主逻辑要如何恢复呢？\n\n对于这一问题，hystrix也为我们实现了自动恢复功能。\n\n当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n\n**All配置**\n\n```java\n@HystrixCommand(fallbackMethod = \"fallbackMethod\", \n                groupKey = \"strGroupCommand\", \n                commandKey = \"strCommand\", \n                threadPoolKey = \"strThreadPool\",\n                \n                commandProperties = {\n                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离\n                    @HystrixProperty(name = \"execution.isolation.strategy\", value = \"THREAD\"),\n                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\n                    @HystrixProperty(name = \"execution.isolation.semaphore.maxConcurrentRequests\", value = \"10\"),\n                    // 配置命令执行的超时时间\n                    @HystrixProperty(name = \"execution.isolation.thread.timeoutinMilliseconds\", value = \"10\"),\n                    // 是否启用超时时间\n                    @HystrixProperty(name = \"execution.timeout.enabled\", value = \"true\"),\n                    // 执行超时的时候是否中断\n                    @HystrixProperty(name = \"execution.isolation.thread.interruptOnTimeout\", value = \"true\"),\n                    \n                    // 执行被取消的时候是否中断\n                    @HystrixProperty(name = \"execution.isolation.thread.interruptOnCancel\", value = \"true\"),\n                    // 允许回调方法执行的最大并发数\n                    @HystrixProperty(name = \"fallback.isolation.semaphore.maxConcurrentRequests\", value = \"10\"),\n                    // 服务降级是否启用，是否执行回调函数\n                    @HystrixProperty(name = \"fallback.enabled\", value = \"true\"),\n                    // 是否启用断路器\n                    @HystrixProperty(name = \"circuitBreaker.enabled\", value = \"true\"),\n                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\n                    @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"20\"),\n                    \n                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 \"打开\" 状态，否则就设置为 \"关闭\" 状态。\n                    @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\"),\n                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 \"半开\" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 \"打开\" 状态，如果成功就设置为 \"关闭\" 状态。\n                    @HystrixProperty(name = \"circuitBreaker.sleepWindowinMilliseconds\", value = \"5000\"),\n                    // 断路器强制打开\n                    @HystrixProperty(name = \"circuitBreaker.forceOpen\", value = \"false\"),\n                    // 断路器强制关闭\n                    @HystrixProperty(name = \"circuitBreaker.forceClosed\", value = \"false\"),\n                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\n                    @HystrixProperty(name = \"metrics.rollingStats.timeinMilliseconds\", value = \"10000\"),\n                    \n                    // 该属性用来设置滚动时间窗统计指标信息时划分\"桶\"的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 \"桶\" 来累计各度量值，每个\"桶\"记录了一段时间内的采集指标。\n                    // 比如 10 秒内拆分成 10 个\"桶\"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常\n                    @HystrixProperty(name = \"metrics.rollingStats.numBuckets\", value = \"10\"),\n                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.enabled\", value = \"false\"),\n                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.timeInMilliseconds\", value = \"60000\"),\n                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.numBuckets\", value = \"60000\"),\n                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\n                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\n                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.bucketSize\", value = \"100\"),\n                    \n                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\n                    @HystrixProperty(name = \"metrics.healthSnapshot.intervalinMilliseconds\", value = \"500\"),\n                    // 是否开启请求缓存\n                    @HystrixProperty(name = \"requestCache.enabled\", value = \"true\"),\n                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中\n                    @HystrixProperty(name = \"requestLog.enabled\", value = \"true\"),\n\n                },\n                threadPoolProperties = {\n                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\n                    @HystrixProperty(name = \"coreSize\", value = \"10\"),\n                    // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。\n                    @HystrixProperty(name = \"maxQueueSize\", value = \"-1\"),\n                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\n                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\n                    @HystrixProperty(name = \"queueSizeRejectionThreshold\", value = \"5\"),\n                }\n               )\npublic String doSomething() {\n\t...\n}\n```\n\n#### Hystrix图形化Dashboard搭建\n\n**概述**\n\n除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。\n\nNetflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\n\n**仪表盘9001**\n\n1新建cloud-consumer-hystrix-dashboard9001\n\n2.POM\n\n```xml\n<dependency>\n       <groupId>org.springframework.cloud</groupId>\n       <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 9001\n```\n\n4.HystrixDashboardMain9001+新注解`@EnableHystrixDashboard`\n\n5.所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n6.浏览器输入http://localhost:9001/hystrix\n\n#### Hystrix图形化Dashboard监控实战\n\n**修改cloud-provider-hystrix-payment8001**\n\n注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class PaymentHystrixMain8001\n{\n    public static void main(String[] args) {\n            SpringApplication.run(PaymentHystrixMain8001.class, args);\n    }\n\n\n    /**\n     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     *ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"，\n     *只要在自己的项目里配置上下面的servlet就可以了\n     *否则，Unable to connect to Command Metric Stream 404\n     */\n    @Bean\n    public ServletRegistrationBean getServlet() {\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings(\"/hystrix.stream\");\n        registrationBean.setName(\"HystrixMetricsStreamServlet\");\n        return registrationBean;\n    }\n}\n```\n\n**监控测试**\n\n启动1个eureka\n\n启动8001，9001\n\n**观察监控窗口**\n\n9001监控8001 - 填写监控地址 - http://localhost:8001/hystrix.stream 到 http://localhost:9001/hystrix页面的输入框。\n\n测试地址\n\n- http://localhost:8001/payment/circuit/1\n- http://localhost:8001/payment/circuit/-1\n- 测试通过\n- 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。\n\n## 服务网关\n\n### GateWay\n\n**概述**\n\nCloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;\n\n但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代\n\n![axh25f.png](https://img-blog.csdnimg.cn/img_convert/54b61d819aa1630bc61732de340b55b4.png)\n\nGateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。\n\n**SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty**。\n\n**作用**\n\n- 方向代理\n- 鉴权\n- 流量控制\n- 熔断\n- 日志监控\n- …\n\n**微服务架构中网关的位置**\n\n![asd14667.png](https://img-blog.csdnimg.cn/img_convert/5877d4b9035ead9cd2d037609dceb442.png)\n\n#### **Gateway工作流程**\n\n**三大核心概念**\n\n- Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；\n- Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由；\n- Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。\n  \n\n![d1c.png](https://img-blog.csdnimg.cn/img_convert/62be54501c6e2b95620b79cc918a2e9a.png)\n\n客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。\n\nHandler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post\"）执行业务逻辑。\n\nFilter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n\n核心逻辑：**路由转发 + 执行过滤器链**。\n\n#### Gateway9527搭建\n\n1.新建Mod\tule - cloud-gateway-gateway9527\n\n2.POM\n\n4.业务类 无\n\n5.主启动类\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class GateWayMain9527\n{\n    public static void main(String[] args) {\n        SpringApplication.run(GateWayMain9527.class, args);\n    }\n}\n```\n\n我们目前不想暴露8001端口，希望在8001外面套一层9527\n\n7.YML新增网关配置\n\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n#############################新增网关配置###########################\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n####################################################################\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n8.测试\n\n启动7001，启动8001-cloud-provider-payment8001，启动9527网关\n\n访问说明\n\n- 添加网关前 - http://localhost:8001/payment/get/1\n- 添加网关后 - http://localhost:9527/payment/get/1\n- 两者访问成功，返回相同结果（可以通过9527端口访问8001端口接口）\n\n#### Gateway配置路由的两种方式\n\n**1.在配置文件yml中配置，见上一章节**\n\n**2.代码中注入RouteLocator的Bean**\n\ncloud-gateway-gateway9527业务实现\n\n```java\n@Configuration\npublic class GateWayConfig\n{\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n\n        routes.route(\"path_route_ljx\",\n                r -> r.path(\"\")\n                        .uri(\"https://www.baidu.com\")).build();\n\n        return routes.build();\n    }\n}\n```\n\n浏览器输入http://localhost:9527，返回https://www.baidu.com相同的页面。\n\n#### GateWay配置动态路由\n\n默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建**动态路由进行转发，从而实现动态路由的功能**（不写死一个地址）\n\n**POM**\n\n cloud-gateway-gateway9527的POM中添加\n\n```xml\n<!--eureka-client-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n**YML**\n\n需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。\n\nlb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。\n\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n#############################新增网关配置###########################\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n####################################################################\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n**测试**\n\n浏览器输入 - http://localhost:9527/payment/lb\n\n不停刷新页面，8001/8002两个端口切换。\n\n#### GateWay常用的Predicate\n\n**常用的Route Predicate Factory**\n\nThe After Route Predicate Factory\nThe Before Route Predicate Factory\nThe Between Route Predicate Factory\nThe Cookie Route Predicate Factory\nThe Header Route Predicate Factory\nThe Host Route Predicate Factory\nThe Method Route Predicate Factory\nThe Path Route Predicate Factory\nThe Query Route Predicate Factory\nThe RemoteAddr Route Predicate Factory\nThe weight Route Predicate Factory\n\n**The After Route Predicate Factory**\n\n**作用：只有在规定的时间之后启动才能生效**\n\n在yml中添加\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: after_route\n        uri: lb://cloud-payment-service\n        predicates:\n        - Path=/payment/get/**      \n        # 这个时间后才能起效\n        - After=2023-08-02T14:59:26.090582100+08:00[Asia/Shanghai]\n```\n\n可以通过下述方法获得上述格式的时间戳字符串\n\n```java\nZonedDateTime zbj = ZonedDateTime.now(); // 默认时区\nSystem.out.println(zbj);\n```\n\n**The Between Route Predicate Factory**\n\n**作用：只有在规定的时间范围内启动才生效**\n\n在yml中添加\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: between_route\n        uri: lb://cloud-payment-service\n        # 两个时间点之间\n        predicates:\n         - Path=/payment/get/**   \n        - Between=2024-01-20T17:42:47.789-07:00[America/Denver], 2023-08-02T14:59:26.090582100+08:00[Asia/Shanghai]\n```\n\n**The Cookie Route Predicate Factory**\n\n作用：**只有带username=ljx的cookie的请求才有效**\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: cookie_route\n        uri: lb://cloud-payment-service\n        predicates:\n        - Cookie=username,ljx\n```\n\n**he Header Route Predicate Factory**\n\n作用：只有带X-Request-Id=正整数的请求头才有效\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: header_route\n        uri: lb://cloud-payment-service\n        predicates:\n        - Header=X-Request-Id, \\d+\n```\n\n**小结**\n\nPredicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。\n\n#### GateWay的Filter\n\n路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。\n\nSpring Cloud Gateway的Filter:\n\n- 生命周期：\n  - pre\n  - post\n- 种类（具体看官方文档）：\n  - GatewayFilter - 有31种\n  - GlobalFilter - 有10种\n\n常用的GatewayFilter：`AddRequestParameter`，`GatewayFilter`\n\n自定义全局GlobalFilter：\n\n两个主要接口介绍：\n\n1. `GlobalFilter`\n2. `Ordered`\n\n能干什么：\n\n1. 全局日志记录\n2. 统一网关鉴权\n3. …\n\n代码案例：\n\nGateWay9527项目添加MyLogGateWayFilter类：\n\n```java\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    \n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    {\n        log.info(\"***********come in MyLogGateWayFilter:  \"+new Date());\n        // 处理只有带了uname的请求才能通过\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n\n        if(uname == null)\n        {\n            log.info(\"*******用户名为null，非法用户，o(╥﹏╥)o\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder()\n    {\n        return 0;\n    }\n}\n```\n\n测试，浏览器输入：\n\n- http://localhost:9527/payment/lb - 反问异常\n- http://localhost:9527/payment/lb?uname=abc - 正常反问\n\n## 服务配置\n\n### config\n\n#### Config分布式配置中心介绍\n\n**分布式系统面临的配置问题**\n\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。\n\nSpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……\n\n![dsaxcj1.png](https://img-blog.csdnimg.cn/img_convert/d5462e3b8c3a063561f5f8fc7fde327e.png)**\n\nSpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n\nSpringCloud Config分为**服务端**和客户端两部分。\n\n- 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。\n\n- 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。\n\n**能干嘛**\n\n- 集中管理配置文件\n- 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n- 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n- 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n- 将配置信息以REST接口的形式暴露 - post/crul访问刷新即可…\n  \n\n**与GitHub整合配置**\n\n由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式。\n\n#### Config配置总控中心搭建\n\n用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository。\n\n由上一步获得刚新建的git地址 - `git@github.com:abc/springcloud-config.git`。\n\n本地硬盘目录上新建git仓库并clone。\n\n- 工作目录为D:\\SpringCloud2021\n- `git clone git@github.com:abc/springcloud-config.git`\n\n此时在工作目录会创建名为springcloud-config的文件夹。\n\n在springcloud-config的文件夹种创建三个配置文件（为本次教学使用的）,随后git add .，git commit -m \"sth\"等一系列上传操作上传到springcloud-config的新Repository。\n\n- config-dev.yml\n\n```yaml\nconfig:\n  info: \"master branch,springcloud-config/config-dev.yml version=7\"\n```\n\n- config-prod.yml\n\n```yaml\nconfig:\n  info: \"master branch,springcloud-config/config-prod.yml version=1\"\n```\n\n- config-test.yml\n\n```yaml\nconfig:\n  info: \"master branch,springcloud-config/config-test.yml version=1\" \n```\n\n新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig Center\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/lijunxi666/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n          skip-ssl-validation: true\n      ####读取分支\n      label: master\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n```\n\n主启动类加上`@EnableConfigServer`\n\nwindows下修改hosts文件，增加映射\n\n```\n127.0.0.1 config-3344.com\n```\n\n**测试**\n\n启动ConfigCenterMain3344\n\n浏览器防问 - http://config-3344.com:3344/master/config-dev.yml\n\n页面返回结果：\n\n```yml\nconfig:\n  info: \"master branch,springcloud-config/config-dev.yml version=7\"\n```\n\n**访问文件的路径**\n\n重要配置细节总结\n\n- /{name}-{profiles}.yml\n- /{label}-{name}-{profiles}.yml\n- label：分支(branch)\n- name：服务名\n- profiles：环境(dev/test/prod)\n\n成功实现了用SpringCloud Config通过GitHub获取配置信息\n\n#### Config客户端配置与测试\n\n**新建cloud-config-client-3355**\n\n**POM**\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n**bootstrap.yml**\n\napplicaiton.yml是用户级的资源配置项\n\nbootstrap.yml是系统级的，优先级更加高\n\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n\n**主启动**添加`@EnableEurekaClient`\n\n**业务类**\n\n```java\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/configInfo\")\n    public String getConfigInfo()\n    {\n        return configInfo;\n    }\n}\n```\n\n**测试**\n\n- 启动Config配置中心3344微服务并自测\n  - http://config-3344.com:3344/master/config-prod.yml\n  - http://config-3344.com:3344/master/config-dev.yml\n\n- 启动3355作为Client准备访问\n  - http://localhost:3355/configlnfo\n\n**成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息可题随时而来**\n\n**分布式配置的动态刷新问题**\n\n- Linux运维修改GitHub上的配置文件内容做调整\n- 刷新3344，发现ConfigServer配置中心立刻响应\n- 刷新3355，发现ConfigClient客户端没有任何响应\n- 3355没有变化除非自己重启或者重新加载\n- 难到每次运维修改配置文件，客户端都需要重启??噩梦\n\n### Config动态刷新手动版\n\n避免每次更新配置都要重启客户端微服务3355\n\n**动态刷新步骤**：\n\n修改3355模块\n\nPOM引入actuator监控\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n修改YML，添加暴露监控端口配置：\n\n```yaml\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n业务类Controller添加`@RefreshScope`\n\n**测试**\n\n此时修改github配置文件内容 -> 访问3344 -> 访问3355：http://localhost:3355/configInfo\n\n发现3355的内容**并没**刷新\n\n**还需要一步**\n\n需要运维人员发送Post请求刷新3355\n\n```\ncurl -X POST \"http://localhost:3355/actuator/refresh\"\n```\n\n再次测试：http://localhost:3355/configInfo\n\n3355 **改了**。\n\n成功实现了客户端3355刷新到最新配置内容，避免了服务重启\n\n**存在的问题**\n\n- 假如有多个微服务客户端3355/3366/3377\n- 每个微服务都要执行—次post请求，手动刷新?\n- 可否广播，一次通知，处处生效?\n- 我们想大范围的自动刷新，求方法\n\n这时候就需要用到**消息总线**\n\n## 消息总线\n\n一言以蔽之，分布式自动刷新配置功能。\n\nSpring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。\n\n![d1xased.png](https://img-blog.csdnimg.cn/img_convert/458fd679c01274ca84f785e1f75c1336.png)\n\nSpring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\n\n**为何被称为总线**\n\n什么是总线？\n\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\n\n基本原理\n\nConfigClient实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。\n\n### RabbitMQ\n\n#### 环境配置\n\n严格遵循erlang和rabbitmq版本对应：[RabbitMQ Erlang Version Requirements — RabbitMQ](https://www.rabbitmq.com/which-erlang.html)\n\n- 安装Erlang，下载地址：http://erlang.org/download/otp_win64_21.3.exe\n\n- 安装RabbitMQ，下载地址：https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.14/rabbitmq-server-3.7.14.exe\n\n- 打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\\devSoft\\RabbitMQ Scrverk\\rabbitmq_server-3.7.14\\sbin\n\n- 输入以下命令启动管理功能`rabbitmq-plugins enable rabbitmq _management`\n\n这样就可以添加可视化插件。\n\n- 访问地址查看是否安装成功：http://localhost:15672/\n- 输入账号密码并登录：guest guest\n\n#### Bus动态刷新全局广播的设计思想和选型\n\n必须先具备良好的RabbitMQ环境先\n\n演示广播效果，增加复杂度，再以3355为模板再制作一个3366\n\n1.新建cloud-config-client-3366\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址\n\n#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n4.主启动添加`@EnableEurekaClient`\n\n5.controller\n\n```java\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/configInfo\")\n    public String configInfo()\n    {\n        return \"serverPort: \"+serverPort+\"\\t\\n\\n configInfo: \"+configInfo;\n    }\n\n}\n```\n\n**设计思想**\n\n1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置\n\n![dascx.png](https://img-blog.csdnimg.cn/img_convert/3a0975f4bac7393fe406821531e9daef.png)\n\n2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置\n\n![2150vg0.png](https://img-blog.csdnimg.cn/img_convert/e2809f728b8eb3e776883e4f905b8712.png)\n\n图二的架构显然更加适合，图—不适合的原因如下：\n\n- 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\n\n- 破坏了微服务各节点的对等性。\n\n- 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。\n\n#### Bus动态刷新全局广播配置实现\n\n**给cloud-config-center-3344配置中心服务端添加消息总线支持**\n\nPOM\n\n```xml\n<!--添加消息总线RabbitNQ支持-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-bus-amap</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org-springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloud-config.git #GitHub上面的git仓库名字\n        ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n#rabbitmq相关配置<--------------------------\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n##rabbitmq相关配置,暴露bus刷新配置的端点<--------------------------\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n```\n\n**给cloud-config-client-3355客户端添加消息总线支持**\n\nPOM\n\n```xml\n<!--添加消息总线RabbitNQ支持-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-bus-amap</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org-springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloud-config.git #GitHub上面的git仓库名字\n        ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n#rabbitmq相关配置<--------------------------\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n##rabbitmq相关配置,暴露bus刷新配置的端点<--------------------------\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n```\n\n**给cloud-config-client-3366客户端添加消息总线支持**\n\nPOM\n\n```xml\n<!--添加消息总线RabbitNQ支持-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-bus-amap</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org-springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址\n\n#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口<-----------------------\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n**测试**\n\n- 启动\n  - EurekaMain7001\n  - EurekaMain7002\n  - ConfigcenterMain3344\n  - ConfigclientMain3355\n  - ConfigclicntMain3366\n\n- 运维工程师\n  - 修改Github上配置文件内容，增加版本号\n  - 发送POST请求\n    - `curl -X POST \"http://localhost:3344/actuator/bus-refresh\"`\n    - **—次发送，处处生效**\n\n- 配置中心\n  - http://config-3344.com:3344/config-dev.yml\n- 客户端\n  - http://localhost:3355/configlnfo\n  - http://localhost:3366/configInfo\n  - 获取配置信息，发现都已经刷新了\n\n**—次修改，广播通知，处处生效**\n\n#### Bus动态刷新定点通知\n\n不想全部通知，只想定点通知\n\n- 只通知3355\n- 不通知3366\n\n简单一句话 - **指定具体某一个实例生效而不是全部**\n\n- 公式：http://localhost:3344/actuator/bus-refresh/{destination}\n- /bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例\n\n案例\n\n- 我们这里以刷新运行在3355端口上的config-client（配置文件中设定的应用名称）为例，只通知3355，不通知3366\n- `curl -X POST \"http://localhost:3344/actuator/bus-refresh/config-client:3355`\n\n**消息通知总结**\n\n![21cx0943.png](https://img-blog.csdnimg.cn/img_convert/ccd5fcc8293edec24d7e889e189d0bfe.png)\n\n## 消息驱动\n\n### Stream\n\n**什么是Spring Cloud Stream？**\n\n官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。\n\n应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。\n\n通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。\n\n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。\nSpring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。\n\n目前仅支持RabbitMQ、 Kafka。\n\n#### 设计思想\n\n![dasd04.png](https://img-blog.csdnimg.cn/img_convert/1ca02dd31581d92a7a610bcd137f6848.png)\n\n- 生产者/消费者之间靠消息媒介传递信息内容\n- 消息必须走特定的通道 - 消息通道 Message Channel\n- 消息通道里的消息如何被消费呢，谁负责收发处理 - 消息通道MessageChannel的子接口SubscribableChannel，由\n- MessageHandler消息处理器所订阅。\n\n#### 常用注解\n\n|    **组成**     |                           **说明**                           |\n| :-------------: | :----------------------------------------------------------: |\n|   Middleware    |              中间件，目前只支持RabbitMQ和Kafka               |\n|     Binder      | inder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,RabbitMQ的exchange)，这些都可以通过配置文件来实现 |\n|     @Input      |   注解标识输入通道，通过该输乎通道接收到的消息进入应用程序   |\n|     @Output     |     注解标识输出通道，发布的消息将通过该通道离开应用程序     |\n| @StreamListener |             监听队列，用于消费者的队列的消息接收             |\n| @EnableBinding  |              指信道channel和exchange绑定在一起               |\n\n **案例说明**\n\n准备RabbitMQ环境\n\n工程中新建三个子模块\n\n- cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块\n- cloud-stream-rabbitmq-consumer8802，作为消息接收模块\n- cloud-stream-rabbitmq-consumer8803，作为消息接收模块\n\n#### Stream消息驱动之生产者\n\n新建Module：cloud-stream-rabbitmq-provider8801\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n      stream:\n        binders: # 在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit: # 表示定义的名称，用于于binding整合\n            type: rabbit # 消息组件类型\n            environment: # 设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings: # 服务的整合处理\n          output: # 这个名字是一个通道的名称\n            destination: studyExchange # 表示要使用的Exchange名称定义\n            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8801.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n```\n\n主启动类StreamMQMain8801\n\n业务类\n\n1.发送消息接口\n\n```java\npublic interface IMessageProvider {\n    public String send();\n}\n```\n\n2.发送消息接口实现类\n\n```java\n@EnableBinding(Source.class) //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send()\n    {\n        String serial = UUID.randomUUID().toString();\n        output.send(MessageBuilder.withPayload(serial).build());\n        System.out.println(\"*****serial: \"+serial);\n        return null;\n    }\n}\n```\n\n3.Controller\n\n```java\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMapping(value = \"/sendMessage\")\n    public String sendMessage() {\n        return messageProvider.send();\n    }\n}\n```\n\n测试\n\n- 启动 7001eureka\n\n- 启动 RabpitMq（\n\n  79_Bus之RabbitMQ环境配置\n\n  ）\n\n  - rabbitmq-plugins enable rabbitmq_management\n  - http://localhost:15672/\n\n- 启动 8801\n\n- 访问 - http://localhost:8801/sendMessage\n\n  - 后台将打印`serial: UUID`字符串\n\n#### Stream消息驱动之消费者\n\n新建Module：cloud-stream-rabbitmq-consumer8802\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8802\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n      stream:\n        binders: # 在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit: # 表示定义的名称，用于于binding整合\n            type: rabbit # 消息组件类型\n            environment: # 设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings: # 服务的整合处理\n          input: # 这个名字是一个通道的名称\n            destination: studyExchange # 表示要使用的Exchange名称定义\n            content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n            binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n\n#### Stream之消息重复消费\n\n依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。\n\n原神，**启动**\n\n- RabbitMQ\n- 服务注册 - 8801\n- 消息生产 - 8801\n- 消息消费 - 8802\n- 消息消费 - 8802\n\n**运行后有两个问题**\n\n1. 有重复消费问题\n2. 消息持久化问题\n\n**消费**\n\n- http://localhost:8801/sendMessage\n- 目前是8802/8803同时都收到了，存在重复消费问题\n- 如何解决：分组和持久化属性group（重要）\n\n**生产实际案例**\n\n比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以**使用Stream中的消息分组来解决**。\n\n![d123654.png](https://img-blog.csdnimg.cn/img_convert/f61e83441af907a42e8886368bde59ff.png)\n\n注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的(重复消费)。\n\n简单总结：只需要每个服务处于统一group下就不会出现重复消费\n\n**解决**\n\n原理\n\n微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。\n\n不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。\n\n8802/8803都变成不同组，group两个不同\n\ngroup: A_Group、B_Group\n\n8802修改YML\n\n```yml\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n      stream:\n        binders: # 在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit: # 表示定义的名称，用于于binding整合\n            type: rabbit # 消息组件类型\n            environment: # 设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings: # 服务的整合处理\n          output: # 这个名字是一个通道的名称\n            destination: studyExchange # 表示要使用的Exchange名称定义\n            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n            group: A_Group #<----------------------------------------关键\n```\n\n8803修改YML（与8802的类似位置 `group: B_Group`）\n\n结论：**还是重复消费**\n\n8802/8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。\n\n**8802/8803都变成相同组，group两个相同**\n\ngroup: A_Group\n\n8802修改YML`group: A_Group`\n\n8803修改YML`group: A_Group`\n\n结论：同一个组的多个微服务实例，每次只会有一个拿到\n\n成功解决重复消费\n\n#### Stream之消息持久化\n\n通过上述，解决了重复消费问题，再看看持久化。\n\n停止8802/8803并去除掉8802的分组group: A_Group，8803的分组group: A_Group没有去掉。\n\n8801先发送4条消息到RabbitMq。\n\n先启动8802，**无分组属性配置**，后台没有打出来消息。\n\n再启动8803，**有分组属性配置**，后台打出来了MQ上的消息。(消息持久化体现)\n\n## 分布式请求链路跟踪\n\n### Sleuth\n\n**为什么会出现这个技术？要解决哪些问题？**\n\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\n\n**是什么**\n\n- https://github.com/spring-cloud/spring-cloud-sleuth\n- Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案\n- 在分布式系统中提供追踪解决方案并且兼容支持了zipkin\n\n#### Sleuth之zipkin搭建安装\n\n1.zipkin\n\n**下载**\n\n- SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可\n- [Central Repository: io/zipkin/zipkin-server (maven.org)](https://repo1.maven.org/maven2/io/zipkin/zipkin-server/)\n- zipkin-server-2.24.3-exec.jar\n\n**运行jar**\n\n```java\njava -jar zipkin-server-2.24.3-exec.jar\n```\n\n**运行控制台**\n\nhttp://localhost:9411/zipkin/\n\n**完整的调用链路**\n\n—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。\n\n![1d9012.png](https://img-blog.csdnimg.cn/img_convert/f75fcfd2146df03428b9c8c53d13c1f1.png)\n\n名词解释\n\n- Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n- span：表示调用链路来源，通俗的理解span就是一次请求信息\n\n#### Sleuth链路监控展现\n\n**修改cloud-provider-payment8001**\n\nPOM\n\n```xml\n<!--包含了sleuth+zipkin-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nspring:\n  application:\n    name: cloud-payment-service\n\n  zipkin: #<-------------------------------------关键 \n      base-url: http://localhost:9411\n  sleuth: #<-------------------------------------关键\n    sampler:\n    #采样率值介于 0 到 1 之间，1 则表示全部采集\n    probability: 1\n```\n\n业务类PaymentController\n\n```java\n@GetMapping(\"/payment/zipkin\")\npublic String paymentZipkin() {\n    return \"hi ,i'am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~\";\n}    \n```\n\n**修改cloue-consumer-order80**\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\nYML\n\n```xml\nspring:\n    application:\n        name: cloud-order-service\n    zipkin:\n      base-url: http://localhost:9411\n    sleuth:\n      sampler:\n        probability: 1\n```\n\n业务类OrderController\n\n```java\n@GetMapping(\"/consumer/payment/zipkin\")\npublic String paymentZipkin()\n{\n    String result = restTemplate.getForObject(\"http://localhost:8001\"+\"/payment/zipkin/\", String.class);\n    return result;\n}\n```\n\n4.依次启动eureka7001/8001/80 - 80调用8001几次测试下\n\n5.打开浏览器访问: http://localhost:9411\n\n## Spring Cloud Alibaba\n\n**为什么会出现SpringCloud alibaba?**\n\nSpring Cloud Netflix项目进入维护模式\n\nhttps://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now\n\n**什么是维护模式？**\n\n将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。\n\n他们将修复block级别的 bug 以及安全问题，他们也会考虑并审查社区的小型pull request。\n\n**SpringCloud alibaba带来了什么**\n\n[spring-cloud-alibaba/README-zh.md at 2.2.x · alibaba/spring-cloud-alibaba (github.com)](https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md)\n\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n\n**能干嘛**\n\n- 服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ \n- 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\n- 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。\n- 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n- 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\n- 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。\n- 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n- 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。\n- 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\n**MAVEN**\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n            <version>2.2.5.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n- Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n- Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n- RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\n- Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。\n- Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\n- Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n- Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\n- Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\n**Spring Cloud Alibaba学习资料获取**\n\n- 官网\n\nhttps://spring.io/projects/spring-cloud-alibaba#overview\n\n- 英文\n\nhttps://github.com/alibaba/spring-cloud-alibaba\nhttps://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html\n\n- 中文\n\nhttps://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md\n\n### Nacos\n\n#### Nacos介绍\n\n**是什么**\n\n- 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n- Nacos: Dynamic Naming and Configuration Service\n- Nacos就是注册中心＋配置中心的组合 -> **Nacos = Eureka+Config+Bus**\n\n**能干嘛**\n\n- 替代Eureka做服务注册中心\n- 替代Config做服务配置中心\n\n**去哪下**\n\n- https://github.com/alibaba/nacos/releases\n- [官网文档](https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring cloud alibaba nacos_discovery)\n\n**各中注册中心比较**\n\n| 服务注册与发现框架 | CAP模型 | 控制台管理 | 社区活跃度      |\n| ------------------ | ------- | ---------- | --------------- |\n| Eureka             | AP      | 支持       | 低(2.x版本闭源) |\n| Zookeeper          | CP      | 不支持     | 中              |\n| consul             | CP      | 支持       | 高              |\n| Nacos              | AP      | 支持       | 高              |\n\n据说Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验。\n\n#### Nacos安装\n\n- 本地Java8+Maven环境已经OK先\n- 从[官网](https://github.com/alibaba/nacos/releases)下载Nacos\n- 解压安装包，直接运行bin目录下的startup.cmd\n- 命令运行成功后直接访问http://localhost:8848/nacos，默认账号密码都是nacos\n- 结果页面\n\n#### Nacos之服务提供者注册\n\n[官方文档](https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery)\n\n新建Module - cloudalibaba-provider-payment9001\n\n**POM**\n\n父POM\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <!--spring cloud alibaba 2.1.0.RELEASE-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n            <version>2.1.0.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n本模块POM\n\n```xml\n <dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n**YML**\n\n```yml\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n```\n\n主启动添加`@EnableDiscoveryClient`\n\n业务类\n\n```java\n@RestController\npublic class PaymentController {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @GetMapping(value = \"/payment/nacos/{id}\")\n    public String getPayment(@PathVariable(\"id\") Integer id) {\n        return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id;\n    }\n}\n```\n\n测试\n\n- http://localhost:9001/payment/nacos/1\n- nacos控制台\n- nacos服务注册中心+服务提供者9001都OK了\n\n再建一个新模块`cloudalibaba-provider-payment9002`\n\n#### Nacos之服务消费者注册和负载\n\n新建Module - cloudalibaba-consumer-nacos-order83\n\nPOM\n\n```xml\n <dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n为什么nacos支持负载均衡？因为spring-cloud-starter-alibaba-nacos-discovery内含netflix-ribbon包。\n\nYML\n\n```yml\nserver:\n  port: 83\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n```\n\n主启动添加`@EnableDiscoveryClient `\n\n业务类\n\nApplicationContextConfig\n\n```java\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n```\n\nOrderNacosController\n\n```java\n@RestController\n@Slf4j\npublic class OrderNacosController {\n    \n    @Resource\n    private RestTemplate restTemplate;\n\n    @Value(\"${service-url.nacos-user-service}\")\n    private String serverURL;\n\n    @GetMapping(value = \"/consumer/payment/nacos/{id}\")\n    public String paymentInfo(@PathVariable(\"id\") Long id)\n    {\n        return restTemplate.getForObject(serverURL+\"/payment/nacos/\"+id,String.class);\n    }\n}\n```\n\n测试\n\n- 启动nacos控制台\n- http://localhost:83/Eonsumer/payment/nacos/13\n  - 83访问9001/9002，轮询负载OK\n\n#### Nacos之服务配置中心\n\n基础配置\n\ncloudalibaba-config-nacos-client3377\n\nPOM\n\n```xml\n<!--nacos-config-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n<!--nacos-discovery-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\nYML\n\nNacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。\n\nspringboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\n\nbootstrap\n\n```yml\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #Nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n        \n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n# nacos-config-client-dev.yaml\n# nacos-config-client-test.yaml   ----> config.info\n```\n\napplication\n\n```qml\nspring:\n  profiles:\n    active: dev # 表示开发环境\n    #active: test # 表示测试环境\n    #active: info\n\n```\n\n主启动添加`@EnableDiscoveryClient`\n\n业务类\n\n```java\n@RestController\n@RefreshScope //支持Nacos的动态刷新功能。\npublic class ConfigClientController\n{\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/config/info\")\n    public String getConfigInfo() {\n        return configInfo;\n    }\n}\n```\n\n**在Nacos中添加配置信息**\n\nNacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则\n\n[官方文档](https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html)\n\n说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。\n\n在 Nacos Spring Cloud中,dataId的完整格式如下：\n\n```java\n${prefix}-${spring-profile.active}.${file-extension}\n```\n\n- prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。\n- spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension}\n- file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。\n- 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。\n\n最后公式：\n\n```java\n${spring.application.name)}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\n```\n\n![21dxw20.png](https://img-blog.csdnimg.cn/img_convert/05d45948bf637614dbd70e2bc8ce992d.png)\n\nNacos界面配置对应 - 设置DataId\n\n![c0tnVf.png](https://img-blog.csdnimg.cn/img_convert/c61619bbe5ea16f34efca8103b0f90ba.png)\n\n配置小结\n\n![202929292.png](https://img-blog.csdnimg.cn/img_convert/b3bffc4a646b30f9bf64fc649bf26f7d.png)\n\n**测试**\n\n- 启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件\n- 运行cloud-config-nacos-client3377的主启动类\n- 调用接口查看配置信息 - http://localhost:3377/config/info\n\n**自带动态刷新**\n\n修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。\n\n#### Nacos之命名空间分组和DataID三者关系\n\n**问题 - 多环境多项目管理**\n\n问题1:\n\n实际开发中，通常一个系统会准备\n\n1. dev开发环境\n2. test测试环境\n3. prod生产环境。\n\n如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?\n\n问题2:\n\n一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?\n\n**Namespace+Group+Data lD三者关系？为什么这么设计？**\n\n1是什么\n\n类似Java里面的package名和类名最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。\n\n2三者情况\n\n![321d10DKLJQ.png](https://img-blog.csdnimg.cn/img_convert/60712abd615dd86ac6c119bf132a28d6.png)\n\n默认情况：Namespace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT\n\n- Nacos默认的Namespace是public，Namespace主要用来实现隔离。\n  - 比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。\n\n- Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去\n- Service就是微服务:一个Service可以包含多个Cluster (集群)，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。\n  - 比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称(HZ) ，给广州机房的Service微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n- 最后是Instance，就是微服务的实例。\n\n#### Nacos之DataID配置\n\n指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置\n\n默认空间+默认分组+新建dev和test两个DatalD\n\n- 新建dev配置DatalD\n- 通过spring.profile.active属性就能进行多环境下配置文件的读取\n\n**测试**\n\n- http://localhost:3377/config/info\n- 配置是什么就加载什么 test/dev\n\n#### Nacos之Group分组方案\n\n通过Group实现环境区分 - 新建Group\n\n![000.png](https://img-blog.csdnimg.cn/img_convert/bdf592aa566fe50f7f454118a70ca03c.png)\n\n在nacos图形界面控制台上面新建配置文件DatalD\n\n![LSINFD.png](https://img-blog.csdnimg.cn/img_convert/28aee2b45901bbb9a6776d5c4398a6bb.png)\n\nbootstrap+application：在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST GROUP\n\n![12LADpw.png](https://img-blog.csdnimg.cn/img_convert/342a167a8bd948d8ba5cbfd760cf66a6.png)\n\n#### Nacos之Namespace空间方案\n\n新建dev/test的Namespace\n\n![Djspc1223.png](https://img-blog.csdnimg.cn/img_convert/a10c71978c75c214aca5fa7057bb2834.png)\n\n回到服务管理-服务列表查看\n\n![2143)KKJ.png](https://img-blog.csdnimg.cn/img_convert/2a9f3fa415f5cead0219d404a47131a0.png)\n\n按照域名配置填写\n\n![wqd1MNCw.png](https://img-blog.csdnimg.cn/img_convert/2177c126090c0db553a8ce77e838a7c9.png)\n\nYML\n\n```yml\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #Nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n        group: DEV_GROUP\n        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4 #<------------指定namespace\n\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n# nacos-config-client-dev.yaml\n# nacos-config-client-test.yaml   ----> config.info\n```\n\n#### Nacos持久化切换配置\n\nNacos默认自带的是嵌入式数据库derby，[nacos的pom.xml](https://blog.csdn.net/u011863024/article/details/github.com/alibaba/nacos/blob/develop/config/pom.xml)中可以看出。\n\nderby到mysql切换配置步骤：\n\n1. nacos-server-1.1.4\\nacos\\conf录下找到nacos-mysql.sql文件，执行脚本。\n2. nacos-server-1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。\n\n```pr\nspring.datasource.platform=mysql\n\ndb.num=1\ndb.url.0=jdbc:mysql://localhost:3306/nacos_devtest?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\ndb.user=root\ndb.password=1234\n```\n\n启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby。\n\n**1.4.1版本的直接打开31-41行的注释修改为自己就行**\n\n#### Nacos集群配置\n\n这里不太会，有点问题\n\n### Sentinel\n\n#### Sentinel介绍\n\n随着微服务的流行，服务和服务之间的稳定性变得越来越重要。[Sentinel](https://so.csdn.net/so/search?q=Sentinel&spm=1001.2101.3001.7020) 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\nSentinel 具有以下特征:\n\n- 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n- 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n- 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。\n- 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n![12dNucx1.png](https://img-blog.csdnimg.cn/img_convert/e4efa9c3547366ae4f747ad4007f6447.png)\n\n—句话解释，之前我们讲解过的Hystrix\n\nHystrix与Sentinel比较：\n\n- Hystrix\n  1. 需要我们程序员自己手工搭建监控平台\n  2. 没有一套web界面可以给我们进行更加细粒度化得配置流控、速率控制、服务熔断、服务降级\n- Sentinel\n  1. 单独一个组件，可以独立出来。\n  2. 直接界面化的细粒度统一配置。\n\n约定 > 配置 > 编码\n\n都可以写在代码里面，但是我们本次还是大规模的学习使用配置和注解的方式，尽量少写代码\n\n#### Sentinel下载安装运行\n\n服务使用中的各种问题：\n\n- 服务雪崩\n- 服务降级\n- 服务熔断\n- 服务限流\n\nSentinel 分为两个部分：\n\n- 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n- 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n#### Sentinel初始化监控\n\n**启动Nacos8848成功**\n\n**新建工程 - cloudalibaba-sentinel-service8401**\n\nPOM\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n<!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到-->\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-datasource-nacos</artifactId>\n</dependency>\n<!--SpringCloud ailibaba sentinel -->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n</dependency>\n<!--openfeign-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n<!-- SpringBoot整合Web组件+actuator -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        port: 8719\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\nfeign:\n  sentinel:\n    enabled: true # 激活Sentinel对Feign的支持\n```\n\n主启动类`@EnableDiscoveryClient`\n\n业务类FlowLimitController\n\n```java\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping(\"/testA\")\n    public String testA()\n    {\n        return \"------testA\";\n    }\n\n    @GetMapping(\"/testB\")\n    public String testB()\n    {\n        log.info(Thread.currentThread().getName()+\"\\t\"+\"...testB\");\n        return \"------testB\";\n    }\n}\n```\n\n**启动Sentinel8080 - `java -jar sentinel-dashboard-1.7.0.jar`**\n\n**启动微服务8401，查看sentienl控制台**\n\n- 刚启动，空空如也，啥都没有\n\n- Sentinel采用的懒加载说明\n  - 执行一次访问即可\n    - http://localhost:8401/testA\n    - http://localhost:8401/testB\n  - 效果 - sentinel8080正在监控微服务8401\n\n#### Sentinel流控规则简介\n\n![11111.png](https://img-blog.csdnimg.cn/img_convert/d8ae2bea252af0bb278332b3aeb8fb77.png)\n\n- 资源名：唯一名称，默认请求路径。\n- 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。\n- 阈值类型/单机阈值：\n  - QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。\n  - 线程数：当调用该API的线程数达到阈值的时候，进行限流。\n- 是否集群：不需要集群。\n- 流控模式：\n  - 直接：API达到限流条件时，直接限流。\n  - 关联：当关联的资源达到阈值时，就限流自己。\n  - 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。\n- 流控效果：\n  - 快速失败：直接失败，抛异常。\n  - Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。\n  - 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。\n\n#### Sentinel流控-QPS直接失败\n\n**直接 -> 快速失败（系统默认）**\n\n**配置及说明**\n\n表示1秒钟内查询1次就是OK，若超过次数1，就直接->快速失败，报默认错误\n\n**测试**\n\n快速多次点击访问http://localhost:8401/testA\n\n**结果**\n\n返回页面 Blocked by Sentinel (flow limiting)\n\n**源码**\n\ncom.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController\n\n**思考**\n\n直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?\n\n#### Sentinel流控-线程数直接失败\n\n修改FlowLimitController，给请求增加时长\n\n```java\n@GetMapping(\"/testA\")\npublic String testA()\n{\n    try {\n        TimeUnit.MILLISECONDS.sleep(800);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"------testA\";\n}\n```\n\n当有多个请求同时访问的时候搜，超过阈值就会出错\n\n#### Sentinel流控-关联\n\n- 当自己关联的资源达到阈值时，就限流自己\n- 当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）\n\n**设置testA**\n\n当关联资源/testB的QPS阀值超过1时，就限流/testA的Rest访问地址，**当关联资源到阈值后限制配置好的资源名**。\n\n![3841.png](https://img-blog.csdnimg.cn/img_convert/12cd41ae91ba50fe3b5525bab7bc3805.png)\n\nJmeter密集访问[localhost:8401/testB](http://localhost:8401/testB)，在此期间访问[localhost:8401/testA](http://localhost:8401/testA)会出现错误`Blocked by Sentinel(flow limiting)`\n\n#### Sentinel流控-预热\n\n> 默认coldFactor为3，即请求QPS 从 threshold / 3开始，经预热时长逐渐升至设定的QPS阈值。[link](https://github.com/alibaba/Sentinel/wiki/流量控制#warm-up)\n\n**源码** - com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController\n\n系统初始化的阀值为10/ 3约等于3,即阀值刚开始为3;然后过了5秒后阀值才慢慢升高恢复到10\n\n**测试**\n\n多次快速点击http://localhost:8401/testB - 刚开始不行，后续慢慢OK\n\n![IOid.png](https://img-blog.csdnimg.cn/img_convert/c26846d68d79eae1e962f37942a2c99f.png)\n\n**应用场景**\n\n如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来,慢慢的把阀值增长到设置的阀值。\n\n#### Sentinel流控-排队等待\n\n匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。\n\n设置：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。\n\n![231000.png](https://img-blog.csdnimg.cn/img_convert/0ddd217545dd0fe2b1f251dbea814ac2.png)\n\n**测试**\n\n- 添加日志记录代码到FlowLimitController的testA方法\n\n```java\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping(\"/testA\")\n    public String testA()\n    {\n        log.info(Thread.currentThread().getName()+\"\\t\"+\"...testA\");//<----\n        return \"------testA\";\n    }\n\n}\n```\n\n用Jmeter测试，发现后端输出是每隔一秒钟输出一个\n\n#### Sentinel降级简介\n\n**熔断降级概述**\n\n> 除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。\n>\n> 现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。\n\n![123ddqghbb.png](https://img-blog.csdnimg.cn/img_convert/6a002ef360a4e5f20ee2748a092f0211.png)\n\n- RT（平均响应时间，秒级）\n  - 平均响应时间 超出阈值 且 在时间窗口内通过的请求>=5，两个条件同时满足后触发降级。\n  - 窗口期过后关闭断路器。\n  - RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效）。\n- 异常比列（秒级）\n  - QPS >= 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。\n- 异常数(分钟级)\n  - 异常数(分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级\n\nSentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。\n\n当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。\n\nSentinei的断路器是没有类似Hystrix半开状态的。(Sentinei 1.8.0 已有半开状态)\n\n半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。\n\n#### Sentinel降级-RT\n\n![20202020.png](https://img-blog.csdnimg.cn/img_convert/dcf85d4362c017e543173c76b7dcc2a8.png)\n\n**注意**：Sentinel 1.7.0才有**平均响应时间**（`DEGRADE_GRADE_RT`），Sentinel 1.8.0的没有这项，取而代之的是**慢调用比例** (`SLOW_REQUEST_RATIO`)。\n\n![087rc.png](https://img-blog.csdnimg.cn/img_convert/3a608908cef3d557322967e6bc0e5696.png)\n\n用jmter测压，一秒打10个\n\ncontroller代码\n\n```java\n@GetMapping(\"/testD\")\npublic String testD() {\n    try { \n        TimeUnit.SECONDS.sleep(1); \n    } catch (InterruptedException e) { \n        e.printStackTrace(); \n    }\n    log.info(\"testD 测试RT\");\n}\n```\n\n**结论**\n\n按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。\n#### Sentinel降级-异常比例\n\n![12c23.png](https://img-blog.csdnimg.cn/img_convert/b8f35b00fffd79ef68e8f744403b92f3.png)\n\n修改controller代码\n\n```java\n@GetMapping(\"/testD\")\npublic String testD() {\n    try { \n        TimeUnit.SECONDS.sleep(1); \n    } catch (InterruptedException e) { \n        e.printStackTrace(); \n    }\n    log.info(\"testD 测试RT\");\n}\n```\n\n![120dxc.png](https://img-blog.csdnimg.cn/img_convert/ab66591ba085c32e9303d96be7b44f0d.png)\n\n按照上述配置，单独访问一次，必然来一次报错一次(int age = 10/0)，调一次错一次。\n\n开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错error而是服务降级了。\n\n#### Sentinel降级-异常数\n\n**异常数是按照分钟统计的，时间窗口一定要大于等于60秒**。\n\n![1211235.png](https://img-blog.csdnimg.cn/img_convert/d92c6a9ae5ed514b52ddf43fdf0d5f0e.png)\n\n添加controller代码\n\n```java\n@GetMapping(\"/testE\")\npublic String testE()\n{\n    log.info(\"testE 测试异常数\");\n    int age = 10/0;\n    return \"------testE 测试异常数\";\n}\n```\n\n![b0thSJ.png](https://img-blog.csdnimg.cn/img_convert/218fe52e19c07b30bbf4d994d05e6a8e.png)\n\n访问http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。\n\n#### Sentinel热点key(上)\n\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n\n- 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制\n- 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制\n\n热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n\n![312sLLL.png](https://img-blog.csdnimg.cn/img_convert/16d2ddeff96b7cb68a064b6ec05bde25.png)\n\n**承上启下复习start**\n\n兜底方法，分为系统默认和客户自定义，两种\n\n之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel (flow limiting)\n\n我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法?\n\n结论 - **从HystrixCommand到@SentinelResource**\n\n再contrller中添加\n\n```java\n@GetMapping(\"/testHotKey\")\n@SentinelResource(value = \"testHotKey\",blockHandler/*兜底方法*/ = \"deal_testHotKey\")\npublic String testHotKey(@RequestParam(value = \"p1\",required = false) String p1,\n                         @RequestParam(value = \"p2\",required = false) String p2) {\n    //int age = 10/0;\n    return \"------testHotKey\";\n}\n\n/*兜底方法*/\npublic String deal_testHotKey (String p1, String p2, BlockException exception) {\n    return \"------deal_testHotKey,o(╥﹏╥)o\";  //sentinel系统默认的提示：Blocked by Sentinel (flow limiting)\n}\n```\n\n**配置**\n\n![dsdcopp.png](https://img-blog.csdnimg.cn/img_convert/9620ee4e7e54d48ba7dda394fa1c8cd0.png)\n\n**测试**\n\n- error\n  - http://localhost:8401/testHotKey?p1=abc\n  - http://localhost:8401/testHotKey?p1=abc&p2=33\n- right\n  - http://localhost:8401/testHotKey?p2=abc\n\n若不配置`@SentinelResource(value = \"testHotKey\",blockHandler/*兜底方法*/ = \"deal_testHotKey\")`的话前端就只能看到一个报错界面 \n\n#### Sentinel热点key(下)\n\n上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流。\n\n**参数例外项**\n\n- 普通 - 超过1秒钟一个后，达到阈值1后马上被限流\n- **我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样**\n- 特例 - 假如当p1的值等于5时，它的阈值可以达到200\n\n![dsax-ca.png](https://img-blog.csdnimg.cn/img_convert/3aa08b15109cd346a6083f080a0468fa.png)\n\n**测试**\n\n- right - http://localhost:8401/testHotKey?p1=5\n- error - http://localhost:8401/testHotKey?p1=3\n- 当p1等于5的时候，阈值变为200\n- 当p1不等于5的时候，阈值就是平常的1\n\n**前提条件** - 热点参数的注意点，参数必须是基本类型或者String\n\n**其它**\n\n在`testHotKey`方法中添加`int age = 10/0;`使程序报错\n\n将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。\n\n- @SentinelResource - 处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理;\n\n- RuntimeException int age = 10/0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管\n\n总结 - @SentinelResource主管配置出错，运行出错该走异常走异常\n\n#### Sentinel系统规则\n\n就是一次性对所有接口进行限制\n\n系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\n\n- Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。\n- CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。\n- 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。\n- 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。\n- 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。\n\n#### SentinelResource配置(上)\n\n*按资源名称限流 + 后续处理*\n\n**启动Nacos成功**\n\n**启动Sentinel成功**\n\n**Module - cloudalibaba-sentinel-service8401**\n\ncontroller\n\n```java\n@RestController\npublic class RateLimitController {\n    \n    @GetMapping(\"/byResource\")\n    @SentinelResource(value = \"byResource\",blockHandler = \"handleException\")\n    public CommonResult byResource() {\n        return new CommonResult(200,\"按资源名称限流测试OK\",new Payment(2020L,\"serial001\"));\n    }\n    \n    public CommonResult handleException(BlockException exception) {\n        return new CommonResult(444,exception.getClass().getCanonicalName()+\"\\t 服务不可用\");\n    }\n}\n```\n\n**配置流控规则**\n\n配置步骤\n\n![21100101.png](https://img-blog.csdnimg.cn/img_convert/91aa0ac210011218db9557a2bfcfebd1.png)\n\n图形配置和代码关系\n\n表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流\n\n**测试**\n\n1秒钟点击1下，OK\n\n超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生\n\n```json\n{\"code\":444, \"message\":\"com.alibaba.csp.sentinel.slots.block.flow.FlowException\\t 服务不可用\", \"data\":null}\n```\n\n**额外问题**\n\n此时关闭问服务8401 -> Sentinel控制台，流控规则消失了\n\n------\n\n*按照Url地址限流 + 后续处理*\n\n**通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息**\n\n**业务类RateLimitController**\n\n```java\n@GetMapping(\"/rateLimit/byUrl\")\n@SentinelResource(value = \"byUrl\")\npublic CommonResult byUrl()\n{\n    return new CommonResult(200,\"按url限流测试OK\",new Payment(2020L,\"serial002\"));\n}\n```\n\n**Sentinel控制台配置**\n\n![1xll.png](https://img-blog.csdnimg.cn/img_convert/d6a79b7cc3f2f9c8b6dcbe3f77f78c6b.png)\n\n**测试**\n\n- 快速点击http://localhost:8401/rateLimit/byUrl\n- 结果 - 会返回Sentinel自带的限流处理结果 `Blocked by Sentinel (flow limiting)`\n\n**上面兜底方案面临的问题**\n\n1. 系统默认的，没有体现我们自己的业务要求。\n2. 依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。\n3. 每个业务方法都添加—个兜底的，那代码膨胀加剧。\n4. 全局统—的处理方法没有体现。\n\n#### SentinelResource配置(中)\n\n客户自定义限流处理逻辑\n\n自定义限流处理类 - 创建`CustomerBlockHandler`类用于自定义限流处理逻辑\n\n```java\nimport com.alibaba.csp.sentinel.slots.block.BlockException;\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\n\npublic class CustomerBlockHandler {\n    public static CommonResult handlerException(BlockException exception) {\n        return new CommonResult(4444,\"按客戶自定义,global handlerException----1\");\n    }\n    \n    public static CommonResult handlerException2(BlockException exception) {\n        return new CommonResult(4444,\"按客戶自定义,global handlerException----2\");\n    }\n}\n```\n\nRateLimitController\n\n```java\n@GetMapping(\"/rateLimit/customerBlockHandler\")\n@SentinelResource(value = \"customerBlockHandler\",\n        blockHandlerClass = CustomerBlockHandler.class,//<-------- 自定义限流处理类\n        blockHandler = \"handlerException2\")//<-----------\npublic CommonResult customerBlockHandler()\n{\n    return new CommonResult(200,\"按客戶自定义\",new Payment(2020L,\"serial003\"));\n}\n```\n\nSentinel控制台配置\n\n![1114-123d.png](https://img-blog.csdnimg.cn/img_convert/44dccf4107a74fda56f0807d39fa53f1.png)\n\n启动微服务后先调用一次 - http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。\n\n#### SentinelResource配置(下)\n\n**@SentinelResource 注解**\n\n> 注意：注解方式埋点不支持 private 方法。\n\n@SentinelResource`用于定义资源，并提供可选的异常处理和 fallback 配置项。 `@SentinelResource` 注解包含以下属性：\n\n- value：资源名称，必需项（不能为空）\n- entryType：entry 类型，可选项（默认为 EntryType.OUT）\n- blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。若本次访问被限流或服务降级，则调用blockHandler指定的接口。\n- fallback /fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若本接口出现未知异常，则调用fallback指定的接口。fallback 函数签名和位置要求：\n  - 返回值类型必须与原函数返回值类型一致；\n  - 方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n  - fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n- defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：\n  - 返回值类型必须与原函数返回值类型一致；\n  - 方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n  - defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n- `exceptionsToIgnore`（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。\n\nSentinel主要有三个核心Api：\n\n1. SphU定义资源\n2. Tracer定义统计\n3. ContextUtil定义了上下文\n\n#### Sentinel服务熔断Ribbon环境预说\n\nsentinel整合ribbon+openFeign+fallback\n\nRibbon系列\n\n- 启动nacos和sentinel\n- 提供者9003/9004\n- 消费者84\n\n------\n\n**提供者9003/9004**\n\n新建cloudalibaba-provider-payment9003/9004，两个一样的做法\n\nPOM\n\n```xml\n<dependencies>\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n        <groupId>com.atguigu.springcloud</groupId>\n        <artifactId>cloud-api-commons</artifactId>\n        <version>${project.version}</version>\n    </dependency>\n    <!-- SpringBoot整合Web组件 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <!--日常通用jar包配置-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\nYML\n\n```yml\nserver:\n  port: 9003\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n```\n\n**记得修改不同的端口号**\n\n主启动添加`@EnableDiscoveryClient`\n\n业务类\n\n```java\n@RestController\npublic class PaymentController {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    //模拟数据库\n    public static HashMap<Long,Payment> hashMap = new HashMap<>();\n    static\n    {\n        hashMap.put(1L,new Payment(1L,\"28a8c1e3bc2742d8848569891fb42181\"));\n        hashMap.put(2L,new Payment(2L,\"bba8c1e3bc2742d8848569891ac32182\"));\n        hashMap.put(3L,new Payment(3L,\"6ua8c1e3bc2742d8848569891xt92183\"));\n    }\n\n    @GetMapping(value = \"/paymentSQL/{id}\")\n    public CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id)\n    {\n        Payment payment = hashMap.get(id);\n        CommonResult<Payment> result = new CommonResult(200,\"from mysql,serverPort:  \"+serverPort,payment);\n        return result;\n    }\n}\n```\n\n测试地址 - http://localhost:9003/paymentSQL/1\n\n------\n\n**消费者84**\n\n新建cloudalibaba-consumer-nacos-order84\n\nPOM\n\n```xml\n<dependencies>\n    <!--SpringCloud openfeign -->\n    <!--\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\n    </dependency>\n\t-->\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n    </dependency>\n    <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n    <dependency>\n        <groupId>com.atguigu.springcloud</groupId>\n        <artifactId>cloud-api-commons</artifactId>\n        <version>${project.version}</version>\n    </dependency>\n    <!-- SpringBoot整合Web组件 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <!--日常通用jar包配置-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\nYML\n\n```yml\nserver:\n  port: 84\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n    sentinel:\n      transport:\n        #配置Sentinel dashboard地址\n        dashboard: localhost:8080\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\n        port: 8719\n\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n\n# 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: false\n```\n\n主启动\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients\n```\n\nApplicationContextConfig\n\n```java\n@Configuration\npublic class ApplicationContextConfig {\n\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\nCircleBreakerController\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping(\"/consumer/fallback/{id}\")\n    @SentinelResource(value = \"fallback\")//没有配置\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    \n}\n```\n\n修改后请重启微服务\n\n- 热部署对java代码级生效及时\n- 对@SentinelResource注解内属性，有时效果不好\n\n目的\n\n- fallback管运行异常\n- blockHandler管配置违规\n\n测试地址 - http://localhost:84/consumer/fallback/1\n\n没有任何配置\n\n只配置fallback\n\n只配置blockHandler\n\nfallback和blockHandler都配置\n\n忽略属性\n\n#### Sentinel服务熔断只配置fallback\n\n为了防止出现程序报错页面，添加兜底方法\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    \n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping(\"/consumer/fallback/{id}\")\n    //@SentinelResource(value = \"fallback\")//没有配置\n    @SentinelResource(value = \"fallback\", fallback = \"handlerFallback\") //fallback只负责业务异常\n    public CommonResult<Payment> fallback(@PathVariable Long id) {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    \n    //本例是fallback\n    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage(),payment);\n    }\n    \n}\n```\n\n#### Sentinel服务熔断只配置blockHandler\n\nblockHandler只负责**sentinel控制台配置违规**\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/consumer/fallback/{id}\")\n    //@SentinelResource(value = \"fallback\") //没有配置\n    //@SentinelResource(value = \"fallback\",fallback = \"handlerFallback\") //fallback只负责业务异常\n    @SentinelResource(value = \"fallback\",blockHandler = \"blockHandler\") //blockHandler只负责sentinel控制台配置违规\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    //本例是fallback\n/*    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage(),payment);\n    }*/\n    \n    //本例是blockHandler\n    public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(445,\"blockHandler-sentinel限流,无此流水: blockException  \"+blockException.getMessage(),payment);\n    }\n}\n```\n\n#### Sentinel服务熔断fallback和blockHandler都配置\n\n若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。\n\n异常访问会走handlerFallback，若设置了限流的话，多次访问会走blockHandler\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/consumer/fallback/{id}\")\n    //@SentinelResource(value = \"fallback\") //没有配置\n    //@SentinelResource(value = \"fallback\",fallback = \"handlerFallback\") //fallback只负责业务异常\n    //@SentinelResource(value = \"fallback\",blockHandler = \"blockHandler\") //blockHandler只负责sentinel控制台配置违规\n    @SentinelResource(value = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\")\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    //本例是fallback\n    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage(),payment);\n    }\n    //本例是blockHandler\n    public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(445,\"blockHandler-sentinel限流,无此流水: blockException  \"+blockException.getMessage(),payment);\n    }\n}\n```\n\n#### Sentinel服务熔断exceptionsToIgnore\n\nexceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController    \n\n    ...\n    \n    @RequestMapping(\"/consumer/fallback/{id}\")\n    @SentinelResource(value = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\",\n            exceptionsToIgnore = {IllegalArgumentException.class})//<-------------\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            //exceptionsToIgnore属性有IllegalArgumentException.class，\n            //所以IllegalArgumentException不会跳入指定的兜底程序。\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n\n\t...\n}\n```\n\n#### Sentinel服务熔断OpenFeign\n\n**修改84模块**\n\n- 84消费者调用提供者9003\n- Feign组件一般是消费侧\n\nPOM\n\n```xml\n<!--SpringCloud openfeign -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\nYML\n\n```yaml\n# 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n```\n\n业务类\n\n带@Feignclient注解的业务接口，fallback = PaymentFallbackService.class\n\n```jade\n@FeignClient(value = \"nacos-payment-provider\",fallback = PaymentFallbackService.class)\npublic interface PaymentService\n{\n    @GetMapping(value = \"/paymentSQL/{id}\")\n    public CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id);\n}\n```\n\n```java\n@Component\npublic class PaymentFallbackService implements PaymentService {\n    @Override\n    public CommonResult<Payment> paymentSQL(Long id)\n    {\n        return new CommonResult<>(44444,\"服务降级返回,---PaymentFallbackService\",new Payment(id,\"errorSerial\"));\n    }\n}\n```\n\nController\n\n```java\n@Resource\nprivate PaymentService paymentService;\n@GetMapping(value = \"/consumer/paymentSQL/{id}\")\npublic CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id)\n{\n    return paymentService.paymentSQL(id);\n}\n```\n\n主启动\n\n```java\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients//<------------------------\npublic class OrderNacosMain84 {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderNacosMain84.class, args);\n    }\n}\n```\n\n测试 - http://localhost:84/consumer/paymentSQL/1\n\n测试84调用9003，此时故意关闭9003微服务提供者，**84消费侧自动降级**，不会被耗死。\n\n**熔断框架比较**\n\n[![pPFrBUP.png](https://s1.ax1x.com/2023/08/04/pPFrBUP.png)](https://imgse.com/i/pPFrBUP)\n\n#### Sentinel持久化规则\n\n**是什么**\n\n一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。\n\n**怎么玩**\n\n将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。\n\n**步骤**\n\n修改cloudalibaba-sentinel-service8401\n\nPOM\n\n```xml\n<!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到-->\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-datasource-nacos</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        port: 8719\n      datasource: #<---------------------------关注点，添加Nacos数据源配置\n        ds1:\n          nacos:\n            server-addr: localhost:8848\n            dataId: cloudalibaba-sentinel-service\n            groupId: DEFAULT_GROUP\n            data-type: json\n            rule-type: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\nfeign:\n  sentinel:\n    enabled: true # 激活Sentinel对Feign的支持\n```\n\n添加Nacos业务规则配置\n\n![214PPPP.png](https://img-blog.csdnimg.cn/img_convert/2401a6b2df715ee64f647da2f31e1eeb.png)\n\n配置内容解析\n\n```jso\n[{\n    \"resource\": \"/rateLimit/byUrl\",\n    \"limitApp\": \"default\",\n    \"grade\": 1,\n    \"count\": 1, \n    \"strategy\": 0,\n    \"controlBehavior\": 0,\n    \"clusterMode\": false\n}]\n```\n\n- resource：资源名称；\n- limitApp：来源应用；\n- grade：阈值类型，0表示线程数, 1表示QPS；\n- count：单机阈值；\n- strategy：流控模式，0表示直接，1表示关联，2表示链路；\n- controlBehavior：流控效果，0表示快速失败，\n- 1表示Warm Up，2表示排队等待；\n- clusterMode：是否集群。\n\n启动8401后刷新sentinel发现业务规则有了\n\n![0-0-0-wqq.png](https://img-blog.csdnimg.cn/img_convert/c854e986254c09d0a7866811ec1e0cb4.png)\n\n快速访问测试接口 - http://localhost:8401/rateLimit/byUrl - 页面返回`Blocked by Sentinel (flow limiting)`\n\n停止8401再看sentinel - 停机后发现流控规则没有了\n\n重新启动8401再看sentinel\n\n- 乍一看还是没有，稍等一会儿\n- 多次调用 - http://localhost:8401/rateLimit/byUrl\n- 重新配置出现了，持久化验证通过\n\n### Seata\n\n#### 分布式事务问题由来\n\n分布式前\n\n- 单机单库没这个问题\n- 从1:1 -> 1:N -> N:N\n\n单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时**每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证**。\n\n一句话：**一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题**。\n\n#### Seata术语\n\nSeata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。\n\n**能干嘛**\n\n一个典型的分布式事务过程\n\n分布式事务处理过程的一ID+三组件模型：\n\n- Transaction ID XID 全局唯一的事务ID\n- 三组件概念\n  - TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。\n  - TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n  - RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n处理过程：\n\n- TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；\n- XID在微服务调用链路的上下文中传播；\n- RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；\n- TM向TC发起针对XID的全局提交或回滚决议；\n- TC调度XID下管辖的全部分支事务完成提交或回滚请求。\n\n![cnaois.png](https://img-blog.csdnimg.cn/img_convert/2d2c6aa29c3158413f66d4ef8c1000dc.png)\n\n#### Seata-Server安装\n\n**下载**\n\n[Releases · seata/seata (github.com)](https://github.com/seata/seata/releases/)\n\n**怎么玩**\n\n本地@Transactional\n\n全局@GlobalTransactional\n**SEATA 的分布式交易解决方案**\n\n我们只需要使用一个 `@GlobalTransactional` 注解在业务方法上\n","title":" SpringCloud学习笔记\n","category":[" Java","SpringCloud\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n笔记参考博客：\n\n https://blog.csdn.net/u011863024/article/details/114298270\n https://blog.csdn.net/u011863024/article/details/114298282\n https://blog.csdn.net/u011863024/article/details/114298288https://blog.csdn.net/u011863024/article/details/114298288\n\n 环境搭建\n\n约定  配置  编码\n\n创建微服务cloud整体聚合父工程Project，有8个关键步骤：\n\n1、New Project  maven工程  create from archetype: mavenarchetypesite\n2、聚合总父工程名字\n3、Maven选版本\n4、工程名字\n5、字符编码  Settings  File encoding\n6、注解生效激活  Settings  Annotation Processors\n7、Java编译版本选8\n8、File Type过滤  Settings  File Type\n\n 复习\n\n DependencyManagement和Dependencies\n\nMaven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。\n\n通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement元素。\n\n使用pom.xml中的dependencyManagement元素能让所有在子项目中引用个依赖而不用显式的列出版本量。\n\nMaven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号。\n\n说白了就是父项目用了版本号，子项目就可以不需要写版本号，便于维护\n\n注意\n\n dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。\n 如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。\n 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。\n\n Maven跳过单元测试\n\nIDEA右侧旁的Maven插件有Toggle ' Skip Tests' Mode按钮，这样maven可以跳过单元测试\n\n父工程创建完成执行mvn : install将父工程发布到仓库方便子工程 继承\n\n Dashboard窗口\n\n1. 打开工程路径下的.idea文件夹的workspace.xml\n2. 在<component name=\"RunDashboard\"中修改或添加以下代码：重启即可\n\nxml\n<option name=\"configurationTypes\"\n\t<set\n\t\t<option value=\"SpringBootApplicationConfigurationType\"/\n    </set\n</option\n\n\n\n\n 支付模块构建\n\n创建微服务模块套路：\n\n1. 建Module\n2. 改POM\n3. 写YML\n4. 主启动\n5. 业务类\n\npPSszzn.pnghttps://s1.ax1x.com/2023/07/29/pPSszzn.pnghttps://imgse.com/i/pPSszzn\n\n 消费模块构建\n\npPSyCLV.pnghttps://s1.ax1x.com/2023/07/29/pPSyCLV.pnghttps://imgse.com/i/pPSyCLV\n\n Restemplate\n\nRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集\n\n使用：\n\n 使用restTemplate访问restful接口非常的简单粗暴无脑。\n url, requestMap, ResponseBean.class这三个参数分别代表。\n REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。\n\njava\n// 消费模块调用支付模块接口\nrestTemplate.postForObject\"http://localhost:8001/payment/create\", payment, CommonResult.class;\n\n\n getForObject / getForEntity  GET请求方法\n\n getForObject：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。\n\n getForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。\n\n 工程重构\n\n观察cloudconsumerorder80与cloudproviderpayment8001两工程有重复代码（entities包下的实体）\n\n1、新建cloudapicommons来存放公共代码和一些配置类等等\n\n2、添加pom文件\n\n3、将cloudconsumerorder80与cloudproviderpayment8001两工程的公有entities包移至cloudapicommons工程下\n\n4、maven clean、install \n\n5、将cloudconsumerorder80与cloudproviderpayment8001两工程的公有entities包移除\n\n6、两个工程引入cloudapicommons依赖\n\nxml\n<dependency\n    <groupIdcom.ljx.springcloud</groupId\n    <artifactIdcloudapicommons</artifactId\n    <version${project.version}</version\n</dependency\n\n\n 知识点\n\npPSgBTK.pnghttps://s1.ax1x.com/2023/07/29/pPSgBTK.pnghttps://imgse.com/i/pPSgBTK\n\n最终需要在上述项目基础上一点点添加这些组件\n\n 服务注册中心\n\n Eureka\n\n 基础知识\n\nEureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。\n\naaa.pnghttps://imgblog.csdnimg.cn/imgconvert/3956561052b9dc3909f16f1ff26d01bb.png\n\nEureka包含两个组件:Eureka Server和Eureka Client\n\nEureka Server提供服务注册服务\n\n各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n\nEurekaClient通过注册中心进行访问\n\n它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询roundrobin负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳默认周期为30秒。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒\n\n EurekaServer服务端安装\n\neurekaServer端服务注册中心，类似物业公司\n\n1.创建名为cloudeurekaserver7001的Maven工程\n\n2.修改pom.xml\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaserver</artifactId\n</dependency\n\n\n3.添加application.yml\n\nyml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost eureka服务端的实例名称\n  client:\n    false表示不向注册中心注册自己。\n    registerwitheureka: false\n    false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetchregistry: false\n    serviceurl:\n      设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n\n4.主启动\n\njava\n@EnableEurekaServer\n\n\n5.测试运行EurekaMain7001，浏览器输入http://localhost:7001/回车，会查看到Spring Eureka服务主页。\n\n 支付微服务8001入驻进EurekaServer\n\nEurekaClient端cloudproviderpayment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。\n\n1.创建名为cloudeurekaserver7001的Maven工程\n\n2.修改pom.xml\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaserver</artifactId\n</dependency\n\n\n3.添加application.yml\n\nyml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost eureka服务端的实例名称\n  client:\n    false表示不向注册中心注册自己。\n    registerwitheureka: false\n    false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetchregistry: false\n    serviceurl:\n      设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n\n4.主启动\n\njava\n@EnableEurekaClient\n\n\n5.测试\n\n 启动cloudproviderpayment8001和cloudeurekaserver7001工程（先启动）。\n\n 浏览器输入  http://localhost:7001/ 主页内的Instances currently registered with Eureka会显示cloudproviderpayment8001的配置文件application.yml设置的应用名cloudpaymentservice\n\n6.自我保护机制\n\nEMERGENCY EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.\n\n紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。\n\n 订单微服务80入驻进EurekaServer\n\nEurekaClient端cloudconsumerorder80将注册进EurekaServer成为服务消费者consumer，类似来上课消费的同学\n\n1.cloudconsumerorder80\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloudorderservice\n\neureka:\n  client:\n    表示是否将自己注册进Eurekaserver默认为true。\n    registerwitheureka: true\n    是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka\n\n\n4.主启动\n\njava\n@EnableEurekaClient\n\n\n5.测试\n\n 启动cloudproviderpayment8001、cloudeurekaserver7001（先启动）和cloudconsumerorder80这三工程。\n 浏览器输入 http://localhost:7001 , 在主页的Instances currently registered with Eureka将会看到cloudproviderpayment8001、cloudconsumerorder80两个工程名。\n\n Eureka集群原理说明\n\nimg.pnghttps://imgblog.csdnimg.cn/imgconvert/14570c4b7c4dd8653be6211da2675e45.png\n\n问题：微服务RPC远程服务调用最核心的是什么？\n高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。\n\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。\n\n互相注册，相互守望。\n\n Eureka集群环境构建\n\n创建cloudeurekaserver7002工程\n\n 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件，修改映射配置添加进hosts文件\n\n\n127.0.0.1 eureka7001.com\n127.0.0.1 eureka7002.com\n\n\n 修改cloudeurekaserver7001配置文件\n\nyml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: eureka7001.com eureka服务端的实例名称\n  client:\n    registerwitheureka: false     false表示不向注册中心注册自己。\n    fetchregistry: false     false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    serviceurl:\n    集群指向其它eureka\n      defaultZone: http://eureka7002.com:7002/eureka/\n    单机就是7001自己\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n\n 修改cloudeurekaserver7002配置文件\n\nyml\nserver:\n  port: 7002\n\neureka:\n  instance:\n    hostname: eureka7002.com eureka服务端的实例名称\n  client:\n    registerwitheureka: false     false表示不向注册中心注册自己。\n    fetchregistry: false     false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    serviceurl:\n    集群指向其它eureka\n      defaultZone: http://eureka7001.com:7001/eureka/\n    单机就是7002自己\n      defaultZone: http://eureka7002.com:7002/eureka/\n\n\n 订单支付两微服务注册进Eureka集群\n\n将它们的配置文件的eureka.client.serviceurl.defaultZone进行修改\n\nyml\neureka:\n  client:\n    表示是否将自己注册进Eurekaserver默认为true。\n    registerwitheureka: true\n    是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    serviceurl:\n      注册到集群中\n      defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka\n\n\n1. 先要启动EurekaServer，7001/7002服务\n2. 再要启动服务提供者provider，8001\n3. 再要启动消费者，80\n4. 浏览器输入  http://localhost/consumer/payment/get/1\n\n 支付微服务集群配置\n\n新建cloudproviderpayment8002参考cloudprovicerpayment8001\n\n负载均衡\n\ncloudconsumerorder80订单服务访问地址不能写死\n\njava\npublic static final String PAYMENTURL = \"http://CLOUDPAYMENTSERVICE\";\n\n\n使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n\njava\n@Configuration\npublic class ApplicationContextConfig {\n    @Bean\n    @LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n    public RestTemplate getRestTemplate{\n        return new RestTemplate;\n    }\n}\n\n\n actuator微服务信息完善\n\n主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）\n\n修改cloudproviderpayment8001，cloudproviderpayment8002\n\n修改部分  YML  eureka.instance.instanceid\n\nyml\neureka:\n  ...\n  instance:\n    instanceid: payment8001 显示名称\n    preferipaddress: true 显示ip地址\n\n\n修改之后\n\neureka主页将显示payment8001，payment8002代替原来显示的IP地址。\n\n 服务发现Discovery\n\n对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n Eureka自我保护理论知识\n\n保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n\n如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:\n\nEMERGENCY EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE\n\n导致原因\n\n一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。\n\n属于CAP里面的AP分支。\n\n为什么会产生Eureka自我保护机制?\n\n为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除\n\n什么是自我保护模式?\n\n认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例默认90秒。但是当网络分区故障发生延时、卡顿、拥挤时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时可能发生了网络分区故障，那么这个节点就会进入自我保护模式。\n\nb.pnghttps://imgblog.csdnimg.cn/imgconvert/264b66e8099a3761beaea2ba44b8fc5e.png\n\n在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例\n\n它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着。\n\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。\n\n禁止自我保护\n\n出厂默认，自我保护机制是开启的\n\nyml\neureka:\n  ...\n  server:\n    关闭自我保护机制，保证不可用服务被及时踢除\n    enableselfpreservation: false\n    evictionintervaltimerinms: 2000\n\n\n关闭效果：springeureka主页会显示出一句：\n\nTHE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.\n\n Zookeeper\n\nLinux下载\n\nsh\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper3.7.1/apachezookeeper3.7.1bin.tar.gz\n\n\n解压\n\nsh\ntar zxvf apachezookeeper3.7.1bin.tar.gz\n\n\n启动\n\nsh\n./zkServer.sh start\n\n\n关闭防火墙\n\nsh\nsudo systemctl stop ufw.service\n\n\n 支付服务注册进zookeeper\n\n1.新建名为cloudproviderpayment8004的Maven工程。\n\n2.POM\n\nxml\n      < SpringBoot整合zookeeper客户端 \n        <dependency\n            <groupIdorg.springframework.cloud</groupId\n            <artifactIdspringcloudstarterzookeeperdiscovery</artifactId\n            <先排除自带的zookeeper3.5.3 防止与3.4.9起冲突\n            <exclusions\n                <exclusion\n                    <groupIdorg.apache.zookeeper</groupId\n                    <artifactIdzookeeper</artifactId\n                </exclusion\n            </exclusions\n        </dependency\n        <添加zookeeper3.4.9版本\n        <dependency\n            <groupIdorg.apache.zookeeper</groupId\n            <artifactIdzookeeper</artifactId\n            <version3.4.9</version\n        </dependency\n\n\n3.YML\n\nyml\n8004表示注册到zookeeper服务器的支付服务提供者端口号\nserver:\n  port: 8004\n\n服务别名注册zookeeper到注册中心名称\nspring:\n  application:\n    name: cloudproviderpayment\n  cloud:\n    zookeeper:\n      connectstring: 127.0.0.1:2181  192.168.111.144:2181 \n\n\n4.主启动类\n\njava\n@EnableDiscoveryClient//该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n\n\n5.Controller\n\nJAVA\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @RequestMappingvalue = \"/payment/zk\"\n    public String paymentzk\n    {\n        return \"springcloud with zookeeper: \"+serverPort+\"\\t\"+ UUID.randomUUID.toString;\n    }\n}\n\n\n 订单服务注册进zookeeper\n\n1.新建cloudconsumerzkorder80（与上面类似）\n\n2.POM\n\n3.YML\n\n4.主启动\n\n5.配置类\n\njava\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate\n    {\n        return new RestTemplate;\n    }\n}\n\n\n6.业务类\n\njava\n@RestController\n@Slf4j\npublic class OrderZKController\n{\n    public static final String INVOKEURL = \"http://cloudproviderpayment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMappingvalue = \"/consumer/payment/zk\"\n    public String paymentInfo\n    {\n        String result = restTemplate.getForObjectINVOKEURL+\"/payment/zk\",String.class;\n        return result;\n    }\n}\n\n\n7.访问测试地址  http://localhost/consumer/payment/zk\n\n Consul\n\n官网链接：https://www.consul.io/\n\nConsul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。\n\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\n\n它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。\n\n能干嘛？\n\n 服务发现  提供HTTP和DNS两种发现方式。\n 健康监测  支持多种方式，HTTP、TCP、Docker、Shell脚本定制化\n KV存储  Key、Value的存储方式\n 多数据中心  Consul支持多数据中心\n 可视化Web界面\n\n相关命令\n\n 查看版本：consul v\n 开发模式启动consul agent dev\n\n浏览器输入  http://localhost:8500/  打开Consul控制页。\n\n 服务提供者注册进Consul\n\n1.新建Module支付服务provider8006\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterconsuldiscovery</artifactId\n</dependency\n\n\n3.YML\n\nyaml\nconsul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consulproviderpayment\nconsul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        hostname: 127.0.0.1\n        servicename: ${spring.application.name}\n\n\n4.主启动类\n\njava\n@EnableDiscoveryClient\n\n\n5.业务类Controller\n\njava\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @RequestMappingvalue = \"/payment/consul\"\n    public String paymentConsul\n    {\n        return \"springcloud with consul: \"+serverPort+\"\\t   \"+ UUID.randomUUID.toString;\n    }\n}\n\n\n6.验证测试\n\n http://localhost:8006/payment/consul\n http://localhost:8500  会显示provider8006\n\n 服务消费者注册进Consul\n\n1.新建Module消费服务order80  cloudconsumerconsulorder80\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterconsuldiscovery</artifactId\n</dependency\n\n\n3.YML\n\njava\nconsul服务端口号\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloudconsumerorder\nconsul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        hostname: 127.0.0.1\n        servicename: ${spring.application.name}\n\n\n4.主启动类\n\njava\n@EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n\n\n5.配置Bean\n\njava\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate\n    {\n        return new RestTemplate;\n    }\n}\n\n\n6.业务类\n\njava\n@RestController\n@Slf4j\npublic class OrderConsulController\n{\n    public static final String INVOKEURL = \"http://consulproviderpayment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMappingvalue = \"/consumer/payment/consul\"\n    public String paymentInfo\n    {\n        String result = restTemplate.getForObjectINVOKEURL+\"/payment/consul\",String.class;\n        return result;\n    }\n}\n\n\n7.验证测试\n\n运行consul，cloudproviderconsulpayment8006，cloudconsumerconsulorder80\n\nhttp://localhost:8500/ 主页会显示出consul，cloudproviderconsulpayment8006，cloudconsumerconsulorder80三服务。\n\n8.访问测试地址  http://localhost/consumer/payment/consul\n\n 三个注册中心异同点\n\n 组件名     语言CAP  服务健康检查  对外暴露接口  Spring Cloud集成 \n          \n Eureka     Java     AP            可配支持      HTTP             \n Consul     Go       CP            支持          HTTP/DNS         \n Zookeeper  Java     CP            支持客户端    已集成           \n\nCAP：\n\n C：Consistency 强一致性\n A：Availability 可用性\n P：Partition tolerance （分区容错性\n\n111.pnghttps://imgblog.csdnimg.cn/imgconvert/b41e0791c9652955dd3a2bc9d2d60983.png\n\n最多只能同时较好的满足两个。\n\nCAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。\n\n因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:\n\nCA  单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。\nCP  满足一致性，分区容忍必的系统，通常性能不是特别高。\nAP  满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n AP架构（Eureka）\n\n当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\n\n结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n\n123.pnghttps://imgblog.csdnimg.cn/imgconvert/2d07748539300b9c466eb1d9bac5cd1b.png\n\n CP架构（ZooKeeper/Consul）\n\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。\n\n结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。\n\ne21x.pnghttps://imgblog.csdnimg.cn/imgconvert/c6f2926a97420015fcebc89b094c5598.png\n\nCP 与 AP 对立同一的矛盾关系。\n\n 服务调用\n\n Ribbon\n\nSpring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。\n\n简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。\n\nRibbon未来可能被Spring Cloud LoadBalacer替代。\n\nLB负载均衡Load Balance是什么\n\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA 高可用。\n\n常见的负载均衡有软件Nginx，LVS，硬件F5等。\n\nRibbon本地负载均衡客户端 VS Nginx服务端负载均衡区别\n\nNginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\nRibbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\n\n集中式LB\n\n即在服务的消费方和提供方之间使用独立的LB设施可以是硬件，如F5, 也可以是软件，如nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方;\n\n进程内LB\n\n将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\nRibbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n一句话\n\n负载均衡 + RestTemplate调用\n\n Ribbon的负载均衡和Rest调用\n\n总结：Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。\n\n1dc.pnghttps://imgblog.csdnimg.cn/imgconvert/145b915e56a85383b3ad40f0bb2256e0.png\n\nRibbon在工作时分成两步：\n\n 第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。\n 第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。\n\n其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。\n\nspringcloudstarternetflixeurekaclient自带了springcloudstarterribbon引用\n\n Ribbon默认自带的负载规则\n\nlRule：根据特定算法中从服务列表中选取一个要访问的服务\n\nasdacg2.pnghttps://imgblog.csdnimg.cn/imgconvert/87243c00c0aaea211819c0d8fc97e445.png\n\n RoundRobinRule 轮询\n RandomRule 随机\n RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重\n WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择\n BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例\n ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器\n\nRibbon负载规则替换\n\n1.修改cloudconsumerorder80\n\n2.注意配置细节\n\n官方文档明确给出了警告：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了（也就是说不要将Ribbon配置类与主启动类同包）\n\n3.新建package  com.lun.myrule\n\n4.在com.ljx.myrule下新建MySelfRule规则类\n\njava\n@Configuration\npublic class MySelfRule {\n\n    @Bean\n    public IRule myRule{\n        return new RandomRule;\n    }\n}\n\n\n5.主启动类添加\n\njava\n@RibbonClientname = \"CLOUDPAYMENTSERVICE\", configuration = MySelfRule.class\n\n\n OpenFeign\n\nFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。\n\n前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\n\nFeign集成了Ribbon\n\n利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。\n\n Feign和OpenFeign两者区别\n\nFeign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterfeign</artifactId\n</dependency\n\n\npenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVc的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n\n\n OpenFeign服务调用\n\n接口+注解：微服务调用接口 + @FeignClient\n\n1.新建cloudconsumerfeignorder80\n\n2.POM\n\nxml\n<dependency\n     <groupIdorg.springframework.cloud</groupId\n     <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 80\n\neureka:\n  client:\n    registerwitheureka: false\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n\n\n4.主启动\n\njava\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n    public static void mainString args {\n        SpringApplication.runOrderFeignMain80.class, args;\n    }\n}\n\n\n5.业务类\n\n业务逻辑接口+@FeignClient配置调用provider服务\n\n新建PaymentFeignService接口并新增注解@FeignClient\n\njava\n@Component\n@FeignClientvalue = \"CLOUDPAYMENTSERVICE\"\npublic interface PaymentFeignService\n{\n    @GetMappingvalue = \"/payment/get/{id}\"\n    public CommonResult<Payment getPaymentById@PathVariable\"id\" Long id;\n}\n\n\n注意：若有公共前缀api的请求，需要修改为@FeignClientvalue = \"xx\", path=\"/api\"\n\nController类\n\njava\n@RestController\n@Slf4j\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n\n    @GetMappingvalue = \"/consumer/payment/get/{id}\"\n    public CommonResult<Payment getPaymentById@PathVariable\"id\" Long id\n    {\n        return paymentFeignService.getPaymentByIdid;\n    }\n}\n\n\n6.测试\n\n先启动2个eureka集群7001/7002，再启动2个微服务8001/8002，最后启动OpenFeign启动\n\n访问http://localhost/consumer/payment/get/1\n\nFeign自带负载均衡配置项\n\n OpenFeign超时控制\n\n超时设置，故意设置超时演示出错情况\n\n1.服务提供方8001/8002故意写暂停程序\n\njava\n    @GetMappingvalue = \"/payment/feign/timeout\"\n    public String paymentFeignTimeout\n    {\n        // 业务逻辑处理正确，但是需要耗费3秒钟\n        try {\n            TimeUnit.SECONDS.sleep3;\n        } catch InterruptedException e {\n            e.printStackTrace;\n        }\n        return serverPort;\n    }\n\n\n2.服务消费方80添加超时方法PaymentFeignService\n\njava\n@GetMappingvalue = \"/payment/feign/timeout\"\npublic String paymentFeignTimeout;\n\n\n3.服务消费方80添加超时方法OrderFeignController\n\njava\n@GetMappingvalue = \"/consumer/payment/feign/timeout\"\npublic String paymentFeignTimeout\n{\n    // OpenFeign客户端一般默认等待1秒钟\n    return paymentFeignService.paymentFeignTimeout;\n}\n\n\n4.测试：\n\n多次刷新http://localhost/consumer/payment/feign/timeout\n\n将会跳出错误Spring Boot默认错误页面，主要异常：feign.RetryableException:Read timed out executing GET http://CLOUDPAYMENTSERVCE/payment/feign/timeout。\n\nOpenFeign默认等待1秒钟，超过后报错\n\nYML文件里需要开启OpenFeign客户端超时控制\n\nyml\n设置feign客户端超时时间OpenFeign默认支持ribbon单位：毫秒\nribbon:\n  指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  ReadTimeout: 5000\n  指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n\n\n OpenFeign日志增强\n\n日志打印功能\n\nFeign提供了日志打印功能，我们可以通过配置来调整日恙级别，从而了解Feign 中 Http请求的细节。\n\n说白了就是对Feign接口的调用情况进行监控和输出\n\n日志级别\n\n NONE：默认的，不显示任何日志;\n BASIC：仅记录请求方法、URL、响应状态码及执行时间;\n HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;\n FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。\n\n配置日志bean\n\njava\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel\n    {\n        return Logger.Level.FULL;\n    }\n}\n\n\nYML文件里需要开启日志的Feign客户端\n\nyml\nlogging:\n  level:\n     feign日志以什么级别监控哪个接口\n    com.ljx.springcloud.service.PaymentFeignService: debug\n\n\n后台日志查看\n\n得到更多日志信息\n\n 服务降级\n\n分布式系统面临的问题\n\n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n\n服务雪崩\n\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\n对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n\n所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n\n Hystrix\n\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n\n\"断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝，向调用方返回一个符合预期的、可处理的备选响应（FallBack，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n主要功能\n\n 服务降级\n 服务熔断\n 接近实对的监控\n\n服务降级\n\n服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback\n\n哪些情况会出发降级？\n\n 程序运行导常\n\n 超时\n 服务熔断触发服务降级\n 线程池/信号量打满也会导致服务降级\n\n服务熔断\n\n类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。\n\n服务的降级  进而熔断  恢复调用链路\n\n服务限流\n\n秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。\n\n Hystrix支付微服务构建\n\n1.新建cloudproviderhygtrixpayment8001\n\n2.POM\n\nxml\n<dependency\n      <groupIdorg.springframework.cloud</groupId\n      <artifactIdspringcloudstarternetflixhystrix</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloudproviderhystrixpayment\n\neureka:\n  client:\n    registerwitheureka: true\n    fetchregistry: true\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n4.主启动\n\njava\n@EnableEurekaClient\n\n\n5.业务类\n\nservice\n\njava\n@Service\npublic class PaymentService {\n    /\n     /\n    public String paymentInfoOKInteger id\n    {\n        return \"线程池:  \"+Thread.currentThread.getName+\"  paymentInfoOK,id:  \"+id+\"\\t\"+\"O∩∩O哈哈\";\n    }\n\n    public String paymentInfoTimeOutInteger id\n    {\n        try { TimeUnit.MILLISECONDS.sleep3000; } catch InterruptedException e { e.printStackTrace; }\n        return \"线程池:  \"+Thread.currentThread.getName+\" id:  \"+id+\"\\t\"+\"O∩∩O哈哈\"+\"  耗时秒: 3\";\n    }\n}\n\n\ncontroller\n\njava\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Resource\n    private PaymentService paymentService;\n\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @GetMapping\"/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id\n    {\n        String result = paymentService.paymentInfoOKid;\n        log.info\"result: \"+result;\n        return result;\n    }\n\n    @GetMapping\"/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id\n    {\n        String result = paymentService.paymentInfoTimeOutid;\n        log.info\"result: \"+result;\n        return result;\n    }\n}\n\n\n6.正常测试\n\n以上述为根基平台，从正确  错误  降级熔断  恢复。\n\n JMeter高并发压测后卡顿\n\n上述在非高并发情形下，还能勉强满足\n\nJmeter压测结论\n\n上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢\n\n Hystrix订单微服务\n\n1.新建  cloudconsumerfeignhystrixorder80\n\n2.POM\n\nxml\n<dependency\n      <groupIdorg.springframework.cloud</groupId\n      <artifactIdspringcloudstarternetflixhystrix</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 80\n\neureka:\n  client:\n    registerwitheureka: false\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n4.主启动\n\n5.业务类\n\njava\n@Component\n@FeignClientvalue = \"CLOUDPROVIDERHYSTRIXPAYMENT\" /,fallback = PaymentFallbackService.class/\npublic interface PaymentHystrixService\n{\n    @GetMapping\"/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id;\n\n    @GetMapping\"/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id;\n}\n\n\njava\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping\"/consumer/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id\n    {\n        String result = paymentHystrixService.paymentInfoOKid;\n        return result;\n    }\n\n    @GetMapping\"/consumer/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id {\n        String result = paymentHystrixService.paymentInfoTimeOutid;\n        return result;\n    }\n}\n\n\n6.正常测试\n\n7.高并发测试\n\n2W个线程压8001，消费端80微服务再去访问正常的Ok微服务8001地址，消费者80被拖慢\n\n原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。\n\n正因为有上述故障或不佳表现才有我们的降级/容错/限流等技术诞生。\n\n 降级容错解决的维度要求\n\n超时导致服务器变慢转圈 》超时不再等待\n\n出错宕机或程序运行出错 》 出错要有兜底\n\n解决：\n\n 对方服务8001超时了，调用者80不能一直卡死等待，必须有服务降级。\n 对方服务8001down机了，调用者80不能一直卡死等待，必须有服务降级。\n 对方服务8001OK，调用者80自己出故障或有自我要求自己的等待时间小于服务提供者，自己处理降级。\n\n Hystrix服务降级支付fallback\n\n降级配置  @HystrixCommand\n\n设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。\n\n—旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法\n\njava\n@Service\npublic class PaymentService{\n\n    @HystrixCommandfallbackMethod = \"paymentInfoTimeOutHandler\", commandProperties = {\n            @HystrixPropertyname=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\"\n    }\n    public String paymentInfoTimeOutInteger id\n    {\n        //int age = 10/0;\n        try { TimeUnit.MILLISECONDS.sleep5000; } catch InterruptedException e { e.printStackTrace; }\n        return \"线程池:  \"+Thread.currentThread.getName+\" id:  \"+id+\"\\t\"+\"O∩∩O哈哈\"+\"  耗时秒: \";\n    }\n\n    //用来善后的方法\n    public String paymentInfoTimeOutHandlerInteger id\n    {\n        return \"线程池:  \"+Thread.currentThread.getName+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o╥﹏╥o\";\n    }\n    \n}\n\n\n上面故意制造两种异常:\n\n1. int age = 10/0，计算异常\n2. 我们能接受3秒钟，它运行5秒钟，超时异常。\n\n当前服务不可用了，做服务降级，兜底的方案都是paymentInfoTimeOutHandler\n\n主启动类激活\n\n添加新注解@EnableCircuitBreaker\n\n Hystrix服务降级订单fallback\n\n1.YML\n\nyml\nserver:\n  port: 80\n\neureka:\n  client:\n    registerwitheureka: false\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n开启\nfeign:\n  hystrix:\n    enabled: true\n\n\n2.主启动添加@EnableHystrix\n\n3.业务类\n\njava\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping\"/consumer/payment/hystrix/timeout/{id}\"\n    @HystrixCommandfallbackMethod = \"paymentTimeOutFallbackMethod\",commandProperties = {\n            @HystrixPropertyname=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"1500\"\n    }\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id {\n        //int age = 10/0;\n        String result = paymentHystrixService.paymentInfoTimeOutid;\n        return result;\n    }\n    \n    //善后方法\n    public String paymentTimeOutFallbackMethod@PathVariable\"id\" Integer id{\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o╥﹏╥o\";\n    }\n}\n\n\n Hystrix全局服务降级DefaultProperties\n\n前问题1 每个业务方法对应一个兜底的方法，代码膨胀\n\n解决方法\n\n1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明\n\n1:N除了个别重要核心业务有专属，其它普通的可以通过@DefaultPropertiesdefaultFallback = “xxx”统一跳转到统一处理结果页面\n\n通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量\n\njava\n@RestController\n@Slf4j\n@DefaultPropertiesdefaultFallback = \"paymentGlobalFallbackMethod\"\npublic class OrderHystirxController {\n\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping\"/consumer/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id\n    {\n        String result = paymentHystrixService.paymentInfoOKid;\n        return result;\n    }\n\n//    @HystrixCommandfallbackMethod = \"paymentTimeOutFallbackMethod\", commandProperties = {\n//            @HystrixPropertyname=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\"\n//    }\n    @HystrixCommand//用全局的fallback方法\n    @GetMapping\"/consumer/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id {\n        String result = paymentHystrixService.paymentInfoTimeOutid;\n        return result;\n    }\n\n    //善后方法\n    public String paymentTimeOutFallbackMethod@PathVariable\"id\" Integer id{\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o╥﹏╥o\";\n    }\n\n    // 下面是全局fallback方法\n    public String paymentGlobalFallbackMethod\n    {\n        return \"Global异常处理信息，请稍后再试，/ㄒoㄒ/\";\n    }\n}\n\n\n Hystrix通配服务降级FeignFallback\n\n目前问题2 统一和自定义的分开，代码混乱\n\n服务降级，客户端去调用服务端，碰上服务端宕机或关闭\n\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feignhttps://so.csdn.net/so/search?q=Feign&spm=1001.2101.3001.7020客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n\n未来我们要面对的异常\n\n 运行\n 超时\n 宕机\n\n1.新建PaymentFallbackService类实现PaymentHystrixService接口\n\njava\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackService implements PaymentHystrixService\n{\n    @Override\n    public String paymentInfoOKInteger id\n    {\n        return \"PaymentFallbackService fall backpaymentInfoOK ,o╥﹏╥o\";\n    }\n\n    @Override\n    public String paymentInfoTimeOutInteger id\n    {\n        return \"PaymentFallbackService fall backpaymentInfoTimeOut ,o╥﹏╥o\";\n    }\n}\n\n\n2.YML\n\nyml\nfeign:\n  hystrix:\n    enabled: true\n\n\n3.PaymentHystrixService接口\n\njava\n@Component\n@FeignClientvalue = \"CLOUDPROVIDERHYSTRIXPAYMENT\" ,\n             fallback = PaymentFallbackService.class//指定PaymentFallbackService类\npublic interface PaymentHystrixService\n{\n    @GetMapping\"/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id;\n\n    @GetMapping\"/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id;\n}\n\n\n4.测试\n\n单个eureka先启动7001，PaymentHystrixMain8001启动\n\n正常访问测试  http://localhost/consumer/payment/hystrix/ok/1，故意关闭微服务8001\n\n客户端自己调用提示  此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。\n\n Hystrix服务熔断理论\n\n断路器，相当于保险丝。\n\n熔断机制概述\n\n熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，只有当成功率挺高到一定阈值才会关闭。熔断机制的注解是@HystrixCommand。\n\n Hystrix之服务熔断案例\n\nHutool国产工具类https://hutool.cn/\n\n修改cloudproviderhystrixpayment8001\n\nservice层\n\njava\n@Service\npublic class PaymentService{    \n   \n    //=====服务熔断\n    @HystrixCommandfallbackMethod = \"paymentCircuitBreakerfallback\",commandProperties = {\n            @HystrixPropertyname = \"circuitBreaker.enabled\",value = \"true\",// 是否开启断路器\n            @HystrixPropertyname = \"circuitBreaker.requestVolumeThreshold\",value = \"10\",// 请求次数\n            @HystrixPropertyname = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\", // 时间窗口期\n            @HystrixPropertyname = \"circuitBreaker.errorThresholdPercentage\",value = \"60\",// 失败率达到多少后跳闸\n    }\n    public String paymentCircuitBreaker@PathVariable\"id\" Integer id {\n        ifid < 0 {\n            throw new RuntimeException\"id 不能负数\";\n        }\n        String serialNumber = IdUtil.simpleUUID;\n\n        return Thread.currentThread.getName+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreakerfallback@PathVariable\"id\" Integer id {\n        return \"id 不能负数，请稍后再试，/ㄒoㄒ/   id: \" +id;\n    }\n\n}\n\n\ncontroller层\n\njava\n@GetMapping\"/payment/circuit/{id}\"\npublic String paymentCircuitBreaker@PathVariable\"id\" Integer id\n{\n    String result = paymentService.paymentCircuitBreakerid;\n    log.info\"result: \"+result;\n    return result;\n}\n\n\n测试\n\n多次错误，再来次正确，但错误得显示\n\n重点测试  多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行\n\n Hystrix服务熔断总结\n\n熔断类型\n\n 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR平均故障处理时间，当打开时长达到所设时钟则进入半熔断状态。\n 熔断关闭：熔断关闭不会对服务进行熔断。\n 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。\n\n断路器开启或者关闭的条件\n\n 到达以下阀值，断路器将会开启：\n   当满足一定的阀值的时候（默认10秒内超过20个请求次数\n   当失败率达到一定的时候（默认10秒内超过50%的请求失败\n 当开启的时候，所有请求都不会进行转发\n 一段时间之后（默认是5秒，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。\n\n断路器打开之后\n\n1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n\n2：原来的主逻辑要如何恢复呢？\n\n对于这一问题，hystrix也为我们实现了自动恢复功能。\n\n当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n\nAll配置\n\njava\n@HystrixCommandfallbackMethod = \"fallbackMethod\", \n                groupKey = \"strGroupCommand\", \n                commandKey = \"strCommand\", \n                threadPoolKey = \"strThreadPool\",\n                \n                commandProperties = {\n                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离\n                    @HystrixPropertyname = \"execution.isolation.strategy\", value = \"THREAD\",\n                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\n                    @HystrixPropertyname = \"execution.isolation.semaphore.maxConcurrentRequests\", value = \"10\",\n                    // 配置命令执行的超时时间\n                    @HystrixPropertyname = \"execution.isolation.thread.timeoutinMilliseconds\", value = \"10\",\n                    // 是否启用超时时间\n                    @HystrixPropertyname = \"execution.timeout.enabled\", value = \"true\",\n                    // 执行超时的时候是否中断\n                    @HystrixPropertyname = \"execution.isolation.thread.interruptOnTimeout\", value = \"true\",\n                    \n                    // 执行被取消的时候是否中断\n                    @HystrixPropertyname = \"execution.isolation.thread.interruptOnCancel\", value = \"true\",\n                    // 允许回调方法执行的最大并发数\n                    @HystrixPropertyname = \"fallback.isolation.semaphore.maxConcurrentRequests\", value = \"10\",\n                    // 服务降级是否启用，是否执行回调函数\n                    @HystrixPropertyname = \"fallback.enabled\", value = \"true\",\n                    // 是否启用断路器\n                    @HystrixPropertyname = \"circuitBreaker.enabled\", value = \"true\",\n                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\n                    @HystrixPropertyname = \"circuitBreaker.requestVolumeThreshold\", value = \"20\",\n                    \n                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 \"打开\" 状态，否则就设置为 \"关闭\" 状态。\n                    @HystrixPropertyname = \"circuitBreaker.errorThresholdPercentage\", value = \"50\",\n                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 \"半开\" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 \"打开\" 状态，如果成功就设置为 \"关闭\" 状态。\n                    @HystrixPropertyname = \"circuitBreaker.sleepWindowinMilliseconds\", value = \"5000\",\n                    // 断路器强制打开\n                    @HystrixPropertyname = \"circuitBreaker.forceOpen\", value = \"false\",\n                    // 断路器强制关闭\n                    @HystrixPropertyname = \"circuitBreaker.forceClosed\", value = \"false\",\n                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\n                    @HystrixPropertyname = \"metrics.rollingStats.timeinMilliseconds\", value = \"10000\",\n                    \n                    // 该属性用来设置滚动时间窗统计指标信息时划分\"桶\"的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 \"桶\" 来累计各度量值，每个\"桶\"记录了一段时间内的采集指标。\n                    // 比如 10 秒内拆分成 10 个\"桶\"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常\n                    @HystrixPropertyname = \"metrics.rollingStats.numBuckets\", value = \"10\",\n                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 1。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.enabled\", value = \"false\",\n                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.timeInMilliseconds\", value = \"60000\",\n                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.numBuckets\", value = \"60000\",\n                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\n                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\n                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.bucketSize\", value = \"100\",\n                    \n                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\n                    @HystrixPropertyname = \"metrics.healthSnapshot.intervalinMilliseconds\", value = \"500\",\n                    // 是否开启请求缓存\n                    @HystrixPropertyname = \"requestCache.enabled\", value = \"true\",\n                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中\n                    @HystrixPropertyname = \"requestLog.enabled\", value = \"true\",\n\n                },\n                threadPoolProperties = {\n                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\n                    @HystrixPropertyname = \"coreSize\", value = \"10\",\n                    // 该参数用来设置线程池的最大队列大小。当设置为 1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。\n                    @HystrixPropertyname = \"maxQueueSize\", value = \"1\",\n                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\n                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\n                    @HystrixPropertyname = \"queueSizeRejectionThreshold\", value = \"5\",\n                }\n               \npublic String doSomething {\n\t...\n}\n\n\n Hystrix图形化Dashboard搭建\n\n概述\n\n除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控Hystrix Dashboard，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。\n\nNetflix通过hystrixmetricseventstream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\n\n仪表盘9001\n\n1新建cloudconsumerhystrixdashboard9001\n\n2.POM\n\nxml\n<dependency\n       <groupIdorg.springframework.cloud</groupId\n       <artifactIdspringcloudstarternetflixhystrixdashboard</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 9001\n\n\n4.HystrixDashboardMain9001+新注解@EnableHystrixDashboard\n\n5.所有Provider微服务提供类8001/8002/8003都需要监控依赖配置\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\n6.浏览器输入http://localhost:9001/hystrix\n\n Hystrix图形化Dashboard监控实战\n\n修改cloudproviderhystrixpayment8001\n\n注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径\n\njava\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class PaymentHystrixMain8001\n{\n    public static void mainString args {\n            SpringApplication.runPaymentHystrixMain8001.class, args;\n    }\n\n\n    /\n     此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"，\n     只要在自己的项目里配置上下面的servlet就可以了\n     否则，Unable to connect to Command Metric Stream 404\n     /\n    @Bean\n    public ServletRegistrationBean getServlet {\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet;\n        ServletRegistrationBean registrationBean = new ServletRegistrationBeanstreamServlet;\n        registrationBean.setLoadOnStartup1;\n        registrationBean.addUrlMappings\"/hystrix.stream\";\n        registrationBean.setName\"HystrixMetricsStreamServlet\";\n        return registrationBean;\n    }\n}\n\n\n监控测试\n\n启动1个eureka\n\n启动8001，9001\n\n观察监控窗口\n\n9001监控8001  填写监控地址  http://localhost:8001/hystrix.stream 到 http://localhost:9001/hystrix页面的输入框。\n\n测试地址\n\n http://localhost:8001/payment/circuit/1\n http://localhost:8001/payment/circuit/1\n 测试通过\n 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。\n\n 服务网关\n\n GateWay\n\n概述\n\nCloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;\n\n但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代\n\naxh25f.pnghttps://imgblog.csdnimg.cn/imgconvert/54b61d819aa1630bc61732de340b55b4.png\n\nGateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。\n\nSpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。\n\n作用\n\n 方向代理\n 鉴权\n 流量控制\n 熔断\n 日志监控\n …\n\n微服务架构中网关的位置\n\nasd14667.pnghttps://imgblog.csdnimg.cn/imgconvert/5877d4b9035ead9cd2d037609dceb442.png\n\n Gateway工作流程\n\n三大核心概念\n\n Route路由  路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；\n Predicate断言  参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容例如请求头或请求参数,如果请求与断言相匹配则进行路由；\n Filter过滤  指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。\n  \n\nd1c.pnghttps://imgblog.csdnimg.cn/imgconvert/62be54501c6e2b95620b79cc918a2e9a.png\n\n客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。\n\nHandler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前“pre”或之后“post\"）执行业务逻辑。\n\nFilter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n\n核心逻辑：路由转发 + 执行过滤器链。\n\n Gateway9527搭建\n\n1.新建Mod\tule  cloudgatewaygateway9527\n\n2.POM\n\n4.业务类 无\n\n5.主启动类\n\njava\n@SpringBootApplication\n@EnableEurekaClient\npublic class GateWayMain9527\n{\n    public static void mainString args {\n        SpringApplication.runGateWayMain9527.class, args;\n    }\n}\n\n\n我们目前不想暴露8001端口，希望在8001外面套一层9527\n\n7.YML新增网关配置\n\nyml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloudgateway\n新增网关配置\n  cloud:\n    gateway:\n      routes:\n         id: paymentrouth paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/get/          断言，路径相匹配的进行路由\n\n         id: paymentrouth2 paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/lb/          断言，路径相匹配的进行路由\n\n\neureka:\n  instance:\n    hostname: cloudgatewayservice\n  client: 服务提供者provider注册进eureka服务列表内\n    serviceurl:\n      registerwitheureka: true\n      fetchregistry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n\n\n8.测试\n\n启动7001，启动8001cloudproviderpayment8001，启动9527网关\n\n访问说明\n\n 添加网关前  http://localhost:8001/payment/get/1\n 添加网关后  http://localhost:9527/payment/get/1\n 两者访问成功，返回相同结果（可以通过9527端口访问8001端口接口）\n\n Gateway配置路由的两种方式\n\n1.在配置文件yml中配置，见上一章节\n\n2.代码中注入RouteLocator的Bean\n\ncloudgatewaygateway9527业务实现\n\njava\n@Configuration\npublic class GateWayConfig\n{\n    @Bean\n    public RouteLocator customRouteLocatorRouteLocatorBuilder routeLocatorBuilder\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes;\n\n        routes.route\"pathrouteljx\",\n                r  r.path\"\"\n                        .uri\"https://www.baidu.com\".build;\n\n        return routes.build;\n    }\n}\n\n\n浏览器输入http://localhost:9527，返回https://www.baidu.com相同的页面。\n\n GateWay配置动态路由\n\n默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能（不写死一个地址）\n\nPOM\n\n cloudgatewaygateway9527的POM中添加\n\nxml\n<eurekaclient\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\nYML\n\n需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。\n\nlb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。\n\nyml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloudgateway\n新增网关配置\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true 开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n         id: paymentrouth paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/get/          断言，路径相匹配的进行路由\n\n         id: paymentrouth2 paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/lb/          断言，路径相匹配的进行路由\n\n\neureka:\n  instance:\n    hostname: cloudgatewayservice\n  client: 服务提供者provider注册进eureka服务列表内\n    serviceurl:\n      registerwitheureka: true\n      fetchregistry: true\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n测试\n\n浏览器输入  http://localhost:9527/payment/lb\n\n不停刷新页面，8001/8002两个端口切换。\n\n GateWay常用的Predicate\n\n常用的Route Predicate Factory\n\nThe After Route Predicate Factory\nThe Before Route Predicate Factory\nThe Between Route Predicate Factory\nThe Cookie Route Predicate Factory\nThe Header Route Predicate Factory\nThe Host Route Predicate Factory\nThe Method Route Predicate Factory\nThe Path Route Predicate Factory\nThe Query Route Predicate Factory\nThe RemoteAddr Route Predicate Factory\nThe weight Route Predicate Factory\n\nThe After Route Predicate Factory\n\n作用：只有在规定的时间之后启动才能生效\n\n在yml中添加\n\nyml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: afterroute\n        uri: lb://cloudpaymentservice\n        predicates:\n         Path=/payment/get/      \n         这个时间后才能起效\n         After=20230802T14:59:26.090582100+08:00Asia/Shanghai\n\n\n可以通过下述方法获得上述格式的时间戳字符串\n\njava\nZonedDateTime zbj = ZonedDateTime.now; // 默认时区\nSystem.out.printlnzbj;\n\n\nThe Between Route Predicate Factory\n\n作用：只有在规定的时间范围内启动才生效\n\n在yml中添加\n\nyaml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: betweenroute\n        uri: lb://cloudpaymentservice\n         两个时间点之间\n        predicates:\n          Path=/payment/get/   \n         Between=20240120T17:42:47.78907:00America/Denver, 20230802T14:59:26.090582100+08:00Asia/Shanghai\n\n\nThe Cookie Route Predicate Factory\n\n作用：只有带username=ljx的cookie的请求才有效\n\nyml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: cookieroute\n        uri: lb://cloudpaymentservice\n        predicates:\n         Cookie=username,ljx\n\n\nhe Header Route Predicate Factory\n\n作用：只有带XRequestId=正整数的请求头才有效\n\nyml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: headerroute\n        uri: lb://cloudpaymentservice\n        predicates:\n         Header=XRequestId, \\d+\n\n\n小结\n\nPredicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。\n\n GateWay的Filter\n\n路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。\n\nSpring Cloud Gateway的Filter:\n\n 生命周期：\n   pre\n   post\n 种类（具体看官方文档）：\n   GatewayFilter  有31种\n   GlobalFilter  有10种\n\n常用的GatewayFilter：AddRequestParameter，GatewayFilter\n\n自定义全局GlobalFilter：\n\n两个主要接口介绍：\n\n1. GlobalFilter\n2. Ordered\n\n能干什么：\n\n1. 全局日志记录\n2. 统一网关鉴权\n3. …\n\n代码案例：\n\nGateWay9527项目添加MyLogGateWayFilter类：\n\njava\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    \n    @Override\n    public Mono<Void filterServerWebExchange exchange, GatewayFilterChain chain\n    {\n        log.info\"come in MyLogGateWayFilter:  \"+new Date;\n        // 处理只有带了uname的请求才能通过\n        String uname = exchange.getRequest.getQueryParams.getFirst\"uname\";\n\n        ifuname == null\n        {\n            log.info\"用户名为null，非法用户，o╥﹏╥o\";\n            exchange.getResponse.setStatusCodeHttpStatus.NOTACCEPTABLE;\n            return exchange.getResponse.setComplete;\n        }\n\n        return chain.filterexchange;\n    }\n\n    @Override\n    public int getOrder\n    {\n        return 0;\n    }\n}\n\n\n测试，浏览器输入：\n\n http://localhost:9527/payment/lb  反问异常\n http://localhost:9527/payment/lb?uname=abc  正常反问\n\n 服务配置\n\n config\n\n Config分布式配置中心介绍\n\n分布式系统面临的配置问题\n\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。\n\nSpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……\n\ndsaxcj1.pnghttps://imgblog.csdnimg.cn/imgconvert/d5462e3b8c3a063561f5f8fc7fde327e.png\n\nSpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n\nSpringCloud Config分为服务端和客户端两部分。\n\n 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。\n\n 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。\n\n能干嘛\n\n 集中管理配置文件\n 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n 将配置信息以REST接口的形式暴露  post/crul访问刷新即可…\n  \n\n与GitHub整合配置\n\n由于SpringCloud Config默认使用Git来存储配置文件也有其它方式,比如支持SVN和本地文件，但最推荐的还是Git，而且使用的是http/https访问的形式。\n\n Config配置总控中心搭建\n\n用你自己的账号在GitHub上新建一个名为springcloudconfig的新Repository。\n\n由上一步获得刚新建的git地址  git@github.com:abc/springcloudconfig.git。\n\n本地硬盘目录上新建git仓库并clone。\n\n 工作目录为D:\\SpringCloud2021\n git clone git@github.com:abc/springcloudconfig.git\n\n此时在工作目录会创建名为springcloudconfig的文件夹。\n\n在springcloudconfig的文件夹种创建三个配置文件（为本次教学使用的）,随后git add .，git commit m \"sth\"等一系列上传操作上传到springcloudconfig的新Repository。\n\n configdev.yml\n\nyaml\nconfig:\n  info: \"master branch,springcloudconfig/configdev.yml version=7\"\n\n\n configprod.yml\n\nyaml\nconfig:\n  info: \"master branch,springcloudconfig/configprod.yml version=1\"\n\n\n configtest.yml\n\nyaml\nconfig:\n  info: \"master branch,springcloudconfig/configtest.yml version=1\" \n\n\n新建Module模块cloudconfigcenter3344，它即为Cloud的配置中心模块CloudConfig Center\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterbusamqp</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudconfigserver</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloudconfigcenter 注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/lijunxi666/springcloudconfig.git GitHub上面的git仓库名字\n          搜索目录\n          searchpaths:\n             springcloudconfig\n          skipsslvalidation: true\n      读取分支\n      label: master\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n\n主启动类加上@EnableConfigServer\n\nwindows下修改hosts文件，增加映射\n\n\n127.0.0.1 config3344.com\n\n\n测试\n\n启动ConfigCenterMain3344\n\n浏览器防问  http://config3344.com:3344/master/configdev.yml\n\n页面返回结果：\n\nyml\nconfig:\n  info: \"master branch,springcloudconfig/configdev.yml version=7\"\n\n\n访问文件的路径\n\n重要配置细节总结\n\n /{name}{profiles}.yml\n /{label}{name}{profiles}.yml\n label：分支branch\n name：服务名\n profiles：环境dev/test/prod\n\n成功实现了用SpringCloud Config通过GitHub获取配置信息\n\n Config客户端配置与测试\n\n新建cloudconfigclient3355\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterbusamqp</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudconfigserver</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\nbootstrap.yml\n\napplicaiton.yml是用户级的资源配置项\n\nbootstrap.yml是系统级的，优先级更加高\n\nyml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: configclient\n  cloud:\n    Config客户端配置\n    config:\n      label: master 分支名称\n      name: config 配置文件名称\n      profile: dev 读取后缀名称   上述3个综合：master分支上configdev.yml的配置文件被读取http://config3344.com:3344/master/configdev.yml\n      uri: http://localhost:3344 配置中心地址k\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka\n\n\n主启动添加@EnableEurekaClient\n\n业务类\n\njava\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value\"${config.info}\"\n    private String configInfo;\n\n    @GetMapping\"/configInfo\"\n    public String getConfigInfo\n    {\n        return configInfo;\n    }\n}\n\n\n测试\n\n 启动Config配置中心3344微服务并自测\n   http://config3344.com:3344/master/configprod.yml\n   http://config3344.com:3344/master/configdev.yml\n\n 启动3355作为Client准备访问\n   http://localhost:3355/configlnfo\n\n成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息可题随时而来\n\n分布式配置的动态刷新问题\n\n Linux运维修改GitHub上的配置文件内容做调整\n 刷新3344，发现ConfigServer配置中心立刻响应\n 刷新3355，发现ConfigClient客户端没有任何响应\n 3355没有变化除非自己重启或者重新加载\n 难到每次运维修改配置文件，客户端都需要重启??噩梦\n\n Config动态刷新手动版\n\n避免每次更新配置都要重启客户端微服务3355\n\n动态刷新步骤：\n\n修改3355模块\n\nPOM引入actuator监控\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\n修改YML，添加暴露监控端口配置：\n\nyaml\n 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"\"\n\n\n业务类Controller添加@RefreshScope\n\n测试\n\n此时修改github配置文件内容  访问3344  访问3355：http://localhost:3355/configInfo\n\n发现3355的内容并没刷新\n\n还需要一步\n\n需要运维人员发送Post请求刷新3355\n\n\ncurl X POST \"http://localhost:3355/actuator/refresh\"\n\n\n再次测试：http://localhost:3355/configInfo\n\n3355 改了。\n\n成功实现了客户端3355刷新到最新配置内容，避免了服务重启\n\n存在的问题\n\n 假如有多个微服务客户端3355/3366/3377\n 每个微服务都要执行—次post请求，手动刷新?\n 可否广播，一次通知，处处生效?\n 我们想大范围的自动刷新，求方法\n\n这时候就需要用到消息总线\n\n 消息总线\n\n一言以蔽之，分布式自动刷新配置功能。\n\nSpring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。\n\nd1xased.pnghttps://imgblog.csdnimg.cn/imgconvert/458fd679c01274ca84f785e1f75c1336.png\n\nSpring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\n\n为何被称为总线\n\n什么是总线？\n\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\n\n基本原理\n\nConfigClient实例都监听MQ中同一个topic默认是Spring Cloud Bus。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。\n\n RabbitMQ\n\n 环境配置\n\n严格遵循erlang和rabbitmq版本对应：RabbitMQ Erlang Version Requirements — RabbitMQhttps://www.rabbitmq.com/whicherlang.html\n\n 安装Erlang，下载地址：http://erlang.org/download/otpwin6421.3.exe\n\n 安装RabbitMQ，下载地址：https://github.com/rabbitmq/rabbitmqserver/releases/download/v3.7.14/rabbitmqserver3.7.14.exe\n\n 打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\\devSoft\\RabbitMQ Scrverk\\rabbitmqserver3.7.14\\sbin\n\n 输入以下命令启动管理功能rabbitmqplugins enable rabbitmq management\n\n这样就可以添加可视化插件。\n\n 访问地址查看是否安装成功：http://localhost:15672/\n 输入账号密码并登录：guest guest\n\n Bus动态刷新全局广播的设计思想和选型\n\n必须先具备良好的RabbitMQ环境先\n\n演示广播效果，增加复杂度，再以3355为模板再制作一个3366\n\n1.新建cloudconfigclient3366\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterbusamqp</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterconfig</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: configclient\n  cloud:\n    Config客户端配置\n    config:\n      label: master 分支名称\n      name: config 配置文件名称\n      profile: dev 读取后缀名称   上述3个综合：master分支上configdev.yml的配置文件被读取http://config3344.com:3344/master/configdev.yml\n      uri: http://localhost:3344 配置中心地址\n\nrabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n\n 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"\"\n\n\n4.主启动添加@EnableEurekaClient\n\n5.controller\n\njava\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @Value\"${config.info}\"\n    private String configInfo;\n\n    @GetMapping\"/configInfo\"\n    public String configInfo\n    {\n        return \"serverPort: \"+serverPort+\"\\t\\n\\n configInfo: \"+configInfo;\n    }\n\n}\n\n\n设计思想\n\n1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置\n\ndascx.pnghttps://imgblog.csdnimg.cn/imgconvert/3a0975f4bac7393fe406821531e9daef.png\n\n2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置\n\n2150vg0.pnghttps://imgblog.csdnimg.cn/imgconvert/e2809f728b8eb3e776883e4f905b8712.png\n\n图二的架构显然更加适合，图—不适合的原因如下：\n\n 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\n\n 破坏了微服务各节点的对等性。\n\n 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。\n\n Bus动态刷新全局广播配置实现\n\n给cloudconfigcenter3344配置中心服务端添加消息总线支持\n\nPOM\n\nxml\n<添加消息总线RabbitNQ支持\n<dependency\n\t<groupIdorg.springframework.cloud</groupId\n\t<artifactIdspringcloudstarterbusamap</artifactId\n</dependency\n<dependency\n\t<groupIdorgspringframework.boot</groupId\n\t<artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloudconfigcenter 注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloudconfig.git GitHub上面的git仓库名字\n        搜索目录\n          searchpaths:\n             springcloudconfig\n      读取分支\n      label: master\nrabbitmq相关配置<\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\nrabbitmq相关配置,暴露bus刷新配置的端点<\nmanagement:\n  endpoints: 暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'busrefresh'\n\n\n给cloudconfigclient3355客户端添加消息总线支持\n\nPOM\n\nxml\n<添加消息总线RabbitNQ支持\n<dependency\n\t<groupIdorg.springframework.cloud</groupId\n\t<artifactIdspringcloudstarterbusamap</artifactId\n</dependency\n<dependency\n\t<groupIdorgspringframework.boot</groupId\n\t<artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name:  cloudconfigcenter 注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloudconfig.git GitHub上面的git仓库名字\n        搜索目录\n          searchpaths:\n             springcloudconfig\n      读取分支\n      label: master\nrabbitmq相关配置<\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\nrabbitmq相关配置,暴露bus刷新配置的端点<\nmanagement:\n  endpoints: 暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'busrefresh'\n\n\n给cloudconfigclient3366客户端添加消息总线支持\n\nPOM\n\nxml\n<添加消息总线RabbitNQ支持\n<dependency\n\t<groupIdorg.springframework.cloud</groupId\n\t<artifactIdspringcloudstarterbusamap</artifactId\n</dependency\n<dependency\n\t<groupIdorgspringframework.boot</groupId\n\t<artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: configclient\n  cloud:\n    Config客户端配置\n    config:\n      label: master 分支名称\n      name: config 配置文件名称\n      profile: dev 读取后缀名称   上述3个综合：master分支上configdev.yml的配置文件被读取http://config3344.com:3344/master/configdev.yml\n      uri: http://localhost:3344 配置中心地址\n\nrabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口<\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"\"\n\n\n测试\n\n 启动\n   EurekaMain7001\n   EurekaMain7002\n   ConfigcenterMain3344\n   ConfigclientMain3355\n   ConfigclicntMain3366\n\n 运维工程师\n   修改Github上配置文件内容，增加版本号\n   发送POST请求\n     curl X POST \"http://localhost:3344/actuator/busrefresh\"\n     —次发送，处处生效\n\n 配置中心\n   http://config3344.com:3344/configdev.yml\n 客户端\n   http://localhost:3355/configlnfo\n   http://localhost:3366/configInfo\n   获取配置信息，发现都已经刷新了\n\n—次修改，广播通知，处处生效\n\n Bus动态刷新定点通知\n\n不想全部通知，只想定点通知\n\n 只通知3355\n 不通知3366\n\n简单一句话  指定具体某一个实例生效而不是全部\n\n 公式：http://localhost:3344/actuator/busrefresh/{destination}\n /bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例\n\n案例\n\n 我们这里以刷新运行在3355端口上的configclient（配置文件中设定的应用名称）为例，只通知3355，不通知3366\n curl X POST \"http://localhost:3344/actuator/busrefresh/configclient:3355\n\n消息通知总结\n\n21cx0943.pnghttps://imgblog.csdnimg.cn/imgconvert/ccd5fcc8293edec24d7e889e189d0bfe.png\n\n 消息驱动\n\n Stream\n\n什么是Spring Cloud Stream？\n\n官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。\n\n应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。\n\n通过我们配置来binding绑定，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。\n\n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。\nSpring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布订阅、消费组、分区的三个核心概念。\n\n目前仅支持RabbitMQ、 Kafka。\n\n 设计思想\n\ndasd04.pnghttps://imgblog.csdnimg.cn/imgconvert/1ca02dd31581d92a7a610bcd137f6848.png\n\n 生产者/消费者之间靠消息媒介传递信息内容\n 消息必须走特定的通道  消息通道 Message Channel\n 消息通道里的消息如何被消费呢，谁负责收发处理  消息通道MessageChannel的子接口SubscribableChannel，由\n MessageHandler消息处理器所订阅。\n\n 常用注解\n\n    组成                                说明                           \n ::  :: \n   Middleware                  中间件，目前只支持RabbitMQ和Kafka               \n     Binder       inder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型对应于Kafka的topic,RabbitMQ的exchange，这些都可以通过配置文件来实现 \n     @Input         注解标识输入通道，通过该输乎通道接收到的消息进入应用程序   \n     @Output          注解标识输出通道，发布的消息将通过该通道离开应用程序     \n @StreamListener              监听队列，用于消费者的队列的消息接收             \n @EnableBinding                指信道channel和exchange绑定在一起               \n\n 案例说明\n\n准备RabbitMQ环境\n\n工程中新建三个子模块\n\n cloudstreamrabbitmqprovider8801，作为生产者进行发消息模块\n cloudstreamrabbitmqconsumer8802，作为消息接收模块\n cloudstreamrabbitmqconsumer8803，作为消息接收模块\n\n Stream消息驱动之生产者\n\n新建Module：cloudstreamrabbitmqprovider8801\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterstreamrabbit</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloudstreamprovider\n  cloud:\n      stream:\n        binders:  在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit:  表示定义的名称，用于于binding整合\n            type: rabbit  消息组件类型\n            environment:  设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings:  服务的整合处理\n          output:  这个名字是一个通道的名称\n            destination: studyExchange  表示要使用的Exchange名称定义\n            contenttype: application/json  设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit  设置要绑定的消息服务的具体设置\n\neureka:\n  client:  客户端进行Eureka注册的配置\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    leaserenewalintervalinseconds: 2  设置心跳的时间间隔（默认是30秒）\n    leaseexpirationdurationinseconds: 5  如果现在超过了5秒的间隔（默认是90秒）\n    instanceid: send8801.com   在信息列表时显示主机名称\n    preferipaddress: true      访问的路径变为IP地址\n\n\n主启动类StreamMQMain8801\n\n业务类\n\n1.发送消息接口\n\njava\npublic interface IMessageProvider {\n    public String send;\n}\n\n\n2.发送消息接口实现类\n\njava\n@EnableBindingSource.class //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send\n    {\n        String serial = UUID.randomUUID.toString;\n        output.sendMessageBuilder.withPayloadserial.build;\n        System.out.println\"serial: \"+serial;\n        return null;\n    }\n}\n\n\n3.Controller\n\njava\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMappingvalue = \"/sendMessage\"\n    public String sendMessage {\n        return messageProvider.send;\n    }\n}\n\n\n测试\n\n 启动 7001eureka\n\n 启动 RabpitMq（\n\n  79Bus之RabbitMQ环境配置\n\n  ）\n\n   rabbitmqplugins enable rabbitmqmanagement\n   http://localhost:15672/\n\n 启动 8801\n\n 访问  http://localhost:8801/sendMessage\n\n   后台将打印serial: UUID字符串\n\n Stream消息驱动之消费者\n\n新建Module：cloudstreamrabbitmqconsumer8802\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterstreamrabbit</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8802\n\nspring:\n  application:\n    name: cloudstreamconsumer\n  cloud:\n      stream:\n        binders:  在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit:  表示定义的名称，用于于binding整合\n            type: rabbit  消息组件类型\n            environment:  设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings:  服务的整合处理\n          input:  这个名字是一个通道的名称\n            destination: studyExchange  表示要使用的Exchange名称定义\n            contenttype: application/json  设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n            binder: defaultRabbit  设置要绑定的消息服务的具体设置\n\neureka:\n  client:  客户端进行Eureka注册的配置\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n  instance:\n    leaserenewalintervalinseconds: 2  设置心跳的时间间隔（默认是30秒）\n    leaseexpirationdurationinseconds: 5  如果现在超过了5秒的间隔（默认是90秒）\n    instanceid: receive8802.com   在信息列表时显示主机名称\n    preferipaddress: true      访问的路径变为IP地址\n\n\n\n Stream之消息重复消费\n\n依照8802，克隆出来一份运行8803  cloudstreamrabbitmqconsumer8803。\n\n原神，启动\n\n RabbitMQ\n 服务注册  8801\n 消息生产  8801\n 消息消费  8802\n 消息消费  8802\n\n运行后有两个问题\n\n1. 有重复消费问题\n2. 消息持久化问题\n\n消费\n\n http://localhost:8801/sendMessage\n 目前是8802/8803同时都收到了，存在重复消费问题\n 如何解决：分组和持久化属性group（重要）\n\n生产实际案例\n\n比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以使用Stream中的消息分组来解决。\n\nd123654.pnghttps://imgblog.csdnimg.cn/imgconvert/f61e83441af907a42e8886368bde59ff.png\n\n注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的重复消费。\n\n简单总结：只需要每个服务处于统一group下就不会出现重复消费\n\n解决\n\n原理\n\n微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。\n\n不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。\n\n8802/8803都变成不同组，group两个不同\n\ngroup: AGroup、BGroup\n\n8802修改YML\n\nyml\nspring:\n  application:\n    name: cloudstreamprovider\n  cloud:\n      stream:\n        binders:  在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit:  表示定义的名称，用于于binding整合\n            type: rabbit  消息组件类型\n            environment:  设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings:  服务的整合处理\n          output:  这个名字是一个通道的名称\n            destination: studyExchange  表示要使用的Exchange名称定义\n            contenttype: application/json  设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit  设置要绑定的消息服务的具体设置\n            group: AGroup <关键\n\n\n8803修改YML（与8802的类似位置 group: BGroup）\n\n结论：还是重复消费\n\n8802/8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。\n\n8802/8803都变成相同组，group两个相同\n\ngroup: AGroup\n\n8802修改YMLgroup: AGroup\n\n8803修改YMLgroup: AGroup\n\n结论：同一个组的多个微服务实例，每次只会有一个拿到\n\n成功解决重复消费\n\n Stream之消息持久化\n\n通过上述，解决了重复消费问题，再看看持久化。\n\n停止8802/8803并去除掉8802的分组group: AGroup，8803的分组group: AGroup没有去掉。\n\n8801先发送4条消息到RabbitMq。\n\n先启动8802，无分组属性配置，后台没有打出来消息。\n\n再启动8803，有分组属性配置，后台打出来了MQ上的消息。消息持久化体现\n\n 分布式请求链路跟踪\n\n Sleuth\n\n为什么会出现这个技术？要解决哪些问题？\n\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\n\n是什么\n\n https://github.com/springcloud/springcloudsleuth\n Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案\n 在分布式系统中提供追踪解决方案并且兼容支持了zipkin\n\n Sleuth之zipkin搭建安装\n\n1.zipkin\n\n下载\n\n SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可\n Central Repository: io/zipkin/zipkinserver maven.orghttps://repo1.maven.org/maven2/io/zipkin/zipkinserver/\n zipkinserver2.24.3exec.jar\n\n运行jar\n\njava\njava jar zipkinserver2.24.3exec.jar\n\n\n运行控制台\n\nhttp://localhost:9411/zipkin/\n\n完整的调用链路\n\n—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。\n\n1d9012.pnghttps://imgblog.csdnimg.cn/imgconvert/f75fcfd2146df03428b9c8c53d13c1f1.png\n\n名词解释\n\n Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n span：表示调用链路来源，通俗的理解span就是一次请求信息\n\n Sleuth链路监控展现\n\n修改cloudproviderpayment8001\n\nPOM\n\nxml\n<包含了sleuth+zipkin\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterzipkin</artifactId\n</dependency\n\n\nYML\n\nyml\nspring:\n  application:\n    name: cloudpaymentservice\n\n  zipkin: <关键 \n      baseurl: http://localhost:9411\n  sleuth: <关键\n    sampler:\n    采样率值介于 0 到 1 之间，1 则表示全部采集\n    probability: 1\n\n\n业务类PaymentController\n\njava\n@GetMapping\"/payment/zipkin\"\npublic String paymentZipkin {\n    return \"hi ,i'am paymentzipkin server fall back，welcome to here, O∩∩O哈哈\";\n}    \n\n\n修改cloueconsumerorder80\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterzipkin</artifactId\n</dependency\n\n\nYML\n\nxml\nspring:\n    application:\n        name: cloudorderservice\n    zipkin:\n      baseurl: http://localhost:9411\n    sleuth:\n      sampler:\n        probability: 1\n\n\n业务类OrderController\n\njava\n@GetMapping\"/consumer/payment/zipkin\"\npublic String paymentZipkin\n{\n    String result = restTemplate.getForObject\"http://localhost:8001\"+\"/payment/zipkin/\", String.class;\n    return result;\n}\n\n\n4.依次启动eureka7001/8001/80  80调用8001几次测试下\n\n5.打开浏览器访问: http://localhost:9411\n\n Spring Cloud Alibaba\n\n为什么会出现SpringCloud alibaba?\n\nSpring Cloud Netflix项目进入维护模式\n\nhttps://spring.io/blog/2018/12/12/springcloudgreenwichrc1availablenow\n\n什么是维护模式？\n\n将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。\n\n他们将修复block级别的 bug 以及安全问题，他们也会考虑并审查社区的小型pull request。\n\nSpringCloud alibaba带来了什么\n\nspringcloudalibaba/READMEzh.md at 2.2.x · alibaba/springcloudalibaba github.comhttps://github.com/alibaba/springcloudalibaba/blob/2.2.x/READMEzh.md\n\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n\n能干嘛\n\n 服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ \n 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\n 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。\n 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\n 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。\n 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerxclient）上执行。\n 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\nMAVEN\n\nxml\n<dependencyManagement\n    <dependencies\n        <dependency\n            <groupIdcom.alibaba.cloud</groupId\n            <artifactIdspringcloudalibabadependencies</artifactId\n            <version2.2.5.RELEASE</version\n            <typepom</type\n            <scopeimport</scope\n        </dependency\n    </dependencies\n</dependencyManagement\n\n\n Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\n Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。\n Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\n Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\n Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\nSpring Cloud Alibaba学习资料获取\n\n 官网\n\nhttps://spring.io/projects/springcloudalibabaoverview\n\n 英文\n\nhttps://github.com/alibaba/springcloudalibaba\nhttps://springcloudalibabagroup.github.io/githubpages/greenwich/springcloudalibaba.html\n\n 中文\n\nhttps://github.com/alibaba/springcloudalibaba/blob/master/READMEzh.md\n\n Nacos\n\n Nacos介绍\n\n是什么\n\n 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n Nacos: Dynamic Naming and Configuration Service\n Nacos就是注册中心＋配置中心的组合  Nacos = Eureka+Config+Bus\n\n能干嘛\n\n 替代Eureka做服务注册中心\n 替代Config做服务配置中心\n\n去哪下\n\n https://github.com/alibaba/nacos/releases\n 官网文档https://springcloudalibabagroup.github.io/githubpages/greenwich/springcloudalibaba.htmlspring cloud alibaba nacosdiscovery\n\n各中注册中心比较\n\n 服务注册与发现框架  CAP模型  控制台管理  社区活跃度      \n        \n Eureka              AP       支持        低2.x版本闭源 \n Zookeeper           CP       不支持      中              \n consul              CP       支持        高              \n Nacos               AP       支持        高              \n\n据说Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验。\n\n Nacos安装\n\n 本地Java8+Maven环境已经OK先\n 从官网https://github.com/alibaba/nacos/releases下载Nacos\n 解压安装包，直接运行bin目录下的startup.cmd\n 命令运行成功后直接访问http://localhost:8848/nacos，默认账号密码都是nacos\n 结果页面\n\n Nacos之服务提供者注册\n\n官方文档https://springcloudalibabagroup.github.io/githubpages/greenwich/springcloudalibaba.htmlspringcloudalibabanacosdiscovery\n\n新建Module  cloudalibabaproviderpayment9001\n\nPOM\n\n父POM\n\nxml\n<dependencyManagement\n    <dependencies\n        <spring cloud alibaba 2.1.0.RELEASE\n        <dependency\n            <groupIdcom.alibaba.cloud</groupId\n            <artifactIdspringcloudalibabadependencies</artifactId\n            <version2.1.0.RELEASE</version\n            <typepom</type\n            <scopeimport</scope\n        </dependency\n    </dependencies\n</dependencyManagement\n\n\n本模块POM\n\nxml\n <dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacospaymentprovider\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\n\n主启动添加@EnableDiscoveryClient\n\n业务类\n\njava\n@RestController\npublic class PaymentController {\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @GetMappingvalue = \"/payment/nacos/{id}\"\n    public String getPayment@PathVariable\"id\" Integer id {\n        return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id;\n    }\n}\n\n\n测试\n\n http://localhost:9001/payment/nacos/1\n nacos控制台\n nacos服务注册中心+服务提供者9001都OK了\n\n再建一个新模块cloudalibabaproviderpayment9002\n\n Nacos之服务消费者注册和负载\n\n新建Module  cloudalibabaconsumernacosorder83\n\nPOM\n\nxml\n <dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n\n\n为什么nacos支持负载均衡？因为springcloudstarteralibabanacosdiscovery内含netflixribbon包。\n\nYML\n\nyml\nserver:\n  port: 83\n\nspring:\n  application:\n    name: nacosorderconsumer\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848\n\n消费者将要去访问的微服务名称注册成功进nacos的微服务提供者\nserviceurl:\n  nacosuserservice: http://nacospaymentprovider\n\n\n主启动添加@EnableDiscoveryClient \n\n业务类\n\nApplicationContextConfig\n\njava\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate\n    {\n        return new RestTemplate;\n    }\n}\n\n\nOrderNacosController\n\njava\n@RestController\n@Slf4j\npublic class OrderNacosController {\n    \n    @Resource\n    private RestTemplate restTemplate;\n\n    @Value\"${serviceurl.nacosuserservice}\"\n    private String serverURL;\n\n    @GetMappingvalue = \"/consumer/payment/nacos/{id}\"\n    public String paymentInfo@PathVariable\"id\" Long id\n    {\n        return restTemplate.getForObjectserverURL+\"/payment/nacos/\"+id,String.class;\n    }\n}\n\n\n测试\n\n 启动nacos控制台\n http://localhost:83/Eonsumer/payment/nacos/13\n   83访问9001/9002，轮询负载OK\n\n Nacos之服务配置中心\n\n基础配置\n\ncloudalibabaconfignacosclient3377\n\nPOM\n\nxml\n<nacosconfig\n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosconfig</artifactId\n</dependency\n<nacosdiscovery\n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n\n\nYML\n\nNacos同springcloudconfig一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。\n\nspringboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\n\nbootstrap\n\nyml\n nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacosconfigclient\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n      config:\n        serveraddr: localhost:8848 Nacos作为配置中心地址\n        fileextension: yaml 指定yaml格式的配置\n        \n ${spring.application.name}${spring.profile.active}.${spring.cloud.nacos.config.fileextension}\n nacosconfigclientdev.yaml\n nacosconfigclienttest.yaml    config.info\n\n\napplication\n\nqml\nspring:\n  profiles:\n    active: dev  表示开发环境\n    active: test  表示测试环境\n    active: info\n\n\n\n主启动添加@EnableDiscoveryClient\n\n业务类\n\njava\n@RestController\n@RefreshScope //支持Nacos的动态刷新功能。\npublic class ConfigClientController\n{\n    @Value\"${config.info}\"\n    private String configInfo;\n\n    @GetMapping\"/config/info\"\n    public String getConfigInfo {\n        return configInfo;\n    }\n}\n\n\n在Nacos中添加配置信息\n\nNacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则\n\n官方文档https://nacos.io/zhcn/docs/quickstartspringcloud.html\n\n说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。\n\n在 Nacos Spring Cloud中,dataId的完整格式如下：\n\njava\n${prefix}${springprofile.active}.${fileextension}\n\n\n prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。\n spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符  也将不存在，datald 的拼接格式变成${prefix}.${fileextension}\n fileexetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.fileextension来配置。目前只支持properties和yaml类型。\n 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。\n\n最后公式：\n\njava\n${spring.application.name}${spring.profiles.active}.${spring.cloud.nacos.config.fileextension}\n\n\n21dxw20.pnghttps://imgblog.csdnimg.cn/imgconvert/05d45948bf637614dbd70e2bc8ce992d.png\n\nNacos界面配置对应  设置DataId\n\nc0tnVf.pnghttps://imgblog.csdnimg.cn/imgconvert/c61619bbe5ea16f34efca8103b0f90ba.png\n\n配置小结\n\n202929292.pnghttps://imgblog.csdnimg.cn/imgconvert/b3bffc4a646b30f9bf64fc649bf26f7d.png\n\n测试\n\n 启动前需要在nacos客户端配置管理配置管理栏目下有对应的yaml配置文件\n 运行cloudconfignacosclient3377的主启动类\n 调用接口查看配置信息  http://localhost:3377/config/info\n\n自带动态刷新\n\n修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。\n\n Nacos之命名空间分组和DataID三者关系\n\n问题  多环境多项目管理\n\n问题1:\n\n实际开发中，通常一个系统会准备\n\n1. dev开发环境\n2. test测试环境\n3. prod生产环境。\n\n如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?\n\n问题2:\n\n一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?\n\nNamespace+Group+Data lD三者关系？为什么这么设计？\n\n1是什么\n\n类似Java里面的package名和类名最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。\n\n2三者情况\n\n321d10DKLJQ.pnghttps://imgblog.csdnimg.cn/imgconvert/60712abd615dd86ac6c119bf132a28d6.png\n\n默认情况：Namespace=public，Group=DEFAULTGROUP，默认Cluster是DEFAULT\n\n Nacos默认的Namespace是public，Namespace主要用来实现隔离。\n   比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。\n\n Group默认是DEFAULTGROUP，Group可以把不同的微服务划分到同一个分组里面去\n Service就是微服务:一个Service可以包含多个Cluster 集群，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。\n   比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称HZ ，给广州机房的Service微服务起一个集群名称GZ，还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n 最后是Instance，就是微服务的实例。\n\n Nacos之DataID配置\n\n指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置\n\n默认空间+默认分组+新建dev和test两个DatalD\n\n 新建dev配置DatalD\n 通过spring.profile.active属性就能进行多环境下配置文件的读取\n\n测试\n\n http://localhost:3377/config/info\n 配置是什么就加载什么 test/dev\n\n Nacos之Group分组方案\n\n通过Group实现环境区分  新建Group\n\n000.pnghttps://imgblog.csdnimg.cn/imgconvert/bdf592aa566fe50f7f454118a70ca03c.png\n\n在nacos图形界面控制台上面新建配置文件DatalD\n\nLSINFD.pnghttps://imgblog.csdnimg.cn/imgconvert/28aee2b45901bbb9a6776d5c4398a6bb.png\n\nbootstrap+application：在config下增加一条group的配置即可。可配置为DEVGROUP或TEST GROUP\n\n12LADpw.pnghttps://imgblog.csdnimg.cn/imgconvert/342a167a8bd948d8ba5cbfd760cf66a6.png\n\n Nacos之Namespace空间方案\n\n新建dev/test的Namespace\n\nDjspc1223.pnghttps://imgblog.csdnimg.cn/imgconvert/a10c71978c75c214aca5fa7057bb2834.png\n\n回到服务管理服务列表查看\n\n2143KKJ.pnghttps://imgblog.csdnimg.cn/imgconvert/2a9f3fa415f5cead0219d404a47131a0.png\n\n按照域名配置填写\n\nwqd1MNCw.pnghttps://imgblog.csdnimg.cn/imgconvert/2177c126090c0db553a8ce77e838a7c9.png\n\nYML\n\nyml\n nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacosconfigclient\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n      config:\n        serveraddr: localhost:8848 Nacos作为配置中心地址\n        fileextension: yaml 指定yaml格式的配置\n        group: DEVGROUP\n        namespace: 7d8f0f5a6a5347859686dd460158e5d4 <指定namespace\n\n ${spring.application.name}${spring.profile.active}.${spring.cloud.nacos.config.fileextension}\n nacosconfigclientdev.yaml\n nacosconfigclienttest.yaml    config.info\n\n\n Nacos持久化切换配置\n\nNacos默认自带的是嵌入式数据库derby，nacos的pom.xmlhttps://blog.csdn.net/u011863024/article/details/github.com/alibaba/nacos/blob/develop/config/pom.xml中可以看出。\n\nderby到mysql切换配置步骤：\n\n1. nacosserver1.1.4\\nacos\\conf录下找到nacosmysql.sql文件，执行脚本。\n2. nacosserver1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。\n\npr\nspring.datasource.platform=mysql\n\ndb.num=1\ndb.url.0=jdbc:mysql://localhost:3306/nacosdevtest?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\ndb.user=root\ndb.password=1234\n\n\n启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby。\n\n1.4.1版本的直接打开3141行的注释修改为自己就行\n\n Nacos集群配置\n\n这里不太会，有点问题\n\n Sentinel\n\n Sentinel介绍\n\n随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinelhttps://so.csdn.net/so/search?q=Sentinel&spm=1001.2101.3001.7020 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\nSentinel 具有以下特征:\n\n 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。\n 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n12dNucx1.pnghttps://imgblog.csdnimg.cn/imgconvert/e4efa9c3547366ae4f747ad4007f6447.png\n\n—句话解释，之前我们讲解过的Hystrix\n\nHystrix与Sentinel比较：\n\n Hystrix\n  1. 需要我们程序员自己手工搭建监控平台\n  2. 没有一套web界面可以给我们进行更加细粒度化得配置流控、速率控制、服务熔断、服务降级\n Sentinel\n  1. 单独一个组件，可以独立出来。\n  2. 直接界面化的细粒度统一配置。\n\n约定  配置  编码\n\n都可以写在代码里面，但是我们本次还是大规模的学习使用配置和注解的方式，尽量少写代码\n\n Sentinel下载安装运行\n\n服务使用中的各种问题：\n\n 服务雪崩\n 服务降级\n 服务熔断\n 服务限流\n\nSentinel 分为两个部分：\n\n 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n Sentinel初始化监控\n\n启动Nacos8848成功\n\n新建工程  cloudalibabasentinelservice8401\n\nPOM\n\nxml\n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n<SpringCloud ailibaba sentineldatasourcenacos 后续做持久化用到\n<dependency\n    <groupIdcom.alibaba.csp</groupId\n    <artifactIdsentineldatasourcenacos</artifactId\n</dependency\n<SpringCloud ailibaba sentinel \n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabasentinel</artifactId\n</dependency\n<openfeign\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n< SpringBoot整合Web组件+actuator \n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarterweb</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibabasentinelservice\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 配置Sentinel dashboard地址\n        port: 8719\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\nfeign:\n  sentinel:\n    enabled: true  激活Sentinel对Feign的支持\n\n\n主启动类@EnableDiscoveryClient\n\n业务类FlowLimitController\n\njava\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping\"/testA\"\n    public String testA\n    {\n        return \"testA\";\n    }\n\n    @GetMapping\"/testB\"\n    public String testB\n    {\n        log.infoThread.currentThread.getName+\"\\t\"+\"...testB\";\n        return \"testB\";\n    }\n}\n\n\n启动Sentinel8080  java jar sentineldashboard1.7.0.jar\n\n启动微服务8401，查看sentienl控制台\n\n 刚启动，空空如也，啥都没有\n\n Sentinel采用的懒加载说明\n   执行一次访问即可\n     http://localhost:8401/testA\n     http://localhost:8401/testB\n   效果  sentinel8080正在监控微服务8401\n\n Sentinel流控规则简介\n\n11111.pnghttps://imgblog.csdnimg.cn/imgconvert/d8ae2bea252af0bb278332b3aeb8fb77.png\n\n 资源名：唯一名称，默认请求路径。\n 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。\n 阈值类型/单机阈值：\n   QPS每秒钟的请求数量︰当调用该API的QPS达到阈值的时候，进行限流。\n   线程数：当调用该API的线程数达到阈值的时候，进行限流。\n 是否集群：不需要集群。\n 流控模式：\n   直接：API达到限流条件时，直接限流。\n   关联：当关联的资源达到阈值时，就限流自己。\n   链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流【API级别的针对来源】。\n 流控效果：\n   快速失败：直接失败，抛异常。\n   Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。\n   排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。\n\n Sentinel流控QPS直接失败\n\n直接  快速失败（系统默认）\n\n配置及说明\n\n表示1秒钟内查询1次就是OK，若超过次数1，就直接快速失败，报默认错误\n\n测试\n\n快速多次点击访问http://localhost:8401/testA\n\n结果\n\n返回页面 Blocked by Sentinel flow limiting\n\n源码\n\ncom.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController\n\n思考\n\n直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?\n\n Sentinel流控线程数直接失败\n\n修改FlowLimitController，给请求增加时长\n\njava\n@GetMapping\"/testA\"\npublic String testA\n{\n    try {\n        TimeUnit.MILLISECONDS.sleep800;\n    } catch InterruptedException e {\n        e.printStackTrace;\n    }\n    return \"testA\";\n}\n\n\n当有多个请求同时访问的时候搜，超过阈值就会出错\n\n Sentinel流控关联\n\n 当自己关联的资源达到阈值时，就限流自己\n 当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）\n\n设置testA\n\n当关联资源/testB的QPS阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名。\n\n3841.pnghttps://imgblog.csdnimg.cn/imgconvert/12cd41ae91ba50fe3b5525bab7bc3805.png\n\nJmeter密集访问localhost:8401/testBhttp://localhost:8401/testB，在此期间访问localhost:8401/testAhttp://localhost:8401/testA会出现错误Blocked by Sentinelflow limiting\n\n Sentinel流控预热\n\n 默认coldFactor为3，即请求QPS 从 threshold / 3开始，经预热时长逐渐升至设定的QPS阈值。linkhttps://github.com/alibaba/Sentinel/wiki/流量控制warmup\n\n源码  com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController\n\n系统初始化的阀值为10/ 3约等于3,即阀值刚开始为3;然后过了5秒后阀值才慢慢升高恢复到10\n\n测试\n\n多次快速点击http://localhost:8401/testB  刚开始不行，后续慢慢OK\n\nIOid.pnghttps://imgblog.csdnimg.cn/imgconvert/c26846d68d79eae1e962f37942a2c99f.png\n\n应用场景\n\n如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来,慢慢的把阀值增长到设置的阀值。\n\n Sentinel流控排队等待\n\n匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。\n\n设置：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。\n\n231000.pnghttps://imgblog.csdnimg.cn/imgconvert/0ddd217545dd0fe2b1f251dbea814ac2.png\n\n测试\n\n 添加日志记录代码到FlowLimitController的testA方法\n\njava\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping\"/testA\"\n    public String testA\n    {\n        log.infoThread.currentThread.getName+\"\\t\"+\"...testA\";//<\n        return \"testA\";\n    }\n\n}\n\n\n用Jmeter测试，发现后端输出是每隔一秒钟输出一个\n\n Sentinel降级简介\n\n熔断降级概述\n\n 除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。\n\n 现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。\n\n123ddqghbb.pnghttps://imgblog.csdnimg.cn/imgconvert/6a002ef360a4e5f20ee2748a092f0211.png\n\n RT（平均响应时间，秒级）\n   平均响应时间 超出阈值 且 在时间窗口内通过的请求=5，两个条件同时满足后触发降级。\n   窗口期过后关闭断路器。\n   RT最大4900（更大的需要通过Dcsp.sentinel.statistic.max.rt=XXXX才能生效）。\n 异常比列（秒级）\n   QPS = 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。\n 异常数分钟级\n   异常数分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级\n\nSentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。\n\n当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。\n\nSentinei的断路器是没有类似Hystrix半开状态的。Sentinei 1.8.0 已有半开状态\n\n半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。\n\n Sentinel降级RT\n\n20202020.pnghttps://imgblog.csdnimg.cn/imgconvert/dcf85d4362c017e543173c76b7dcc2a8.png\n\n注意：Sentinel 1.7.0才有平均响应时间（DEGRADEGRADERT），Sentinel 1.8.0的没有这项，取而代之的是慢调用比例 SLOWREQUESTRATIO。\n\n087rc.pnghttps://imgblog.csdnimg.cn/imgconvert/3a608908cef3d557322967e6bc0e5696.png\n\n用jmter测压，一秒打10个\n\ncontroller代码\n\njava\n@GetMapping\"/testD\"\npublic String testD {\n    try { \n        TimeUnit.SECONDS.sleep1; \n    } catch InterruptedException e { \n        e.printStackTrace; \n    }\n    log.info\"testD 测试RT\";\n}\n\n\n结论\n\n按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。\n Sentinel降级异常比例\n\n12c23.pnghttps://imgblog.csdnimg.cn/imgconvert/b8f35b00fffd79ef68e8f744403b92f3.png\n\n修改controller代码\n\njava\n@GetMapping\"/testD\"\npublic String testD {\n    try { \n        TimeUnit.SECONDS.sleep1; \n    } catch InterruptedException e { \n        e.printStackTrace; \n    }\n    log.info\"testD 测试RT\";\n}\n\n\n120dxc.pnghttps://imgblog.csdnimg.cn/imgconvert/ab66591ba085c32e9303d96be7b44f0d.png\n\n按照上述配置，单独访问一次，必然来一次报错一次int age = 10/0，调一次错一次。\n\n开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启保险丝跳闸，微服务不可用了，不再报错error而是服务降级了。\n\n Sentinel降级异常数\n\n异常数是按照分钟统计的，时间窗口一定要大于等于60秒。\n\n1211235.pnghttps://imgblog.csdnimg.cn/imgconvert/d92c6a9ae5ed514b52ddf43fdf0d5f0e.png\n\n添加controller代码\n\njava\n@GetMapping\"/testE\"\npublic String testE\n{\n    log.info\"testE 测试异常数\";\n    int age = 10/0;\n    return \"testE 测试异常数\";\n}\n\n\nb0thSJ.pnghttps://imgblog.csdnimg.cn/imgconvert/218fe52e19c07b30bbf4d994d05e6a8e.png\n\n访问http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。\n\n Sentinel热点key上\n\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n\n 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制\n 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制\n\n热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n\n312sLLL.pnghttps://imgblog.csdnimg.cn/imgconvert/16d2ddeff96b7cb68a064b6ec05bde25.png\n\n承上启下复习start\n\n兜底方法，分为系统默认和客户自定义，两种\n\n之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel flow limiting\n\n我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法?\n\n结论  从HystrixCommand到@SentinelResource\n\n再contrller中添加\n\njava\n@GetMapping\"/testHotKey\"\n@SentinelResourcevalue = \"testHotKey\",blockHandler/兜底方法/ = \"dealtestHotKey\"\npublic String testHotKey@RequestParamvalue = \"p1\",required = false String p1,\n                         @RequestParamvalue = \"p2\",required = false String p2 {\n    //int age = 10/0;\n    return \"testHotKey\";\n}\n\n/兜底方法/\npublic String dealtestHotKey String p1, String p2, BlockException exception {\n    return \"dealtestHotKey,o╥﹏╥o\";  //sentinel系统默认的提示：Blocked by Sentinel flow limiting\n}\n\n\n配置\n\ndsdcopp.pnghttps://imgblog.csdnimg.cn/imgconvert/9620ee4e7e54d48ba7dda394fa1c8cd0.png\n\n测试\n\n error\n   http://localhost:8401/testHotKey?p1=abc\n   http://localhost:8401/testHotKey?p1=abc&p2=33\n right\n   http://localhost:8401/testHotKey?p2=abc\n\n若不配置@SentinelResourcevalue = \"testHotKey\",blockHandler/兜底方法/ = \"dealtestHotKey\"的话前端就只能看到一个报错界面 \n\n Sentinel热点key下\n\n上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流。\n\n参数例外项\n\n 普通  超过1秒钟一个后，达到阈值1后马上被限流\n 我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样\n 特例  假如当p1的值等于5时，它的阈值可以达到200\n\ndsaxca.pnghttps://imgblog.csdnimg.cn/imgconvert/3aa08b15109cd346a6083f080a0468fa.png\n\n测试\n\n right  http://localhost:8401/testHotKey?p1=5\n error  http://localhost:8401/testHotKey?p1=3\n 当p1等于5的时候，阈值变为200\n 当p1不等于5的时候，阈值就是平常的1\n\n前提条件  热点参数的注意点，参数必须是基本类型或者String\n\n其它\n\n在testHotKey方法中添加int age = 10/0;使程序报错\n\n将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。\n\n @SentinelResource  处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理;\n\n RuntimeException int age = 10/0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管\n\n总结  @SentinelResource主管配置出错，运行出错该走异常走异常\n\n Sentinel系统规则\n\n就是一次性对所有接口进行限制\n\n系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\n\n Load 自适应（仅对 Linux/Unixlike 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps  minRt 估算得出。设定参考值一般是 CPU cores  2.5。\n CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.01.0），比较灵敏。\n 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。\n 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。\n 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。\n\n SentinelResource配置上\n\n按资源名称限流 + 后续处理\n\n启动Nacos成功\n\n启动Sentinel成功\n\nModule  cloudalibabasentinelservice8401\n\ncontroller\n\njava\n@RestController\npublic class RateLimitController {\n    \n    @GetMapping\"/byResource\"\n    @SentinelResourcevalue = \"byResource\",blockHandler = \"handleException\"\n    public CommonResult byResource {\n        return new CommonResult200,\"按资源名称限流测试OK\",new Payment2020L,\"serial001\";\n    }\n    \n    public CommonResult handleExceptionBlockException exception {\n        return new CommonResult444,exception.getClass.getCanonicalName+\"\\t 服务不可用\";\n    }\n}\n\n\n配置流控规则\n\n配置步骤\n\n21100101.pnghttps://imgblog.csdnimg.cn/imgconvert/91aa0ac210011218db9557a2bfcfebd1.png\n\n图形配置和代码关系\n\n表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流\n\n测试\n\n1秒钟点击1下，OK\n\n超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生\n\njson\n{\"code\":444, \"message\":\"com.alibaba.csp.sentinel.slots.block.flow.FlowException\\t 服务不可用\", \"data\":null}\n\n\n额外问题\n\n此时关闭问服务8401  Sentinel控制台，流控规则消失了\n\n\n\n按照Url地址限流 + 后续处理\n\n通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息\n\n业务类RateLimitController\n\njava\n@GetMapping\"/rateLimit/byUrl\"\n@SentinelResourcevalue = \"byUrl\"\npublic CommonResult byUrl\n{\n    return new CommonResult200,\"按url限流测试OK\",new Payment2020L,\"serial002\";\n}\n\n\nSentinel控制台配置\n\n1xll.pnghttps://imgblog.csdnimg.cn/imgconvert/d6a79b7cc3f2f9c8b6dcbe3f77f78c6b.png\n\n测试\n\n 快速点击http://localhost:8401/rateLimit/byUrl\n 结果  会返回Sentinel自带的限流处理结果 Blocked by Sentinel flow limiting\n\n上面兜底方案面临的问题\n\n1. 系统默认的，没有体现我们自己的业务要求。\n2. 依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。\n3. 每个业务方法都添加—个兜底的，那代码膨胀加剧。\n4. 全局统—的处理方法没有体现。\n\n SentinelResource配置中\n\n客户自定义限流处理逻辑\n\n自定义限流处理类  创建CustomerBlockHandler类用于自定义限流处理逻辑\n\njava\nimport com.alibaba.csp.sentinel.slots.block.BlockException;\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\n\npublic class CustomerBlockHandler {\n    public static CommonResult handlerExceptionBlockException exception {\n        return new CommonResult4444,\"按客戶自定义,global handlerException1\";\n    }\n    \n    public static CommonResult handlerException2BlockException exception {\n        return new CommonResult4444,\"按客戶自定义,global handlerException2\";\n    }\n}\n\n\nRateLimitController\n\njava\n@GetMapping\"/rateLimit/customerBlockHandler\"\n@SentinelResourcevalue = \"customerBlockHandler\",\n        blockHandlerClass = CustomerBlockHandler.class,//< 自定义限流处理类\n        blockHandler = \"handlerException2\"//<\npublic CommonResult customerBlockHandler\n{\n    return new CommonResult200,\"按客戶自定义\",new Payment2020L,\"serial003\";\n}\n\n\nSentinel控制台配置\n\n1114123d.pnghttps://imgblog.csdnimg.cn/imgconvert/44dccf4107a74fda56f0807d39fa53f1.png\n\n启动微服务后先调用一次  http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。\n\n SentinelResource配置下\n\n@SentinelResource 注解\n\n 注意：注解方式埋点不支持 private 方法。\n\n@SentinelResource用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：\n\n value：资源名称，必需项（不能为空）\n entryType：entry 类型，可选项（默认为 EntryType.OUT）\n blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。若本次访问被限流或服务降级，则调用blockHandler指定的接口。\n fallback /fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若本接口出现未知异常，则调用fallback指定的接口。fallback 函数签名和位置要求：\n   返回值类型必须与原函数返回值类型一致；\n   方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n   fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：\n   返回值类型必须与原函数返回值类型一致；\n   方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n   defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。\n\nSentinel主要有三个核心Api：\n\n1. SphU定义资源\n2. Tracer定义统计\n3. ContextUtil定义了上下文\n\n Sentinel服务熔断Ribbon环境预说\n\nsentinel整合ribbon+openFeign+fallback\n\nRibbon系列\n\n 启动nacos和sentinel\n 提供者9003/9004\n 消费者84\n\n\n\n提供者9003/9004\n\n新建cloudalibabaproviderpayment9003/9004，两个一样的做法\n\nPOM\n\nxml\n<dependencies\n    <SpringCloud ailibaba nacos \n    <dependency\n        <groupIdcom.alibaba.cloud</groupId\n        <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n    </dependency\n    <dependency< 引入自己定义的api通用包，可以使用Payment支付Entity \n        <groupIdcom.atguigu.springcloud</groupId\n        <artifactIdcloudapicommons</artifactId\n        <version${project.version}</version\n    </dependency\n    < SpringBoot整合Web组件 \n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarterweb</artifactId\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarteractuator</artifactId\n    </dependency\n    <日常通用jar包配置\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootdevtools</artifactId\n        <scoperuntime</scope\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.projectlombok</groupId\n        <artifactIdlombok</artifactId\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstartertest</artifactId\n        <scopetest</scope\n    </dependency\n</dependencies\n\n\nYML\n\nyml\nserver:\n  port: 9003\n\nspring:\n  application:\n    name: nacospaymentprovider\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\n\n记得修改不同的端口号\n\n主启动添加@EnableDiscoveryClient\n\n业务类\n\njava\n@RestController\npublic class PaymentController {\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    //模拟数据库\n    public static HashMap<Long,Payment hashMap = new HashMap<;\n    static\n    {\n        hashMap.put1L,new Payment1L,\"28a8c1e3bc2742d8848569891fb42181\";\n        hashMap.put2L,new Payment2L,\"bba8c1e3bc2742d8848569891ac32182\";\n        hashMap.put3L,new Payment3L,\"6ua8c1e3bc2742d8848569891xt92183\";\n    }\n\n    @GetMappingvalue = \"/paymentSQL/{id}\"\n    public CommonResult<Payment paymentSQL@PathVariable\"id\" Long id\n    {\n        Payment payment = hashMap.getid;\n        CommonResult<Payment result = new CommonResult200,\"from mysql,serverPort:  \"+serverPort,payment;\n        return result;\n    }\n}\n\n\n测试地址  http://localhost:9003/paymentSQL/1\n\n\n\n消费者84\n\n新建cloudalibabaconsumernacosorder84\n\nPOM\n\nxml\n<dependencies\n    <SpringCloud openfeign \n    <\n    <dependency\n        <groupIdorg.springframework.cloud</groupId\n        <artifactIdspringcloudstarteropenfeign</artifactId\n    </dependency\n\t\n    <SpringCloud ailibaba nacos \n    <dependency\n        <groupIdcom.alibaba.cloud</groupId\n        <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n    </dependency\n    <SpringCloud ailibaba sentinel \n    <dependency\n        <groupIdcom.alibaba.cloud</groupId\n        <artifactIdspringcloudstarteralibabasentinel</artifactId\n    </dependency\n    < 引入自己定义的api通用包，可以使用Payment支付Entity \n    <dependency\n        <groupIdcom.atguigu.springcloud</groupId\n        <artifactIdcloudapicommons</artifactId\n        <version${project.version}</version\n    </dependency\n    < SpringBoot整合Web组件 \n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarterweb</artifactId\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarteractuator</artifactId\n    </dependency\n    <日常通用jar包配置\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootdevtools</artifactId\n        <scoperuntime</scope\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.projectlombok</groupId\n        <artifactIdlombok</artifactId\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstartertest</artifactId\n        <scopetest</scope\n    </dependency\n</dependencies\n\n\nYML\n\nyml\nserver:\n  port: 84\n\nspring:\n  application:\n    name: nacosorderconsumer\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848\n    sentinel:\n      transport:\n        配置Sentinel dashboard地址\n        dashboard: localhost:8080\n        默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\n        port: 8719\n\n消费者将要去访问的微服务名称注册成功进nacos的微服务提供者\nserviceurl:\n  nacosuserservice: http://nacospaymentprovider\n\n 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: false\n\n\n主启动\n\njava\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients\n\n\nApplicationContextConfig\n\njava\n@Configuration\npublic class ApplicationContextConfig {\n\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate {\n        return new RestTemplate;\n    }\n}\n\n\nCircleBreakerController\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping\"/consumer/fallback/{id}\"\n    @SentinelResourcevalue = \"fallback\"//没有配置\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    \n}\n\n\n修改后请重启微服务\n\n 热部署对java代码级生效及时\n 对@SentinelResource注解内属性，有时效果不好\n\n目的\n\n fallback管运行异常\n blockHandler管配置违规\n\n测试地址  http://localhost:84/consumer/fallback/1\n\n没有任何配置\n\n只配置fallback\n\n只配置blockHandler\n\nfallback和blockHandler都配置\n\n忽略属性\n\n Sentinel服务熔断只配置fallback\n\n为了防止出现程序报错页面，添加兜底方法\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    \n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping\"/consumer/fallback/{id}\"\n    //@SentinelResourcevalue = \"fallback\"//没有配置\n    @SentinelResourcevalue = \"fallback\", fallback = \"handlerFallback\" //fallback只负责业务异常\n    public CommonResult<Payment fallback@PathVariable Long id {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    \n    //本例是fallback\n    public CommonResult handlerFallback@PathVariable  Long id,Throwable e {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage,payment;\n    }\n    \n}\n\n\n Sentinel服务熔断只配置blockHandler\n\nblockHandler只负责sentinel控制台配置违规\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping\"/consumer/fallback/{id}\"\n    //@SentinelResourcevalue = \"fallback\" //没有配置\n    //@SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\" //fallback只负责业务异常\n    @SentinelResourcevalue = \"fallback\",blockHandler = \"blockHandler\" //blockHandler只负责sentinel控制台配置违规\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    //本例是fallback\n/    public CommonResult handlerFallback@PathVariable  Long id,Throwable e {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage,payment;\n    }/\n    \n    //本例是blockHandler\n    public CommonResult blockHandler@PathVariable  Long id,BlockException blockException {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<445,\"blockHandlersentinel限流,无此流水: blockException  \"+blockException.getMessage,payment;\n    }\n}\n\n\n Sentinel服务熔断fallback和blockHandler都配置\n\n若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。\n\n异常访问会走handlerFallback，若设置了限流的话，多次访问会走blockHandler\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping\"/consumer/fallback/{id}\"\n    //@SentinelResourcevalue = \"fallback\" //没有配置\n    //@SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\" //fallback只负责业务异常\n    //@SentinelResourcevalue = \"fallback\",blockHandler = \"blockHandler\" //blockHandler只负责sentinel控制台配置违规\n    @SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\"\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    //本例是fallback\n    public CommonResult handlerFallback@PathVariable  Long id,Throwable e {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage,payment;\n    }\n    //本例是blockHandler\n    public CommonResult blockHandler@PathVariable  Long id,BlockException blockException {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<445,\"blockHandlersentinel限流,无此流水: blockException  \"+blockException.getMessage,payment;\n    }\n}\n\n\n Sentinel服务熔断exceptionsToIgnore\n\nexceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController    \n\n    ...\n    \n    @RequestMapping\"/consumer/fallback/{id}\"\n    @SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\",\n            exceptionsToIgnore = {IllegalArgumentException.class}//<\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            //exceptionsToIgnore属性有IllegalArgumentException.class，\n            //所以IllegalArgumentException不会跳入指定的兜底程序。\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n\n\t...\n}\n\n\n Sentinel服务熔断OpenFeign\n\n修改84模块\n\n 84消费者调用提供者9003\n Feign组件一般是消费侧\n\nPOM\n\nxml\n<SpringCloud openfeign \n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n\n\nYML\n\nyaml\n 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n\n\n业务类\n\n带@Feignclient注解的业务接口，fallback = PaymentFallbackService.class\n\njade\n@FeignClientvalue = \"nacospaymentprovider\",fallback = PaymentFallbackService.class\npublic interface PaymentService\n{\n    @GetMappingvalue = \"/paymentSQL/{id}\"\n    public CommonResult<Payment paymentSQL@PathVariable\"id\" Long id;\n}\n\n\njava\n@Component\npublic class PaymentFallbackService implements PaymentService {\n    @Override\n    public CommonResult<Payment paymentSQLLong id\n    {\n        return new CommonResult<44444,\"服务降级返回,PaymentFallbackService\",new Paymentid,\"errorSerial\";\n    }\n}\n\n\nController\n\njava\n@Resource\nprivate PaymentService paymentService;\n@GetMappingvalue = \"/consumer/paymentSQL/{id}\"\npublic CommonResult<Payment paymentSQL@PathVariable\"id\" Long id\n{\n    return paymentService.paymentSQLid;\n}\n\n\n主启动\n\njava\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients//<\npublic class OrderNacosMain84 {\n    public static void mainString args {\n        SpringApplication.runOrderNacosMain84.class, args;\n    }\n}\n\n\n测试  http://localhost:84/consumer/paymentSQL/1\n\n测试84调用9003，此时故意关闭9003微服务提供者，84消费侧自动降级，不会被耗死。\n\n熔断框架比较\n\npPFrBUP.pnghttps://s1.ax1x.com/2023/08/04/pPFrBUP.pnghttps://imgse.com/i/pPFrBUP\n\n Sentinel持久化规则\n\n是什么\n\n一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。\n\n怎么玩\n\n将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。\n\n步骤\n\n修改cloudalibabasentinelservice8401\n\nPOM\n\nxml\n<SpringCloud ailibaba sentineldatasourcenacos 后续做持久化用到\n<dependency\n    <groupIdcom.alibaba.csp</groupId\n    <artifactIdsentineldatasourcenacos</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibabasentinelservice\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 配置Sentinel dashboard地址\n        port: 8719\n      datasource: <关注点，添加Nacos数据源配置\n        ds1:\n          nacos:\n            serveraddr: localhost:8848\n            dataId: cloudalibabasentinelservice\n            groupId: DEFAULTGROUP\n            datatype: json\n            ruletype: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\nfeign:\n  sentinel:\n    enabled: true  激活Sentinel对Feign的支持\n\n\n添加Nacos业务规则配置\n\n214PPPP.pnghttps://imgblog.csdnimg.cn/imgconvert/2401a6b2df715ee64f647da2f31e1eeb.png\n\n配置内容解析\n\njso\n{\n    \"resource\": \"/rateLimit/byUrl\",\n    \"limitApp\": \"default\",\n    \"grade\": 1,\n    \"count\": 1, \n    \"strategy\": 0,\n    \"controlBehavior\": 0,\n    \"clusterMode\": false\n}\n\n\n resource：资源名称；\n limitApp：来源应用；\n grade：阈值类型，0表示线程数, 1表示QPS；\n count：单机阈值；\n strategy：流控模式，0表示直接，1表示关联，2表示链路；\n controlBehavior：流控效果，0表示快速失败，\n 1表示Warm Up，2表示排队等待；\n clusterMode：是否集群。\n\n启动8401后刷新sentinel发现业务规则有了\n\n000wqq.pnghttps://imgblog.csdnimg.cn/imgconvert/c854e986254c09d0a7866811ec1e0cb4.png\n\n快速访问测试接口  http://localhost:8401/rateLimit/byUrl  页面返回Blocked by Sentinel flow limiting\n\n停止8401再看sentinel  停机后发现流控规则没有了\n\n重新启动8401再看sentinel\n\n 乍一看还是没有，稍等一会儿\n 多次调用  http://localhost:8401/rateLimit/byUrl\n 重新配置出现了，持久化验证通过\n\n Seata\n\n 分布式事务问题由来\n\n分布式前\n\n 单机单库没这个问题\n 从1:1  1:N  N:N\n\n单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证。\n\n一句话：一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题。\n\n Seata术语\n\nSeata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。\n\n能干嘛\n\n一个典型的分布式事务过程\n\n分布式事务处理过程的一ID+三组件模型：\n\n Transaction ID XID 全局唯一的事务ID\n 三组件概念\n   TC Transaction Coordinator  事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。\n   TM Transaction Manager  事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n   RM Resource Manager  资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n处理过程：\n\n TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；\n XID在微服务调用链路的上下文中传播；\n RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；\n TM向TC发起针对XID的全局提交或回滚决议；\n TC调度XID下管辖的全部分支事务完成提交或回滚请求。\n\ncnaois.pnghttps://imgblog.csdnimg.cn/imgconvert/2d2c6aa29c3158413f66d4ef8c1000dc.png\n\n SeataServer安装\n\n下载\n\nReleases · seata/seata github.comhttps://github.com/seata/seata/releases/\n\n怎么玩\n\n本地@Transactional\n\n全局@GlobalTransactional\nSEATA 的分布式交易解决方案\n\n我们只需要使用一个 @GlobalTransactional 注解在业务方法上\n"},{"filename":"springsecurity-learn","category":"java","md":{"topSummary":"\ntitle: SpringSecurity学习笔记\ncategory: Java,SpringSecurity\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n两个核心功能：**认证**和**授权**\n\n## 基本原理\n\n### 拦截器链\n\nSpringSecurity本质是一个过滤器链，在 SpringBoot 2.3.4.RELEASE中，共有15种拦截器，如图所示：\n\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/springsecurity-filter//dkhd21HR825.png)\n\n```\norg.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter org.springframework.security.web.context.SecurityContextPersistenceFilter  org.springframework.security.web.header.HeaderWriterFilter org.springframework.security.web.csrf.CsrfFilter org.springframework.security.web.authentication.logout.LogoutFilter  org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter  org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter  org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter org.springframework.security.web.savedrequest.RequestCacheAwareFilter org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter org.springframework.security.web.authentication.AnonymousAuthenticationFilter  org.springframework.security.web.session.SessionManagementFilter  org.springframework.security.web.access.ExceptionTranslationFilter  org.springframework.security.web.access.intercept.FilterSecurityIntercepto\n```\n\n重点三个：\n\n`FilterSecurityInterceptor`：是一个方法级的权限过滤器, 基本位于过滤链的最底部。\n\n`ExceptionTranslationFilter`：是个异常过滤器，用来处理在认证授权过程中抛出的异常\n\n`UsernamePasswordAuthenticationFilter` ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码\n\n### 主要拦截器介绍\n\n#### SecurityContextPersistenceFilter\n\n包路径：org.springframework.security.web.context\n\n负责将安全上下文存储在 HttpSession 中，以便在后续请求中访问\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    // 判断是否是第一次请求\n    if (request.getAttribute(\"__spring_security_scpf_applied\") != null) {\n        chain.doFilter(request, response);\n    } else {\n        boolean debug = this.logger.isDebugEnabled();\n        // 设置值\n        request.setAttribute(\"__spring_security_scpf_applied\", Boolean.TRUE);\n        if (this.forceEagerSessionCreation) {\n            HttpSession session = request.getSession();\n            if (debug && session.isNew()) {\n                this.logger.debug(\"Eagerly created session: \" + session.getId());\n            }\n        }\n\n        HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request, response);\n        SecurityContext contextBeforeChainExecution = this.repo.loadContext(holder);\n        boolean var13 = false;\n\n        try {\n            var13 = true;\n            // 将SecurityContext安全信息设置到SecurityContextHolder线程上下文中\n            SecurityContextHolder.setContext(contextBSecurityContextHolder中eforeChainExecution);\n            chain.doFilter(holder.getR\tequest(), holder.getResponse());\n            var13 = false;\n        } finally {\n            if (var13) {\n                SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\n                SecurityContextHolder.clearContext();\n                // 将上下文信息保存在session中\n                this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());\n                request.removeAttribute(\"__spring_security_scpf_applied\");\n                if (debug) {\n                    this.logger.debug(\"SecurityContextHolder now cleared, as request processing completed\");\n                }\n\n            }\n        }\n\n        SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\n        SecurityContextHolder.clearContext();\n        this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());\n            request.removeAttribute(\"__spring_security_scpf_applied\");\n        if (debug) {\n            this.logger.debug(\"SecurityContextHolder now cleared, as request processing completed\");\n        }\n\n    }\n}\n```\n\n#### LogoutFilter\n\n包路径：org.springframework.security.web.authentication.logout.LogoutFilter\n\n匹配URL为 /logout 的请求，实现用户退出，清除认证信息\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    if (this.requiresLogout(request, response)) { // 匹配URL\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Logging out user '\" + auth + \"' and transferring to logout destination\");\n        }\n\n        this.handler.logout(request, response, auth); // 清除认证信息\n        this.logoutSuccessHandler.onLogoutSuccess(request, response, auth); // 处理自定义退出成功逻辑\n    } else {\n        chain.doFilter(request, response);\n    }\n}\n```\n\n对于 `logoutSuccessHandler.onLogoutSuccess` 这个方法，我们可以对他进行重写，实现自己的退出成功逻辑\n\n#### UsernamePasswordAuthenticationFilter\n\n包路径：org.springframework.security.web.authentication\n\n匹配请求为 POST，且路径为` /login` 的请求，通过表单的用户名和密码进行认证，认证成功会将用户信息放到上下文中\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    if (!this.requiresAuthentication(request, response)) {\n        chain.doFilter(request, response);\n    } else {\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Request is to process authentication\");\n        }\n\n        Authentication authResult;\n        try {\n            // 调用子类的attemptAuthentication方法\n            authResult = this.attemptAuthentication(request, response);\n            // 子类未完成认证\n            if (authResult == null) {\n                return;\n            }\n\n            this.sessionStrategy.onAuthentication(authResult, request, response);\n        } catch (InternalAuthenticationServiceException var8) {\n            this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8);\n            // 认证失败\n            this.unsuccessfulAuthentication(request, response, var8);\n            return;\n        } catch (AuthenticationException var9) {\n            // 认证失败\n            this.unsuccessfulAuthentication(request, response, var9);\n            return;\n        }\n\n        if (this.continueChainBeforeSuccessfulAuthentication) {\n            chain.doFilter(request, response);\n        }\n\t\t// 认证成功\n        this.successfulAuthentication(request, response, chain, authResult);\n    }\n}\n\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n    if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n        throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n    } else {\n        String username = this.obtainUsername(request);\n        String password = this.obtainPassword(request);\n        if (username == null) {\n            username = \"\";\n        }\n\n        if (password == null) {\n            password = \"\";\n        }\n\n        username = username.trim();\n        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n        this.setDetails(request, authRequest);\n        // 核心部分，交给内部的AuthenticationManager去认证，并返回认证后的 Authentication\n        return this.getAuthenticationManager().authenticate(authRequest);\n    }\n}\n```\n\n#### DefaultLoginPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n若未自定义认证界面，过滤器会生成一个默认的认证界面\n\n```java\nprivate void init(UsernamePasswordAuthenticationFilter authFilter, AbstractAuthenticationProcessingFilter openIDFilter) {\n    this.loginPageUrl = \"/login\";\n    this.logoutSuccessUrl = \"/login?logout\";\n    this.failureUrl = \"/login?error\";\n    if (authFilter != null) { // 若自定义了，authFilter就为null\n        this.formLoginEnabled = true;\n        this.usernameParameter = authFilter.getUsernameParameter();\n        this.passwordParameter = authFilter.getPasswordParameter();\n        if (authFilter.getRememberMeServices() instanceof AbstractRememberMeServices) {\n            this.rememberMeParameter = ((AbstractRememberMeServices)authFilter.getRememberMeServices()).getParameter();\n        }\n    }\n\n    if (openIDFilter != null) {\n        this.openIdEnabled = true;\n        this.openIDusernameParameter = \"openid_identifier\";\n        if (openIDFilter.getRememberMeServices() instanceof AbstractRememberMeServices) {\n            this.openIDrememberMeParameter = ((AbstractRememberMeServices)openIDFilter.getRememberMeServices()).getParameter();\n        }\n    }\n\n}\n```\n\n#### DefaultLogoutPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n和 DefaultLogoutPageGeneratingFilter 类似，此过滤器可以生产一个默认的退出登录页面\n\n```java\nprivate void renderLogout(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String page = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"utf-8\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1, shrink-to-fit=no\\\">\\n    <meta name=\\\"description\\\" content=\\\"\\\">\\n    <meta name=\\\"author\\\" content=\\\"\\\">\\n    <title>Confirm Log Out?</title>\\n    <link href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\" integrity=\\\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\\\" crossorigin=\\\"anonymous\\\">\\n    <link href=\\\"https://getbootstrap.com/docs/4.0/examples/signin/signin.css\\\" rel=\\\"stylesheet\\\" crossorigin=\\\"anonymous\\\"/>\\n  </head>\\n  <body>\\n     <div class=\\\"container\\\">\\n      <form class=\\\"form-signin\\\" method=\\\"post\\\" action=\\\"\" + request.getContextPath() + \"/logout\\\">\\n        <h2 class=\\\"form-signin-heading\\\">Are you sure you want to log out?</h2>\\n\" + this.renderHiddenInputs(request) + \"        <button class=\\\"btn btn-lg btn-primary btn-block\\\" type=\\\"submit\\\">Log Out</button>\\n      </form>\\n    </div>\\n  </body>\\n</html>\";\n    response.setContentType(\"text/html;charset=UTF-8\");\n    response.getWriter().write(page);\n}\n```\n\n#### AnonymousAuthenticationFilter\n\n当用户没有授权认证，那么就会给他一个匿名身份\n\n\n\n#### ExceptionTranslationFilter\n\n包路径：org.springframework.security.web.access\n\n捕获并处理认证和授权过程中发生的异常\n\n\n\n#### FilterSecurityInterceptor\n\n包路径：org.springframework.security.web.access.intercept\n\n获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来决定其是否有权限\n\n\n\n## 过滤器加载流程\n\n### DelegatingFilterProxy类\n\n首先执行`doFilter`方法\n\n```java\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        Filter delegateToUse = this.delegate;\n        if (delegateToUse == null) {\n            synchronized(this.delegateMonitor) {\n                delegateToUse = this.delegate;\n                if (delegateToUse == null) {\n                    WebApplicationContext wac = this.findWebApplicationContext();\n                    if (wac == null) {\n                        throw new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?\");\n                    }\n\n                    delegateToUse = this.initDelegate(wac);\n                }\n\n                this.delegate = delegateToUse;\n            }\n        }\n```\n\n接着执行`initDelegate`\n\n```java\n protected Filter initDelegate(WebApplicationContext wac) throws ServletException {\n        String targetBeanName = this.getTargetBeanName();\n        Assert.state(targetBeanName != null, \"No target bean name set\");\n        Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);\n        if (this.isTargetFilterLifecycle()) {\n            delegate.init(this.getFilterConfig());\n        }\n\n        return delegate;\n    }\n```\n\n`targetBeanName`在`SpringSecurity`中有一个固定的名字：`FilterChainProxy`\n\n### FilterChainProxy类\n\n首先执行`doFilter`方法\n\n```java\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        boolean clearContext = request.getAttribute(FILTER_APPLIED) == null;\n        if (clearContext) {\n            try {\n                request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n                this.doFilterInternal(request, response, chain);\n            } finally {\n                SecurityContextHolder.clearContext();\n                request.removeAttribute(FILTER_APPLIED);\n            }\n        } else {\n            this.doFilterInternal(request, response, chain);\n        }\n\n    }\n```\n\n执行`doFilterInternal`方法\n\n```java\nprivate void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        FirewalledRequest fwRequest = this.firewall.getFirewalledRequest((HttpServletRequest)request);\n        HttpServletResponse fwResponse = this.firewall.getFirewalledResponse((HttpServletResponse)response);\n        List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);\n        if (filters != null && filters.size() != 0) {\n            FilterChainProxy.VirtualFilterChain vfc = new FilterChainProxy.VirtualFilterChain(fwRequest, chain, filters);\n            vfc.doFilter(fwRequest, fwResponse);\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(UrlUtils.buildRequestUrl(fwRequest) + (filters == null ? \" has no matching filters\" : \" has an empty filter list\"));\n            }\n\n            fwRequest.reset();\n            chain.doFilter(fwRequest, fwResponse);\n        }\n    }\n```\n\n`  List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);`会执行`getFilters`方法，它会把过滤器一个一个加载到过滤链中\n\n```java\nprivate List<Filter> getFilters(HttpServletRequest request) {\n      Iterator var2 = this.filterChains.iterator();\n\n      SecurityFilterChain chain;\n      do {\n          if (!var2.hasNext()) {\n              return null;\n          }\n\n          chain = (SecurityFilterChain)var2.next();\n      } while(!chain.matches(request));\n\n      return chain.getFilters();\n}\n```\n\n## 重要接口\n\n### UserDetailsService\n\n```java\npublic interface UserDetailsService {\n    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;\n}\n```\n\n> 当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 `UserDetailsService `接口即可。\n\n作用：查询数据库用户名和密码过程\n\n- 创建类继承`UsernamePasswordAuthenticationFilter`，重写三个方法\n- 创建类实现`UserDetailService`，返回`UserDetails`对象（框架提供的对象）\n\n`UserDetails`类\n\n```java\npublic interface UserDetails extends Serializable {\n  \t// 表示获取登录用户所有权限\n    Collection<? extends GrantedAuthority> getAuthorities();\n    // 表示获取密码\n    String getPassword();\n    // 表示获取用户名\n    String getUsername();\n    // 表示判断账户是否过期\n    boolean isAccountNonExpired();\n    // 表示判断账户是否被锁定\n    boolean isAccountNonLocked();\n    // 表示凭证{密码}是否过期\n    boolean isCredentialsNonExpired();\n    // 表示当前用户是否可用\n    boolean isEnabled();\n}\n```\n\n### PasswordEncoder\n\n```java\npublic interface PasswordEncoder {\n    // 表示把参数按照特定的解析规则进行解析\n    String encode(CharSequence var1);\n\t// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。\n    boolean matches(CharSequence var1, String var2);\n\t// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncoding(String encodedPassword) {\n        return false;\n    }\n}\n```\n\n接口实现\n\n`BCryptPasswordEncoder` 是 Spring Security 官方推荐的密码解析器，是对`PasswordEncoder`类的实现\n\n加密\n\n```java\npublic String encode(CharSequence rawPassword) {\n        if (rawPassword == null) {\n            throw new IllegalArgumentException(\"rawPassword cannot be null\");\n        } else {\n            String salt;\n            if (this.random != null) {\n                salt = BCrypt.gensalt(this.version.getVersion(), this.strength, this.random);\n            } else {\n                salt = BCrypt.gensalt(this.version.getVersion(), this.strength);\n            }\n\n            return BCrypt.hashpw(rawPassword.toString(), salt);\n        }\n    }\n```\n\n匹配\n\n```java\npublic boolean matches(CharSequence rawPassword, String encodedPassword) {\n        if (rawPassword == null) {\n            throw new IllegalArgumentException(\"rawPassword cannot be null\");\n        } else if (encodedPassword != null && encodedPassword.length() != 0) {\n            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {\n                this.logger.warn(\"Encoded password does not look like BCrypt\");\n                return false;\n            } else {\n                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);\n            }\n        } else {\n            this.logger.warn(\"Empty encoded password\");\n            return false;\n        }\n    }\n```\n\n## SpringSecurity Web 权限方案\n\n授权和认证两种\n\n### 设置用户名和密码\n\n方式一：配置文件实现\n\n```properties\nspring.security.user.name=ljx\nspring.security.user.password=ljx\n```\n\n方式二：配置类实现\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        BCryptPasswordEncoder cryptPasswordEncoder = new BCryptPasswordEncoder();\n        auth.inMemoryAuthentication().withUser(\"ljx\").password(cryptPasswordEncoder.encode(\"ljx\")).roles(\"user\");\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n}\n```\n\n方式三：自定义实现类\n\n创建配置类\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    /**\n     * 自定义类实现登录\n     * @param auth\n     * @throws Exception\n     */\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());\n\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n编写`userDetailService`实现类，返回`User`对象`\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<GrantedAuthority> list = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(\"ljx\", new BCryptPasswordEncoder().encode(\"ljx\"), list);\n    }\n}\n```\n\n### 整合数据库实现登录\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        User user = userMapper.queryUserByUsername(s);\n        if(s == null){\n            throw new UsernameNotFoundException(\"用户不存在\");\n        }\n        List<GrantedAuthority> list = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(user.getUsername(), new BCryptPasswordEncoder().encode(user.getPassword()), list);\n    }\n}\n```\n\n### 路径拦截路径拦截\n\n实现`configure`的另一个方法（与上面的不一样）\n\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n           http.and()\n                .authorizeRequests()\n                .antMatchers(\"/api/main/t\").permitAll() // 不需要认证\n                .anyRequest().authenticated()\n                .and().csrf().disable();  // 关闭csrf\n    }\n```\n\n## 角色权限访问控制\n\n### hasAuthority\n\n如果当前的主体具有指定的权限，则返回 true,否则返回 false\n\n```java\n.antMatchers(\"/test1\").hasAuthority(\"admin\")\n```\n\n### hasAnyAuthority\n\n如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串表）的话，返回 true\n\n```java\n.antMatchers(\"/test2\").hasAnyAuthority(\"admin, role\")\n```\n\n### hasRole\n\n如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。\n\n```java\n.antMatchers(\"/test3\").hasRole(\"sale\")\n```\n\n这个方法于之前两个不同的是底层原码是默认加了`ROLE_`前缀，所以在添加用户权限的时候需注意在角色前面加`ROLE_`\n\n```java\nprivate static String hasRole(String role) {\n        Assert.notNull(role, \"role cannot be null\");\n        if (role.startsWith(\"ROLE_\")) {\n            throw new IllegalArgumentException(\"role should not start with 'ROLE_' since it is automatically inserted. Got '\" + role + \"'\");\n        } else {\n            return \"hasRole('ROLE_\" + role + \"')\";\n        }\n    }\n```\n\n### hasAnyRole\n\n表示用户具备任何一个条件都可以访问\n\n```java\n.antMatchers(\"/test3\").hasAnyRole(\"sale\")\n```\n\n要求于`hasRole`一样\n\n### 自定义403页面\n\n```java\nhttp.exceptionHandling().accessDeniedPage(\"/unauth\");\n```\n\n```java\n@GetMapping(\"/unauth\")\n@ResponseBody\npublic String t4(){\n    return \"unauth\";\n}\n```\n\n### 注解使用\n\n#### @Secured\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(securedEnabled = true)\n```\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“\n\n在方法上加上这个注解\n\n```java\n@Secured({\"ROLE_sole\", \"ROLE_aaa\"})\n```\n\n#### @PreAuthorize\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n```\n\n注解适合进入方法前的权限验证\n\n```java\n@PreAuthorize(\"hasAnyAuthority('menu:system')\")\n// 此处hasAnyAuthority可以换成hasAnyRole，hasRole，hasAnyAuthority其中一个\n```\n\n#### @PostAuthorize\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true\n```\n\n在方法执行后再进行权限验证（接口里面方法任会被执行，只是最后会权限验证），适合验证带有返回值的权限\n\n```java\n@PostAuthorize(\"hasAnyAuthority('menu:system')\")\n```\n\n#### @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是` admin1`的数据，表达式中的 `filterObject`引用的是方法返回值 List 中的某一个元素\n\n```java\n@RequestMapping(\"getAll\")\n@PreAuthorize(\"hasRole('ROLE_role')\")\n@PostFilter(\"filterObject.username == 'admin1'\")\n@ResponseBody\npublic List<UserInfo> getAllUser(){\n ArrayList<UserInfo> list = new ArrayList<>();\n list.add(new UserInfo(1l,\"admin1\",\"6666\"));\n list.add(new UserInfo(2l,\"admin2\",\"888\"));\nreturn list;\n}\n```\n\n最终返回页面的数据\n\n```json\n[\n    {\n        \"id\": 1,\n        \"username\": \"admin1\",\n        \"num\": \"6666\"\n    }\n]\n```\n\n#### @PreFilter\n\n进入控制器之前对数据进行过滤\n\n```java\n@RequestMapping(\"getTestPreFilter\")\n@PreAuthorize(\"hasRole('ROLE_role')\")\n@PreFilter(value = \"filterObject.id % 2 == 0\")\n@ResponseBody\npublic List<UserInfo> getTestPreFilter(@RequestBody List<UserInfo> \nlist){\n list.forEach(t-> {\n System.out.println(t.getId()+\"\\t\"+t.getUsername());\n });\nreturn list;\n}\n```\n\n最终接收到的参数只有id为偶数才能被接收\n\n### 退出登录\n\n```java\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/index\").permitAll\n```\n\n## CSRF\n\n跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click  attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任\n\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。\n\n关闭csrf\n\n```java\nhttp.csrf().disable()\n```\n\n## 微服务\n\n### 数据库\n\n![image-20230726154749582](https://s1.ax1x.com/2023/07/26/pCjwOSS.png)\n\n### 搭建项目\n\n![image-20230726154749582](https://s1.ax1x.com/2023/07/26/pCjax1g.png)\n\n### 前置知识\n\n#### Nacos\n\n阿里巴巴的注册中心，网关服务（9001端口）通过注册中心转发到权限管理服务（8081端口）\n\n启动：Windows点击`startup.cmd`，Linux运行`startup.sh`\n\n访问地址：http://localhost:8848/nacos，默认用户名和密码都是nacos\n\n## 认证流程\n\n[![pCvJddf.png](https://s1.ax1x.com/2023/07/27/pCvJddf.png)](https://imgse.com/i/pCvJddf)\n\n`UsernamePasswordAuthenticationFilter`\n\n继承`AbstractAuthenticationProcessingFilter`父类\n\n查看父类的`doFilter`方法\n\n```java\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        // 判断是否是post提交\n        if (!this.requiresAuthentication(request, response)) {\n            chain.doFilter(request, response);\n        } else {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Request is to process authentication\");\n            }\n\t\t\t// 进行身份认证，认证成功将信息封装到Authentication中\n            Authentication authResult;\n            try {\n                authResult = this.attemptAuthentication(request, response);\n                if (authResult == null) {\n                    return;\n                }\t\n\t\t\t\t// session策略处理\n                this.sessionStrategy.onAuthentication(authResult, request, response);\n            } catch (InternalAuthenticationServiceException var8) {\n                // 认证失败\n                this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8);\n                this.unsuccessfulAuthentication(request, response, var8);\n                return;\n            } catch (AuthenticationException var9) {\n                this.unsuccessfulAuthentication(request, response, var9);\n                return;\n            }\n\t\t\t// 认证成功\n            // continueChainBeforeSuccessfulAuthentication默认为false\n            if (this.continueChainBeforeSuccessfulAuthentication) {\n                chain.doFilter(request, response);\n            }\n\n            this.successfulAuthentication(request, response, chain, authResult);\n        }\n    }\n```\n\n查看`UsernamePasswordAuthenticationFilter`子类中的`attemptAuthentication`方法（上述代码中的`attemptAuthentication`方法）\n\n```java\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        // 判断是否是post请求\n        if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n            throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n        } else {\n            // 检查参数书否为空\n            String username = this.obtainUsername(request);\n            String password = this.obtainPassword(request);\n            if (username == null) {\n                username = \"\";\n            }\n\n            if (password == null) {\n                password = \"\";\n            }\n\t\t\t// 去掉空格\n            username = username.trim();\n            // 使用获取数据构造对象，标记未认证\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n            // 将请求的信息设置到Authentication对象中\n            this.setDetails(request, authRequest);\n            // 进行身份验证（调用userDetailsService）\n            return this.getAuthenticationManager().authenticate(authRequest);\n        }\n    }\n```\n\n查看`ProviderManager`实现`AuthenticationManager`接口（该接口包含上述代码最后一行的的`authenticate`方法）\n\n```java\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        // 获取Authentication的类型，即UsernamePasswordAuthenticationToken.class\n        Class<? extends Authentication> toTest = authentication.getClass();\n        AuthenticationException lastException = null;\n        AuthenticationException parentException = null;\n        Authentication result = null;\n        Authentication parentResult = null;\n        boolean debug = logger.isDebugEnabled();\n        // 获取认证方式列表List<AuthenticationProvider>迭代器\n        Iterator var8 = this.getProviders().iterator();\n\n        while(var8.hasNext()) {\n            AuthenticationProvider provider = (AuthenticationProvider)var8.next();\n            // 判断当前AuthenticationProvider是否适用UsernamePasswordAuthenticationToken.class类型的Authentication\n            if (provider.supports(toTest)) {\n                if (debug) {\n                    logger.debug(\"Authentication attempt using \" + provider.getClass().getName());\n                }\n\n                try {\n                    // 认证成功会返回标记已认证的Authentication对象\n                    result = provider.authenticate(authentication);\n                    if (result != null) {\n                        // 信息拷贝到result中\n                        this.copyDetails(authentication, result);\n                        break;\n                    }\n                } catch (InternalAuthenticationServiceException | AccountStatusException var13) {\n                    this.prepareException(var13, authentication);\n                    throw var13;\n                } catch (AuthenticationException var14) {\n                    lastException = var14;\n                }\n            }\n        }\n\n        if (result == null && this.parent != null) {\n            try {\n                // 认证失败，使其父类型AuthenticationManager进行验证\n                result = parentResult = this.parent.authenticate(authentication);\n            } catch (ProviderNotFoundException var11) {\n            } catch (AuthenticationException var12) {\n                parentException = var12;\n                lastException = var12;\n            }\n        }\n\n        if (result != null) {\n            // 认证成功，去掉result铭感信息\n            if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {\n                // 去除的过程就是调用CredentialsContainer的eraseCredentials方法\n                ((CredentialsContainer)result).eraseCredentials();\n            }\n\t\t\t// 发布成功认证的事件\n            if (parentResult == null) {\n                this.eventPublisher.publishAuthenticationSuccess(result);\n            }\n\n            return result;\n        } else {\n            // 认证失败抛出异常\n            if (lastException == null) {\n                lastException = new ProviderNotFoundException(this.messages.getMessage(\"ProviderManager.providerNotFound\", new Object[]{toTest.getName()}, \"No AuthenticationProvider found for {0}\"));\n            }\n\n            if (parentException == null) {\n                this.prepareException((AuthenticationException)lastException, authentication);\n            }\n\n            throw lastException;\n        }\n    }\n```\n\n上述代码的去掉敏感信息方法\n\n```java\npublic abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer {\n    // 实现CredentialsContainer接口\n    public void eraseCredentials() {\n        // 前端传入的密码设为null\n        this.eraseSecret(this.getCredentials());\n        this.eraseSecret(this.getPrincipal());\n        this.eraseSecret(this.details);\n    }\n}\n```\n\n认证成功`successfulAuthentication`方法\n\n```java\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult);\n        }\n\t\t// 将认证成功的用户信息Authentication封装到SecurtyContext对象，并存入SecurityContextHolader\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n        // 处理RememberMe\n        this.rememberMeServices.loginSuccess(request, response, authResult);\n        if (this.eventPublisher != null) {\n            // 发布认证成功的属性\t\n            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n        }\n\t\t// 调用成功认证处理器\n        this.successHandler.onAuthenticationSuccess(request, response, authResult);\n    }\n```\n\n认证失败`unsuccessfulAuthentication`方法\n\n```java\nprotected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {\n    //清楚线程在SecurityContextHolder中的SecurtyContext对象\n    SecurityContextHolder.clearContext();\n    if (this.logger.isDebugEnabled()) {\n        this.logger.debug(\"Authentication request failed: \" + failed.toString(), failed);\n        this.logger.debug(\"Updated SecurityContextHolder to contain null Authentication\");\n        this.logger.debug(\"Delegating to authentication failure handler \" + this.failureHandler);\n    }\n\t // 处理RememberMe\n    this.rememberMeServices.loginFail(request, response);\n    // 调用认证失败处理器\n    this.failureHandler.onAuthenticationFailure(request, response, failed);\n}\n```\n\n[![pCvJGzd.png](https://s1.ax1x.com/2023/07/27/pCvJGzd.png)](https://imgse.com/i/pCvJGzd)\n","title":" SpringSecurity学习笔记\n","category":[" Java","SpringSecurity\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n两个核心功能：认证和授权\n\n 基本原理\n\n 拦截器链\n\nSpringSecurity本质是一个过滤器链，在 SpringBoot 2.3.4.RELEASE中，共有15种拦截器，如图所示：\n\nhttps://gitee.com/lijunxi666/picturebed/raw/master/springsecurityfilter//dkhd21HR825.png\n\n\norg.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter org.springframework.security.web.context.SecurityContextPersistenceFilter  org.springframework.security.web.header.HeaderWriterFilter org.springframework.security.web.csrf.CsrfFilter org.springframework.security.web.authentication.logout.LogoutFilter  org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter  org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter  org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter org.springframework.security.web.savedrequest.RequestCacheAwareFilter org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter org.springframework.security.web.authentication.AnonymousAuthenticationFilter  org.springframework.security.web.session.SessionManagementFilter  org.springframework.security.web.access.ExceptionTranslationFilter  org.springframework.security.web.access.intercept.FilterSecurityIntercepto\n\n\n重点三个：\n\nFilterSecurityInterceptor：是一个方法级的权限过滤器, 基本位于过滤链的最底部。\n\nExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常\n\nUsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码\n\n 主要拦截器介绍\n\n SecurityContextPersistenceFilter\n\n包路径：org.springframework.security.web.context\n\n负责将安全上下文存储在 HttpSession 中，以便在后续请求中访问\n\njava\npublic void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n    HttpServletRequest request = HttpServletRequestreq;\n    HttpServletResponse response = HttpServletResponseres;\n    // 判断是否是第一次请求\n    if request.getAttribute\"springsecurityscpfapplied\" = null {\n        chain.doFilterrequest, response;\n    } else {\n        boolean debug = this.logger.isDebugEnabled;\n        // 设置值\n        request.setAttribute\"springsecurityscpfapplied\", Boolean.TRUE;\n        if this.forceEagerSessionCreation {\n            HttpSession session = request.getSession;\n            if debug && session.isNew {\n                this.logger.debug\"Eagerly created session: \" + session.getId;\n            }\n        }\n\n        HttpRequestResponseHolder holder = new HttpRequestResponseHolderrequest, response;\n        SecurityContext contextBeforeChainExecution = this.repo.loadContextholder;\n        boolean var13 = false;\n\n        try {\n            var13 = true;\n            // 将SecurityContext安全信息设置到SecurityContextHolder线程上下文中\n            SecurityContextHolder.setContextcontextBSecurityContextHolder中eforeChainExecution;\n            chain.doFilterholder.getR\tequest, holder.getResponse;\n            var13 = false;\n        } finally {\n            if var13 {\n                SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext;\n                SecurityContextHolder.clearContext;\n                // 将上下文信息保存在session中\n                this.repo.saveContextcontextAfterChainExecution, holder.getRequest, holder.getResponse;\n                request.removeAttribute\"springsecurityscpfapplied\";\n                if debug {\n                    this.logger.debug\"SecurityContextHolder now cleared, as request processing completed\";\n                }\n\n            }\n        }\n\n        SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext;\n        SecurityContextHolder.clearContext;\n        this.repo.saveContextcontextAfterChainExecution, holder.getRequest, holder.getResponse;\n            request.removeAttribute\"springsecurityscpfapplied\";\n        if debug {\n            this.logger.debug\"SecurityContextHolder now cleared, as request processing completed\";\n        }\n\n    }\n}\n\n\n LogoutFilter\n\n包路径：org.springframework.security.web.authentication.logout.LogoutFilter\n\n匹配URL为 /logout 的请求，实现用户退出，清除认证信息\n\njava\npublic void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n    HttpServletRequest request = HttpServletRequestreq;\n    HttpServletResponse response = HttpServletResponseres;\n    if this.requiresLogoutrequest, response { // 匹配URL\n        Authentication auth = SecurityContextHolder.getContext.getAuthentication;\n        if this.logger.isDebugEnabled {\n            this.logger.debug\"Logging out user '\" + auth + \"' and transferring to logout destination\";\n        }\n\n        this.handler.logoutrequest, response, auth; // 清除认证信息\n        this.logoutSuccessHandler.onLogoutSuccessrequest, response, auth; // 处理自定义退出成功逻辑\n    } else {\n        chain.doFilterrequest, response;\n    }\n}\n\n\n对于 logoutSuccessHandler.onLogoutSuccess 这个方法，我们可以对他进行重写，实现自己的退出成功逻辑\n\n UsernamePasswordAuthenticationFilter\n\n包路径：org.springframework.security.web.authentication\n\n匹配请求为 POST，且路径为 /login 的请求，通过表单的用户名和密码进行认证，认证成功会将用户信息放到上下文中\n\njava\npublic void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n    HttpServletRequest request = HttpServletRequestreq;\n    HttpServletResponse response = HttpServletResponseres;\n    if this.requiresAuthenticationrequest, response {\n        chain.doFilterrequest, response;\n    } else {\n        if this.logger.isDebugEnabled {\n            this.logger.debug\"Request is to process authentication\";\n        }\n\n        Authentication authResult;\n        try {\n            // 调用子类的attemptAuthentication方法\n            authResult = this.attemptAuthenticationrequest, response;\n            // 子类未完成认证\n            if authResult == null {\n                return;\n            }\n\n            this.sessionStrategy.onAuthenticationauthResult, request, response;\n        } catch InternalAuthenticationServiceException var8 {\n            this.logger.error\"An internal error occurred while trying to authenticate the user.\", var8;\n            // 认证失败\n            this.unsuccessfulAuthenticationrequest, response, var8;\n            return;\n        } catch AuthenticationException var9 {\n            // 认证失败\n            this.unsuccessfulAuthenticationrequest, response, var9;\n            return;\n        }\n\n        if this.continueChainBeforeSuccessfulAuthentication {\n            chain.doFilterrequest, response;\n        }\n\t\t// 认证成功\n        this.successfulAuthenticationrequest, response, chain, authResult;\n    }\n}\n\npublic Authentication attemptAuthenticationHttpServletRequest request, HttpServletResponse response throws AuthenticationException {\n    if this.postOnly && request.getMethod.equals\"POST\" {\n        throw new AuthenticationServiceException\"Authentication method not supported: \" + request.getMethod;\n    } else {\n        String username = this.obtainUsernamerequest;\n        String password = this.obtainPasswordrequest;\n        if username == null {\n            username = \"\";\n        }\n\n        if password == null {\n            password = \"\";\n        }\n\n        username = username.trim;\n        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationTokenusername, password;\n        this.setDetailsrequest, authRequest;\n        // 核心部分，交给内部的AuthenticationManager去认证，并返回认证后的 Authentication\n        return this.getAuthenticationManager.authenticateauthRequest;\n    }\n}\n\n\n DefaultLoginPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n若未自定义认证界面，过滤器会生成一个默认的认证界面\n\njava\nprivate void initUsernamePasswordAuthenticationFilter authFilter, AbstractAuthenticationProcessingFilter openIDFilter {\n    this.loginPageUrl = \"/login\";\n    this.logoutSuccessUrl = \"/login?logout\";\n    this.failureUrl = \"/login?error\";\n    if authFilter = null { // 若自定义了，authFilter就为null\n        this.formLoginEnabled = true;\n        this.usernameParameter = authFilter.getUsernameParameter;\n        this.passwordParameter = authFilter.getPasswordParameter;\n        if authFilter.getRememberMeServices instanceof AbstractRememberMeServices {\n            this.rememberMeParameter = AbstractRememberMeServicesauthFilter.getRememberMeServices.getParameter;\n        }\n    }\n\n    if openIDFilter = null {\n        this.openIdEnabled = true;\n        this.openIDusernameParameter = \"openididentifier\";\n        if openIDFilter.getRememberMeServices instanceof AbstractRememberMeServices {\n            this.openIDrememberMeParameter = AbstractRememberMeServicesopenIDFilter.getRememberMeServices.getParameter;\n        }\n    }\n\n}\n\n\n DefaultLogoutPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n和 DefaultLogoutPageGeneratingFilter 类似，此过滤器可以生产一个默认的退出登录页面\n\njava\nprivate void renderLogoutHttpServletRequest request, HttpServletResponse response throws IOException {\n    String page = \"<DOCTYPE html\\n<html lang=\\\"en\\\"\\n  <head\\n    <meta charset=\\\"utf8\\\"\\n    <meta name=\\\"viewport\\\" content=\\\"width=devicewidth, initialscale=1, shrinktofit=no\\\"\\n    <meta name=\\\"description\\\" content=\\\"\\\"\\n    <meta name=\\\"author\\\" content=\\\"\\\"\\n    <titleConfirm Log Out?</title\\n    <link href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0beta/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\" integrity=\\\"sha384/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\\\" crossorigin=\\\"anonymous\\\"\\n    <link href=\\\"https://getbootstrap.com/docs/4.0/examples/signin/signin.css\\\" rel=\\\"stylesheet\\\" crossorigin=\\\"anonymous\\\"/\\n  </head\\n  <body\\n     <div class=\\\"container\\\"\\n      <form class=\\\"formsignin\\\" method=\\\"post\\\" action=\\\"\" + request.getContextPath + \"/logout\\\"\\n        <h2 class=\\\"formsigninheading\\\"Are you sure you want to log out?</h2\\n\" + this.renderHiddenInputsrequest + \"        <button class=\\\"btn btnlg btnprimary btnblock\\\" type=\\\"submit\\\"Log Out</button\\n      </form\\n    </div\\n  </body\\n</html\";\n    response.setContentType\"text/html;charset=UTF8\";\n    response.getWriter.writepage;\n}\n\n\n AnonymousAuthenticationFilter\n\n当用户没有授权认证，那么就会给他一个匿名身份\n\n\n\n ExceptionTranslationFilter\n\n包路径：org.springframework.security.web.access\n\n捕获并处理认证和授权过程中发生的异常\n\n\n\n FilterSecurityInterceptor\n\n包路径：org.springframework.security.web.access.intercept\n\n获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来决定其是否有权限\n\n\n\n 过滤器加载流程\n\n DelegatingFilterProxy类\n\n首先执行doFilter方法\n\njava\npublic void doFilterServletRequest request, ServletResponse response, FilterChain filterChain throws ServletException, IOException {\n        Filter delegateToUse = this.delegate;\n        if delegateToUse == null {\n            synchronizedthis.delegateMonitor {\n                delegateToUse = this.delegate;\n                if delegateToUse == null {\n                    WebApplicationContext wac = this.findWebApplicationContext;\n                    if wac == null {\n                        throw new IllegalStateException\"No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?\";\n                    }\n\n                    delegateToUse = this.initDelegatewac;\n                }\n\n                this.delegate = delegateToUse;\n            }\n        }\n\n\n接着执行initDelegate\n\njava\n protected Filter initDelegateWebApplicationContext wac throws ServletException {\n        String targetBeanName = this.getTargetBeanName;\n        Assert.statetargetBeanName = null, \"No target bean name set\";\n        Filter delegate = Filterwac.getBeantargetBeanName, Filter.class;\n        if this.isTargetFilterLifecycle {\n            delegate.initthis.getFilterConfig;\n        }\n\n        return delegate;\n    }\n\n\ntargetBeanName在SpringSecurity中有一个固定的名字：FilterChainProxy\n\n FilterChainProxy类\n\n首先执行doFilter方法\n\njava\n    public void doFilterServletRequest request, ServletResponse response, FilterChain chain throws IOException, ServletException {\n        boolean clearContext = request.getAttributeFILTERAPPLIED == null;\n        if clearContext {\n            try {\n                request.setAttributeFILTERAPPLIED, Boolean.TRUE;\n                this.doFilterInternalrequest, response, chain;\n            } finally {\n                SecurityContextHolder.clearContext;\n                request.removeAttributeFILTERAPPLIED;\n            }\n        } else {\n            this.doFilterInternalrequest, response, chain;\n        }\n\n    }\n\n\n执行doFilterInternal方法\n\njava\nprivate void doFilterInternalServletRequest request, ServletResponse response, FilterChain chain throws IOException, ServletException {\n        FirewalledRequest fwRequest = this.firewall.getFirewalledRequestHttpServletRequestrequest;\n        HttpServletResponse fwResponse = this.firewall.getFirewalledResponseHttpServletResponseresponse;\n        List<Filter filters = this.getFiltersHttpServletRequestfwRequest;\n        if filters = null && filters.size = 0 {\n            FilterChainProxy.VirtualFilterChain vfc = new FilterChainProxy.VirtualFilterChainfwRequest, chain, filters;\n            vfc.doFilterfwRequest, fwResponse;\n        } else {\n            if logger.isDebugEnabled {\n                logger.debugUrlUtils.buildRequestUrlfwRequest + filters == null ? \" has no matching filters\" : \" has an empty filter list\";\n            }\n\n            fwRequest.reset;\n            chain.doFilterfwRequest, fwResponse;\n        }\n    }\n\n\n  List<Filter filters = this.getFiltersHttpServletRequestfwRequest;会执行getFilters方法，它会把过滤器一个一个加载到过滤链中\n\njava\nprivate List<Filter getFiltersHttpServletRequest request {\n      Iterator var2 = this.filterChains.iterator;\n\n      SecurityFilterChain chain;\n      do {\n          if var2.hasNext {\n              return null;\n          }\n\n          chain = SecurityFilterChainvar2.next;\n      } whilechain.matchesrequest;\n\n      return chain.getFilters;\n}\n\n\n 重要接口\n\n UserDetailsService\n\njava\npublic interface UserDetailsService {\n    UserDetails loadUserByUsernameString var1 throws UsernameNotFoundException;\n}\n\n\n 当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。\n\n作用：查询数据库用户名和密码过程\n\n 创建类继承UsernamePasswordAuthenticationFilter，重写三个方法\n 创建类实现UserDetailService，返回UserDetails对象（框架提供的对象）\n\nUserDetails类\n\njava\npublic interface UserDetails extends Serializable {\n  \t// 表示获取登录用户所有权限\n    Collection<? extends GrantedAuthority getAuthorities;\n    // 表示获取密码\n    String getPassword;\n    // 表示获取用户名\n    String getUsername;\n    // 表示判断账户是否过期\n    boolean isAccountNonExpired;\n    // 表示判断账户是否被锁定\n    boolean isAccountNonLocked;\n    // 表示凭证{密码}是否过期\n    boolean isCredentialsNonExpired;\n    // 表示当前用户是否可用\n    boolean isEnabled;\n}\n\n\n PasswordEncoder\n\njava\npublic interface PasswordEncoder {\n    // 表示把参数按照特定的解析规则进行解析\n    String encodeCharSequence var1;\n\t// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。\n    boolean matchesCharSequence var1, String var2;\n\t// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncodingString encodedPassword {\n        return false;\n    }\n}\n\n\n接口实现\n\nBCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，是对PasswordEncoder类的实现\n\n加密\n\njava\npublic String encodeCharSequence rawPassword {\n        if rawPassword == null {\n            throw new IllegalArgumentException\"rawPassword cannot be null\";\n        } else {\n            String salt;\n            if this.random = null {\n                salt = BCrypt.gensaltthis.version.getVersion, this.strength, this.random;\n            } else {\n                salt = BCrypt.gensaltthis.version.getVersion, this.strength;\n            }\n\n            return BCrypt.hashpwrawPassword.toString, salt;\n        }\n    }\n\n\n匹配\n\njava\npublic boolean matchesCharSequence rawPassword, String encodedPassword {\n        if rawPassword == null {\n            throw new IllegalArgumentException\"rawPassword cannot be null\";\n        } else if encodedPassword = null && encodedPassword.length = 0 {\n            if this.BCRYPTPATTERN.matcherencodedPassword.matches {\n                this.logger.warn\"Encoded password does not look like BCrypt\";\n                return false;\n            } else {\n                return BCrypt.checkpwrawPassword.toString, encodedPassword;\n            }\n        } else {\n            this.logger.warn\"Empty encoded password\";\n            return false;\n        }\n    }\n\n\n SpringSecurity Web 权限方案\n\n授权和认证两种\n\n 设置用户名和密码\n\n方式一：配置文件实现\n\nproperties\nspring.security.user.name=ljx\nspring.security.user.password=ljx\n\n\n方式二：配置类实现\n\njava\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configureAuthenticationManagerBuilder auth throws Exception {\n        BCryptPasswordEncoder cryptPasswordEncoder = new BCryptPasswordEncoder;\n        auth.inMemoryAuthentication.withUser\"ljx\".passwordcryptPasswordEncoder.encode\"ljx\".roles\"user\";\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder{\n        return new BCryptPasswordEncoder;\n    }\n\n}\n\n\n方式三：自定义实现类\n\n创建配置类\n\njava\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    /\n      自定义类实现登录\n      @param auth\n      @throws Exception\n     /\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configureAuthenticationManagerBuilder auth throws Exception {\n        auth.userDetailsServiceuserDetailsService.passwordEncoderpasswordEncoder;\n\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder{\n        return new BCryptPasswordEncoder;\n    }\n}\n\n\n编写userDetailService实现类，返回User对象\n\njava\n@Service\"userDetailsService\"\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsernameString s throws UsernameNotFoundException {\n        List<GrantedAuthority list = AuthorityUtils.commaSeparatedStringToAuthorityList\"role\";\n        return new User\"ljx\", new BCryptPasswordEncoder.encode\"ljx\", list;\n    }\n}\n\n\n 整合数据库实现登录\n\njava\n@Service\"userDetailsService\"\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsernameString s throws UsernameNotFoundException {\n        User user = userMapper.queryUserByUsernames;\n        ifs == null{\n            throw new UsernameNotFoundException\"用户不存在\";\n        }\n        List<GrantedAuthority list = AuthorityUtils.commaSeparatedStringToAuthorityList\"role\";\n        return new Useruser.getUsername, new BCryptPasswordEncoder.encodeuser.getPassword, list;\n    }\n}\n\n\n 路径拦截路径拦截\n\n实现configure的另一个方法（与上面的不一样）\n\njava\n@Override\nprotected void configureHttpSecurity http throws Exception {\n           http.and\n                .authorizeRequests\n                .antMatchers\"/api/main/t\".permitAll // 不需要认证\n                .anyRequest.authenticated\n                .and.csrf.disable;  // 关闭csrf\n    }\n\n\n 角色权限访问控制\n\n hasAuthority\n\n如果当前的主体具有指定的权限，则返回 true,否则返回 false\n\njava\n.antMatchers\"/test1\".hasAuthority\"admin\"\n\n\n hasAnyAuthority\n\n如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串表）的话，返回 true\n\njava\n.antMatchers\"/test2\".hasAnyAuthority\"admin, role\"\n\n\n hasRole\n\n如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。\n\njava\n.antMatchers\"/test3\".hasRole\"sale\"\n\n\n这个方法于之前两个不同的是底层原码是默认加了ROLE前缀，所以在添加用户权限的时候需注意在角色前面加ROLE\n\njava\nprivate static String hasRoleString role {\n        Assert.notNullrole, \"role cannot be null\";\n        if role.startsWith\"ROLE\" {\n            throw new IllegalArgumentException\"role should not start with 'ROLE' since it is automatically inserted. Got '\" + role + \"'\";\n        } else {\n            return \"hasRole'ROLE\" + role + \"'\";\n        }\n    }\n\n\n hasAnyRole\n\n表示用户具备任何一个条件都可以访问\n\njava\n.antMatchers\"/test3\".hasAnyRole\"sale\"\n\n\n要求于hasRole一样\n\n 自定义403页面\n\njava\nhttp.exceptionHandling.accessDeniedPage\"/unauth\";\n\n\njava\n@GetMapping\"/unauth\"\n@ResponseBody\npublic String t4{\n    return \"unauth\";\n}\n\n\n 注解使用\n\n @Secured\n\n使用注解先要开启注解功能\n\njava\n@EnableGlobalMethodSecuritysecuredEnabled = true\n\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE“\n\n在方法上加上这个注解\n\njava\n@Secured{\"ROLEsole\", \"ROLEaaa\"}\n\n\n @PreAuthorize\n\n使用注解先要开启注解功能\n\njava\n@EnableGlobalMethodSecurityprePostEnabled = true\n\n\n注解适合进入方法前的权限验证\n\njava\n@PreAuthorize\"hasAnyAuthority'menu:system'\"\n// 此处hasAnyAuthority可以换成hasAnyRole，hasRole，hasAnyAuthority其中一个\n\n\n @PostAuthorize\n\n使用注解先要开启注解功能\n\njava\n@EnableGlobalMethodSecurityprePostEnabled = true\n\n\n在方法执行后再进行权限验证（接口里面方法任会被执行，只是最后会权限验证），适合验证带有返回值的权限\n\njava\n@PostAuthorize\"hasAnyAuthority'menu:system'\"\n\n\n @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是 admin1的数据，表达式中的 filterObject引用的是方法返回值 List 中的某一个元素\n\njava\n@RequestMapping\"getAll\"\n@PreAuthorize\"hasRole'ROLErole'\"\n@PostFilter\"filterObject.username == 'admin1'\"\n@ResponseBody\npublic List<UserInfo getAllUser{\n ArrayList<UserInfo list = new ArrayList<;\n list.addnew UserInfo1l,\"admin1\",\"6666\";\n list.addnew UserInfo2l,\"admin2\",\"888\";\nreturn list;\n}\n\n\n最终返回页面的数据\n\njson\n\n    {\n        \"id\": 1,\n        \"username\": \"admin1\",\n        \"num\": \"6666\"\n    }\n\n\n\n @PreFilter\n\n进入控制器之前对数据进行过滤\n\njava\n@RequestMapping\"getTestPreFilter\"\n@PreAuthorize\"hasRole'ROLErole'\"\n@PreFiltervalue = \"filterObject.id % 2 == 0\"\n@ResponseBody\npublic List<UserInfo getTestPreFilter@RequestBody List<UserInfo \nlist{\n list.forEacht {\n System.out.printlnt.getId+\"\\t\"+t.getUsername;\n };\nreturn list;\n}\n\n\n最终接收到的参数只有id为偶数才能被接收\n\n 退出登录\n\njava\nhttp.logout.logoutUrl\"/logout\".logoutSuccessUrl\"/index\".permitAll\n\n\n CSRF\n\n跨站请求伪造（英语：Crosssite request forgery），也被称为 oneclick  attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任\n\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。\n\n关闭csrf\n\njava\nhttp.csrf.disable\n\n\n 微服务\n\n 数据库\n\nimage20230726154749582https://s1.ax1x.com/2023/07/26/pCjwOSS.png\n\n 搭建项目\n\nimage20230726154749582https://s1.ax1x.com/2023/07/26/pCjax1g.png\n\n 前置知识\n\n Nacos\n\n阿里巴巴的注册中心，网关服务（9001端口）通过注册中心转发到权限管理服务（8081端口）\n\n启动：Windows点击startup.cmd，Linux运行startup.sh\n\n访问地址：http://localhost:8848/nacos，默认用户名和密码都是nacos\n\n 认证流程\n\npCvJddf.pnghttps://s1.ax1x.com/2023/07/27/pCvJddf.pnghttps://imgse.com/i/pCvJddf\n\nUsernamePasswordAuthenticationFilter\n\n继承AbstractAuthenticationProcessingFilter父类\n\n查看父类的doFilter方法\n\njava\n    public void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n        HttpServletRequest request = HttpServletRequestreq;\n        HttpServletResponse response = HttpServletResponseres;\n        // 判断是否是post提交\n        if this.requiresAuthenticationrequest, response {\n            chain.doFilterrequest, response;\n        } else {\n            if this.logger.isDebugEnabled {\n                this.logger.debug\"Request is to process authentication\";\n            }\n\t\t\t// 进行身份认证，认证成功将信息封装到Authentication中\n            Authentication authResult;\n            try {\n                authResult = this.attemptAuthenticationrequest, response;\n                if authResult == null {\n                    return;\n                }\t\n\t\t\t\t// session策略处理\n                this.sessionStrategy.onAuthenticationauthResult, request, response;\n            } catch InternalAuthenticationServiceException var8 {\n                // 认证失败\n                this.logger.error\"An internal error occurred while trying to authenticate the user.\", var8;\n                this.unsuccessfulAuthenticationrequest, response, var8;\n                return;\n            } catch AuthenticationException var9 {\n                this.unsuccessfulAuthenticationrequest, response, var9;\n                return;\n            }\n\t\t\t// 认证成功\n            // continueChainBeforeSuccessfulAuthentication默认为false\n            if this.continueChainBeforeSuccessfulAuthentication {\n                chain.doFilterrequest, response;\n            }\n\n            this.successfulAuthenticationrequest, response, chain, authResult;\n        }\n    }\n\n\n查看UsernamePasswordAuthenticationFilter子类中的attemptAuthentication方法（上述代码中的attemptAuthentication方法）\n\njava\n    public Authentication attemptAuthenticationHttpServletRequest request, HttpServletResponse response throws AuthenticationException {\n        // 判断是否是post请求\n        if this.postOnly && request.getMethod.equals\"POST\" {\n            throw new AuthenticationServiceException\"Authentication method not supported: \" + request.getMethod;\n        } else {\n            // 检查参数书否为空\n            String username = this.obtainUsernamerequest;\n            String password = this.obtainPasswordrequest;\n            if username == null {\n                username = \"\";\n            }\n\n            if password == null {\n                password = \"\";\n            }\n\t\t\t// 去掉空格\n            username = username.trim;\n            // 使用获取数据构造对象，标记未认证\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationTokenusername, password;\n            // 将请求的信息设置到Authentication对象中\n            this.setDetailsrequest, authRequest;\n            // 进行身份验证（调用userDetailsService）\n            return this.getAuthenticationManager.authenticateauthRequest;\n        }\n    }\n\n\n查看ProviderManager实现AuthenticationManager接口（该接口包含上述代码最后一行的的authenticate方法）\n\njava\n    public Authentication authenticateAuthentication authentication throws AuthenticationException {\n        // 获取Authentication的类型，即UsernamePasswordAuthenticationToken.class\n        Class<? extends Authentication toTest = authentication.getClass;\n        AuthenticationException lastException = null;\n        AuthenticationException parentException = null;\n        Authentication result = null;\n        Authentication parentResult = null;\n        boolean debug = logger.isDebugEnabled;\n        // 获取认证方式列表List<AuthenticationProvider迭代器\n        Iterator var8 = this.getProviders.iterator;\n\n        whilevar8.hasNext {\n            AuthenticationProvider provider = AuthenticationProvidervar8.next;\n            // 判断当前AuthenticationProvider是否适用UsernamePasswordAuthenticationToken.class类型的Authentication\n            if provider.supportstoTest {\n                if debug {\n                    logger.debug\"Authentication attempt using \" + provider.getClass.getName;\n                }\n\n                try {\n                    // 认证成功会返回标记已认证的Authentication对象\n                    result = provider.authenticateauthentication;\n                    if result = null {\n                        // 信息拷贝到result中\n                        this.copyDetailsauthentication, result;\n                        break;\n                    }\n                } catch InternalAuthenticationServiceException  AccountStatusException var13 {\n                    this.prepareExceptionvar13, authentication;\n                    throw var13;\n                } catch AuthenticationException var14 {\n                    lastException = var14;\n                }\n            }\n        }\n\n        if result == null && this.parent = null {\n            try {\n                // 认证失败，使其父类型AuthenticationManager进行验证\n                result = parentResult = this.parent.authenticateauthentication;\n            } catch ProviderNotFoundException var11 {\n            } catch AuthenticationException var12 {\n                parentException = var12;\n                lastException = var12;\n            }\n        }\n\n        if result = null {\n            // 认证成功，去掉result铭感信息\n            if this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer {\n                // 去除的过程就是调用CredentialsContainer的eraseCredentials方法\n                CredentialsContainerresult.eraseCredentials;\n            }\n\t\t\t// 发布成功认证的事件\n            if parentResult == null {\n                this.eventPublisher.publishAuthenticationSuccessresult;\n            }\n\n            return result;\n        } else {\n            // 认证失败抛出异常\n            if lastException == null {\n                lastException = new ProviderNotFoundExceptionthis.messages.getMessage\"ProviderManager.providerNotFound\", new Object{toTest.getName}, \"No AuthenticationProvider found for {0}\";\n            }\n\n            if parentException == null {\n                this.prepareExceptionAuthenticationExceptionlastException, authentication;\n            }\n\n            throw lastException;\n        }\n    }\n\n\n上述代码的去掉敏感信息方法\n\njava\npublic abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer {\n    // 实现CredentialsContainer接口\n    public void eraseCredentials {\n        // 前端传入的密码设为null\n        this.eraseSecretthis.getCredentials;\n        this.eraseSecretthis.getPrincipal;\n        this.eraseSecretthis.details;\n    }\n}\n\n\n认证成功successfulAuthentication方法\n\njava\n    protected void successfulAuthenticationHttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult throws IOException, ServletException {\n        if this.logger.isDebugEnabled {\n            this.logger.debug\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult;\n        }\n\t\t// 将认证成功的用户信息Authentication封装到SecurtyContext对象，并存入SecurityContextHolader\n        SecurityContextHolder.getContext.setAuthenticationauthResult;\n        // 处理RememberMe\n        this.rememberMeServices.loginSuccessrequest, response, authResult;\n        if this.eventPublisher = null {\n            // 发布认证成功的属性\t\n            this.eventPublisher.publishEventnew InteractiveAuthenticationSuccessEventauthResult, this.getClass;\n        }\n\t\t// 调用成功认证处理器\n        this.successHandler.onAuthenticationSuccessrequest, response, authResult;\n    }\n\n\n认证失败unsuccessfulAuthentication方法\n\njava\nprotected void unsuccessfulAuthenticationHttpServletRequest request, HttpServletResponse response, AuthenticationException failed throws IOException, ServletException {\n    //清楚线程在SecurityContextHolder中的SecurtyContext对象\n    SecurityContextHolder.clearContext;\n    if this.logger.isDebugEnabled {\n        this.logger.debug\"Authentication request failed: \" + failed.toString, failed;\n        this.logger.debug\"Updated SecurityContextHolder to contain null Authentication\";\n        this.logger.debug\"Delegating to authentication failure handler \" + this.failureHandler;\n    }\n\t // 处理RememberMe\n    this.rememberMeServices.loginFailrequest, response;\n    // 调用认证失败处理器\n    this.failureHandler.onAuthenticationFailurerequest, response, failed;\n}\n\n\npCvJGzd.pnghttps://s1.ax1x.com/2023/07/27/pCvJGzd.pnghttps://imgse.com/i/pCvJGzd\n"},{"filename":"bad-code","category":"java","md":{"topSummary":"\r\ntitle: 重构","mainContent":"代码的坏味道\r\ncategory: Java\r\ndate: 2024-07-05\r\nauthor: Jixer\r\nsource: 原创\r\n---\r\n\r\n本章节参考书籍《》\r\n\r\n","title":"\r\ntitle:","category":["\r\ntitle:"],"date":"\r\nti","author":"\r\ntitl","source":"e: 重构"},"simpleMd":"代码的坏味道\r\ncategory: Java\r\ndate: 20240705\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n\r\n本章节参考书籍《》\r\n\r\n"}]