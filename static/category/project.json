[{"filename":"mallchat","category":"project","md":{"topSummary":"\ntitle: MallChat项目笔记\ncategory: SpringBoot,实战项目\ndate: 2024-02-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 微信扫码登录\n\n### 准备\n\n#### 工具\n\n> 误区：微信扫码登录每个人都可以，不是只有认证号才行。测试阶段可以用测试接口来进行测试，只不过项目部署后才需要认证使用\n>\n> 注意：微信回调接口需要开启内网穿透\n\n- 微信公众号的开发者账号：[点击此处进行注册](https://mp.weixin.qq.com/)\n- 内网穿透工具：[点击此处注册](https://natapp.cn/)\n\n#### 引入依赖\n\n```xml\n<dependency>\n    <groupId>com.github.binarywang</groupId>\n    <artifactId>weixin-java-mp</artifactId>\n    <version>4.4.0</version>\n</dependency>\n```\n\n#### 配置文件\n\n这里配置文件参考Binary Wang的代码\n\n```yml\nwx:\n  mp:\n    callback: ${mallchat.wx.callback} # 回调地址\n    configs:\n      - appId: ${mallchat.wx.appId} # 第一个公众号的appid\n        secret: ${mallchat.wx.secret} # 公众号的appsecret\n        token: ${mallchat.wx.token} # 接口配置里的Token值\n        aesKey: ${mallchat.wx.aesKey} # 接口配置里的EncodingAESKey值\n```\n\nWxMpProperties.java\n\n```java\n@Data\n@ConfigurationProperties(prefix = \"wx.mp\")\npublic class WxMpProperties {\n    /**\n     * 是否使用redis存储access token\n     */\n    private boolean useRedis;\n\n    /**\n     * redis 配置\n     */\n    private RedisConfig redisConfig;\n\n    @Data\n    public static class RedisConfig {\n        /**\n         * redis服务器 主机地址\n         */\n        private String host;\n\n        /**\n         * redis服务器 端口号\n         */\n        private Integer port;\n\n        /**\n         * redis服务器 密码\n         */\n        private String password;\n\n        /**\n         * redis 服务连接超时时间\n         */\n        private Integer timeout;\n    }\n\n    /**\n     * 多个公众号配置信息\n     */\n    private List<MpConfig> configs;\n\n    @Data\n    public static class MpConfig {\n        /**\n         * 设置微信公众号的appid\n         */\n        private String appId;\n\n        /**\n         * 设置微信公众号的app secret\n         */\n        private String secret;\n\n        /**\n         * 设置微信公众号的token\n         */\n        private String token;\n\n        /**\n         * 设置微信公众号的EncodingAESKey\n         */\n        private String aesKey;\n    }\n\n    @Override\n    public String toString() {\n        return JSONUtil.toJsonStr(this);\n    }\n}\n```\n\nWxMpConfiguration.java\n\n```java\n@AllArgsConstructor\n@Configuration\n@EnableConfigurationProperties(WxMpProperties.class)\npublic class WxMpConfiguration {\n    private final LogHandler logHandler;\n    private final MsgHandler msgHandler;\n    private final SubscribeHandler subscribeHandler;\n    private final ScanHandler scanHandler;\n    private final WxMpProperties properties;\n\n    @Bean\n    public WxMpService wxMpService() {\n        // 代码里 getConfigs()处报错的同学，请注意仔细阅读项目说明，你的IDE需要引入lombok插件！！！！\n        final List<WxMpProperties.MpConfig> configs = this.properties.getConfigs();\n        if (configs == null) {\n            throw new RuntimeException(\"大哥，拜托先看下项目首页的说明（readme文件），添加下相关配置，注意别配错了！\");\n        }\n\n        WxMpService service = new WxMpServiceImpl();\n        service.setMultiConfigStorages(configs\n                .stream().map(a -> {\n                    WxMpDefaultConfigImpl configStorage;\n                    configStorage = new WxMpDefaultConfigImpl();\n\n                    configStorage.setAppId(a.getAppId());\n                    configStorage.setSecret(a.getSecret());\n                    configStorage.setToken(a.getToken());\n                    configStorage.setAesKey(a.getAesKey());\n                    return configStorage;\n                }).collect(Collectors.toMap(WxMpDefaultConfigImpl::getAppId, a -> a, (o, n) -> o)));\n        return service;\n    }\n\n    @Bean\n    public WxMpMessageRouter messageRouter(WxMpService wxMpService) {\n        final WxMpMessageRouter newRouter = new WxMpMessageRouter(wxMpService);\n\n        // 记录所有事件的日志 （异步执行）\n        newRouter.rule().handler(this.logHandler).next();\n\n        // 关注事件\n        newRouter.rule().async(false).msgType(EVENT).event(SUBSCRIBE).handler(this.subscribeHandler).end();\n\n        // 扫码事件\n        newRouter.rule().async(false).msgType(EVENT).event(EventType.SCAN).handler(this.scanHandler).end();\n\n        // 默认\n        newRouter.rule().async(false).handler(this.msgHandler).end();\n\n        return newRouter;\n    }\n\n}\n```\n\n#### 配置消息处理器\n\nAbstractHandler.java\n\n```java\npublic abstract class AbstractHandler implements WxMpMessageHandler {\n    protected Logger logger = LoggerFactory.getLogger(getClass());\n}\n```\n\nLogHandler.java（日志）\n\n```java\n@Component\n@Slf4j\npublic class LogHandler extends AbstractHandler {\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,\n                                    Map<String, Object> context, WxMpService wxMpService,\n                                    WxSessionManager sessionManager) {\n        log.info(\"\\n接收到请求消息，内容：{}\", JSONUtil.toJsonStr(wxMessage));\n        return null;\n    }\n}\n```\n\nMsgHandler.java\n\n```java\n@Component\npublic class MsgHandler extends AbstractHandler {\n\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,\n                                    Map<String, Object> context, WxMpService weixinService,\n                                    WxSessionManager sessionManager) {\n\n        return null;\n    }\n}\n```\n\nScanHandler.java\n\n```java\n@Component\npublic class ScanHandler extends AbstractHandler {\n\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /**\n     * 处理用户扫码【不是第一次】\n     */\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMpXmlMessage, Map<String, Object> map,\n                                    WxMpService wxMpService, WxSessionManager wxSessionManager) throws WxErrorException {\n        // 扫码事件处理\n        return wxMsgService.scan(wxMpService, wxMpXmlMessage);\n    }\n}\n```\n\nSubscribeHandler.java\n\n```java\n@Component\npublic class SubscribeHandler extends AbstractHandler {\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /**\n     * 扫描登录二维码后第一次进入需要关注公众号\n     * @param wxMessage\n     * @param context\n     * @param weixinService\n     * @param sessionManager\n     * @return\n     * @throws WxErrorException\n     */\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,\n                                    Map<String, Object> context, WxMpService weixinService,\n                                    WxSessionManager sessionManager) throws WxErrorException {\n\n        this.logger.info(\"新关注用户 OPENID: \" + wxMessage.getFromUser());\n\n        WxMpXmlOutMessage responseResult = null;\n        try {\n            responseResult = this.handleSpecial(weixinService, wxMessage);\n        } catch (Exception e) {\n            this.logger.error(e.getMessage(), e);\n        }\n\n        if (responseResult != null) {\n            return responseResult;\n        }\n\n        try {\n            return new TextBuilder().build(\"感谢关注\", wxMessage, weixinService);\n        } catch (Exception e) {\n            this.logger.error(e.getMessage(), e);\n        }\n\n        return null;\n    }\n\n    /**\n     * 处理特殊请求，比如如果是扫码进来的，可以做相应处理\n     */\n    private WxMpXmlOutMessage handleSpecial(WxMpService weixinService, WxMpXmlMessage wxMessage)\n            throws Exception {\n        return wxMsgService.scan(weixinService, wxMessage);\n    }\n\n}\n```\n\n### 执行过程\n\n#### 1、获取登录二维码\n\n```java\npublic void handleLoginReq(Channel channel) {\n  // 生成登录随机码\n  Integer code = generateLoginCode(channel);\n  // 微信生成带参二维码\n  WxMpQrCodeTicket wxMpQrCodeTicket = null;\n  try {\n      wxMpQrCodeTicket = wxMpService.getQrcodeService().qrCodeCreateTmpTicket(code, (int) DURATION.getSeconds());\n  } catch (WxErrorException e) {\n      e.printStackTrace();\n  }\n  // 把二维码推送前端\n  sendMsg(channel, WebSocketAdapter.buildResp(wxMpQrCodeTicket));\n}\n```\n\n这里我是对二维码做了过期策略，`wxMpQrCodeTicket.getUrl()`就是带参二维码的地址，通过草料二维码生成器便能生成一个二维码\n\n#### 2、公众号返回登录授权\n\n在`ScanHandler`类的`handle`方法中写入，专门处理扫码登录事件\n\n```java\nString openid = wxMpXmlMessage.getFromUser();\nInteger code = getEventKey(wxMpXmlMessage);\nif (ObjectUtil.isNull(code)){\n    return null;\n}\n\n// 保存用户信息\nUser user = userDao.getByOpenId(openid);\nboolean registered = Objects.nonNull(user);\nboolean authorized = registered && StrUtil.isNotBlank(user.getName());\nif (registered && authorized){\n\t// 用户已经注册了，直接返回用户+token信息\n    webSocketService.scanLoginSuccess(code, user.getId());\n    return null;\n}\nif (!registered){\n    // 未写入数据库\n    User insert = UserAdapter.buildUserSave(openid);\n    userService.register(insert);\n}\nWAIT_AUTHORIZE_MAP.put(openid, code);\n// 通知前端正在等待认证\nwebSocketService.waitAuthorize(code);\n// 拼接URL，获取认证地址\nString authorizeUrl = String.format(URL, wxMpService.getWxMpConfigStorage().getAppId(), URLDecoder.decode(callback + \"wx/portal/public/callBack\"));\nreturn TextBuilder.build(\"请点击登录：<a href=\\\"\" + authorizeUrl + \"\\\">登录</a>\", wxMpXmlMessage, wxMpService);\n```\n\n当用户扫码并关注成功后，会自动弹出消息\n\n> 请点击登录：[登录]()\n\n用户点击登录后，会跳转到`\"https://open.weixin.qq.com/connect/oauth2/authorize?appid=%s&redirect_uri=%s&response_type=code&scope=snsapi_userinfo&state=STATE#wechat_redirect\"`微信授权页面，需要传入appid和回调接口地址，授权成功后将带着code参数访问给定的回调接口\n\n#### 3、微信调用给定的回调接口\n\n```java\n@GetMapping(\"/callBack\")\npublic RedirectView callBack(@RequestParam String code) {\n    try {\n        // 根据code获取token\n        WxOAuth2AccessToken accessToken = wxMpService.getOAuth2Service().getAccessToken(code);\n        // 根据token获取用户信息\n        WxOAuth2UserInfo userInfo = wxMpService.getOAuth2Service().getUserInfo(accessToken, \"zh_CN\");\n        wxMsgService.authorize(userInfo);\n    } catch (Exception e) {\n        log.error(\"callBack error\", e);\n    }\n    RedirectView redirectView = new RedirectView();\n    redirectView.setUrl(\"https://mp.weixin.qq.com/s/m1SRsBG96kLJW5mPe4AVGA\");\n    return redirectView;\n}\n```\n\n通过回调传来的code获取token，通过token来获取微信用户信息【只有昵称和头像】\n\n` wxMsgService.authorize(userInfo)`将用户不全的信息【用户头像，昵称】进行更新，并生成token进行返回\n\n就这样，前端就拿到了后端传来的token\n\n## 用户认证技术Token方案\n\nToken 的生成方式通常有以下几种：\n\n- **随机字符串**：可以使用一些随机数生成算法，如 **UUID**、**Snowflake(雪花算法)** 等来生成一个随机的字符串作为 Token。由于随机字符串本身就是随机分布的，因此具有很高的安全性。\n- **JWT**（JSON Web Token）：JWT 是一种基于 JSON 格式的开放标准（RFC 7519），用于在多方之间安全地传输信息。它将用户身份信息和权限等相关信息编码成一个 JSON 对象，并通过数字签名或者加密等方式进行验证和保护。JWT 除了可以用于 Token 登录外，还可以用于 API 认证、单点登录等场景。\n- **SessionID**。\n\n通常的Token在服务器端的实现方式有这几个：\n\n1. 用SessionID实现Token的功能\n2. 使用Json Web Token (JWT)\n3. 中心化存储Token\n\n下面分析一下各个存储方式的优缺点。\n\n### Cookie + Session 登录\n\nHTTP 是一种**无状态的协议**。\n\n无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求返回数据，但不会记录任何信息。\n\n为了解决 HTTP 无状态的问题，出现了 Cookie。\n\nCookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。\n\n![](https://s11.ax1x.com/2024/02/01/pFMooHx.png)\n\n**认证流程：**\n\n1. 前端输入账号密码，提交给后端\n2. 后端验证成功后，创建一个`Session`。`Session`是一种服务器端保存用户会话信息的机制，用于识别多次请求之间的逻辑关系。\n3. 后端将`Session ID`（通常是一个随机的字符串）返回给前端，并通过 `Cookie` 的方式将`Session ID`保存在浏览器中。这样就可以保证当用户再次发送请求时，后端可以通过该 `Session ID `来识别用户身份，并完成相关的操作。\n4. 在后续的请求中，浏览器会自动将保存的 `Cookie `信息发送到后端进行验证，如果` Session ID`有效，则返回相应的数据。如果 `Session ID `失效或者不存在，则需要重新登录获取新的 `Session ID`。\n5. 用户退出时，后端要删除对应的`Session`信息\n\n#### Cookie的设置原理\n\ncookie的简单之处，在于前端是无感知的，无需额外开发。这是http协议的约定，后端可以通过返回的报文，将cookie设置进网页，网页下次请求也会**自动携带**。`SetCookie` 命令\n\n![](https://s11.ax1x.com/2024/02/01/pFMoHUK.png)\n\n#### 缺点\n\n- 跨域问题：由于 Cookie 只能在同域名下共享，因此跨域访问时无法访问到对应的 Cookie 信息。这时，可能需要采用一些其他的跨域解决方案，如 JSONP、CORS 等。\n- 扩展性问题：由于 Session 信息存储在服务器端，当系统扩展到多台服务器时，需要采用一些集中式的 Session 管理方案，否则会出现 Session 不一致或者丢失等问题。\n- 一些移动设备和浏览器可能会禁用 Cookie 和 Session 机制，这会导致无法正常登录\n\n#### 总结\n\n- 给服务器的`sessionID`其实就相当于是一个`token`，只不过前端是无感知的设置进`cookie`的，这种方案 通常适用于后台。\n- 由于cookie的一些限制，这个token最好还是由前端**主动保存**比如保存到**localStorage**。登录的时候主动从**请求头**携带。\n- 由于现在都是集群部署，token的关系保存，最好又是**集中化管理**，或者**无状态化管理**\n\n### JWT实现token\n\n简单来说JWT就是通过可逆加密算法，生成一串包含用户、过期时间等关键信息的Token，每次请求服务器拿到这个Token解密出来就能得到用户信息，从而判断用户状态。\n\n![](https://s11.ax1x.com/2024/02/01/pFMob4O.png)\n\n#### 优点\n\n1. JWT的最大特点是**服务器不保存会话状态，**无论哪个服务器**解析**出来的Token信息都一样，而且不需要做任何查询操作，省掉了数据库/Redis的开销\n\n#### 缺点\n\n1. 正式因为JWT的特点，使用期间不可能取消令牌或更改令牌的权限，一旦JWT签发，在有效期内将会一直有效。\n2. 无法主动更新Token的有效性，只要用户传回来的Token没有过期，服务器就会认为这个用户操作是有效的。比如一下这个场景：某用户被封禁，此时该用户所有操作都应该被禁止，但是由于之前发给用户的JWT Token还没有过期，服务器仍然认为该用户操作合法。有一个解决方案是维护一张JWT黑名单表，只有没在表上的用户的JWT是有效的。**但是随之而来又有一个问题便是这个JWT黑名单表存在哪里。存在服务器，那么又要搞多服务器同步。存在关系数据库，那么查数据库效率又低。存在Redis，则又回到了Token丢失问题。** \n3. 其实解析JWT Token也是消耗服务器CPU的\n\n#### 总结\n\n1. 由于jwt是无状态的，它一发布开始，就意味着固定了过期时间。我们没法对他做**失效**，没法实现**续期**，它的好处也是显而易见的。不需要任何一个中心化的地方去保存它，管理它，查询它，比对它。\n\n### 双token方案\n\n双token是为了**解决jwt的续期**问题的。由于jwt一颁布，就意味着在指定时间内能够通行。\n\n1. 如果给的有**效期过长**，风险是比较大的，服务器失去了掌控力。在这期间如果想让用户失效，或者是有人盗取了token。都可以胡作非为好久。\n2. 如果给的有**效期过短**，用户经常需要重新登录，体验也很不好。\n3. 如果**中心化管理**用户状态，也就是每次解析jwt token之后，还需要去中心化比对能否通过。这样又违背了初衷。增加每次**认证的耗时**\n\n双token分为`access_token`和`refresh_token`。一般`access_token`的有效期可以设置为10分钟，`refresh_token`的有效期可以设置为7天。用户每次请求都用`access_token`，如果前端发现请求401，也就是过期了，就用`refresh_token`去重新申请一个`access_token`。继续请求。\n\n这里的关键在于，`refresh_token`申请`access_token`的时候，用户是无感知的，前后端的框架自动去更新这个新的`access_token`。\n\n还有一个点在申请`access_token`的时候，后端这时候会去校验用户的状态等问题，如果发现用户被禁用了，就申请不到token了。\n\n#### 总结\n\n双token是一个多方平衡的完美方案。它希望对用户的认证有所**掌控**，又不希望每次的检验会增加**耗时**。它不想给用户**过长的授权时间**，又不想用户因此**频繁登录**影响体验。因此变成了每隔一段`access_token`的过期时间，都会重新掌控局面，进行重新认证的复杂判断。\n\n### 中心管理token\n\nJWT碰巧有去中心化的特性，但为了能够控制它的**上下线**，**主动下线** ，**登录续期**等功能。我们依然可以对它进行中心化的管理。\n\n~~这也是抹茶当前采用的方式(参考的大佬文章)~~。依赖redis中心化管理uid-》token的信息。确保一个uid只有一个有效的token。用户登录后，每一次认证都会解析出uid，并请求redis进行token比对。并且异步判断有效期小于一天，进行续期。\n\n> 有人说为啥不用uuid做token呢，既然都是redis中心存储，用uuid还可以少一次解析。\n\n如果用uuid，前端每一次请求除了带上uuid还需要带上uid。\n\n因为单纯用uuid，黑客很有可能不断遍历uuid去撞库，碰巧撞到有关联的在线用户。而如果将uuid和uid一起比对，哪怕uuid碰巧撞到了登录的用户，还需要确保是相同的uid。这个概率会降低非常之多。\n\n用jwt的话，正好包含了uid，让前端传起来方便，所以就这么选择了。\n\n大家明白了其中的差别，到时候就懂得怎么去对线面试官的。其实我们用jwt，但是却没怎么用到它的特性。本质上这样的场景用个uuid就差不多了\n\n## 分布式锁\n\nRedisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。\n\n**依赖**\n\n```xml\n<dependency>\n      <groupId>org.redisson</groupId>\n      <artifactId>redisson-spring-boot-starter</artifactId>\n</dependency>\n```\n\n使用Redission实现分布式很简单\n\n比如就一个简单的发放物品\n\n```java\nRLock lock = redissonClient.getLock(\"acquireItem\" + idempotent);\nboolean b = lock.tryLock();\nAssertUtil.isTrue(b, \"请求太频繁了\");\ntry {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotent(idempotent);\n    if (Objects.nonNull(userBackpack)){\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpack(uid, itemId, idempotent);\n    userBackpackDao.save(insert);\n} finally {\n    lock.unlock();\n}\n```\n\n通过`redissonClient.getLock(key)`获取锁对象，用`lock.tryLock()`就能获取锁，用`lock.unlock()`就能释放锁\n\n现在对这个redisson的锁的部分进行封装，分别使用使用**编程式**的方法和**注解**方法进行改造，简化逻辑代码\n\n### 编程式\n\n新建一个`LockService`来实现分布式锁的公共部分\n\n```java\n@Service\npublic class LockService {\n\n    @Autowired\n    private RedissonClient redissonClient;\n\n    /**\n     *\n     * @param key\n     * @param waiteTime\n     * @param timeUnit\n     * @param supplier 只有出参没有入参, Function：既有出参又有入参\n     * @param <T>\n     * @return\n     */\n    @SneakyThrows\n    public <T> T executeWithLock(String key, int waiteTime, TimeUnit timeUnit, Supplier<T> supplier) {\n        RLock lock = redissonClient.getLock(key);\n        boolean b = lock.tryLock(waiteTime, timeUnit);\n        if (!b){\n            throw new BusinessException(CommonErrorEnum.LOCK_LIMIT);\n        }\n        try {\n            return supplier.get();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public <T> T executeWithLock(String key, Supplier<T> supplier) {\n        return executeWithLock(key, -1, TimeUnit.MILLISECONDS, supplier);\n    }\n\n    /**\n     *\n     * @param key\n     * @param runnable 既不传参，也不返参\n     * @param <T>\n     * @return\n     * @throws InterruptedException\n     */\n    public <T> T executeWithLock(String key, Runnable runnable) {\n        return executeWithLock(key, -1, TimeUnit.MILLISECONDS, () -> {\n            runnable.run();\n            return null;\n        });\n    }\n}\n```\n\n这里对`executeWithLock`方法进行了重载，能够适应多种加锁的场景【可以实现有返回值的，无返回值，既有出参又有入参的】\n\n说明一下`Supplier`：只有出参没有入参，`Function`：既有出参又有入参，`Runnable`：既不传参，也不返参\n\n`executeWithLock`方法实现了分布式的公共部分，具体的代码逻辑由`supplier.get()`实现，也就是通过参数传入，需要我们自己来写\n\n**编程式的修改代码如下**\n\n```java\nlockService.executeWithLock(\"acquireItem\" + idempotent, () -> {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotent(idempotent);\n    if (Objects.nonNull(userBackpack)){\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpack(uid, itemId, idempotent);\n    userBackpackDao.save(insert);\n});\n```\n\n比原先相比代码量减少了，可复用性提高了\n\n### 注解\n\n新建一个分布式注解`RedissonLock`\n\n```java\n@Retention(RetentionPolicy.RUNTIME) // 运行时生效\n@Target(ElementType.METHOD) // 作用在方法上\npublic @interface RedissonLock {\n\n    /**\n     * key的前缀\n     * @return\n     */\n    String prefixKey() default \"\";\n\n    /**\n     * EL表达式\n     * @return\n     */\n    String key();\n\n    /**\n     * 等待锁时间，默认不等待\n     * @return\n     */\n    int waitTime() default -1;\n\n    /**\n     * 时间单位，默认毫秒\n     * @return\n     */\n    TimeUnit timeUnit() default TimeUnit.MILLISECONDS;\n}\n```\n\n对这个注解进行切面\n\n```java\n@Component\n@Aspect\n@Order(0) // 确保在事务注解之前先执行，分布式在事务外\npublic class RedissonLockAspect {\n\n    @Autowired\n    private LockService lockService;\n\n    @Around(\"@annotation(redissonLock)\")\n    public Object around(ProceedingJoinPoint joinPoint, RedissonLock redissonLock) {\n        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n        String prefix = StrUtil.isBlank(redissonLock.prefixKey()) ? SpElUtils.getMethodKey(method) : redissonLock.prefixKey();\n        String key = SpElUtils.parseSpEl(method, joinPoint.getArgs(), redissonLock.key());\n        return lockService.executeWithLock(prefix + \":\" + key, redissonLock.waitTime(), redissonLock.timeUnit(), joinPoint::proceed);\n    }\n}\n```\n\nprefix为前缀，若没有给定，就需要通过`method.getDeclaringClass() + \"#\" + method.getName()`为默认的前缀\n\nkey为关键字，需要通过给定的**EL表达式**来进行匹配【会将给定的key和方法的参数名称进行匹配，若一致就写入`EvaluationContext（类似于map，键为方法参数名称，值为方法参数的值）`中】，用`parser.parseExpression`解析EL表达式，返回解析结果\n\n具体的匹配代码如下\n\nSpElUtils：EL表达式工具\n\n```java\npublic class SpElUtils {\n    private static final ExpressionParser parser = new SpelExpressionParser();\n    private static final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n    public static String parseSpEl(Method method, Object[] args, String spEl) {\n        String[] params = Optional.ofNullable(parameterNameDiscoverer.getParameterNames(method)).orElse(new String[]{});//解析参数名\n        EvaluationContext context = new StandardEvaluationContext();//el解析需要的上下文对象\n        for (int i = 0; i < params.length; i++) {\n            context.setVariable(params[i], args[i]);//所有参数都作为原材料扔进去\n        }\n        Expression expression = parser.parseExpression(spEl);\n        return expression.getValue(context, String.class);\n    }\n\n    public static String getMethodKey(Method method) {\n        return method.getDeclaringClass() + \"#\" + method.getName();\n    }\n}\n```\n\n注解切面的最后就是将解析出来的key，waitTime，timeUnit，joinPoint::proceed(自己写的逻辑)当作参数传入`lockService.executeWithLock()`自己写的编程式方法中\n\n**使用注解方法修改的代码如下**\n\n```java\n@Override\npublic void acquireItem(Long uid, Long itemId, IdempotentEnum idempotentEnum, String businessId) {\n    // 幂等号\n    String idempotent = getIdempotent(uid, itemId, businessId);\n\n    // 分布式注解方法\n    userBackpackService.doAcquire(uid, itemId, idempotent);\n}\n\n@Transactional\n@RedissonLock(key = \"#idempotent\", waitTime = 5000)\npublic void doAcquire(Long uid, Long itemId, String idempotent) {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotent(idempotent);\n    if (Objects.nonNull(userBackpack)) {\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpack(uid, itemId, idempotent);\n    userBackpackDao.save(insert);\n}\n```\n\n## IP归属地\n\n### 具体流程\n\nIP归属地是社交网站常用的功能，实现起来非常简单\n\n大致步骤：hutool工具类解析出ip地址 -> 通过淘宝的接口获取归属地 -> 更新数据库\n\n本项目是在**登录之后**，**带token请求http**，**带token连接ws**，这几处进行ip解析\n\n### 核心代码\n\n```java\nprivate void loginSuccess(Channel channel, User user, String token) {\n    // 保存用户channel和uid对应关系\n    WSChannelExtraDTO wsChannelExtraDTO = ONLINE_WS_MAP.get(channel);\n    wsChannelExtraDTO.setUid(user.getId());\n    // 给前端推送消息\n    sendMsg(channel, WebSocketAdapter.buildResp(user, token));\n    // 用户上线事件\n    user.setLastOptTime(LocalDateTime.now());\n    user.refreshIp(NettyUtil.getAttr(channel, NettyUtil.IP));\n    applicationEventPublisher.publishEvent(new UserOnlineEvent(this, user));\n}\n```\n\nUser实体\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = false)\n@TableName(value = \"user\", autoResultMap = true)\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 用户id\n     */\n      @TableId(value = \"id\", type = IdType.AUTO)\n    private Long id;\n\n    /**\n     * 用户昵称\n     */\n    @TableField(\"name\")\n    private String name;\n\n    /**\n     * 用户头像\n     */\n    @TableField(\"avatar\")\n    private String avatar;\n\n    /**\n     * 性别 1为男性，2为女性\n     */\n    @TableField(\"sex\")\n    private Integer sex;\n\n    /**\n     * 微信openid用户标识\n     */\n    @TableField(\"open_id\")\n    private String openId;\n\n    /**\n     * 在线状态 1在线 2离线\n     */\n    @TableField(\"active_status\")\n    private Integer activeStatus;\n\n    /**\n     * 最后上下线时间\n     */\n    @TableField(\"last_opt_time\")\n    private LocalDateTime lastOptTime;\n\n    /**\n     * ip信息\n     */\n    @TableField(value = \"ip_info\", typeHandler = JacksonTypeHandler.class)\n    private IpInfo ipInfo;\n\n    /**\n     * 佩戴的徽章id\n     */\n    @TableField(\"item_id\")\n    private Long itemId;\n\n    /**\n     * 使用状态 0.正常 1拉黑\n     */\n    @TableField(\"status\")\n    private Integer status;\n\n    /**\n     * 创建时间\n     */\n    @TableField(\"create_time\")\n    private LocalDateTime createTime;\n\n    /**\n     * 修改时间\n     */\n    @TableField(\"update_time\")\n    private LocalDateTime updateTime;\n\n\n    public void refreshIp(String attr) {\n        if (ipInfo == null){\n            ipInfo = new IpInfo();\n        }\n        ipInfo.refreshIp(attr);\n    }\n}\n```\n\nIpInfo实体\n\n```java\n@Data\npublic class IpInfo implements Serializable {\n\n    // 注册的ip\n    private String createIp;\n\n    // 注册时ip的详情\n    private IpDetail ipDetail;\n\n    // 更新的ip\n    private String updateIp;\n\n    // 更新时的ip详情\n    private IpDetail updateIpDetail;\n\n    public void refreshIp(String ip) {\n        if (StrUtil.isBlank(ip)){\n            return;\n        }\n        if (StrUtil.isBlank(createIp)){\n            createIp = ip;\n        }\n        updateIp = ip;\n    }\n\n    public String needRefreshIp() {\n        boolean needRefresh = Optional.ofNullable(updateIpDetail)\n                .map(IpDetail::getIp)\n                .filter(item -> Objects.equals(updateIp, item))\n                .isPresent(); // 判断结果是否是null\n\n        return needRefresh ? null : updateIp;\n    }\n\n    public void refreshIpDetail(IpDetail ipDetail) {\n        if (Objects.equals(ipDetail.getIp(), createIp)){\n            this.ipDetail = ipDetail;\n        }\n        if (Objects.equals(ipDetail.getIp(), updateIp)){\n            this.updateIpDetail = ipDetail;\n        }\n\n    }\n}\n```\n\n`refreshIp`是对当前登录的ip进行刷新，有个关键点就是先对注册ip进行判断，注册的ip无就需要对注册的ip进行赋值，其次在是更新的ip\n\n在用户登录成功后，通过` applicationEventPublisher.publishEvent(new UserOnlineEvent(this, user));`发送异步消息SpringEvent，通过一个事件监听来接受\n\n```java\n@Component\npublic class UserOnlineListener {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private IpService ipService;\n\n    @Async // 异步执行\n    @EventListener(classes = UserOnlineEvent.class)\n    public void userOnline(UserOnlineEvent event){\n        User user = event.getUser();\n        // 更新用户信息【Ip，是否登录等】\n        User update = new User();\n        update.setId(user.getId());\n        update.setLastOptTime(user.getLastOptTime());\n        update.setIpInfo(user.getIpInfo());\n        update.setActiveStatus(UserActiveStatusEnum.ONLINE.getType());\n        userDao.updateById(update);\n        // 用户IP解析\n        ipService.refreshDetailAsync(user.getId());\n\n    }\n}\n```\n\n这里是对用户的信息做了更新【最后一次登录事件，登录状态，IP信息】，用`ipService.refreshDetailAsync(user.getId())`实现对IP的异步刷新解析\n\n```java\n@Service\n@Slf4j\npublic class IpServiceImpl implements IpService {\n\n    private static ExecutorService executor = new ThreadPoolExecutor(1, 1,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(500), new NamedThreadFactory(\"refresh-ipDetail\", false));\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void refreshDetailAsync(Long id) {\n        executor.execute(() -> {\n            User user = userDao.getById(id);\n            IpInfo ipInfo = user.getIpInfo();\n            if (Objects.isNull(ipInfo)){\n                return;\n            }\n            // 判断是否需要刷新ip详情\n            String ip = ipInfo.needRefreshIp();\n            if (StrUtil.isBlank(ip)){\n                // 更新ip和更新ip一致无需刷新\n                return;\n            }\n\n            // 获取ip详情\n            IpDetail ipDetail = tryGetIpDetailOrNull(ip);\n            if (Objects.nonNull(ipDetail)){\n                // 刷新ipInfo的详情\n                ipInfo.refreshIpDetail(ipDetail);\n                // 更新ip详情\n                User update = new User();\n                update.setIpInfo(ipInfo);\n                update.setId(id);\n                userDao.updateById(update);\n            }\n        });\n    }\n\n    private IpDetail tryGetIpDetailOrNull(String ip) {\n        for (int i = 0; i < 3; i++){\n            IpDetail ipDetail = getIpDetailOrNull(ip);\n            if (Objects.nonNull(ipDetail)){\n                return ipDetail;\n            }\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e){\n                log.error(\"tryGetIpDetailOrNull InterruptedException\", e);\n            }\n        }\n        return null;\n    }\n\n    private IpDetail getIpDetailOrNull(String ip) {\n        String body = HttpUtil.get(\"https://ip.taobao.com/outGetIpInfo?ip=\" + ip + \"&accessKey=alibaba-inc\");\n        try {\n            ApiResult<IpDetail> result = JSONUtil.toBean(body, new TypeReference<ApiResult<IpDetail>>() {\n            }, false);\n            if (result.isSuccess()) {\n                return result.getData();\n            }\n        } catch (Exception e) {\n            return null;\n        }\n\n        return null;\n    }\n}\n```\n\n在实现方法`refreshDetailAsync`中，使用了线程池来进行异步排队处理，设置了最大容量为1个，并且设置了`refresh-ipDetail`线程前缀来便于排查出问题\n\n通过`needRefreshIp`判断是否需要刷新，若需要刷新就返回要刷新的ip地址，否则就返回null；是否刷新的判断依据是用用户当前数据库已经保存的IP解析的地址和当前登录的ip地址进行对比，若一致就返回null，否则就返回当前的登录的ip地址\n\n`tryGetIpDetailOrNull`方法是尝试获取ip解析信息，有3次机会，每次执行完有2秒的睡眠时间\n\n`refreshIpDetail`方法是刷新当前用户的ip解析信息，通过ip进行判断是注册ip还是更新ip，从而进行赋值\n\n## 黑名单功能\n\n### 具体流程\n\n实现黑名单功能就是将用户的ip和id放在黑名单数据库中，通过拦截器判断登陆的用户是否在名单中，从而决定是否拦截通过\n\n本项目中的黑名单功能需要用到权限，权限管理多用于b端项目，对于c端来说，权限没有到那么复杂的级别。因此权限设计只涉及到了用户身份\n\n![](https://cdn.nlark.com/yuque/0/2023/png/26318626/1686979132303-1934c4b2-943f-45d3-b892-a78a228e4821.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_109%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1280%2Climit_0)\n\n**流程**：登录的时候返回角色 -> 管理拉黑【判断权限】-> 推送给前端消息 -> 写入黑名单表， 修改状态【SpringEvent事件异步处理】 -> 拉黑用户拦截\n\n### **核心代码**\n\n判断用户是否具有某个权限，用来set巧妙处理\n\n```java\n@Service\npublic class RoleDao implements IRoleService {\n\n    @Autowired\n    private UserCache userCache;\n\n    @Override\n    public boolean isPower(Long uid, RoleEnum roleEnum) {\n        // 获取用户所有权限\n        Set<Long> roleSet = userCache.getRoleSet(uid);\n\n        return isAdmin(roleSet) || roleSet.contains(roleEnum.getId());\n    }\n\n    private boolean isAdmin(Set<Long> roleSet){\n        return roleSet.contains(RoleEnum.ADMIN.getId());\n    }\n}\n```\n\n将用户写入黑名单，并且通过SpringEvent发送异步事件处理黑名单事件\n\n```java\n @Override\n @Transactional(rollbackFor = Exception.class)\n public void black(BlackReq blackReq) {\n     // 将id写入黑名单\n     Long uid = blackReq.getUid();\n     Black black = new Black();\n     black.setType(BlackTypeEnum.UID.getId());\n     black.setTarget(uid.toString());\n     blackDao.save(black);\n    // 将ip写入黑名单\n    User user = userDao.getById(uid);\n    blackIp(Optional.ofNullable(user.getIpInfo().getCreateIp()).orElse(null));\n    blackIp(Optional.ofNullable(user.getIpInfo().getUpdateIp()).orElse(null));\n\n    applicationEventPublisher.publishEvent(new UserBlackEvent(this, user));\n}\n\n/**\n * 封禁IP\n *\n * @param ip\n */\nprivate void blackIp(String ip) {\n    if (StrUtil.isBlank(ip)) {\n        return;\n    }\n\n    try {\n        Black insert = new Black();\n        insert.setTarget(ip);\n        insert.setType(BlackTypeEnum.IP.getId());\n        blackDao.save(insert);\n    } catch (Exception e) {\n\n    }\n}\n```\n\n监听黑名单事件并作处理【推送前端消息，更新用户状态，清空黑名单缓存列表(拦截器处理的时候会用到)】\n\n```java\n@Component\npublic class UserBlackListener {\n\n    @Autowired\n    private WebSocketService webSocketService;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private UserCache userCache;\n\n    /**\n     * 推送前端消息\n     * @param event\n     */\n    @Async // 异步执行\n    @TransactionalEventListener(classes = UserBlackEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void sendMsg(UserBlackEvent event){\n        User user = event.getUser();\n        webSocketService.sendMsgToAll(WebSocketAdapter.buildBlack(user));\n    }\n\n    /**\n     * 更新用户状态\n     * @param event\n     */\n    @Async // 异步执行\n    @TransactionalEventListener(classes = UserBlackEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void changeActivity(UserBlackEvent event){\n        User user = event.getUser();\n        userDao.invalidUid(user.getId());\n    }\n\n    /**\n     * 清空黑名单缓存\n     * @param event\n     */\n    @Async // 异步执行\n    @TransactionalEventListener(classes = UserBlackEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void clearBlackList(UserBlackEvent event){\n        userCache.evictBlack();\n    }\n}\n```\n\n推送给前端所有用户这里用到了线程池，加快处理效率\n\n```java\n@Autowired\nprivate ThreadPoolTaskExecutor threadPoolTaskExecutor;\n\n@Override\npublic void sendMsgToAll(WSBaseResp<?> resp) {\n    ONLINE_WS_MAP.forEach(((channel, wsChannelExtraDTO) -> {\n        // 使用线程池，加快发送速度\n        threadPoolTaskExecutor.execute(() -> {\n            sendMsg(channel, resp);\n        });\n    }));\n}\n```\n\n## 游标翻页\n\n游标翻页更适用于一页一页跳转的场景，而对于跳页反转（例如第一页跳到第五页就不适用）\n\n本项目为聊天项目，适合适用游标翻页\n\n### 深翻页问题\n\n普通翻页前端一般会有个分页条。能够指定一页的**条数**，以及任意选择查看**第几页**。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685187350715-ec688988-ee5a-426e-88ea-dbb85f6aac22.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n对应的参数就是`pageNo`和`pageSize`\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685187427310-3e189d14-a215-4dbf-b86d-5badf5bd5a12.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n假设前端想要查看第11页的内容，传的值`pageNo`=11，`pageSize`=10\n\n其中`100`代表需要跳过的条数，`10`代表跳过指定条数后，往后需要再取的条数。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685188112380-ab4f8dec-f339-451b-87eb-2ae6ae1bfbe1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n对应图片就是这样的一个效果，需要在数据库的位置先读出100条，然后**丢弃**。丢弃完100条后，再继续取10条**选用**。\n\n如果我们翻页到了很深的地方，比如读到了第1000页，对应的sql语句就是`select * from table limit 10000,10`\n\n需要先查询10000条进行丢弃，再取那么个10条选用。这个效率也太低了，\n\n>  我们经常需要定时任务全量去跑一张表的数据，普通翻页去跑的话，到后面数据量大的时候，就会越跑越慢，这就是深翻页带来的问题。\n\n**解决办法**\n\n目前的问题在于每次翻页都需要花时间扫描一些不需要的记录，然后丢弃。那么是不是可以优化这个步骤呢？\n\n以后不论第几页，我们都不需要跳过一些值。直接取`limit 0,10`。这样语句变成了`select * from table limit 0,10`\n\n取到的是1-10这些记录，取不到我们想要的101-110，没关系，再加一个条件`select * from table where id>100 order by id limit 0,10`\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685188635346-68f634f3-3276-4f87-8788-4691ec990d83.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n只要id这个字段有索引，就能直接定位到101这个字段，然后去10条记录。以后无论翻页到多大，通过索引直接定位到读取的位置，效率基本是一样的。这个`id>100`就是我们的游标，这就是**游标翻页。**\n\n### 游标介绍\n\n游标翻页可以完美的解决深翻页问题，依赖的就是我们的游标，即`cursor`。针对mysql的游标翻页，我们需要通过`cursor`快速定位到指定记录，意味着游标必须添加索引。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685189222316-cf64fcf1-da85-46f0-b6b0-4088cd66b89e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n前端之前传的`pageNo`字段改成了`cursor`字段。`cursor`是上一次查询结果的位置，作为下一次查询的游标，由后端返回\n\n我们来模拟一次前后端的翻页交互\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1685189899438-884c817d-0ee5-4b7d-a540-6be3bb135975.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n随着翻页的持续，游标不断往翻页的方向推进。\n\n**所以游标翻页不适合跳页，只能不断的往下翻。更适合C端的列表场景**\n\n### 总结\n\n游标翻页的`优点`：\n\n1.解决深翻页问题\n\n2.解决频繁变动的列表翻页问题。\n\n`缺点`：\n\n1.无法跳页，只能不断往下翻\n\n游标翻页更适合c端场景，用户只能不断下滑翻页。\n\n普通翻页更适合B端场景。用户能看见总页数，能随意跳页\n\n## 前后端资源懒加载\n\n### 选用原因\n\n#### 带宽占用\n\n对于项目中的个别请求，有时候会有大量冗余和重复的消息。特别是用户的`头像`，`名称`，`佩戴徽章`，这些东西，基本都是重复的，但是我们每一次的消息推送，成员上下线，都需要携带。\n\n对于这些数据，其实我们只想知道消息的拥有者是谁，也就是uid。其他的头像，徽章，这些我们之前都有，但是他们却占据了消息体的大部分内容，有效载荷太少。\n\n在压测的时候发现了很多时候我们的**瓶颈就在带宽**上。而带宽都被头像的url给占用了。\n\n#### 代码复杂度\n\n如果每次因为一个简单的消息推送，就要去写一套复杂的代码，去加载用户的名称，以及徽章相关的信息。都会增大后端代码的复杂度。\n\n每次组装vo数据，都得去查出用户的关联信息，进行组装。哪怕是可以复用这段代码，但是相应的性能损耗，也是不可避免的。\n\n### 解决办法\n\n#### 图片路径协议优化\n\n前后端可以将用户头像遵循一种固定的路径协议，比如`https://img.mallchat.cn/avatar/{uid}.png`;\n\n这样只给前端uid，他自己就能组装出用户头像了\n\n#### 懒加载时间点\n\n前端在什么场景下会请求后端进行信息懒加载，每次请求后端，需要更新自己库里的懒加载时间`lastModifyTime`\n\n- 没数据加载\n- 数据过期加载（校验）：`lastModifyTime`小于数据库存的`lastModifyTime`\n- 主动加载（校验）：例如用户主动点击头像查询信息\n\n### 总结\n\n了解到了项目的**瓶颈**，大多是来源带宽不足。为了**节省带宽**，同时简化后端的逻辑，我们设计了一套**前后端资源懒加载的交互框架**。他有三个懒加载的**时间点**，同时保证了**及时性**，以及**最终一致性**。这个框架的核心就是**lastModifyTime**字段的定义。有了它，只要没有变动，后端都可以不返回用户信息，又能节省一大部分带宽。并且为了不需要展示的字段不返回null。我们用了一个json的注解，又节省了一小部分带宽。\n\n## 批量缓存框架\n\n缓存通常有两种使用方式，一种是Cache-Aside，一种是cache-through。也就是旁路缓存和缓存即数据源。\n\n一般一种用于读，另一种用于读写。\n\n### 盘路缓存\n\n我们通常用的都是旁路缓存模式\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1696084655149-bf1c5c2b-3626-45b2-8b43-0d9268f5a6bc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\nGET缓存获取不到，就LOAD加载数据库，再将数据库写回redis缓存。\n\n盘路缓存也有很好用的框架，比如spring-cache。只需要写load逻辑。加上个注解，就能实现盘路缓存的效果。\n\n**缺点**：在极端情况下。我需要获取一批用户的信息，碰巧所有用户的缓存都失效了，都需全部重新加载。那么这样一个本来性能很高的循环，就等同于全部查了数据库，缓存一点儿作用都没了。\n\n### 批量缓存查询\n\n对于这种批量查询缓存的需求，传统的旁路缓存框架无法达到我们的需求。我们需要让他能够批量的get or load。\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1696085632392-3b47a5e4-9700-4702-9ede-bef81682e82e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n类似这张图，批量的get。发现没有的数据，再批量的load一次，这样和redis以及数据库的交互都只会有一次。\n\n**具体代码**\n\n```java\n/**\n * 获取用户信息，盘路缓存模式\n */\npublic Map<Long, User> getUserInfoBatch(Set<Long> uids) {\n    //批量组装key\n    List<String> keys = uids.stream().map(a -> RedisKey.getKey(RedisKey.USER_INFO_STRING, a)).collect(Collectors.toList());\n    //批量get\n    List<User> mget = RedisUtils.mget(keys, User.class);\n    Map<Long, User> map = mget.stream().filter(Objects::nonNull).collect(Collectors.toMap(User::getId, Function.identity()));\n    //发现差集——还需要load更新的uid\n    List<Long> needLoadUidList = uids.stream().filter(a -> !map.containsKey(a)).collect(Collectors.toList());\n    if (CollUtil.isNotEmpty(needLoadUidList)) {\n        //批量load\n        List<User> needLoadUserList = userDao.listByIds(needLoadUidList);\n        Map<String, User> redisMap = needLoadUserList.stream().collect(Collectors.toMap(a -> RedisKey.getKey(RedisKey.USER_INFO_STRING, a.getId()), Function.identity()));\n        RedisUtils.mset(redisMap, 5 * 60);\n        //加载回redis\n        map.putAll(needLoadUserList.stream().collect(Collectors.toMap(User::getId, Function.identity())));\n    }\n    return map;\n}\n```\n\n我们在很多处都要用到这个接口，所以就需要对这个批量查询缓存进行封装\n\n这时候又要轮到我们的常规抽象环节了\n\n![img](https://cdn.nlark.com/yuque/0/2023/png/26318626/1696085827579-fa03f689-bdb1-476e-b53f-a291b3314660.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_TWFsbENoYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n黄色代表可复用的流程，红色代表个性化的代码。\n\n### 批量缓存框架\n\n先创建批量缓存框架的接口\n\n接口\n\n```java\npublic interface BatchCache<IN, OUT> {\n    /**\n     * 获取单个\n     */\n    OUT get(IN req);\n\n    /**\n     * 获取批量\n     */\n    Map<IN, OUT> getBatch(List<IN> req);\n\n    /**\n     * 修改删除单个\n     */\n    void delete(IN req);\n\n    /**\n     * 修改删除多个\n     */\n    void deleteBatch(List<IN> req);\n}\n```\n\n再通过抽象类，定义好骨架\n\n抽象类\n\n```java\npublic abstract class AbstractRedisStringCache<IN, OUT> implements BatchCache<IN, OUT> {\n\n    private Class<OUT> outClass;\n\n    protected AbstractRedisStringCache() {\n        ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass();\n        this.outClass = (Class<OUT>) genericSuperclass.getActualTypeArguments()[1];\n    }\n\n    protected abstract String getKey(IN req);\n\n    protected abstract Long getExpireSeconds();\n\n    protected abstract Map<IN, OUT> load(List<IN> req);\n\n    @Override\n    public OUT get(IN req) {\n        return getBatch(Collections.singletonList(req)).get(req);\n    }\n\n    @Override\n    public Map<IN, OUT> getBatch(List<IN> req) {\n        if (CollectionUtil.isEmpty(req)) {//防御性编程\n            return new HashMap<>();\n        }\n        //去重\n        req = req.stream().distinct().collect(Collectors.toList());\n        //组装key\n        List<String> keys = req.stream().map(this::getKey).collect(Collectors.toList());\n        //批量get\n        List<OUT> valueList = RedisUtils.mget(keys, outClass);\n        //差集计算\n        List<IN> loadReqs = new ArrayList<>();\n        for (int i = 0; i < valueList.size(); i++) {\n            if (Objects.isNull(valueList.get(i))) {\n                loadReqs.add(req.get(i));\n            }\n        }\n        Map<IN, OUT> load = new HashMap<>();\n        //不足的重新加载进redis\n        if (CollectionUtil.isNotEmpty(loadReqs)) {\n            //批量load\n            load = load(loadReqs);\n            Map<String, OUT> loadMap = load.entrySet().stream()\n                    .map(a -> Pair.of(getKey(a.getKey()), a.getValue()))\n                    .collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));\n            RedisUtils.mset(loadMap, getExpireSeconds());\n        }\n\n        //组装最后的结果\n        Map<IN, OUT> resultMap = new HashMap<>();\n        for (int i = 0; i < req.size(); i++) {\n            IN in = req.get(i);\n            OUT out = Optional.ofNullable(valueList.get(i))\n                    .orElse(load.get(in));\n            resultMap.put(in, out);\n        }\n        return resultMap;\n    }\n\n    @Override\n    public void delete(IN req) {\n        deleteBatch(Collections.singletonList(req));\n    }\n\n    @Override\n    public void deleteBatch(List<IN> req) {\n        List<String> keys = req.stream().map(this::getKey).collect(Collectors.toList());\n        RedisUtils.del(keys);\n    }\n}\n```\n\n这时候你就会发现，写一个批量的旁路缓存有多简单。\n\n具体实现\n\n```java\n@Component\npublic class UserInfoCache extends AbstractRedisStringCache<Long, User> {\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    protected String getKey(Long uid) {\n        return RedisKey.getKey(RedisKey.USER_INFO_STRING, uid);\n    }\n\n    @Override\n    protected Long getExpireSeconds() {\n        return 5 * 60L;\n    }\n\n    @Override\n    protected Map<Long, User> load(List<Long> uidList) {\n        List<User> needLoadUserList = userDao.listByIds(uidList);\n        return needLoadUserList.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n    }\n}\n```\n","title":" MallChat项目笔记\n","category":[" SpringBoot","实战项目\n"],"date":" 2024-02-08\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 微信扫码登录\n\n 准备\n\n 工具\n\n 误区：微信扫码登录每个人都可以，不是只有认证号才行。测试阶段可以用测试接口来进行测试，只不过项目部署后才需要认证使用\n\n 注意：微信回调接口需要开启内网穿透\n\n 微信公众号的开发者账号：点击此处进行注册https://mp.weixin.qq.com/\n 内网穿透工具：点击此处注册https://natapp.cn/\n\n 引入依赖\n\nxml\n<dependency\n    <groupIdcom.github.binarywang</groupId\n    <artifactIdweixinjavamp</artifactId\n    <version4.4.0</version\n</dependency\n\n\n 配置文件\n\n这里配置文件参考Binary Wang的代码\n\nyml\nwx:\n  mp:\n    callback: ${mallchat.wx.callback}  回调地址\n    configs:\n       appId: ${mallchat.wx.appId}  第一个公众号的appid\n        secret: ${mallchat.wx.secret}  公众号的appsecret\n        token: ${mallchat.wx.token}  接口配置里的Token值\n        aesKey: ${mallchat.wx.aesKey}  接口配置里的EncodingAESKey值\n\n\nWxMpProperties.java\n\njava\n@Data\n@ConfigurationPropertiesprefix = \"wx.mp\"\npublic class WxMpProperties {\n    /\n      是否使用redis存储access token\n     /\n    private boolean useRedis;\n\n    /\n      redis 配置\n     /\n    private RedisConfig redisConfig;\n\n    @Data\n    public static class RedisConfig {\n        /\n          redis服务器 主机地址\n         /\n        private String host;\n\n        /\n          redis服务器 端口号\n         /\n        private Integer port;\n\n        /\n          redis服务器 密码\n         /\n        private String password;\n\n        /\n          redis 服务连接超时时间\n         /\n        private Integer timeout;\n    }\n\n    /\n      多个公众号配置信息\n     /\n    private List<MpConfig configs;\n\n    @Data\n    public static class MpConfig {\n        /\n          设置微信公众号的appid\n         /\n        private String appId;\n\n        /\n          设置微信公众号的app secret\n         /\n        private String secret;\n\n        /\n          设置微信公众号的token\n         /\n        private String token;\n\n        /\n          设置微信公众号的EncodingAESKey\n         /\n        private String aesKey;\n    }\n\n    @Override\n    public String toString {\n        return JSONUtil.toJsonStrthis;\n    }\n}\n\n\nWxMpConfiguration.java\n\njava\n@AllArgsConstructor\n@Configuration\n@EnableConfigurationPropertiesWxMpProperties.class\npublic class WxMpConfiguration {\n    private final LogHandler logHandler;\n    private final MsgHandler msgHandler;\n    private final SubscribeHandler subscribeHandler;\n    private final ScanHandler scanHandler;\n    private final WxMpProperties properties;\n\n    @Bean\n    public WxMpService wxMpService {\n        // 代码里 getConfigs处报错的同学，请注意仔细阅读项目说明，你的IDE需要引入lombok插件！！！！\n        final List<WxMpProperties.MpConfig configs = this.properties.getConfigs;\n        if configs == null {\n            throw new RuntimeException\"大哥，拜托先看下项目首页的说明（readme文件），添加下相关配置，注意别配错了！\";\n        }\n\n        WxMpService service = new WxMpServiceImpl;\n        service.setMultiConfigStoragesconfigs\n                .stream.mapa  {\n                    WxMpDefaultConfigImpl configStorage;\n                    configStorage = new WxMpDefaultConfigImpl;\n\n                    configStorage.setAppIda.getAppId;\n                    configStorage.setSecreta.getSecret;\n                    configStorage.setTokena.getToken;\n                    configStorage.setAesKeya.getAesKey;\n                    return configStorage;\n                }.collectCollectors.toMapWxMpDefaultConfigImpl::getAppId, a  a, o, n  o;\n        return service;\n    }\n\n    @Bean\n    public WxMpMessageRouter messageRouterWxMpService wxMpService {\n        final WxMpMessageRouter newRouter = new WxMpMessageRouterwxMpService;\n\n        // 记录所有事件的日志 （异步执行）\n        newRouter.rule.handlerthis.logHandler.next;\n\n        // 关注事件\n        newRouter.rule.asyncfalse.msgTypeEVENT.eventSUBSCRIBE.handlerthis.subscribeHandler.end;\n\n        // 扫码事件\n        newRouter.rule.asyncfalse.msgTypeEVENT.eventEventType.SCAN.handlerthis.scanHandler.end;\n\n        // 默认\n        newRouter.rule.asyncfalse.handlerthis.msgHandler.end;\n\n        return newRouter;\n    }\n\n}\n\n\n 配置消息处理器\n\nAbstractHandler.java\n\njava\npublic abstract class AbstractHandler implements WxMpMessageHandler {\n    protected Logger logger = LoggerFactory.getLoggergetClass;\n}\n\n\nLogHandler.java（日志）\n\njava\n@Component\n@Slf4j\npublic class LogHandler extends AbstractHandler {\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMessage,\n                                    Map<String, Object context, WxMpService wxMpService,\n                                    WxSessionManager sessionManager {\n        log.info\"\\n接收到请求消息，内容：{}\", JSONUtil.toJsonStrwxMessage;\n        return null;\n    }\n}\n\n\nMsgHandler.java\n\njava\n@Component\npublic class MsgHandler extends AbstractHandler {\n\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMessage,\n                                    Map<String, Object context, WxMpService weixinService,\n                                    WxSessionManager sessionManager {\n\n        return null;\n    }\n}\n\n\nScanHandler.java\n\njava\n@Component\npublic class ScanHandler extends AbstractHandler {\n\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /\n      处理用户扫码【不是第一次】\n     /\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMpXmlMessage, Map<String, Object map,\n                                    WxMpService wxMpService, WxSessionManager wxSessionManager throws WxErrorException {\n        // 扫码事件处理\n        return wxMsgService.scanwxMpService, wxMpXmlMessage;\n    }\n}\n\n\nSubscribeHandler.java\n\njava\n@Component\npublic class SubscribeHandler extends AbstractHandler {\n    @Autowired\n    private WxMsgService wxMsgService;\n\n    /\n      扫描登录二维码后第一次进入需要关注公众号\n      @param wxMessage\n      @param context\n      @param weixinService\n      @param sessionManager\n      @return\n      @throws WxErrorException\n     /\n    @Override\n    public WxMpXmlOutMessage handleWxMpXmlMessage wxMessage,\n                                    Map<String, Object context, WxMpService weixinService,\n                                    WxSessionManager sessionManager throws WxErrorException {\n\n        this.logger.info\"新关注用户 OPENID: \" + wxMessage.getFromUser;\n\n        WxMpXmlOutMessage responseResult = null;\n        try {\n            responseResult = this.handleSpecialweixinService, wxMessage;\n        } catch Exception e {\n            this.logger.errore.getMessage, e;\n        }\n\n        if responseResult = null {\n            return responseResult;\n        }\n\n        try {\n            return new TextBuilder.build\"感谢关注\", wxMessage, weixinService;\n        } catch Exception e {\n            this.logger.errore.getMessage, e;\n        }\n\n        return null;\n    }\n\n    /\n      处理特殊请求，比如如果是扫码进来的，可以做相应处理\n     /\n    private WxMpXmlOutMessage handleSpecialWxMpService weixinService, WxMpXmlMessage wxMessage\n            throws Exception {\n        return wxMsgService.scanweixinService, wxMessage;\n    }\n\n}\n\n\n 执行过程\n\n 1、获取登录二维码\n\njava\npublic void handleLoginReqChannel channel {\n  // 生成登录随机码\n  Integer code = generateLoginCodechannel;\n  // 微信生成带参二维码\n  WxMpQrCodeTicket wxMpQrCodeTicket = null;\n  try {\n      wxMpQrCodeTicket = wxMpService.getQrcodeService.qrCodeCreateTmpTicketcode, int DURATION.getSeconds;\n  } catch WxErrorException e {\n      e.printStackTrace;\n  }\n  // 把二维码推送前端\n  sendMsgchannel, WebSocketAdapter.buildRespwxMpQrCodeTicket;\n}\n\n\n这里我是对二维码做了过期策略，wxMpQrCodeTicket.getUrl就是带参二维码的地址，通过草料二维码生成器便能生成一个二维码\n\n 2、公众号返回登录授权\n\n在ScanHandler类的handle方法中写入，专门处理扫码登录事件\n\njava\nString openid = wxMpXmlMessage.getFromUser;\nInteger code = getEventKeywxMpXmlMessage;\nif ObjectUtil.isNullcode{\n    return null;\n}\n\n// 保存用户信息\nUser user = userDao.getByOpenIdopenid;\nboolean registered = Objects.nonNulluser;\nboolean authorized = registered && StrUtil.isNotBlankuser.getName;\nif registered && authorized{\n\t// 用户已经注册了，直接返回用户+token信息\n    webSocketService.scanLoginSuccesscode, user.getId;\n    return null;\n}\nif registered{\n    // 未写入数据库\n    User insert = UserAdapter.buildUserSaveopenid;\n    userService.registerinsert;\n}\nWAITAUTHORIZEMAP.putopenid, code;\n// 通知前端正在等待认证\nwebSocketService.waitAuthorizecode;\n// 拼接URL，获取认证地址\nString authorizeUrl = String.formatURL, wxMpService.getWxMpConfigStorage.getAppId, URLDecoder.decodecallback + \"wx/portal/public/callBack\";\nreturn TextBuilder.build\"请点击登录：<a href=\\\"\" + authorizeUrl + \"\\\"登录</a\", wxMpXmlMessage, wxMpService;\n\n\n当用户扫码并关注成功后，会自动弹出消息\n\n 请点击登录：登录\n\n用户点击登录后，会跳转到\"https://open.weixin.qq.com/connect/oauth2/authorize?appid=%s&redirecturi=%s&responsetype=code&scope=snsapiuserinfo&state=STATEwechatredirect\"微信授权页面，需要传入appid和回调接口地址，授权成功后将带着code参数访问给定的回调接口\n\n 3、微信调用给定的回调接口\n\njava\n@GetMapping\"/callBack\"\npublic RedirectView callBack@RequestParam String code {\n    try {\n        // 根据code获取token\n        WxOAuth2AccessToken accessToken = wxMpService.getOAuth2Service.getAccessTokencode;\n        // 根据token获取用户信息\n        WxOAuth2UserInfo userInfo = wxMpService.getOAuth2Service.getUserInfoaccessToken, \"zhCN\";\n        wxMsgService.authorizeuserInfo;\n    } catch Exception e {\n        log.error\"callBack error\", e;\n    }\n    RedirectView redirectView = new RedirectView;\n    redirectView.setUrl\"https://mp.weixin.qq.com/s/m1SRsBG96kLJW5mPe4AVGA\";\n    return redirectView;\n}\n\n\n通过回调传来的code获取token，通过token来获取微信用户信息【只有昵称和头像】\n\n wxMsgService.authorizeuserInfo将用户不全的信息【用户头像，昵称】进行更新，并生成token进行返回\n\n就这样，前端就拿到了后端传来的token\n\n 用户认证技术Token方案\n\nToken 的生成方式通常有以下几种：\n\n 随机字符串：可以使用一些随机数生成算法，如 UUID、Snowflake雪花算法 等来生成一个随机的字符串作为 Token。由于随机字符串本身就是随机分布的，因此具有很高的安全性。\n JWT（JSON Web Token）：JWT 是一种基于 JSON 格式的开放标准（RFC 7519），用于在多方之间安全地传输信息。它将用户身份信息和权限等相关信息编码成一个 JSON 对象，并通过数字签名或者加密等方式进行验证和保护。JWT 除了可以用于 Token 登录外，还可以用于 API 认证、单点登录等场景。\n SessionID。\n\n通常的Token在服务器端的实现方式有这几个：\n\n1. 用SessionID实现Token的功能\n2. 使用Json Web Token JWT\n3. 中心化存储Token\n\n下面分析一下各个存储方式的优缺点。\n\n Cookie + Session 登录\n\nHTTP 是一种无状态的协议。\n\n无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求返回数据，但不会记录任何信息。\n\n为了解决 HTTP 无状态的问题，出现了 Cookie。\n\nCookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。\n\nhttps://s11.ax1x.com/2024/02/01/pFMooHx.png\n\n认证流程：\n\n1. 前端输入账号密码，提交给后端\n2. 后端验证成功后，创建一个Session。Session是一种服务器端保存用户会话信息的机制，用于识别多次请求之间的逻辑关系。\n3. 后端将Session ID（通常是一个随机的字符串）返回给前端，并通过 Cookie 的方式将Session ID保存在浏览器中。这样就可以保证当用户再次发送请求时，后端可以通过该 Session ID 来识别用户身份，并完成相关的操作。\n4. 在后续的请求中，浏览器会自动将保存的 Cookie 信息发送到后端进行验证，如果 Session ID有效，则返回相应的数据。如果 Session ID 失效或者不存在，则需要重新登录获取新的 Session ID。\n5. 用户退出时，后端要删除对应的Session信息\n\n Cookie的设置原理\n\ncookie的简单之处，在于前端是无感知的，无需额外开发。这是http协议的约定，后端可以通过返回的报文，将cookie设置进网页，网页下次请求也会自动携带。SetCookie 命令\n\nhttps://s11.ax1x.com/2024/02/01/pFMoHUK.png\n\n 缺点\n\n 跨域问题：由于 Cookie 只能在同域名下共享，因此跨域访问时无法访问到对应的 Cookie 信息。这时，可能需要采用一些其他的跨域解决方案，如 JSONP、CORS 等。\n 扩展性问题：由于 Session 信息存储在服务器端，当系统扩展到多台服务器时，需要采用一些集中式的 Session 管理方案，否则会出现 Session 不一致或者丢失等问题。\n 一些移动设备和浏览器可能会禁用 Cookie 和 Session 机制，这会导致无法正常登录\n\n 总结\n\n 给服务器的sessionID其实就相当于是一个token，只不过前端是无感知的设置进cookie的，这种方案 通常适用于后台。\n 由于cookie的一些限制，这个token最好还是由前端主动保存比如保存到localStorage。登录的时候主动从请求头携带。\n 由于现在都是集群部署，token的关系保存，最好又是集中化管理，或者无状态化管理\n\n JWT实现token\n\n简单来说JWT就是通过可逆加密算法，生成一串包含用户、过期时间等关键信息的Token，每次请求服务器拿到这个Token解密出来就能得到用户信息，从而判断用户状态。\n\nhttps://s11.ax1x.com/2024/02/01/pFMob4O.png\n\n 优点\n\n1. JWT的最大特点是服务器不保存会话状态，无论哪个服务器解析出来的Token信息都一样，而且不需要做任何查询操作，省掉了数据库/Redis的开销\n\n 缺点\n\n1. 正式因为JWT的特点，使用期间不可能取消令牌或更改令牌的权限，一旦JWT签发，在有效期内将会一直有效。\n2. 无法主动更新Token的有效性，只要用户传回来的Token没有过期，服务器就会认为这个用户操作是有效的。比如一下这个场景：某用户被封禁，此时该用户所有操作都应该被禁止，但是由于之前发给用户的JWT Token还没有过期，服务器仍然认为该用户操作合法。有一个解决方案是维护一张JWT黑名单表，只有没在表上的用户的JWT是有效的。但是随之而来又有一个问题便是这个JWT黑名单表存在哪里。存在服务器，那么又要搞多服务器同步。存在关系数据库，那么查数据库效率又低。存在Redis，则又回到了Token丢失问题。 \n3. 其实解析JWT Token也是消耗服务器CPU的\n\n 总结\n\n1. 由于jwt是无状态的，它一发布开始，就意味着固定了过期时间。我们没法对他做失效，没法实现续期，它的好处也是显而易见的。不需要任何一个中心化的地方去保存它，管理它，查询它，比对它。\n\n 双token方案\n\n双token是为了解决jwt的续期问题的。由于jwt一颁布，就意味着在指定时间内能够通行。\n\n1. 如果给的有效期过长，风险是比较大的，服务器失去了掌控力。在这期间如果想让用户失效，或者是有人盗取了token。都可以胡作非为好久。\n2. 如果给的有效期过短，用户经常需要重新登录，体验也很不好。\n3. 如果中心化管理用户状态，也就是每次解析jwt token之后，还需要去中心化比对能否通过。这样又违背了初衷。增加每次认证的耗时\n\n双token分为accesstoken和refreshtoken。一般accesstoken的有效期可以设置为10分钟，refreshtoken的有效期可以设置为7天。用户每次请求都用accesstoken，如果前端发现请求401，也就是过期了，就用refreshtoken去重新申请一个accesstoken。继续请求。\n\n这里的关键在于，refreshtoken申请accesstoken的时候，用户是无感知的，前后端的框架自动去更新这个新的accesstoken。\n\n还有一个点在申请accesstoken的时候，后端这时候会去校验用户的状态等问题，如果发现用户被禁用了，就申请不到token了。\n\n 总结\n\n双token是一个多方平衡的完美方案。它希望对用户的认证有所掌控，又不希望每次的检验会增加耗时。它不想给用户过长的授权时间，又不想用户因此频繁登录影响体验。因此变成了每隔一段accesstoken的过期时间，都会重新掌控局面，进行重新认证的复杂判断。\n\n 中心管理token\n\nJWT碰巧有去中心化的特性，但为了能够控制它的上下线，主动下线 ，登录续期等功能。我们依然可以对它进行中心化的管理。\n\n这也是抹茶当前采用的方式参考的大佬文章。依赖redis中心化管理uid》token的信息。确保一个uid只有一个有效的token。用户登录后，每一次认证都会解析出uid，并请求redis进行token比对。并且异步判断有效期小于一天，进行续期。\n\n 有人说为啥不用uuid做token呢，既然都是redis中心存储，用uuid还可以少一次解析。\n\n如果用uuid，前端每一次请求除了带上uuid还需要带上uid。\n\n因为单纯用uuid，黑客很有可能不断遍历uuid去撞库，碰巧撞到有关联的在线用户。而如果将uuid和uid一起比对，哪怕uuid碰巧撞到了登录的用户，还需要确保是相同的uid。这个概率会降低非常之多。\n\n用jwt的话，正好包含了uid，让前端传起来方便，所以就这么选择了。\n\n大家明白了其中的差别，到时候就懂得怎么去对线面试官的。其实我们用jwt，但是却没怎么用到它的特性。本质上这样的场景用个uuid就差不多了\n\n 分布式锁\n\nRedisson是架设在Redis基础上的一个Java驻内存数据网格（InMemory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。\n\n依赖\n\nxml\n<dependency\n      <groupIdorg.redisson</groupId\n      <artifactIdredissonspringbootstarter</artifactId\n</dependency\n\n\n使用Redission实现分布式很简单\n\n比如就一个简单的发放物品\n\njava\nRLock lock = redissonClient.getLock\"acquireItem\" + idempotent;\nboolean b = lock.tryLock;\nAssertUtil.isTrueb, \"请求太频繁了\";\ntry {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotentidempotent;\n    if Objects.nonNulluserBackpack{\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpackuid, itemId, idempotent;\n    userBackpackDao.saveinsert;\n} finally {\n    lock.unlock;\n}\n\n\n通过redissonClient.getLockkey获取锁对象，用lock.tryLock就能获取锁，用lock.unlock就能释放锁\n\n现在对这个redisson的锁的部分进行封装，分别使用使用编程式的方法和注解方法进行改造，简化逻辑代码\n\n 编程式\n\n新建一个LockService来实现分布式锁的公共部分\n\njava\n@Service\npublic class LockService {\n\n    @Autowired\n    private RedissonClient redissonClient;\n\n    /\n     \n      @param key\n      @param waiteTime\n      @param timeUnit\n      @param supplier 只有出参没有入参, Function：既有出参又有入参\n      @param <T\n      @return\n     /\n    @SneakyThrows\n    public <T T executeWithLockString key, int waiteTime, TimeUnit timeUnit, Supplier<T supplier {\n        RLock lock = redissonClient.getLockkey;\n        boolean b = lock.tryLockwaiteTime, timeUnit;\n        if b{\n            throw new BusinessExceptionCommonErrorEnum.LOCKLIMIT;\n        }\n        try {\n            return supplier.get;\n        } finally {\n            lock.unlock;\n        }\n    }\n\n    public <T T executeWithLockString key, Supplier<T supplier {\n        return executeWithLockkey, 1, TimeUnit.MILLISECONDS, supplier;\n    }\n\n    /\n     \n      @param key\n      @param runnable 既不传参，也不返参\n      @param <T\n      @return\n      @throws InterruptedException\n     /\n    public <T T executeWithLockString key, Runnable runnable {\n        return executeWithLockkey, 1, TimeUnit.MILLISECONDS,   {\n            runnable.run;\n            return null;\n        };\n    }\n}\n\n\n这里对executeWithLock方法进行了重载，能够适应多种加锁的场景【可以实现有返回值的，无返回值，既有出参又有入参的】\n\n说明一下Supplier：只有出参没有入参，Function：既有出参又有入参，Runnable：既不传参，也不返参\n\nexecuteWithLock方法实现了分布式的公共部分，具体的代码逻辑由supplier.get实现，也就是通过参数传入，需要我们自己来写\n\n编程式的修改代码如下\n\njava\nlockService.executeWithLock\"acquireItem\" + idempotent,   {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotentidempotent;\n    if Objects.nonNulluserBackpack{\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpackuid, itemId, idempotent;\n    userBackpackDao.saveinsert;\n};\n\n\n比原先相比代码量减少了，可复用性提高了\n\n 注解\n\n新建一个分布式注解RedissonLock\n\njava\n@RetentionRetentionPolicy.RUNTIME // 运行时生效\n@TargetElementType.METHOD // 作用在方法上\npublic @interface RedissonLock {\n\n    /\n      key的前缀\n      @return\n     /\n    String prefixKey default \"\";\n\n    /\n      EL表达式\n      @return\n     /\n    String key;\n\n    /\n      等待锁时间，默认不等待\n      @return\n     /\n    int waitTime default 1;\n\n    /\n      时间单位，默认毫秒\n      @return\n     /\n    TimeUnit timeUnit default TimeUnit.MILLISECONDS;\n}\n\n\n对这个注解进行切面\n\njava\n@Component\n@Aspect\n@Order0 // 确保在事务注解之前先执行，分布式在事务外\npublic class RedissonLockAspect {\n\n    @Autowired\n    private LockService lockService;\n\n    @Around\"@annotationredissonLock\"\n    public Object aroundProceedingJoinPoint joinPoint, RedissonLock redissonLock {\n        Method method = MethodSignature joinPoint.getSignature.getMethod;\n        String prefix = StrUtil.isBlankredissonLock.prefixKey ? SpElUtils.getMethodKeymethod : redissonLock.prefixKey;\n        String key = SpElUtils.parseSpElmethod, joinPoint.getArgs, redissonLock.key;\n        return lockService.executeWithLockprefix + \":\" + key, redissonLock.waitTime, redissonLock.timeUnit, joinPoint::proceed;\n    }\n}\n\n\nprefix为前缀，若没有给定，就需要通过method.getDeclaringClass + \"\" + method.getName为默认的前缀\n\nkey为关键字，需要通过给定的EL表达式来进行匹配【会将给定的key和方法的参数名称进行匹配，若一致就写入EvaluationContext（类似于map，键为方法参数名称，值为方法参数的值）中】，用parser.parseExpression解析EL表达式，返回解析结果\n\n具体的匹配代码如下\n\nSpElUtils：EL表达式工具\n\njava\npublic class SpElUtils {\n    private static final ExpressionParser parser = new SpelExpressionParser;\n    private static final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer;\n\n    public static String parseSpElMethod method, Object args, String spEl {\n        String params = Optional.ofNullableparameterNameDiscoverer.getParameterNamesmethod.orElsenew String{};//解析参数名\n        EvaluationContext context = new StandardEvaluationContext;//el解析需要的上下文对象\n        for int i = 0; i < params.length; i++ {\n            context.setVariableparamsi, argsi;//所有参数都作为原材料扔进去\n        }\n        Expression expression = parser.parseExpressionspEl;\n        return expression.getValuecontext, String.class;\n    }\n\n    public static String getMethodKeyMethod method {\n        return method.getDeclaringClass + \"\" + method.getName;\n    }\n}\n\n\n注解切面的最后就是将解析出来的key，waitTime，timeUnit，joinPoint::proceed自己写的逻辑当作参数传入lockService.executeWithLock自己写的编程式方法中\n\n使用注解方法修改的代码如下\n\njava\n@Override\npublic void acquireItemLong uid, Long itemId, IdempotentEnum idempotentEnum, String businessId {\n    // 幂等号\n    String idempotent = getIdempotentuid, itemId, businessId;\n\n    // 分布式注解方法\n    userBackpackService.doAcquireuid, itemId, idempotent;\n}\n\n@Transactional\n@RedissonLockkey = \"idempotent\", waitTime = 5000\npublic void doAcquireLong uid, Long itemId, String idempotent {\n    // 是否已经获取了\n    UserBackpack userBackpack = userBackpackDao.getByIdempotentidempotent;\n    if Objects.nonNulluserBackpack {\n        return;\n    }\n    // 发放物品\n    UserBackpack insert = UserBackpackAdapter.buildUserBackpackuid, itemId, idempotent;\n    userBackpackDao.saveinsert;\n}\n\n\n IP归属地\n\n 具体流程\n\nIP归属地是社交网站常用的功能，实现起来非常简单\n\n大致步骤：hutool工具类解析出ip地址  通过淘宝的接口获取归属地  更新数据库\n\n本项目是在登录之后，带token请求http，带token连接ws，这几处进行ip解析\n\n 核心代码\n\njava\nprivate void loginSuccessChannel channel, User user, String token {\n    // 保存用户channel和uid对应关系\n    WSChannelExtraDTO wsChannelExtraDTO = ONLINEWSMAP.getchannel;\n    wsChannelExtraDTO.setUiduser.getId;\n    // 给前端推送消息\n    sendMsgchannel, WebSocketAdapter.buildRespuser, token;\n    // 用户上线事件\n    user.setLastOptTimeLocalDateTime.now;\n    user.refreshIpNettyUtil.getAttrchannel, NettyUtil.IP;\n    applicationEventPublisher.publishEventnew UserOnlineEventthis, user;\n}\n\n\nUser实体\n\njava\n@Data\n@EqualsAndHashCodecallSuper = false\n@TableNamevalue = \"user\", autoResultMap = true\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /\n      用户id\n     /\n      @TableIdvalue = \"id\", type = IdType.AUTO\n    private Long id;\n\n    /\n      用户昵称\n     /\n    @TableField\"name\"\n    private String name;\n\n    /\n      用户头像\n     /\n    @TableField\"avatar\"\n    private String avatar;\n\n    /\n      性别 1为男性，2为女性\n     /\n    @TableField\"sex\"\n    private Integer sex;\n\n    /\n      微信openid用户标识\n     /\n    @TableField\"openid\"\n    private String openId;\n\n    /\n      在线状态 1在线 2离线\n     /\n    @TableField\"activestatus\"\n    private Integer activeStatus;\n\n    /\n      最后上下线时间\n     /\n    @TableField\"lastopttime\"\n    private LocalDateTime lastOptTime;\n\n    /\n      ip信息\n     /\n    @TableFieldvalue = \"ipinfo\", typeHandler = JacksonTypeHandler.class\n    private IpInfo ipInfo;\n\n    /\n      佩戴的徽章id\n     /\n    @TableField\"itemid\"\n    private Long itemId;\n\n    /\n      使用状态 0.正常 1拉黑\n     /\n    @TableField\"status\"\n    private Integer status;\n\n    /\n      创建时间\n     /\n    @TableField\"createtime\"\n    private LocalDateTime createTime;\n\n    /\n      修改时间\n     /\n    @TableField\"updatetime\"\n    private LocalDateTime updateTime;\n\n\n    public void refreshIpString attr {\n        if ipInfo == null{\n            ipInfo = new IpInfo;\n        }\n        ipInfo.refreshIpattr;\n    }\n}\n\n\nIpInfo实体\n\njava\n@Data\npublic class IpInfo implements Serializable {\n\n    // 注册的ip\n    private String createIp;\n\n    // 注册时ip的详情\n    private IpDetail ipDetail;\n\n    // 更新的ip\n    private String updateIp;\n\n    // 更新时的ip详情\n    private IpDetail updateIpDetail;\n\n    public void refreshIpString ip {\n        if StrUtil.isBlankip{\n            return;\n        }\n        if StrUtil.isBlankcreateIp{\n            createIp = ip;\n        }\n        updateIp = ip;\n    }\n\n    public String needRefreshIp {\n        boolean needRefresh = Optional.ofNullableupdateIpDetail\n                .mapIpDetail::getIp\n                .filteritem  Objects.equalsupdateIp, item\n                .isPresent; // 判断结果是否是null\n\n        return needRefresh ? null : updateIp;\n    }\n\n    public void refreshIpDetailIpDetail ipDetail {\n        if Objects.equalsipDetail.getIp, createIp{\n            this.ipDetail = ipDetail;\n        }\n        if Objects.equalsipDetail.getIp, updateIp{\n            this.updateIpDetail = ipDetail;\n        }\n\n    }\n}\n\n\nrefreshIp是对当前登录的ip进行刷新，有个关键点就是先对注册ip进行判断，注册的ip无就需要对注册的ip进行赋值，其次在是更新的ip\n\n在用户登录成功后，通过 applicationEventPublisher.publishEventnew UserOnlineEventthis, user;发送异步消息SpringEvent，通过一个事件监听来接受\n\njava\n@Component\npublic class UserOnlineListener {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private IpService ipService;\n\n    @Async // 异步执行\n    @EventListenerclasses = UserOnlineEvent.class\n    public void userOnlineUserOnlineEvent event{\n        User user = event.getUser;\n        // 更新用户信息【Ip，是否登录等】\n        User update = new User;\n        update.setIduser.getId;\n        update.setLastOptTimeuser.getLastOptTime;\n        update.setIpInfouser.getIpInfo;\n        update.setActiveStatusUserActiveStatusEnum.ONLINE.getType;\n        userDao.updateByIdupdate;\n        // 用户IP解析\n        ipService.refreshDetailAsyncuser.getId;\n\n    }\n}\n\n\n这里是对用户的信息做了更新【最后一次登录事件，登录状态，IP信息】，用ipService.refreshDetailAsyncuser.getId实现对IP的异步刷新解析\n\njava\n@Service\n@Slf4j\npublic class IpServiceImpl implements IpService {\n\n    private static ExecutorService executor = new ThreadPoolExecutor1, 1,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable500, new NamedThreadFactory\"refreshipDetail\", false;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void refreshDetailAsyncLong id {\n        executor.execute  {\n            User user = userDao.getByIdid;\n            IpInfo ipInfo = user.getIpInfo;\n            if Objects.isNullipInfo{\n                return;\n            }\n            // 判断是否需要刷新ip详情\n            String ip = ipInfo.needRefreshIp;\n            if StrUtil.isBlankip{\n                // 更新ip和更新ip一致无需刷新\n                return;\n            }\n\n            // 获取ip详情\n            IpDetail ipDetail = tryGetIpDetailOrNullip;\n            if Objects.nonNullipDetail{\n                // 刷新ipInfo的详情\n                ipInfo.refreshIpDetailipDetail;\n                // 更新ip详情\n                User update = new User;\n                update.setIpInfoipInfo;\n                update.setIdid;\n                userDao.updateByIdupdate;\n            }\n        };\n    }\n\n    private IpDetail tryGetIpDetailOrNullString ip {\n        for int i = 0; i < 3; i++{\n            IpDetail ipDetail = getIpDetailOrNullip;\n            if Objects.nonNullipDetail{\n                return ipDetail;\n            }\n            try {\n                Thread.sleep2000;\n            } catch InterruptedException e{\n                log.error\"tryGetIpDetailOrNull InterruptedException\", e;\n            }\n        }\n        return null;\n    }\n\n    private IpDetail getIpDetailOrNullString ip {\n        String body = HttpUtil.get\"https://ip.taobao.com/outGetIpInfo?ip=\" + ip + \"&accessKey=alibabainc\";\n        try {\n            ApiResult<IpDetail result = JSONUtil.toBeanbody, new TypeReference<ApiResult<IpDetail {\n            }, false;\n            if result.isSuccess {\n                return result.getData;\n            }\n        } catch Exception e {\n            return null;\n        }\n\n        return null;\n    }\n}\n\n\n在实现方法refreshDetailAsync中，使用了线程池来进行异步排队处理，设置了最大容量为1个，并且设置了refreshipDetail线程前缀来便于排查出问题\n\n通过needRefreshIp判断是否需要刷新，若需要刷新就返回要刷新的ip地址，否则就返回null；是否刷新的判断依据是用用户当前数据库已经保存的IP解析的地址和当前登录的ip地址进行对比，若一致就返回null，否则就返回当前的登录的ip地址\n\ntryGetIpDetailOrNull方法是尝试获取ip解析信息，有3次机会，每次执行完有2秒的睡眠时间\n\nrefreshIpDetail方法是刷新当前用户的ip解析信息，通过ip进行判断是注册ip还是更新ip，从而进行赋值\n\n 黑名单功能\n\n 具体流程\n\n实现黑名单功能就是将用户的ip和id放在黑名单数据库中，通过拦截器判断登陆的用户是否在名单中，从而决定是否拦截通过\n\n本项目中的黑名单功能需要用到权限，权限管理多用于b端项目，对于c端来说，权限没有到那么复杂的级别。因此权限设计只涉及到了用户身份\n\nhttps://cdn.nlark.com/yuque/0/2023/png/26318626/16869791323031934c4b2943f45d3b892a78a228e4821.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize109%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10%2Fresize%2Cw1280%2Climit0\n\n流程：登录的时候返回角色  管理拉黑【判断权限】 推送给前端消息  写入黑名单表， 修改状态【SpringEvent事件异步处理】  拉黑用户拦截\n\n 核心代码\n\n判断用户是否具有某个权限，用来set巧妙处理\n\njava\n@Service\npublic class RoleDao implements IRoleService {\n\n    @Autowired\n    private UserCache userCache;\n\n    @Override\n    public boolean isPowerLong uid, RoleEnum roleEnum {\n        // 获取用户所有权限\n        Set<Long roleSet = userCache.getRoleSetuid;\n\n        return isAdminroleSet  roleSet.containsroleEnum.getId;\n    }\n\n    private boolean isAdminSet<Long roleSet{\n        return roleSet.containsRoleEnum.ADMIN.getId;\n    }\n}\n\n\n将用户写入黑名单，并且通过SpringEvent发送异步事件处理黑名单事件\n\njava\n @Override\n @TransactionalrollbackFor = Exception.class\n public void blackBlackReq blackReq {\n     // 将id写入黑名单\n     Long uid = blackReq.getUid;\n     Black black = new Black;\n     black.setTypeBlackTypeEnum.UID.getId;\n     black.setTargetuid.toString;\n     blackDao.saveblack;\n    // 将ip写入黑名单\n    User user = userDao.getByIduid;\n    blackIpOptional.ofNullableuser.getIpInfo.getCreateIp.orElsenull;\n    blackIpOptional.ofNullableuser.getIpInfo.getUpdateIp.orElsenull;\n\n    applicationEventPublisher.publishEventnew UserBlackEventthis, user;\n}\n\n/\n  封禁IP\n \n  @param ip\n /\nprivate void blackIpString ip {\n    if StrUtil.isBlankip {\n        return;\n    }\n\n    try {\n        Black insert = new Black;\n        insert.setTargetip;\n        insert.setTypeBlackTypeEnum.IP.getId;\n        blackDao.saveinsert;\n    } catch Exception e {\n\n    }\n}\n\n\n监听黑名单事件并作处理【推送前端消息，更新用户状态，清空黑名单缓存列表拦截器处理的时候会用到】\n\njava\n@Component\npublic class UserBlackListener {\n\n    @Autowired\n    private WebSocketService webSocketService;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Autowired\n    private UserCache userCache;\n\n    /\n      推送前端消息\n      @param event\n     /\n    @Async // 异步执行\n    @TransactionalEventListenerclasses = UserBlackEvent.class, phase = TransactionPhase.AFTERCOMMIT\n    public void sendMsgUserBlackEvent event{\n        User user = event.getUser;\n        webSocketService.sendMsgToAllWebSocketAdapter.buildBlackuser;\n    }\n\n    /\n      更新用户状态\n      @param event\n     /\n    @Async // 异步执行\n    @TransactionalEventListenerclasses = UserBlackEvent.class, phase = TransactionPhase.AFTERCOMMIT\n    public void changeActivityUserBlackEvent event{\n        User user = event.getUser;\n        userDao.invalidUiduser.getId;\n    }\n\n    /\n      清空黑名单缓存\n      @param event\n     /\n    @Async // 异步执行\n    @TransactionalEventListenerclasses = UserBlackEvent.class, phase = TransactionPhase.AFTERCOMMIT\n    public void clearBlackListUserBlackEvent event{\n        userCache.evictBlack;\n    }\n}\n\n\n推送给前端所有用户这里用到了线程池，加快处理效率\n\njava\n@Autowired\nprivate ThreadPoolTaskExecutor threadPoolTaskExecutor;\n\n@Override\npublic void sendMsgToAllWSBaseResp<? resp {\n    ONLINEWSMAP.forEachchannel, wsChannelExtraDTO  {\n        // 使用线程池，加快发送速度\n        threadPoolTaskExecutor.execute  {\n            sendMsgchannel, resp;\n        };\n    };\n}\n\n\n 游标翻页\n\n游标翻页更适用于一页一页跳转的场景，而对于跳页反转（例如第一页跳到第五页就不适用）\n\n本项目为聊天项目，适合适用游标翻页\n\n 深翻页问题\n\n普通翻页前端一般会有个分页条。能够指定一页的条数，以及任意选择查看第几页。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685187350715ec688988ee5a426e88eadbb85f6aac22.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize16%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n对应的参数就是pageNo和pageSize\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/16851874273103e189d14a2154dbfb86d5badf5bd5a12.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize14%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n假设前端想要查看第11页的内容，传的值pageNo=11，pageSize=10\n\n其中100代表需要跳过的条数，10代表跳过指定条数后，往后需要再取的条数。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685188112380ab4f8decf339451b87eb2ae6ae1bfbe1.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize12%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n对应图片就是这样的一个效果，需要在数据库的位置先读出100条，然后丢弃。丢弃完100条后，再继续取10条选用。\n\n如果我们翻页到了很深的地方，比如读到了第1000页，对应的sql语句就是select  from table limit 10000,10\n\n需要先查询10000条进行丢弃，再取那么个10条选用。这个效率也太低了，\n\n  我们经常需要定时任务全量去跑一张表的数据，普通翻页去跑的话，到后面数据量大的时候，就会越跑越慢，这就是深翻页带来的问题。\n\n解决办法\n\n目前的问题在于每次翻页都需要花时间扫描一些不需要的记录，然后丢弃。那么是不是可以优化这个步骤呢？\n\n以后不论第几页，我们都不需要跳过一些值。直接取limit 0,10。这样语句变成了select  from table limit 0,10\n\n取到的是110这些记录，取不到我们想要的101110，没关系，再加一个条件select  from table where id100 order by id limit 0,10\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/168518863534668f634f332764f8787884691ec990d83.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize13%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n只要id这个字段有索引，就能直接定位到101这个字段，然后去10条记录。以后无论翻页到多大，通过索引直接定位到读取的位置，效率基本是一样的。这个id100就是我们的游标，这就是游标翻页。\n\n 游标介绍\n\n游标翻页可以完美的解决深翻页问题，依赖的就是我们的游标，即cursor。针对mysql的游标翻页，我们需要通过cursor快速定位到指定记录，意味着游标必须添加索引。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685189222316cf64fcf1da8546f0b6b04088cd66b89e.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize15%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n前端之前传的pageNo字段改成了cursor字段。cursor是上一次查询结果的位置，作为下一次查询的游标，由后端返回\n\n我们来模拟一次前后端的翻页交互\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1685189899438884c817d0ee54b7da5406be3bb135975.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize19%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n随着翻页的持续，游标不断往翻页的方向推进。\n\n所以游标翻页不适合跳页，只能不断的往下翻。更适合C端的列表场景\n\n 总结\n\n游标翻页的优点：\n\n1.解决深翻页问题\n\n2.解决频繁变动的列表翻页问题。\n\n缺点：\n\n1.无法跳页，只能不断往下翻\n\n游标翻页更适合c端场景，用户只能不断下滑翻页。\n\n普通翻页更适合B端场景。用户能看见总页数，能随意跳页\n\n 前后端资源懒加载\n\n 选用原因\n\n 带宽占用\n\n对于项目中的个别请求，有时候会有大量冗余和重复的消息。特别是用户的头像，名称，佩戴徽章，这些东西，基本都是重复的，但是我们每一次的消息推送，成员上下线，都需要携带。\n\n对于这些数据，其实我们只想知道消息的拥有者是谁，也就是uid。其他的头像，徽章，这些我们之前都有，但是他们却占据了消息体的大部分内容，有效载荷太少。\n\n在压测的时候发现了很多时候我们的瓶颈就在带宽上。而带宽都被头像的url给占用了。\n\n 代码复杂度\n\n如果每次因为一个简单的消息推送，就要去写一套复杂的代码，去加载用户的名称，以及徽章相关的信息。都会增大后端代码的复杂度。\n\n每次组装vo数据，都得去查出用户的关联信息，进行组装。哪怕是可以复用这段代码，但是相应的性能损耗，也是不可避免的。\n\n 解决办法\n\n 图片路径协议优化\n\n前后端可以将用户头像遵循一种固定的路径协议，比如https://img.mallchat.cn/avatar/{uid}.png;\n\n这样只给前端uid，他自己就能组装出用户头像了\n\n 懒加载时间点\n\n前端在什么场景下会请求后端进行信息懒加载，每次请求后端，需要更新自己库里的懒加载时间lastModifyTime\n\n 没数据加载\n 数据过期加载（校验）：lastModifyTime小于数据库存的lastModifyTime\n 主动加载（校验）：例如用户主动点击头像查询信息\n\n 总结\n\n了解到了项目的瓶颈，大多是来源带宽不足。为了节省带宽，同时简化后端的逻辑，我们设计了一套前后端资源懒加载的交互框架。他有三个懒加载的时间点，同时保证了及时性，以及最终一致性。这个框架的核心就是lastModifyTime字段的定义。有了它，只要没有变动，后端都可以不返回用户信息，又能节省一大部分带宽。并且为了不需要展示的字段不返回null。我们用了一个json的注解，又节省了一小部分带宽。\n\n 批量缓存框架\n\n缓存通常有两种使用方式，一种是CacheAside，一种是cachethrough。也就是旁路缓存和缓存即数据源。\n\n一般一种用于读，另一种用于读写。\n\n 盘路缓存\n\n我们通常用的都是旁路缓存模式\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1696084655149bf1c5c2b362645b28b430d9268f5a6bc.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize14%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\nGET缓存获取不到，就LOAD加载数据库，再将数据库写回redis缓存。\n\n盘路缓存也有很好用的框架，比如springcache。只需要写load逻辑。加上个注解，就能实现盘路缓存的效果。\n\n缺点：在极端情况下。我需要获取一批用户的信息，碰巧所有用户的缓存都失效了，都需全部重新加载。那么这样一个本来性能很高的循环，就等同于全部查了数据库，缓存一点儿作用都没了。\n\n 批量缓存查询\n\n对于这种批量查询缓存的需求，传统的旁路缓存框架无法达到我们的需求。我们需要让他能够批量的get or load。\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/16960856323923b47a5e4970047029edebef81682e82e.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize12%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n类似这张图，批量的get。发现没有的数据，再批量的load一次，这样和redis以及数据库的交互都只会有一次。\n\n具体代码\n\njava\n/\n  获取用户信息，盘路缓存模式\n /\npublic Map<Long, User getUserInfoBatchSet<Long uids {\n    //批量组装key\n    List<String keys = uids.stream.mapa  RedisKey.getKeyRedisKey.USERINFOSTRING, a.collectCollectors.toList;\n    //批量get\n    List<User mget = RedisUtils.mgetkeys, User.class;\n    Map<Long, User map = mget.stream.filterObjects::nonNull.collectCollectors.toMapUser::getId, Function.identity;\n    //发现差集——还需要load更新的uid\n    List<Long needLoadUidList = uids.stream.filtera  map.containsKeya.collectCollectors.toList;\n    if CollUtil.isNotEmptyneedLoadUidList {\n        //批量load\n        List<User needLoadUserList = userDao.listByIdsneedLoadUidList;\n        Map<String, User redisMap = needLoadUserList.stream.collectCollectors.toMapa  RedisKey.getKeyRedisKey.USERINFOSTRING, a.getId, Function.identity;\n        RedisUtils.msetredisMap, 5  60;\n        //加载回redis\n        map.putAllneedLoadUserList.stream.collectCollectors.toMapUser::getId, Function.identity;\n    }\n    return map;\n}\n\n\n我们在很多处都要用到这个接口，所以就需要对这个批量查询缓存进行封装\n\n这时候又要轮到我们的常规抽象环节了\n\nimghttps://cdn.nlark.com/yuque/0/2023/png/26318626/1696085827579fa03f689bdb1476eb53fa291b3314660.png?xossprocess=image%2Fwatermark%2Ctyped3F5LW1pY3JvaGVp%2Csize34%2CtextTWFsbENoYXQ%3D%2CcolorFFFFFF%2Cshadow50%2Ct80%2Cgse%2Cx10%2Cy10\n\n黄色代表可复用的流程，红色代表个性化的代码。\n\n 批量缓存框架\n\n先创建批量缓存框架的接口\n\n接口\n\njava\npublic interface BatchCache<IN, OUT {\n    /\n      获取单个\n     /\n    OUT getIN req;\n\n    /\n      获取批量\n     /\n    Map<IN, OUT getBatchList<IN req;\n\n    /\n      修改删除单个\n     /\n    void deleteIN req;\n\n    /\n      修改删除多个\n     /\n    void deleteBatchList<IN req;\n}\n\n\n再通过抽象类，定义好骨架\n\n抽象类\n\njava\npublic abstract class AbstractRedisStringCache<IN, OUT implements BatchCache<IN, OUT {\n\n    private Class<OUT outClass;\n\n    protected AbstractRedisStringCache {\n        ParameterizedType genericSuperclass = ParameterizedType this.getClass.getGenericSuperclass;\n        this.outClass = Class<OUT genericSuperclass.getActualTypeArguments1;\n    }\n\n    protected abstract String getKeyIN req;\n\n    protected abstract Long getExpireSeconds;\n\n    protected abstract Map<IN, OUT loadList<IN req;\n\n    @Override\n    public OUT getIN req {\n        return getBatchCollections.singletonListreq.getreq;\n    }\n\n    @Override\n    public Map<IN, OUT getBatchList<IN req {\n        if CollectionUtil.isEmptyreq {//防御性编程\n            return new HashMap<;\n        }\n        //去重\n        req = req.stream.distinct.collectCollectors.toList;\n        //组装key\n        List<String keys = req.stream.mapthis::getKey.collectCollectors.toList;\n        //批量get\n        List<OUT valueList = RedisUtils.mgetkeys, outClass;\n        //差集计算\n        List<IN loadReqs = new ArrayList<;\n        for int i = 0; i < valueList.size; i++ {\n            if Objects.isNullvalueList.geti {\n                loadReqs.addreq.geti;\n            }\n        }\n        Map<IN, OUT load = new HashMap<;\n        //不足的重新加载进redis\n        if CollectionUtil.isNotEmptyloadReqs {\n            //批量load\n            load = loadloadReqs;\n            Map<String, OUT loadMap = load.entrySet.stream\n                    .mapa  Pair.ofgetKeya.getKey, a.getValue\n                    .collectCollectors.toMapPair::getFirst, Pair::getSecond;\n            RedisUtils.msetloadMap, getExpireSeconds;\n        }\n\n        //组装最后的结果\n        Map<IN, OUT resultMap = new HashMap<;\n        for int i = 0; i < req.size; i++ {\n            IN in = req.geti;\n            OUT out = Optional.ofNullablevalueList.geti\n                    .orElseload.getin;\n            resultMap.putin, out;\n        }\n        return resultMap;\n    }\n\n    @Override\n    public void deleteIN req {\n        deleteBatchCollections.singletonListreq;\n    }\n\n    @Override\n    public void deleteBatchList<IN req {\n        List<String keys = req.stream.mapthis::getKey.collectCollectors.toList;\n        RedisUtils.delkeys;\n    }\n}\n\n\n这时候你就会发现，写一个批量的旁路缓存有多简单。\n\n具体实现\n\njava\n@Component\npublic class UserInfoCache extends AbstractRedisStringCache<Long, User {\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    protected String getKeyLong uid {\n        return RedisKey.getKeyRedisKey.USERINFOSTRING, uid;\n    }\n\n    @Override\n    protected Long getExpireSeconds {\n        return 5  60L;\n    }\n\n    @Override\n    protected Map<Long, User loadList<Long uidList {\n        List<User needLoadUserList = userDao.listByIdsuidList;\n        return needLoadUserList.stream.collectCollectors.toMapUser::getId, Function.identity;\n    }\n}\n\n"},{"filename":"hmdp","category":"project","md":{"topSummary":"\ntitle: 黑马点评项目笔记\ncategory: SpringBoot,Redis,实战项目\ndate: 2024-01-26\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## Session共享问题\n\n多台Tomcat并不共享session存储空间，当切换到不同的tomcat服务时导致数据丢失的问题\n\n## 缓存更新策略\n\n- 内存淘汰：reids自带的内存淘汰机制\n- 过期淘汰：利用exprie命令给数据设置过期时间\n- 主动更新：主动完成数据库与reids的同时更新\n\n### 策略选择\n\n- 低一致性需求：内存淘汰或过期淘汰\n- 高一致性需求：主动更新为主，过期淘汰为辅\n\n### 关于主动更新策略的思考\n\n1、**问题：是更新缓存还是删除缓存？**\n\n更新缓存：会产生无效更新，因为有可能你更新了，系统一直没用上。并且存在较大的线程安全问题\n\n删除缓存：本质是延迟更新，没有无效更新，线程安全问题相对较低\n\n经过思考得出的最佳策略：**删除缓存**\n\n2、**问题：先操作数据库还是缓存？**\n\n**方案一：先删除缓存，再更新数据库**\n\n正常情况：线程一先执行删除缓存，再更新数据库；线程二查询缓存有发现没有缓存，就查询数据库。\n\n异常情况：线程一先执行删除缓存，这时候线程二到了，查询缓存后发现无缓存，就去查询数据库，这时候数据库的数据是没更新的数据，就出现了异常，最后线程一才执行更新数据库。\n\n**方案二：先更新数据库，再删除缓存**\n\n正常情况：线程一先更新数据库，再删除缓存，线程二查询缓存发现没有缓存，就查询数据库。\n\n异常情况：线程二线查询缓存，发现有缓存，这时候线程一才到达，线程一就更新数据库，删除缓存，线程二就出现了异常，用的是没更新的数据。\n\n经过思考得出的最佳策略：**方案二**\n\n3、**如何确保数据库与缓存操作的原子性？**\n\n单体系统：利用事务机制\n\n分布式系统：利用分布式事务机制\n\n## 缓存穿透\n\n缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n**解决方案**\n\n- 缓存空对象：请求到了后缓存一个值为null的数据到redis中\n  - 优点：简单，容易维护\n  - 缺点：1、额外的内存消耗。2、可能造成短期的不一致\n- 布隆过滤：在客户端和redis之间加个过滤器，用二进制数组判断是否存在。注意这个方法并不是百分百准确\n  - 优先：内存占用少\n  - 缺点：1、实现复杂。2、存在误判可能\n\n## 缓存雪崩\n\n缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n\n**解决方案**\n\n- 给不同的key设置不同的的过期时间\n- 添加Redis集群提高服务可用性\n- 给缓存添加降级限流策略\n- 给业务添加多级缓存\n\n## 缓存击穿\n\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n**解决方案**\n\n- 给热点接口添加互斥锁\n- 逻辑过期【在redis中额外添加一个时间字段】\n\n## Redis全局唯一ID\n\n![](https://s11.ax1x.com/2024/01/17/pFkCTn1.png)\n\n- 符号位：1bit，永远为0\n- 时间戳：31bit，以秒为单位，可以用69年\n- 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同的ID\n\n## 优惠券秒杀\n\n### 超卖\n\n**解决办法**\n\n- 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取同步锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁\n  - 优点：简单粗暴\n  - 缺点：性能一般\n- 乐观锁：认为线程安全问题不一定会发生，因此不加锁，**只是在更新数据时去判断有没有其它线程对数据做了修改**。\n  - 如果没有修改则认为是安全的，自己才更新数据。\n  - 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。\n  - 优点：性能好\n  - 缺点：存在成功率低的问题（需要做处理）\n\n#### 悲观锁方法\n\n使用`synchronized`过于简单，采用乐观锁方法\n\n#### 乐观锁方法\n\n> 对于**乐观锁**的关键是判断之前查询得到的数据受否被修改过，常见的方法有两种：\n\n1、**版本号法**\n\n![](https://s11.ax1x.com/2024/01/17/pFkM5m8.png)\n\n2、**CAS法**\n\nCAS法和版本号法的区别在于CAS法是直接将库存和原来库做比较，而版本号法是比较的版本\n\n![](https://s11.ax1x.com/2024/01/17/pFkMOlq.png)\n\n**弊端**：出错率大大增加，100个库春，结果只有几十个成功卖出。为什么呢？\n\n解答：假设有100个线程同时请求，只有一个线程成功，其他99线程都在最后一步扣减库存的时候需要判断是否和之前的库存一致出错了，所以就大大提高了错误率。\n\n**怎么解决这个弊端？**\n\n解答：将最后判断是否和之前库存一致改为**只要库存大于0**就行了\n\n### 一人一单\n\n**解决办法**：使用乐观锁方法，添加同步代码`synchronized`，限制只有一个线程进入\n\n**存在的问题**：在单机模式下没问题，但在集群模式下就会出现问题，不同的SpringBoot服务中JVM使用的常量池、锁监视器是不一样，这导致了同一个用户两次请求都会进入到锁里，就出现了安全问题\n\n![](https://s11.ax1x.com/2024/01/18/pFkqadJ.png)\n\n**解决办法**：分布式锁，下面讲解分布式锁\n\n### 分布式锁\n\n**概念**：满足分布式系统或集群模式下多进程可见并且互斥的锁\n\n**满足的基本特性**：多进程可见、高可用、互斥、好性能、安全性\n\n**核心**：实现多进程之间的互斥，下面是常见的三种\n\n![](https://s11.ax1x.com/2024/01/18/pFkL2cV.png)\n\n**需要实现的两个基本方法**\n\n- 获取锁【通过`set lock name NX EX 10`来实现互斥锁并加上过期时间，NX是互斥，EX是设置超时时间】\n  - 互斥：确保只能有一个线程获取锁\n  - 非阻塞：尝试一次，成功返回true，失败返回false\n- 释放锁【`Del key`】\n  - 手动释放\n  - 超时释放\n\n**分布式锁误删问题**：因为线程一的某种原因导致阻塞，时间超过了Redis锁的过期时间，锁自动释放，线程二获取了线程一的锁，若此时线程一的业务执行完毕，就会手动调用释放锁，就把线程二的锁给释放了，出现了误删的情况\n\n![](https://s11.ax1x.com/2024/01/18/pFkjB7D.png)\n\n**误删情况解决办法**：获取锁的时候将value值设置为UUID+线程ID，每次释放锁的时候就拿redis中存放的值与这个值判断一下，相同才释放，否则不释放\n\n**采用上诉方法还是存在问题**\n\n释放锁的过程，是先判断reids中的值是否一致，再释放锁。可能出现在判断过后到是否锁之间出现阻塞的情况，因为在JVM中有个东西叫垃圾回收，它会阻塞代码。于是需要保证判断和释放这两部操作是原子操作，不可分割\n\n![](https://s11.ax1x.com/2024/01/18/pFAPylQ.png)\n\n**解决办法**：采用Lua脚本解决，编写Lua脚本，用Java调用\n\n#### 总结\n\n**实现Reids分布式锁的思路**\n\n- 利用`set nx ex`获取锁，并设置过期时间，保存现场标识\n- 释放锁先判断线程标识是否与自己一致，一致就删除锁【使用Lua脚本保证原子性】\n\n## Redisson\n\n**Redis的分布式锁是基于setnx实现的，存在一下问题**\n\n- 不可重入：同一个线程无法多次获取同一把锁\n- 不可重试：获取锁只尝试一次就返回false，没有重试机制\n- 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患\n- 主从一致性：如果Redis提供了主从集群,主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现\n\n**Redisson提供一系列分布式的Java常用对象和许多分布式服务**\n\n![](https://s11.ax1x.com/2024/01/18/pFAEp5t.png)\n\n### 可重入锁原理\n\n通过redis的hash结构进行锁的存储，同一个线程进入，会将value值加一，并设置有效期，每次释放锁就value值减一。若减后的值不为0，就重置有效期，否则就直接删除。实现代码通过Lua脚本进行。\n\n![](https://s11.ax1x.com/2024/01/18/pFAVqne.png)\n\n**流程图**\n\n![](https://s11.ax1x.com/2024/01/18/pFAZp1f.png)\n\n### 可重试锁原理\n\n利用信号量和PubSub功能实现等待、唤醒、获取锁失效的重试机制\n\n![](https://s11.ax1x.com/2024/01/18/pFAeYZQ.png)\n\n### 超时续约原理\n\n利用wathDog，每隔一段时间，重置超时时间\n\n### 主从一致性原理\n\n多个独立的Redis结点，必须所有的结点都获取重入锁，才算获取锁成功\n\n## 秒杀优化\n\n### 思路\n\n- 利用Reids Lua脚本完成库存余量、一人一单判断，完成抢单业务\n- 再将下单业务放入阻塞队列中，利用独立线程异步下单\n\n### 使用阻塞队列存在的问题\n\n- 内存限制问题：当队列的元素超过容量的时候会出现内存溢出\n- 数据安全问题：当队列的任务服务出现宕机，任务就会丢失\n\n## Reids消息队列\n\n### 基于List结构模拟消息队列\n\nReids中的List数据结构是一个双向链表，利用LPUSH结合RPOP，或者RPUSH结合LPOP来实现\n\n不过需要注意的是，当消息队列没有消息时RPOP和LPOP操作会返回NULL，并不像JVM阻塞队列那样会阻塞并等待消息。\n\n因此应该使用BRPOP或者BLPOP来实现阻塞效果\n\n#### 优点\n\n- 利用Reids存储，不受限于JVM内存上限\n- 基于Reidis的持久化机制，数据安全性有保证\n- 可以满足消息有序性\n\n#### 缺点\n\n- 无法避免消息丢失\n- 只支持单消费者\n\n### 基于PubSub的消息队列\n\n生产者向对应的cahnnel发送消息后，所有订阅者都能收到消息【一对多】\n\n- SUBSCRIBE channel [channel]：订阅一个或多个频道\n- PUSLISH channel msg：向一个频道发送消息\n- PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道\n\n#### 优点\n\n- 采用发布订阅模型，支持多生产、多消费\n\n#### 缺点\n\n- 不支持数据持久化\n- 无法避免消息丢失\n- 消息堆积有上限，超出时数据丢失\n\n### 基于Stream类型消息队列\n\nstream是一种数据类型，专门为消息队列设计的，相较于前面两种方式能够更加完美实现一个消息队列\n\n**生产消息**：用于向指定的Stream流中添加一个消息\n\n```\nXADD key *|ID value [value ...]\n\n# 创建名为 users 的队列，并向其中发送一个消息，内容是：{name=jack,age=21}，并且使用Redis自动生成ID\n127.0.0.1:6379> XADD users * name jack age 21\n\"1644805700523-0\n```\n\nkey就是消息队列，key不存(*)在会自动创建（默认），ID是消息表示，value是消息的内容\n\n**消费消息**：\n\n```\nXREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID ID\n\n# 读取XREAD中的第一条消息\nXREAD COUNT 1 STREAMS users 0\n# 阻塞1秒钟后从XREAD中读取的最新消息\nXREAD COUNT 1 BLOCK 1000 STREAMS users $\n```\n\n注意：当我们指定起始ID为`$`时代表读取最后一条消息（读取最新的消息）ID为`0`时代表读最开始的一条消息（读取最旧的消息），如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题\n\n#### 特点\n\n- 消息可回溯\n- 一个消息可以被多个消费者读取\n- 可以阻塞堆区\n- 有消息漏读风险\n\n#### 消费者组\n\n上面我们介绍的消费方式都是**单消费方式**，容易发生消息堆积导致消息丢失，所以我们需要改用消费者组的模式\n\n**消费者组**：将多个消费者划分到一个组，监听同一队列\n\n- **消息分流**：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度\n- **消息标识**：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费\n- **消息确认**：消费者获取消息后，消息处于`pending`（待处理）状态，并存入一个`pending-list`。当处理完成后需要通过`XACK`来确认消息，标记消息为已处理，才会从pending-list移除。\n\n```\n# 创建消费者组\nXGROUP CREATE key groupName ID\n# 删除指定的消费者组\nXGROUP DESTORY key groupName\n# 给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupName consumerName\n# 删除消费者组中指定消费者\nXGROUP DELCONSUMER key groupName consumerName\n# 从消费者组中读取消息\nXREADGROUP GROUP\n```\n\n![](https://img-blog.csdnimg.cn/img_convert/27039c5d7c9c137c15bab614293a63fe.png)\n\n![](https://img-blog.csdnimg.cn/img_convert/c1ffb0ac9d815f997953b1dfeae6768f.png)\n\n`stream`类型消息队列的`XREADGROUP`命令特点：\n\n- 消息可回溯\n- 可以多消费者争抢消息，加快消费速度\n- 可以阻塞读取\n- 没有消息漏读的风险\n- 有消息确认机制，保证消息至少被消费一次\n\n### 比较\n\n![](https://s21.ax1x.com/2024/03/11/pF6P3RK.png)\n\n## Feed流\n\n关注推送也叫投喂，为用户持续提供沉浸式体验，通过无限下拉刷新获取新的信息\n\n### 与传统模式的区别\n\n- 传统模式：用户寻找内容\n\n- Feed模式：内容匹配用户\n\n### Feed流常见的模式\n\n- TimeLine：不做内容筛选，简单的按照内容发布时间排序，常用于好友或者关注\n- 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容\n\n### Feed流实现方案\n\n![](https://s11.ax1x.com/2024/01/19/pFAoHxO.png)\n\n## HyperLogLog用法\n\n首先搞懂两个概念\n\n- UV：独立访客量，1天内一个用户多次访问该网站，只记录一次\n- PV：页面访问量：用户多次打开页面，记录多次PV\n\nUV统计\n\n- 优点：内存占用极小\n- 缺点：存在0.81%的误差【不过可以完全忽略】\n\n## 总结\n\n### 2024-1-16\n\n1、写了发短信验证码和登录接口，随机生成token，将用户信息存入redis中\n\n2、写了两个拦截器，一个拦截所有请求的token刷新拦截器【没有token直接放行，token中找不到数据直接放行，全部通过就存入UserHolder中】，一个是只拦截需要验证的登录拦截器【只需要检验UserHolder中是否有数据，有就通过，否则拦截】。\n\n3、对查询商品接口做了缓存，并且对**缓存击穿【互斥锁】**和**缓存穿透【缓存空对象】**做了处理，用jmeter进行检验\n\n### 2024-1-17\n\n1、 用逻辑过期时间解决缓存击穿【在shop中使用expire字段】，**使用这个方法需要将热点key提前预热**。通过比较当前时间和逻辑时间，而从决定是否需要重建数据。通过互斥锁来保证只有一个线程能够进入，通过独立线程来重构数据来减少响应时间\n\n2、创建了redis全局唯一ID生成器，通过符号位(1位)+时间错(31位)+序列号(32位)来形成一个唯一ID，但这样这个ID最大值并不满足总量的所需的范围要求，因此需要通过**不同的key来生成序列号**【通过加上`年:月:日`前缀】来保证每天的都有会不同的ID，这个最大值并不会超过一天所需的范围要求。\n\n3、写了优惠券秒杀功能，正常写法会出现超卖的情况，使用**乐观锁**优化后加上库存限制解决超卖问题【这里也可以用悲观锁解决，通过互斥锁或者同步代码】；使用**悲观锁**`synchronized`解决一人一单的问题，并用**代理事务【AopContext.currentProxy()】**解决事务\t\n\n### 2024-1-18\n\n1、一人一单集群模式下使用分布式锁解决，分布式锁带来了一系列问题，比如：两个服务的`synchronized (userId.toString().intern())`获取的对象不一致【**通过互斥锁解决**】，误删【**通过每次释放前判断存入锁的值是否一致解决**】，原子性问题【**释放锁的操作分为判断是否一致和释放锁，需要用Java调用写好的Lua脚本来确保原子性**】\n\n2、整合Redisson，了解其可重入的原理，可重试锁原理、超时续约原理、主从一致性原理\n\n3、新增查询笔记、点赞笔记\n\n### 2024-1-19\n\n1、点赞排行榜【采用redis的zSet存储，按照时间戳排序】、关注、共同关注【set集合取两个集合的并集】\n\n2、使用Feed流，在博文发布的时候推送给关注自己的人\n\n3、签到：使用二进制位`stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);`存储签到，签到了就是1，没签到就是0\n\n4、统计连续签到，通过`stringRedisTemplate.opsForValue().bitField`来获取 本月截至今天为止所有的签到记录\n\n### 2024-3-10\n\n1、优化优惠券秒杀逻辑，将原本对数据库的查询等判断条件全部放到Lua脚本中，改为从Reids中判断，极大的优化了查询的时间\n\n2、使用阻塞队列 + 线程池实现异步秒杀\n\n### 2024-3-11\n\n1、优化秒杀，使用Stream消息队列替换阻塞队列，能够弥补阻塞队列带来的问题，例如：内存上限，数据丢失等\n","title":" 黑马点评项目笔记\n","category":[" SpringBoot","Redis","实战项目\n"],"date":" 2024-01-26\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n Session共享问题\n\n多台Tomcat并不共享session存储空间，当切换到不同的tomcat服务时导致数据丢失的问题\n\n 缓存更新策略\n\n 内存淘汰：reids自带的内存淘汰机制\n 过期淘汰：利用exprie命令给数据设置过期时间\n 主动更新：主动完成数据库与reids的同时更新\n\n 策略选择\n\n 低一致性需求：内存淘汰或过期淘汰\n 高一致性需求：主动更新为主，过期淘汰为辅\n\n 关于主动更新策略的思考\n\n1、问题：是更新缓存还是删除缓存？\n\n更新缓存：会产生无效更新，因为有可能你更新了，系统一直没用上。并且存在较大的线程安全问题\n\n删除缓存：本质是延迟更新，没有无效更新，线程安全问题相对较低\n\n经过思考得出的最佳策略：删除缓存\n\n2、问题：先操作数据库还是缓存？\n\n方案一：先删除缓存，再更新数据库\n\n正常情况：线程一先执行删除缓存，再更新数据库；线程二查询缓存有发现没有缓存，就查询数据库。\n\n异常情况：线程一先执行删除缓存，这时候线程二到了，查询缓存后发现无缓存，就去查询数据库，这时候数据库的数据是没更新的数据，就出现了异常，最后线程一才执行更新数据库。\n\n方案二：先更新数据库，再删除缓存\n\n正常情况：线程一先更新数据库，再删除缓存，线程二查询缓存发现没有缓存，就查询数据库。\n\n异常情况：线程二线查询缓存，发现有缓存，这时候线程一才到达，线程一就更新数据库，删除缓存，线程二就出现了异常，用的是没更新的数据。\n\n经过思考得出的最佳策略：方案二\n\n3、如何确保数据库与缓存操作的原子性？\n\n单体系统：利用事务机制\n\n分布式系统：利用分布式事务机制\n\n 缓存穿透\n\n缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n解决方案\n\n 缓存空对象：请求到了后缓存一个值为null的数据到redis中\n   优点：简单，容易维护\n   缺点：1、额外的内存消耗。2、可能造成短期的不一致\n 布隆过滤：在客户端和redis之间加个过滤器，用二进制数组判断是否存在。注意这个方法并不是百分百准确\n   优先：内存占用少\n   缺点：1、实现复杂。2、存在误判可能\n\n 缓存雪崩\n\n缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n\n解决方案\n\n 给不同的key设置不同的的过期时间\n 添加Redis集群提高服务可用性\n 给缓存添加降级限流策略\n 给业务添加多级缓存\n\n 缓存击穿\n\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n解决方案\n\n 给热点接口添加互斥锁\n 逻辑过期【在redis中额外添加一个时间字段】\n\n Redis全局唯一ID\n\nhttps://s11.ax1x.com/2024/01/17/pFkCTn1.png\n\n 符号位：1bit，永远为0\n 时间戳：31bit，以秒为单位，可以用69年\n 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同的ID\n\n 优惠券秒杀\n\n 超卖\n\n解决办法\n\n 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取同步锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁\n   优点：简单粗暴\n   缺点：性能一般\n 乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。\n   如果没有修改则认为是安全的，自己才更新数据。\n   如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。\n   优点：性能好\n   缺点：存在成功率低的问题（需要做处理）\n\n 悲观锁方法\n\n使用synchronized过于简单，采用乐观锁方法\n\n 乐观锁方法\n\n 对于乐观锁的关键是判断之前查询得到的数据受否被修改过，常见的方法有两种：\n\n1、版本号法\n\nhttps://s11.ax1x.com/2024/01/17/pFkM5m8.png\n\n2、CAS法\n\nCAS法和版本号法的区别在于CAS法是直接将库存和原来库做比较，而版本号法是比较的版本\n\nhttps://s11.ax1x.com/2024/01/17/pFkMOlq.png\n\n弊端：出错率大大增加，100个库春，结果只有几十个成功卖出。为什么呢？\n\n解答：假设有100个线程同时请求，只有一个线程成功，其他99线程都在最后一步扣减库存的时候需要判断是否和之前的库存一致出错了，所以就大大提高了错误率。\n\n怎么解决这个弊端？\n\n解答：将最后判断是否和之前库存一致改为只要库存大于0就行了\n\n 一人一单\n\n解决办法：使用乐观锁方法，添加同步代码synchronized，限制只有一个线程进入\n\n存在的问题：在单机模式下没问题，但在集群模式下就会出现问题，不同的SpringBoot服务中JVM使用的常量池、锁监视器是不一样，这导致了同一个用户两次请求都会进入到锁里，就出现了安全问题\n\nhttps://s11.ax1x.com/2024/01/18/pFkqadJ.png\n\n解决办法：分布式锁，下面讲解分布式锁\n\n 分布式锁\n\n概念：满足分布式系统或集群模式下多进程可见并且互斥的锁\n\n满足的基本特性：多进程可见、高可用、互斥、好性能、安全性\n\n核心：实现多进程之间的互斥，下面是常见的三种\n\nhttps://s11.ax1x.com/2024/01/18/pFkL2cV.png\n\n需要实现的两个基本方法\n\n 获取锁【通过set lock name NX EX 10来实现互斥锁并加上过期时间，NX是互斥，EX是设置超时时间】\n   互斥：确保只能有一个线程获取锁\n   非阻塞：尝试一次，成功返回true，失败返回false\n 释放锁【Del key】\n   手动释放\n   超时释放\n\n分布式锁误删问题：因为线程一的某种原因导致阻塞，时间超过了Redis锁的过期时间，锁自动释放，线程二获取了线程一的锁，若此时线程一的业务执行完毕，就会手动调用释放锁，就把线程二的锁给释放了，出现了误删的情况\n\nhttps://s11.ax1x.com/2024/01/18/pFkjB7D.png\n\n误删情况解决办法：获取锁的时候将value值设置为UUID+线程ID，每次释放锁的时候就拿redis中存放的值与这个值判断一下，相同才释放，否则不释放\n\n采用上诉方法还是存在问题\n\n释放锁的过程，是先判断reids中的值是否一致，再释放锁。可能出现在判断过后到是否锁之间出现阻塞的情况，因为在JVM中有个东西叫垃圾回收，它会阻塞代码。于是需要保证判断和释放这两部操作是原子操作，不可分割\n\nhttps://s11.ax1x.com/2024/01/18/pFAPylQ.png\n\n解决办法：采用Lua脚本解决，编写Lua脚本，用Java调用\n\n 总结\n\n实现Reids分布式锁的思路\n\n 利用set nx ex获取锁，并设置过期时间，保存现场标识\n 释放锁先判断线程标识是否与自己一致，一致就删除锁【使用Lua脚本保证原子性】\n\n Redisson\n\nRedis的分布式锁是基于setnx实现的，存在一下问题\n\n 不可重入：同一个线程无法多次获取同一把锁\n 不可重试：获取锁只尝试一次就返回false，没有重试机制\n 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患\n 主从一致性：如果Redis提供了主从集群,主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现\n\nRedisson提供一系列分布式的Java常用对象和许多分布式服务\n\nhttps://s11.ax1x.com/2024/01/18/pFAEp5t.png\n\n 可重入锁原理\n\n通过redis的hash结构进行锁的存储，同一个线程进入，会将value值加一，并设置有效期，每次释放锁就value值减一。若减后的值不为0，就重置有效期，否则就直接删除。实现代码通过Lua脚本进行。\n\nhttps://s11.ax1x.com/2024/01/18/pFAVqne.png\n\n流程图\n\nhttps://s11.ax1x.com/2024/01/18/pFAZp1f.png\n\n 可重试锁原理\n\n利用信号量和PubSub功能实现等待、唤醒、获取锁失效的重试机制\n\nhttps://s11.ax1x.com/2024/01/18/pFAeYZQ.png\n\n 超时续约原理\n\n利用wathDog，每隔一段时间，重置超时时间\n\n 主从一致性原理\n\n多个独立的Redis结点，必须所有的结点都获取重入锁，才算获取锁成功\n\n 秒杀优化\n\n 思路\n\n 利用Reids Lua脚本完成库存余量、一人一单判断，完成抢单业务\n 再将下单业务放入阻塞队列中，利用独立线程异步下单\n\n 使用阻塞队列存在的问题\n\n 内存限制问题：当队列的元素超过容量的时候会出现内存溢出\n 数据安全问题：当队列的任务服务出现宕机，任务就会丢失\n\n Reids消息队列\n\n 基于List结构模拟消息队列\n\nReids中的List数据结构是一个双向链表，利用LPUSH结合RPOP，或者RPUSH结合LPOP来实现\n\n不过需要注意的是，当消息队列没有消息时RPOP和LPOP操作会返回NULL，并不像JVM阻塞队列那样会阻塞并等待消息。\n\n因此应该使用BRPOP或者BLPOP来实现阻塞效果\n\n 优点\n\n 利用Reids存储，不受限于JVM内存上限\n 基于Reidis的持久化机制，数据安全性有保证\n 可以满足消息有序性\n\n 缺点\n\n 无法避免消息丢失\n 只支持单消费者\n\n 基于PubSub的消息队列\n\n生产者向对应的cahnnel发送消息后，所有订阅者都能收到消息【一对多】\n\n SUBSCRIBE channel channel：订阅一个或多个频道\n PUSLISH channel msg：向一个频道发送消息\n PSUBSCRIBE pattern pattern：订阅与pattern格式匹配的所有频道\n\n 优点\n\n 采用发布订阅模型，支持多生产、多消费\n\n 缺点\n\n 不支持数据持久化\n 无法避免消息丢失\n 消息堆积有上限，超出时数据丢失\n\n 基于Stream类型消息队列\n\nstream是一种数据类型，专门为消息队列设计的，相较于前面两种方式能够更加完美实现一个消息队列\n\n生产消息：用于向指定的Stream流中添加一个消息\n\n\nXADD key ID value value ...\n\n 创建名为 users 的队列，并向其中发送一个消息，内容是：{name=jack,age=21}，并且使用Redis自动生成ID\n127.0.0.1:6379 XADD users  name jack age 21\n\"16448057005230\n\n\nkey就是消息队列，key不存在会自动创建（默认），ID是消息表示，value是消息的内容\n\n消费消息：\n\n\nXREAD COUNT count BLOCK milliseconds STREAMS key key ... ID ID\n\n 读取XREAD中的第一条消息\nXREAD COUNT 1 STREAMS users 0\n 阻塞1秒钟后从XREAD中读取的最新消息\nXREAD COUNT 1 BLOCK 1000 STREAMS users $\n\n\n注意：当我们指定起始ID为$时代表读取最后一条消息（读取最新的消息）ID为0时代表读最开始的一条消息（读取最旧的消息），如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题\n\n 特点\n\n 消息可回溯\n 一个消息可以被多个消费者读取\n 可以阻塞堆区\n 有消息漏读风险\n\n 消费者组\n\n上面我们介绍的消费方式都是单消费方式，容易发生消息堆积导致消息丢失，所以我们需要改用消费者组的模式\n\n消费者组：将多个消费者划分到一个组，监听同一队列\n\n 消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度\n 消息标识：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费\n 消息确认：消费者获取消息后，消息处于pending（待处理）状态，并存入一个pendinglist。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pendinglist移除。\n\n\n 创建消费者组\nXGROUP CREATE key groupName ID\n 删除指定的消费者组\nXGROUP DESTORY key groupName\n 给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupName consumerName\n 删除消费者组中指定消费者\nXGROUP DELCONSUMER key groupName consumerName\n 从消费者组中读取消息\nXREADGROUP GROUP\n\n\nhttps://imgblog.csdnimg.cn/imgconvert/27039c5d7c9c137c15bab614293a63fe.png\n\nhttps://imgblog.csdnimg.cn/imgconvert/c1ffb0ac9d815f997953b1dfeae6768f.png\n\nstream类型消息队列的XREADGROUP命令特点：\n\n 消息可回溯\n 可以多消费者争抢消息，加快消费速度\n 可以阻塞读取\n 没有消息漏读的风险\n 有消息确认机制，保证消息至少被消费一次\n\n 比较\n\nhttps://s21.ax1x.com/2024/03/11/pF6P3RK.png\n\n Feed流\n\n关注推送也叫投喂，为用户持续提供沉浸式体验，通过无限下拉刷新获取新的信息\n\n 与传统模式的区别\n\n 传统模式：用户寻找内容\n\n Feed模式：内容匹配用户\n\n Feed流常见的模式\n\n TimeLine：不做内容筛选，简单的按照内容发布时间排序，常用于好友或者关注\n 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容\n\n Feed流实现方案\n\nhttps://s11.ax1x.com/2024/01/19/pFAoHxO.png\n\n HyperLogLog用法\n\n首先搞懂两个概念\n\n UV：独立访客量，1天内一个用户多次访问该网站，只记录一次\n PV：页面访问量：用户多次打开页面，记录多次PV\n\nUV统计\n\n 优点：内存占用极小\n 缺点：存在0.81%的误差【不过可以完全忽略】\n\n 总结\n\n 2024116\n\n1、写了发短信验证码和登录接口，随机生成token，将用户信息存入redis中\n\n2、写了两个拦截器，一个拦截所有请求的token刷新拦截器【没有token直接放行，token中找不到数据直接放行，全部通过就存入UserHolder中】，一个是只拦截需要验证的登录拦截器【只需要检验UserHolder中是否有数据，有就通过，否则拦截】。\n\n3、对查询商品接口做了缓存，并且对缓存击穿【互斥锁】和缓存穿透【缓存空对象】做了处理，用jmeter进行检验\n\n 2024117\n\n1、 用逻辑过期时间解决缓存击穿【在shop中使用expire字段】，使用这个方法需要将热点key提前预热。通过比较当前时间和逻辑时间，而从决定是否需要重建数据。通过互斥锁来保证只有一个线程能够进入，通过独立线程来重构数据来减少响应时间\n\n2、创建了redis全局唯一ID生成器，通过符号位1位+时间错31位+序列号32位来形成一个唯一ID，但这样这个ID最大值并不满足总量的所需的范围要求，因此需要通过不同的key来生成序列号【通过加上年:月:日前缀】来保证每天的都有会不同的ID，这个最大值并不会超过一天所需的范围要求。\n\n3、写了优惠券秒杀功能，正常写法会出现超卖的情况，使用乐观锁优化后加上库存限制解决超卖问题【这里也可以用悲观锁解决，通过互斥锁或者同步代码】；使用悲观锁synchronized解决一人一单的问题，并用代理事务【AopContext.currentProxy】解决事务\t\n\n 2024118\n\n1、一人一单集群模式下使用分布式锁解决，分布式锁带来了一系列问题，比如：两个服务的synchronized userId.toString.intern获取的对象不一致【通过互斥锁解决】，误删【通过每次释放前判断存入锁的值是否一致解决】，原子性问题【释放锁的操作分为判断是否一致和释放锁，需要用Java调用写好的Lua脚本来确保原子性】\n\n2、整合Redisson，了解其可重入的原理，可重试锁原理、超时续约原理、主从一致性原理\n\n3、新增查询笔记、点赞笔记\n\n 2024119\n\n1、点赞排行榜【采用redis的zSet存储，按照时间戳排序】、关注、共同关注【set集合取两个集合的并集】\n\n2、使用Feed流，在博文发布的时候推送给关注自己的人\n\n3、签到：使用二进制位stringRedisTemplate.opsForValue.setBitkey, dayOfMonth  1, true;存储签到，签到了就是1，没签到就是0\n\n4、统计连续签到，通过stringRedisTemplate.opsForValue.bitField来获取 本月截至今天为止所有的签到记录\n\n 2024310\n\n1、优化优惠券秒杀逻辑，将原本对数据库的查询等判断条件全部放到Lua脚本中，改为从Reids中判断，极大的优化了查询的时间\n\n2、使用阻塞队列 + 线程池实现异步秒杀\n\n 2024311\n\n1、优化秒杀，使用Stream消息队列替换阻塞队列，能够弥补阻塞队列带来的问题，例如：内存上限，数据丢失等\n"}]