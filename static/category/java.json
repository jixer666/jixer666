[{"filename":"java-more","category":"java","md":{"topSummary":"\r\ntitle: Java的深入理解\r\ncategory: Java\r\ndate: 2024-07-05\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## ArryList 扩容机制\r\n\r\n下面是 ArryList 的 `add` 方法\r\n\r\n```java\r\n/**\r\n* 将指定的元素追加到此列表的末尾。\r\n*/\r\npublic boolean add(E e) {\r\n    // 加元素之前，先调用ensureCapacityInternal方法\r\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n    elementData[size++] = e;\r\n    return true;\r\n}\r\n```\r\n\r\n`ensureCapacityInternal` 方法代码如下：\r\n\r\n```java\r\n// 根据给定的最小容量和当前数组元素来计算所需容量。\r\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\r\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\r\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\r\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\r\n    }\r\n    // 否则直接返回最小容量\r\n    return minCapacity;\r\n}\r\n\r\n// 确保内部容量达到指定的最小容量。\r\nprivate void ensureCapacityInternal(int minCapacity) {\r\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\r\n}\r\n```\r\n\r\n`ensureExplicitCapacity` 代码如下：\r\n\r\n```java\r\n//判断是否需要扩容\r\nprivate void ensureExplicitCapacity(int minCapacity) {\r\n    modCount++;\r\n    //判断当前数组容量是否足以存储minCapacity个元素\r\n    if (minCapacity - elementData.length > 0)\r\n        //调用grow方法进行扩容\r\n        grow(minCapacity);\r\n}\r\n```\r\n\r\n`gorw` 扩容代码如下：\r\n\r\n```java\r\n/**\r\n * 要分配的最大数组大小\r\n */\r\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\r\n\r\n/**\r\n * ArrayList扩容的核心方法。\r\n */\r\nprivate void grow(int minCapacity) {\r\n    // oldCapacity为旧容量，newCapacity为新容量\r\n    int oldCapacity = elementData.length;\r\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n\r\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n\r\n    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\r\n    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\r\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n        newCapacity = hugeCapacity(minCapacity);\r\n\r\n    // minCapacity is usually close to size, so this is a win:\r\n    elementData = Arrays.copyOf(elementData, newCapacity);\r\n}\r\n```\r\n\r\n分析：\r\n\r\n1、当传入第1个元素的时候\r\n\r\n- 因为当前数组为空，所以 `if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)` 条件成立，返回默认值10\r\n- 此时的 `elementData.length` 长度为0，所以 ` if (minCapacity - elementData.length > 0)` 条件成立，会执行扩容\r\n- `newCapacity` 大小为0，`minCapacity` 大小为10，所以 `if (newCapacity - minCapacity < 0)` 条件成立，最后执行 `Arrays.copyOf` 对数组进行增加容量\r\n\r\n2、当传入到第11个元素的时候\r\n\r\n- `calculateCapacity` 返回的是 size + 1，也就是 10 + 1 = 11\r\n- 此时的 `elementData.length` 长度为10，所以 ` if (minCapacity - elementData.length > 0)` 条件成立，会执行扩容\r\n- `newCapacity` 大小为15，`minCapacity` 大小为10，所以方法的两个 if 语句都不会执行，最后执行 `Arrays.copyOf` 对数组进行增加容量\r\n\r\n扩容方法会对长度为0或者长度超 `int` 类型范围的时候进行特判，其他的长度都是扩大1.5倍\r\n\r\n ## HashMap\r\n\r\n### 扩容机制\r\n\r\n1、若没有自定义容量大小，会默认初始化大小为16。每次扩容都会变为原来的2倍\r\n\r\n2、若自定义了容量大小，会用给定的容量作为初始化大小。每次扩容都会变为原来的2的幂次方【为什么？**因为获取元素下标的方法是应该是`hash % length`，为了让 `hash % length == hash & (length - 1)` 的前提是 length 是 2 的 n 次方**】\r\n\r\n### 数据结构\r\n\r\n1、在 JDK 1.8之前，底层数据结构选用的是**数组 + 链表**。当加入键值对的时候，会先对键进行扰动函数处理得到 hash 值，然后通过 `(n - 1) & hash` 获取得到当前需要存放的位置，若元素以及存在，就覆盖，否则就拉链法解决冲突\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是**数组 + 链表/红黑树**。当加入键值对的时候，为了解决哈希冲突，当链表的长度8的时候，会将链表转为红黑树（在转红黑树之前，先会对数组长度进行判断，若长度小于64，会先将数组进行扩容）\r\n\r\n## ConcurrentHashMap\r\n\r\n### 容量\r\n\r\n1、在 JDK 1.7之前，若没指定大小，默认为16，且一旦确定就不可变\r\n\r\n2、在 JDK 1.18之后，若没指定大小，默认为16，可以进行扩容\r\n\r\n### 数据结构\r\n\r\n1、在JDK1.7之前，底层数据结构选用的是**分段数组 + 链表**，分段数组每段里都有一把锁（分段锁），每一把锁只锁当前的一段数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是**node 数组 + 链表/红黑树**，并发控制通过 `synchronized` 和 CAS 来操作，`synchronized` 只锁定当前链表或红黑二叉树的首节点，锁粒度更细","title":" Java的深入理解\r\n","category":[" Java\r\n"],"date":" 2024-07-05\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n ArryList 扩容机制\r\n\r\n下面是 ArryList 的 add 方法\r\n\r\njava\r\n/\r\n 将指定的元素追加到此列表的末尾。\r\n/\r\npublic boolean addE e {\r\n    // 加元素之前，先调用ensureCapacityInternal方法\r\n    ensureCapacityInternalsize + 1;  // Increments modCount\r\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n    elementDatasize++ = e;\r\n    return true;\r\n}\r\n\r\n\r\nensureCapacityInternal 方法代码如下：\r\n\r\njava\r\n// 根据给定的最小容量和当前数组元素来计算所需容量。\r\nprivate static int calculateCapacityObject elementData, int minCapacity {\r\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\r\n    if elementData == DEFAULTCAPACITYEMPTYELEMENTDATA {\r\n        return Math.maxDEFAULTCAPACITY, minCapacity;\r\n    }\r\n    // 否则直接返回最小容量\r\n    return minCapacity;\r\n}\r\n\r\n// 确保内部容量达到指定的最小容量。\r\nprivate void ensureCapacityInternalint minCapacity {\r\n    ensureExplicitCapacitycalculateCapacityelementData, minCapacity;\r\n}\r\n\r\n\r\nensureExplicitCapacity 代码如下：\r\n\r\njava\r\n//判断是否需要扩容\r\nprivate void ensureExplicitCapacityint minCapacity {\r\n    modCount++;\r\n    //判断当前数组容量是否足以存储minCapacity个元素\r\n    if minCapacity  elementData.length  0\r\n        //调用grow方法进行扩容\r\n        growminCapacity;\r\n}\r\n\r\n\r\ngorw 扩容代码如下：\r\n\r\njava\r\n/\r\n  要分配的最大数组大小\r\n /\r\nprivate static final int MAXARRAYSIZE = Integer.MAXVALUE  8;\r\n\r\n/\r\n  ArrayList扩容的核心方法。\r\n /\r\nprivate void growint minCapacity {\r\n    // oldCapacity为旧容量，newCapacity为新容量\r\n    int oldCapacity = elementData.length;\r\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n    int newCapacity = oldCapacity + oldCapacity  1;\r\n\r\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n    if newCapacity  minCapacity < 0\r\n        newCapacity = minCapacity;\r\n\r\n    // 如果新容量大于 MAXARRAYSIZE,进入执行 hugeCapacity 方法来比较 minCapacity 和 MAXARRAYSIZE，\r\n    // 如果minCapacity大于最大容量，则新容量则为Integer.MAXVALUE，否则，新容量大小则为 MAXARRAYSIZE 即为 Integer.MAXVALUE  8。\r\n    if newCapacity  MAXARRAYSIZE  0\r\n        newCapacity = hugeCapacityminCapacity;\r\n\r\n    // minCapacity is usually close to size, so this is a win:\r\n    elementData = Arrays.copyOfelementData, newCapacity;\r\n}\r\n\r\n\r\n分析：\r\n\r\n1、当传入第1个元素的时候\r\n\r\n 因为当前数组为空，所以 if elementData == DEFAULTCAPACITYEMPTYELEMENTDATA 条件成立，返回默认值10\r\n 此时的 elementData.length 长度为0，所以  if minCapacity  elementData.length  0 条件成立，会执行扩容\r\n newCapacity 大小为0，minCapacity 大小为10，所以 if newCapacity  minCapacity < 0 条件成立，最后执行 Arrays.copyOf 对数组进行增加容量\r\n\r\n2、当传入到第11个元素的时候\r\n\r\n calculateCapacity 返回的是 size + 1，也就是 10 + 1 = 11\r\n 此时的 elementData.length 长度为10，所以  if minCapacity  elementData.length  0 条件成立，会执行扩容\r\n newCapacity 大小为15，minCapacity 大小为10，所以方法的两个 if 语句都不会执行，最后执行 Arrays.copyOf 对数组进行增加容量\r\n\r\n扩容方法会对长度为0或者长度超 int 类型范围的时候进行特判，其他的长度都是扩大1.5倍\r\n\r\n  HashMap\r\n\r\n 扩容机制\r\n\r\n1、若没有自定义容量大小，会默认初始化大小为16。每次扩容都会变为原来的2倍\r\n\r\n2、若自定义了容量大小，会用给定的容量作为初始化大小。每次扩容都会变为原来的2的幂次方【为什么？因为获取元素下标的方法是应该是hash % length，为了让 hash % length == hash & length  1 的前提是 length 是 2 的 n 次方】\r\n\r\n 数据结构\r\n\r\n1、在 JDK 1.8之前，底层数据结构选用的是数组 + 链表。当加入键值对的时候，会先对键进行扰动函数处理得到 hash 值，然后通过 n  1 & hash 获取得到当前需要存放的位置，若元素以及存在，就覆盖，否则就拉链法解决冲突\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是数组 + 链表/红黑树。当加入键值对的时候，为了解决哈希冲突，当链表的长度8的时候，会将链表转为红黑树（在转红黑树之前，先会对数组长度进行判断，若长度小于64，会先将数组进行扩容）\r\n\r\n ConcurrentHashMap\r\n\r\n 容量\r\n\r\n1、在 JDK 1.7之前，若没指定大小，默认为16，且一旦确定就不可变\r\n\r\n2、在 JDK 1.18之后，若没指定大小，默认为16，可以进行扩容\r\n\r\n 数据结构\r\n\r\n1、在JDK1.7之前，底层数据结构选用的是分段数组 + 链表，分段数组每段里都有一把锁（分段锁），每一把锁只锁当前的一段数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是node 数组 + 链表/红黑树，并发控制通过 synchronized 和 CAS 来操作，synchronized 只锁定当前链表或红黑二叉树的首节点，锁粒度更细"},{"filename":"springsecurity-perms-control","category":"java","md":{"topSummary":"\ntitle: SpringSecurity权限控制\ncategory: Java,SpringCloud\ndate: 2024-06-18\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 前置说明\n\n必备知识：SpringSecurity 的使用\n\n提前准备：5个基本表（权限表、角色表、菜单表、角色权限表、角色菜单表），为了方便这里是展示必须的操作，数据库的操作返回的数据是直接模拟的\n\n## 步骤\n\n### 自定义登录逻辑\n\n加入 jar 包我们什么都不做，启动项目，访问任何接口会默认跳转到一个登录页面。我们现在需要做的就是不让他显示这个页面并且通过我们自己定义的登录接口实现认证\n\n定义 `SecurityConfig` 配置类，用来管理整个安全配置\n\n首先修改一下 `configure(HttpSecurity http)` 方法\n\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http\n            // CSRF禁用，因为不使用session\n            .csrf().disable()\n            // 禁用HTTP响应标头\n            .headers().cacheControl().disable().and()\n            // 基于token，所以不需要session\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n            // 过滤请求\n            .authorizeRequests()\n            // 对于登录login 注册register 验证码captchaImage 允许匿名访问\n            .antMatchers(\"/auth/login\", \"/auth/register\").permitAll()\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest().authenticated()\n            .and()\n            .headers().frameOptions().disable();\n}\n```\n\n开放 `/auth/login` 登录接口，自定义 AuthenticationManager 的建造器，并确定加密算法为 `BCryptPasswordEncoder` ，这个加密算法可以替换为 MD5 加密\n\n```java\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\n    auth.userDetailsService(customUserDetailService).passwordEncoder(new BCryptPasswordEncoder());\n}\n```\n\n注入 AuthenticationManager Bean，目的是为了让我们在自己的接口调用 `authenticationManager.authenticate()` 方法进行验证\n\n```java\n@Bean\n@Override\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n```\n\n下面写自己的登录接口，在登陆方法中调用 `authenticationManager.authenticate` 来实现验证，而调用这个方法会调用我们自定义实现的 `CustomUserDetailService` 类的 `loadUserByUsername` 方法\n\n```java\n@Autowired\nprivate AuthenticationManager authenticationManager;\n\n@Override\npublic String login(LoginForm loginForm) {\n    // 若有其他检验项也需要检查\n    Authentication authentication = null;\n    try {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginForm.getUsername(), loginForm.getPassword());\n        UserHolder.setContext(authenticationToken);\n        // 这里会调用 UserDetailService 接口的 loadUserByUsername 方法\n        authentication = authenticationManager.authenticate(authenticationToken);\n    } catch (Exception e){\n        e.printStackTrace();\n    } finally {\n        UserHolder.clearContext();\n    }\n    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n\n    return JwtUtil.createToken(loginUser.getUsername());\n}\n```\n\n自定义 `CustomUserDetailService` 类，实现 `UserDetailsService` 接口，为了让登录验证走我们自己的验证逻辑，判断账号密码，从而生成 Token\n\n注：这里的查询用户拥有的权限是模拟的，真实项目需要联表查询数据库\n\n```java\n@Service\npublic class CustomUserDetailService implements UserDetailsService{\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // 检验账号状态\n        // 查询数据库检验账户密码的正确性\n        // ...\n\n        Authentication context = UserHolder.getContext();\n        return new LoginUser(new User(context.getName(), new BCryptPasswordEncoder().encode(context.getCredentials().toString())),\n                getPermsList());\n    }\n\n    /**\n     * 模拟用户拥有的权限\n     * @return\n     */\n    private Set<String> getPermsList() {\n        Set<String> res = new HashSet<>();\n        res.add(\"user:t1\");\n        res.add(\"user:t2\");\n\n        return res;\n    }\n}\n```\n\n### 自定义认证失败处理\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n\n// 认证失败处理类\nhttp.exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint).and() \n```\n\n`CustomAuthenticationEntryPoint` 类就是我们自定义的认证失败的逻辑处理类，我们可以通过 response 返回失败的 Json 数据\n\n```java\n@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setStatus(HttpStatus.UNAUTHORIZED.value());\n        response.setContentType(\"application/json\");\n        response.setCharacterEncoding(\"utf-8\");\n\n        Map<String, String> res = new HashMap<>();\n        res.put(\"code\", \"401\");\n        res.put(\"msg\", \"认证失败，无法访问系统资源\");\n\n        response.getWriter().print(JSON.toJSON(res));\n    }\n}\n```\n\n### 自定义退出登录处理\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomLogoutSuccessHandler customLogoutSuccessHandler;\n\n// 自定义退出登录\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessHandler(customLogoutSuccessHandler);\n```\n\n这段代码的代码的意思当我们调用接口 `/logout` 会走 `CustomLogoutSuccessHandler` 处理逻辑，我们可以在里面清除用户相关的数据等操作，并返回相关的 Json 数据\n\n```java\n@Component\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        // 清除Redis缓存的用户数据\n        // 写入用户操作日志\n        // ...\n\n        response.setStatus(HttpStatus.OK.value());\n        response.setContentType(\"application/json\");\n        response.setCharacterEncoding(\"utf-8\");\n\n        Map<String, String> res = new HashMap<>();\n        res.put(\"code\", \"200\");\n        res.put(\"msg\", \"退出成功\");\n\n        response.getWriter().print(JSON.toJSON(res));\n    }\n}\n```\n\n### 自定义Token拦截器\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomJwtAuthenticationTokenFilter customJwtAuthenticationTokenFilter;\n\n// 自定义Token拦截器\nhttp.addFilterBefore(customJwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n这段代码的意思就是在 执行 `UsernamePasswordAuthenticationFilter` 之前执行我们定义的 `CustomJwtAuthenticationTokenFilter` Token 拦截器\n\n```java\n@Component\npublic class CustomJwtAuthenticationTokenFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        LoginUser loginUser = JwtUtil.getLoginUser(request);\n        if (Objects.nonNull(loginUser)){\n            // 检验成功，看是否需要刷新token\n             JwtUtil.verifyRefreshToken(loginUser);\n            // 将用户信息设置在SecurityContextHolder中\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());\n            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n            SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        }\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n这里需要将用户信息保存到 `SecurityContextHolder` 中，不保存的化它任然会走认证失败的逻辑\n\n### 自定义跨域配置\n\n实现跨域配置需要实现一个 CorsFilte 的 Bean\n\n```java\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsFilter corsFilter() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        // 设置访问源地址\n        config.addAllowedOriginPattern(\"*\");\n        // 设置访问源请求头\n        config.addAllowedHeader(\"*\");\n        // 设置访问源请求方法\n        config.addAllowedMethod(\"*\");\n        // 有效期 1800秒\n        config.setMaxAge(1800L);\n        // 添加映射路径，拦截一切请求\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        // 返回新的CorsFilter\n        return new CorsFilter(source);\n    }\n}\n```\n\n然后将这个 Bean 写入到安全配置中\n\n```java\n// 添加CORS filter\nhttp.addFilterBefore(corsFilter, CustomJwtAuthenticationTokenFilter.class);\nhttp.addFilterBefore(corsFilter, LogoutFilter.class);\n```\n\n\n\n### 自定义认证白名单\n\n对于接口的匿名认证有两种方式，一种是在代码中写入\n\n```java\nhttp.antMatchers(\"/auth/login\", \"/auth/register\").permitAll()\n```\n\n另一种是通过 yml 配置文件来读取写入，这里我就用后一种方法来演示\n\n新建一个白名单配置类，使用 `@ConfigurationProperties` 注解来表明配置文件的位置\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"security.ignored\")\npublic class IgnorePathConfig {\n\n    private List<String> paths = new ArrayList<>();\n\n    public List<String> getPaths() {\n        return paths;\n    }\n}\n```\n\n在 yml 配置文件中写入\n\n```yml\nsecurity: # 白名单路径\n  ignored:\n    paths:\n      - /auth/test\n```\n\n好了现在就差个将这个白名单配置写入安全配置中，通过遍历白名单，将路径设置为匿名访问\n\n```java\n@Autowired\nprivate IgnorePathConfig ignorePathConfig;\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    // 配置不需要保护的资源路径允许访问\n    ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry registry = http.authorizeRequests();\n    ignorePathConfig.getPaths().forEach(url -> registry.antMatchers(url).permitAll());\n\t// ...\n    // ...\n}\n```\n\n### 自定义动态权限控制\n\n这个动态权限控制说白了还是拦截器，将用户拥有的权限与路径所需要的权限作比较，若用户没有这个权限就走认证逻辑\n\n新建一个拦截器，继承 `AbstractSecurityInterceptor` 类，实现 `Filter` 接口\n\n```java\n@Component\npublic class CustomAbstractSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {\n\n    @Autowired\n    private IgnorePathConfig ignorePathConfig;\n\n    @Autowired\n    private CustomFilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;\n\n    @Autowired\n    public void setMyAccessDecisionManager(CustomAccessDecisionManager myAccessDecisionManager) {\n        super.setAccessDecisionManager(myAccessDecisionManager);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);\n        // OPTIONS请求直接放行\n        if(request.getMethod().equals(HttpMethod.OPTIONS.toString())){\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n            return;\n        }\n        // 白名单请求直接放行\n        PathMatcher pathMatcher = new AntPathMatcher();\n        for (String path : ignorePathConfig.getPaths()) {\n            if(pathMatcher.match(path,request.getRequestURI())){\n                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n                return;\n            }\n        }\n        // 此处会调用AccessDecisionManager中的decide方法进行鉴权操作\n        InterceptorStatusToken token = super.beforeInvocation(fi);\n        try {\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        } finally {\n            super.afterInvocation(token, null);\n        }\n    }\n\n    @Override\n    public Class<?> getSecureObjectClass() {\n        return FilterInvocation.class;\n    }\n\n    @Override\n    public SecurityMetadataSource obtainSecurityMetadataSource() {\n        return filterInvocationSecurityMetadataSource;\n    }\n}\n```\n\n这里将 OPTIONS 和白名单的请求直接放，然后就调用 `AccessDecisionManager` 中的decide方法进行鉴权操作，所以还需要自定以这个鉴权操作\n\n```java\n@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager {\n\n    @Override\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\n        // 当接口未被配置资源时直接放行\n        // configAttributes存在当前路径所需要的权限\n        if (CollUtil.isEmpty(configAttributes)) {\n            return;\n        }\n        Iterator<ConfigAttribute> iterator = configAttributes.iterator();\n        while (iterator.hasNext()) {\n            ConfigAttribute configAttribute = iterator.next();\n            // 将访问所需权限或用户拥有权限进行比对\n            // 用户的权限在登录的时候就会查询保存在Redis中，用户一访问就会根据token查询到权限，所以需要重写getAuthorities方法\n            String needAuthority = configAttribute.getAttribute();\n            System.out.println(\"需要的资源:\" + needAuthority);\n            System.out.println(\"拥有的资源:\" + authentication.getAuthorities());\n            for (GrantedAuthority grantedAuthority : authentication.getAuthorities()) {\n                if (needAuthority.trim().equals(grantedAuthority.getAuthority())) {\n                    return;\n                }\n            }\n        }\n        throw new AccessDeniedException(\"抱歉，您没有访问权限\");\n    }\n\n    @Override\n    public boolean supports(ConfigAttribute configAttribute) {\n        return true;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n}\n```\n\n这个鉴权是核心部分，就是判断用户是否拥有这个请求的权限\n\n那么问题来了：我们是如何知道路径的请求和它的请求权限的呢？\n\n注意在 `CustomAbstractSecurityInterceptor` 类中有个 `obtainSecurityMetadataSource` 方法\n\n```java\n@Override\npublic SecurityMetadataSource obtainSecurityMetadataSource() {\n    return filterInvocationSecurityMetadataSource;\n}\n```\n\n该对象用于读取数据库，获取请求对应的权限信息\n\n```java\n@Component\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {\n\n    private static Map<String, ConfigAttribute> configAttributeMap = null;\n\n    @Autowired\n    private CustomDynamicSecurityService myDynamicSecurityService;\n\n    @PostConstruct\n    public void loadDataSource() {\n        configAttributeMap = myDynamicSecurityService.loadDataSource();\n    }\n\n    public void clearDataSource() {\n        configAttributeMap.clear();\n        configAttributeMap = null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {\n        // 若不存在就先加载（一般都是存在的，因为启动项目的时候已经加载好了）\n        if (configAttributeMap == null) {\n            this.loadDataSource();\n        }\n        List<ConfigAttribute> configAttributes = new ArrayList<>();\n        // 获取当前访问的路径\n        String url = ((FilterInvocation) o).getRequestUrl();\n        String path = URLUtil.getPath(url);\n        PathMatcher pathMatcher = new AntPathMatcher();\n        Iterator<String> iterator = configAttributeMap.keySet().iterator();\n        // 匹配当前路径所需的权限，若当前路径需要某个权限就加入configAttributes中\n        while (iterator.hasNext()) {\n            String pattern = iterator.next();\n            if (pathMatcher.match(pattern, path)) {\n                configAttributes.add(configAttributeMap.get(pattern));\n            }\n        }\n        // 未设置操作请求权限，返回空集合\n        return configAttributes;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return true;\n    }\n}\n```\n\nconfigAttributeMap 是个 Map，键存放的路径，值存放的是权限\n\n这里需要返回 `Collection<ConfigAttribute>` 集合，就获取当前的路径，遍历从数据查询的所有路径的权限，依次匹配，看当前的路径是否需要权限，若需要有就加入 `configAttributes`\n\n`CustomDynamicSecurityService` 是个接口，具体实现需要在用户层实现，因为需要用到 mapper 方法的调用\n\n```java\npublic interface CustomDynamicSecurityService {\n    /**\n     * 加载资源ANT通配符和资源对应MAP\n     * 这里Bean注入需要用到用户模块的权限信息，所以在用户模块注入\n     * 只要与启动项目就回会运行\n     */\n    Map<String, ConfigAttribute>  ();\n}\n```\n\n在用户层中定义一个Bean，实现 `loadDataSource` 方法，同样的，这里的查询权限的数据也是模拟的，真实项目中需要查询数据库\n\n权限说明：访问 `/auth/t1` 接口需要 `user:t1` 权限，其他的同理\n\n```java\n@Bean\npublic CustomDynamicSecurityService dynamicSecurityService() {\n    return new CustomDynamicSecurityService() {\n        @Override\n        public Map<String, ConfigAttribute> loadDataSource() {\n            Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();\n            // 查询所有权限列表\n            // 这里模拟数据\n            map.put(\"/auth/t1\", new org.springframework.security.access.SecurityConfig(\"user:t1\"));\n            map.put(\"/auth/t2\", new org.springframework.security.access.SecurityConfig(\"user:t2\"));\n            map.put(\"/auth/t3\", new org.springframework.security.access.SecurityConfig(\"user:t3\"));\n\n            return map;\n        }\n    };\n}\n```\n\n好了，到这里就结束了，通过重写方法一系列的方法，拦截请求的路径，根据数据库查询的所有的权限，匹配到这个请求路径所需要的权限，再根据用户的权限来匹配，若用户有该权限就放行，否则就拦截\n\n## 代码\n\nGitee：[https://gitee.com/lijunxi666/further-use-of-spring-security](https://gitee.com/lijunxi666/further-use-of-spring-security)","title":" SpringSecurity权限控制\n","category":[" Java","SpringCloud\n"],"date":" 2024-06-18\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 前置说明\n\n必备知识：SpringSecurity 的使用\n\n提前准备：5个基本表（权限表、角色表、菜单表、角色权限表、角色菜单表），为了方便这里是展示必须的操作，数据库的操作返回的数据是直接模拟的\n\n 步骤\n\n 自定义登录逻辑\n\n加入 jar 包我们什么都不做，启动项目，访问任何接口会默认跳转到一个登录页面。我们现在需要做的就是不让他显示这个页面并且通过我们自己定义的登录接口实现认证\n\n定义 SecurityConfig 配置类，用来管理整个安全配置\n\n首先修改一下 configureHttpSecurity http 方法\n\njava\n@Override\nprotected void configureHttpSecurity http throws Exception {\n    http\n            // CSRF禁用，因为不使用session\n            .csrf.disable\n            // 禁用HTTP响应标头\n            .headers.cacheControl.disable.and\n            // 基于token，所以不需要session\n            .sessionManagement.sessionCreationPolicySessionCreationPolicy.STATELESS.and\n            // 过滤请求\n            .authorizeRequests\n            // 对于登录login 注册register 验证码captchaImage 允许匿名访问\n            .antMatchers\"/auth/login\", \"/auth/register\".permitAll\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest.authenticated\n            .and\n            .headers.frameOptions.disable;\n}\n\n\n开放 /auth/login 登录接口，自定义 AuthenticationManager 的建造器，并确定加密算法为 BCryptPasswordEncoder ，这个加密算法可以替换为 MD5 加密\n\njava\n@Override\nprotected void configureAuthenticationManagerBuilder auth throws Exception {\n    auth.userDetailsServicecustomUserDetailService.passwordEncodernew BCryptPasswordEncoder;\n}\n\n\n注入 AuthenticationManager Bean，目的是为了让我们在自己的接口调用 authenticationManager.authenticate 方法进行验证\n\njava\n@Bean\n@Override\npublic AuthenticationManager authenticationManagerBean throws Exception {\n    return super.authenticationManagerBean;\n}\n\n\n下面写自己的登录接口，在登陆方法中调用 authenticationManager.authenticate 来实现验证，而调用这个方法会调用我们自定义实现的 CustomUserDetailService 类的 loadUserByUsername 方法\n\njava\n@Autowired\nprivate AuthenticationManager authenticationManager;\n\n@Override\npublic String loginLoginForm loginForm {\n    // 若有其他检验项也需要检查\n    Authentication authentication = null;\n    try {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationTokenloginForm.getUsername, loginForm.getPassword;\n        UserHolder.setContextauthenticationToken;\n        // 这里会调用 UserDetailService 接口的 loadUserByUsername 方法\n        authentication = authenticationManager.authenticateauthenticationToken;\n    } catch Exception e{\n        e.printStackTrace;\n    } finally {\n        UserHolder.clearContext;\n    }\n    LoginUser loginUser = LoginUser authentication.getPrincipal;\n\n    return JwtUtil.createTokenloginUser.getUsername;\n}\n\n\n自定义 CustomUserDetailService 类，实现 UserDetailsService 接口，为了让登录验证走我们自己的验证逻辑，判断账号密码，从而生成 Token\n\n注：这里的查询用户拥有的权限是模拟的，真实项目需要联表查询数据库\n\njava\n@Service\npublic class CustomUserDetailService implements UserDetailsService{\n\n    @Override\n    public UserDetails loadUserByUsernameString username throws UsernameNotFoundException {\n        // 检验账号状态\n        // 查询数据库检验账户密码的正确性\n        // ...\n\n        Authentication context = UserHolder.getContext;\n        return new LoginUsernew Usercontext.getName, new BCryptPasswordEncoder.encodecontext.getCredentials.toString,\n                getPermsList;\n    }\n\n    /\n      模拟用户拥有的权限\n      @return\n     /\n    private Set<String getPermsList {\n        Set<String res = new HashSet<;\n        res.add\"user:t1\";\n        res.add\"user:t2\";\n\n        return res;\n    }\n}\n\n\n 自定义认证失败处理\n\n在 SecurityConfig 配置类中修改，添加一句话\n\njava\n@Autowired\nprivate CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n\n// 认证失败处理类\nhttp.exceptionHandling.authenticationEntryPointcustomAuthenticationEntryPoint.and \n\n\nCustomAuthenticationEntryPoint 类就是我们自定义的认证失败的逻辑处理类，我们可以通过 response 返回失败的 Json 数据\n\njava\n@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {\n    @Override\n    public void commenceHttpServletRequest request, HttpServletResponse response, AuthenticationException authException throws IOException, ServletException {\n        response.setStatusHttpStatus.UNAUTHORIZED.value;\n        response.setContentType\"application/json\";\n        response.setCharacterEncoding\"utf8\";\n\n        Map<String, String res = new HashMap<;\n        res.put\"code\", \"401\";\n        res.put\"msg\", \"认证失败，无法访问系统资源\";\n\n        response.getWriter.printJSON.toJSONres;\n    }\n}\n\n\n 自定义退出登录处理\n\n在 SecurityConfig 配置类中修改，添加一句话\n\njava\n@Autowired\nprivate CustomLogoutSuccessHandler customLogoutSuccessHandler;\n\n// 自定义退出登录\nhttp.logout.logoutUrl\"/logout\".logoutSuccessHandlercustomLogoutSuccessHandler;\n\n\n这段代码的代码的意思当我们调用接口 /logout 会走 CustomLogoutSuccessHandler 处理逻辑，我们可以在里面清除用户相关的数据等操作，并返回相关的 Json 数据\n\njava\n@Component\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccessHttpServletRequest request, HttpServletResponse response, Authentication authentication throws IOException, ServletException {\n        // 清除Redis缓存的用户数据\n        // 写入用户操作日志\n        // ...\n\n        response.setStatusHttpStatus.OK.value;\n        response.setContentType\"application/json\";\n        response.setCharacterEncoding\"utf8\";\n\n        Map<String, String res = new HashMap<;\n        res.put\"code\", \"200\";\n        res.put\"msg\", \"退出成功\";\n\n        response.getWriter.printJSON.toJSONres;\n    }\n}\n\n\n 自定义Token拦截器\n\n在 SecurityConfig 配置类中修改，添加一句话\n\njava\n@Autowired\nprivate CustomJwtAuthenticationTokenFilter customJwtAuthenticationTokenFilter;\n\n// 自定义Token拦截器\nhttp.addFilterBeforecustomJwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class;\n\n\n这段代码的意思就是在 执行 UsernamePasswordAuthenticationFilter 之前执行我们定义的 CustomJwtAuthenticationTokenFilter Token 拦截器\n\njava\n@Component\npublic class CustomJwtAuthenticationTokenFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternalHttpServletRequest request, HttpServletResponse response, FilterChain filterChain throws ServletException, IOException {\n        LoginUser loginUser = JwtUtil.getLoginUserrequest;\n        if Objects.nonNullloginUser{\n            // 检验成功，看是否需要刷新token\n             JwtUtil.verifyRefreshTokenloginUser;\n            // 将用户信息设置在SecurityContextHolder中\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationTokenloginUser, null, loginUser.getAuthorities;\n            authenticationToken.setDetailsnew WebAuthenticationDetailsSource.buildDetailsrequest;\n            SecurityContextHolder.getContext.setAuthenticationauthenticationToken;\n        }\n        filterChain.doFilterrequest, response;\n    }\n}\n\n\n这里需要将用户信息保存到 SecurityContextHolder 中，不保存的化它任然会走认证失败的逻辑\n\n 自定义跨域配置\n\n实现跨域配置需要实现一个 CorsFilte 的 Bean\n\njava\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsFilter corsFilter {\n        CorsConfiguration config = new CorsConfiguration;\n        config.setAllowCredentialstrue;\n        // 设置访问源地址\n        config.addAllowedOriginPattern\"\";\n        // 设置访问源请求头\n        config.addAllowedHeader\"\";\n        // 设置访问源请求方法\n        config.addAllowedMethod\"\";\n        // 有效期 1800秒\n        config.setMaxAge1800L;\n        // 添加映射路径，拦截一切请求\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource;\n        source.registerCorsConfiguration\"/\", config;\n        // 返回新的CorsFilter\n        return new CorsFiltersource;\n    }\n}\n\n\n然后将这个 Bean 写入到安全配置中\n\njava\n// 添加CORS filter\nhttp.addFilterBeforecorsFilter, CustomJwtAuthenticationTokenFilter.class;\nhttp.addFilterBeforecorsFilter, LogoutFilter.class;\n\n\n\n\n 自定义认证白名单\n\n对于接口的匿名认证有两种方式，一种是在代码中写入\n\njava\nhttp.antMatchers\"/auth/login\", \"/auth/register\".permitAll\n\n\n另一种是通过 yml 配置文件来读取写入，这里我就用后一种方法来演示\n\n新建一个白名单配置类，使用 @ConfigurationProperties 注解来表明配置文件的位置\n\njava\n@Component\n@ConfigurationPropertiesprefix = \"security.ignored\"\npublic class IgnorePathConfig {\n\n    private List<String paths = new ArrayList<;\n\n    public List<String getPaths {\n        return paths;\n    }\n}\n\n\n在 yml 配置文件中写入\n\nyml\nsecurity:  白名单路径\n  ignored:\n    paths:\n       /auth/test\n\n\n好了现在就差个将这个白名单配置写入安全配置中，通过遍历白名单，将路径设置为匿名访问\n\njava\n@Autowired\nprivate IgnorePathConfig ignorePathConfig;\n\n@Override\nprotected void configureHttpSecurity http throws Exception {\n    // 配置不需要保护的资源路径允许访问\n    ExpressionUrlAuthorizationConfigurer<HttpSecurity.ExpressionInterceptUrlRegistry registry = http.authorizeRequests;\n    ignorePathConfig.getPaths.forEachurl  registry.antMatchersurl.permitAll;\n\t// ...\n    // ...\n}\n\n\n 自定义动态权限控制\n\n这个动态权限控制说白了还是拦截器，将用户拥有的权限与路径所需要的权限作比较，若用户没有这个权限就走认证逻辑\n\n新建一个拦截器，继承 AbstractSecurityInterceptor 类，实现 Filter 接口\n\njava\n@Component\npublic class CustomAbstractSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {\n\n    @Autowired\n    private IgnorePathConfig ignorePathConfig;\n\n    @Autowired\n    private CustomFilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;\n\n    @Autowired\n    public void setMyAccessDecisionManagerCustomAccessDecisionManager myAccessDecisionManager {\n        super.setAccessDecisionManagermyAccessDecisionManager;\n    }\n\n    @Override\n    public void doFilterServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain throws IOException, ServletException {\n        HttpServletRequest request = HttpServletRequest servletRequest;\n        FilterInvocation fi = new FilterInvocationservletRequest, servletResponse, filterChain;\n        // OPTIONS请求直接放行\n        ifrequest.getMethod.equalsHttpMethod.OPTIONS.toString{\n            fi.getChain.doFilterfi.getRequest, fi.getResponse;\n            return;\n        }\n        // 白名单请求直接放行\n        PathMatcher pathMatcher = new AntPathMatcher;\n        for String path : ignorePathConfig.getPaths {\n            ifpathMatcher.matchpath,request.getRequestURI{\n                fi.getChain.doFilterfi.getRequest, fi.getResponse;\n                return;\n            }\n        }\n        // 此处会调用AccessDecisionManager中的decide方法进行鉴权操作\n        InterceptorStatusToken token = super.beforeInvocationfi;\n        try {\n            fi.getChain.doFilterfi.getRequest, fi.getResponse;\n        } finally {\n            super.afterInvocationtoken, null;\n        }\n    }\n\n    @Override\n    public Class<? getSecureObjectClass {\n        return FilterInvocation.class;\n    }\n\n    @Override\n    public SecurityMetadataSource obtainSecurityMetadataSource {\n        return filterInvocationSecurityMetadataSource;\n    }\n}\n\n\n这里将 OPTIONS 和白名单的请求直接放，然后就调用 AccessDecisionManager 中的decide方法进行鉴权操作，所以还需要自定以这个鉴权操作\n\njava\n@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager {\n\n    @Override\n    public void decideAuthentication authentication, Object object, Collection<ConfigAttribute configAttributes throws AccessDeniedException, InsufficientAuthenticationException {\n        // 当接口未被配置资源时直接放行\n        // configAttributes存在当前路径所需要的权限\n        if CollUtil.isEmptyconfigAttributes {\n            return;\n        }\n        Iterator<ConfigAttribute iterator = configAttributes.iterator;\n        while iterator.hasNext {\n            ConfigAttribute configAttribute = iterator.next;\n            // 将访问所需权限或用户拥有权限进行比对\n            // 用户的权限在登录的时候就会查询保存在Redis中，用户一访问就会根据token查询到权限，所以需要重写getAuthorities方法\n            String needAuthority = configAttribute.getAttribute;\n            System.out.println\"需要的资源:\" + needAuthority;\n            System.out.println\"拥有的资源:\" + authentication.getAuthorities;\n            for GrantedAuthority grantedAuthority : authentication.getAuthorities {\n                if needAuthority.trim.equalsgrantedAuthority.getAuthority {\n                    return;\n                }\n            }\n        }\n        throw new AccessDeniedException\"抱歉，您没有访问权限\";\n    }\n\n    @Override\n    public boolean supportsConfigAttribute configAttribute {\n        return true;\n    }\n\n    @Override\n    public boolean supportsClass<? aClass {\n        return true;\n    }\n}\n\n\n这个鉴权是核心部分，就是判断用户是否拥有这个请求的权限\n\n那么问题来了：我们是如何知道路径的请求和它的请求权限的呢？\n\n注意在 CustomAbstractSecurityInterceptor 类中有个 obtainSecurityMetadataSource 方法\n\njava\n@Override\npublic SecurityMetadataSource obtainSecurityMetadataSource {\n    return filterInvocationSecurityMetadataSource;\n}\n\n\n该对象用于读取数据库，获取请求对应的权限信息\n\njava\n@Component\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {\n\n    private static Map<String, ConfigAttribute configAttributeMap = null;\n\n    @Autowired\n    private CustomDynamicSecurityService myDynamicSecurityService;\n\n    @PostConstruct\n    public void loadDataSource {\n        configAttributeMap = myDynamicSecurityService.loadDataSource;\n    }\n\n    public void clearDataSource {\n        configAttributeMap.clear;\n        configAttributeMap = null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute getAttributesObject o throws IllegalArgumentException {\n        // 若不存在就先加载（一般都是存在的，因为启动项目的时候已经加载好了）\n        if configAttributeMap == null {\n            this.loadDataSource;\n        }\n        List<ConfigAttribute configAttributes = new ArrayList<;\n        // 获取当前访问的路径\n        String url = FilterInvocation o.getRequestUrl;\n        String path = URLUtil.getPathurl;\n        PathMatcher pathMatcher = new AntPathMatcher;\n        Iterator<String iterator = configAttributeMap.keySet.iterator;\n        // 匹配当前路径所需的权限，若当前路径需要某个权限就加入configAttributes中\n        while iterator.hasNext {\n            String pattern = iterator.next;\n            if pathMatcher.matchpattern, path {\n                configAttributes.addconfigAttributeMap.getpattern;\n            }\n        }\n        // 未设置操作请求权限，返回空集合\n        return configAttributes;\n    }\n\n    @Override\n    public Collection<ConfigAttribute getAllConfigAttributes {\n        return null;\n    }\n\n    @Override\n    public boolean supportsClass<? clazz {\n        return true;\n    }\n}\n\n\nconfigAttributeMap 是个 Map，键存放的路径，值存放的是权限\n\n这里需要返回 Collection<ConfigAttribute 集合，就获取当前的路径，遍历从数据查询的所有路径的权限，依次匹配，看当前的路径是否需要权限，若需要有就加入 configAttributes\n\nCustomDynamicSecurityService 是个接口，具体实现需要在用户层实现，因为需要用到 mapper 方法的调用\n\njava\npublic interface CustomDynamicSecurityService {\n    /\n      加载资源ANT通配符和资源对应MAP\n      这里Bean注入需要用到用户模块的权限信息，所以在用户模块注入\n      只要与启动项目就回会运行\n     /\n    Map<String, ConfigAttribute  ;\n}\n\n\n在用户层中定义一个Bean，实现 loadDataSource 方法，同样的，这里的查询权限的数据也是模拟的，真实项目中需要查询数据库\n\n权限说明：访问 /auth/t1 接口需要 user:t1 权限，其他的同理\n\njava\n@Bean\npublic CustomDynamicSecurityService dynamicSecurityService {\n    return new CustomDynamicSecurityService {\n        @Override\n        public Map<String, ConfigAttribute loadDataSource {\n            Map<String, ConfigAttribute map = new ConcurrentHashMap<;\n            // 查询所有权限列表\n            // 这里模拟数据\n            map.put\"/auth/t1\", new org.springframework.security.access.SecurityConfig\"user:t1\";\n            map.put\"/auth/t2\", new org.springframework.security.access.SecurityConfig\"user:t2\";\n            map.put\"/auth/t3\", new org.springframework.security.access.SecurityConfig\"user:t3\";\n\n            return map;\n        }\n    };\n}\n\n\n好了，到这里就结束了，通过重写方法一系列的方法，拦截请求的路径，根据数据库查询的所有的权限，匹配到这个请求路径所需要的权限，再根据用户的权限来匹配，若用户有该权限就放行，否则就拦截\n\n 代码\n\nGitee：https://gitee.com/lijunxi666/furtheruseofspringsecurityhttps://gitee.com/lijunxi666/furtheruseofspringsecurity"},{"filename":"jvm","category":"java","md":{"topSummary":"\ntitle: JVM知识点总结\ncategory: Java\ndate: 2024-05-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n参考文章：[JavaGuide](https://javaguide.cn/java/jvm/memory-area.html) 和 黑马程序员笔记\n\n## 运行时数据区域\n\n**JDK1.7**\n\n1、线程共享：堆（包括字符串常量池），方法区（包括运行时常量池，使用的是永久代空间）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：直接内存\n\n**JDK1.8**\n\n1、线程共享：堆（包括字符串常量池）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：元空间（包括运行时常量池）、直接内存\n\n### 程序计数器\n\n一小块固定的内存空间，每个线程的程序计数器不会相互影响，独立存储。随着线程的创建而创建，随着线程的结束而死亡，所以程序计数器**不会出现内存溢出的情况**\n\n有两个作用：\n\n- 控制程序指令的进行，实现代码的流程控制\n- 在多线程下，程序计数器记录了当前线程执行的位置，以便于在线程执行完后切换回来能够返回到当前位置\n\n### Java虚拟机栈\n\nJava虚拟机栈中存放了一个个栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法返回地址。随着线程的创建而创建，随着线程的结束而死亡。\n\n每个方法调用都会有一个对应的栈帧压入栈中，调用结束后，都会有一个栈帧被弹出。\n\n可能出现的两种错误：\n\n- 当在循环条件下进行调用的话会导致栈中被压入太多栈帧而占用空间，当超过Java虚拟机最大深度的时候会报出`StackOverFlowError`的错误。\n- 当栈内存可以动态拓展的时候，如果虚拟机无法申请到足够的内存空间会报出`OutOfMemoryError`错误\n\n#### 局部变量表\n\n存放编译时可知的基本数据类型、对象类型。\n\n#### 操作数栈\n\n存放方法执行过程中产生的中间计算结果，也存放临时变量。\n\n#### 动态链接\n\n主要用在当一个方法调用另一个方法的时候，需要将 Class 文件常量池中的符号引用转为内存地址的直接引用。\n\n### 本地方法栈\n\n与Java虚拟栈不同的是：Java虚拟机栈存放的是Java方法栈帧，而本地方法栈存放的是Native方法栈帧。\n\n### 堆\n\n最大的一块内存区域，主要存放的是**对象实例以及数组**（局部变量表中存放的是堆上对象的引用）。\n\n**几乎所有的对象都在堆上分配内存**，但是随着技术升级，如果某些方法中的对象没有被外部使用或者没有被返回，那么对象可以直接在Java虚拟机栈上分配内存。\n\n### 方法区\n\n方法区存放类的元信息（类的基本信息、字段信息、变量信息等），还包括运行时常量池、字符串常量池(JDK7之前)\n\nJDK1.8之前方法区实现是永久代空间，存放在堆区域中\n\nJDK1.8之后方法区实现是元空间，存放在直接内存区域中\n\n> 方法区与永久代和元空间的关系就像是接口和实现类的关系，方法区是接口，永久代和元空间是实现类\n\n### 运行时常量池\n\n方法区的一部分，存放编译期生成的各种字面量和符号引用\n\n### 字符串常量池\n\n方法区的一部分，存放常量字符串内容\n\n主要目的是为了避免字符串的重复创建\n\n#### 与运行时常量池的关系\n\nJDK7之前：运行时常量池包括字符串常量池，方法区实现为永久代\n\nJDK7：字符串常量池从方法区拿到堆中，运行时常量池剩下的还在方法区的永久代中\n\nJDK8之后：方法区用元空间替换了永久代空间，字符串常量池还在堆中\n\n### 直接内存\n\n一种特殊的内存缓冲区\n\n## 垃圾回收\n\nJava的自动内存管理主要针对对象内存回收和对象内存分配，最核心的功能是堆内存中对象的回收和分配\n\nJava堆是垃圾收集器管理的主要区域，因此也被称作**GC堆**\n\n### 堆空间基本结构\n\nJava堆分为不同的 区域，根据各个区域的特点选择合适的垃圾收集算法\n\n**JDK1.7：**\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、永久代：PerGen\n\n**JDK1.8：**\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、元空间：MetaSpace\n\n### 垃圾回收流程\n\n大部分情况，对象首先在Eden区域分配内存，若在一次新生代垃圾回收后，该对象还存活，就将它放到S0或S1并将年龄加1。当再一次一次新生代垃圾回收后，若对象任然存在，那么就回将当前存活的对象放到另一个地方（若当前是 S0，就放到 S1；若是 S1，就放到 S0）并将年龄加1，当年龄增加到默认值阈值（15）的时候，会将对象晋升至老年代中。若老年代空间不足，会触发 Full GC 对整个堆进行垃圾回收。若 Full GC 无法回收老年代的对象，那么当对象继续放入老年代时，就会抛出 `Out Of Memory` 异常。\n\n> 年龄是0-15的原因：年龄记录区域大小通常是4位，最大的二进制表示是1111，也就是15。\n\n### 对象判断死亡的方法\n\n当一个对象可以被回收，不一定代表一定会被回收！对象回收至少需要经过两次标记的过程，可达分析法是第一次筛选，筛选的条件是对象是否有必要执行`finalize`方法（若对象没有覆盖`finalize`方法或 `finalize` 方法已经被虚拟机调用过，就说明没有执行的必要），将需要执行的对象放在一个队列中进行第二次筛选，当这个对象与引用链上任意一个对象相关联，就不会回收，否则就会回收。\n\n#### 引用计数法\n\n给对象添加一个引用计数器，当对象被引用的时候就，计数器就加1，当引用消失的时候，引用就减1。当引用为0的时候就说明对象可以被回收\n\n优点：实现简单\n\n缺点：1、每次对象引用和取消都需要维护一下，影响系统的性能。2、当出现A引用B，同时B引用A的情况，也就是循环引用时会出现无法回收的问题\n\n#### 可达性分析算法\n\n用一个GC ROOT座作为根节点，与每个有引用的对象相连接，若对象到GC ROOT没有连接就说明对象可以被回收。\n\n**常见的GC ROOT：**\n\n- 虚拟机栈(栈帧中的局部变量表)中引用的对象\n- 本地方法栈(Native 方法)中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 所有被同步锁持有的对象\n- JNI（Java Native Interface）引用的对象\n\n### 引用类型\n\n#### 强引用\n\n大部分使用的引用都是强引用，垃圾回收器绝不会回收此类引用\n\n#### 软引用\n\n软引用通过`SoftReference`类实现，若系统内存不足，就会回收它，若内存足够，就不管。\n\n软引用可以用来实现内存敏感的高速缓存\n\n软引用可以和一个引用对象联合使用，若软引用的对象被垃圾回收，就会放到与之关联的引用队列中，通过遍历引用队列，将`SoftReference`的强引用删除\n\n#### 弱引用\n\n只具有弱引用的对象拥有更短暂的生命周期\n\n不管系统内存是否足够，只要发现是弱引用，就可能被垃圾回收。但是垃圾回收器是一个优先级很低的线程，不一定发现得了弱引用\n\n与软引用类似，弱引用可以和一个引用对象联合使用，若弱引用的对象被垃圾回收，就会放到与之关联的引用队列中\n\n#### 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n### 垃圾回收算法\n\n#### 标记-清除法\n\n标记出不需要回收的对象，在标记完后统一回收没有标记的对象\n\n优点：实现简单\n\n缺点：1、碎片化问题，没有标志的内存不连续，标记清除后会产生大量不连续的内存碎片。2、标记和清除两个过程效率都不高\n\n**实现过程：**\n\n1、对象被创建的时候，标记为0\n\n2、在标记阶段，将所有可达的对象标记为1\n\n3、扫描阶段，清除所有标记为0的对象\n\n#### 复制算法\n\n将内存分为相同的两块，每次使用其中的一块，当进行了垃圾回收后，将存活的对象移到另一块未使用的内存，然后将使用的内存一次性清除掉，这样每次回收都是内存的一半\n\n优点：解决了碎片化问题\n\n缺点：1、可用内存减小为原来的一般。2、存活对象数量多的化复制性能就变得很差\n\n#### 标记-整理算法\n\n过程与标记-清除算法类似，但是它标记后并不会回收对象，而是让存活的对象移动到另一端，清除掉段边界以外的内存\n\n#### 分代收集算法\n\n当前虚拟机都采用的这种算法，可以根据年代的特点进行使用不同的回收算法\n\n例如在新生代中，每次收集都会有大量对象死去，所以就采用标记-复制算法（只需要少部分复制成本就能完成对象收集），老年代中的对象存活率较高，所以就采用标记-整理或者标记-清除算法\n\n### 垃圾收集器\n\n如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是内存回收后的实现\n\n#### Serial收集器\n\n单线程收集器，在进行垃圾收集的时候会停止掉所有的工作线程，直到它收集结束\n\n优点就是简单高效，没有线程交互的开销\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### ParNew收集器\n\nParNew收集器是Serial收集器的多线程版本\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### Parallel Scavenge收集器\n\nParallel Scavenge收集器看上去和ParNew收集器都一样，不同点是Parallel Scavenge收集器关注点是吞吐量（高效率的的利用CPU），而CMS等收集器关注点是用户线程的停顿时间（提高用户体验）\n\nParallel Scavenge收集器提供很多参数供用户找到最合适的停顿时间或最大吞吐量\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### Serial Old收集器\n\nSerial收集器的老年代版本，主要有两大用途：\n\n1、JDK1.5版本之前与Parallel Scavenge收集器配合使用\n\n2、作为CMS收集器的后备方案\n\n#### Parallel Old收集器\n\nParallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法\n\n> 在关注吞吐量和CPU资源的场景下，可以优先考虑Parallel Scavenge收集器和Parallel Old收集器\n\n#### CMS收集器\n\n一款老年代收集器，可以分配新生代的 Serial 和 ParNew 收集器一起使用\n\n**一种以获取最短回收时间为目的的收集器，注重用户体验，能够实现GC和用户线程（基本上）同时进行**\n\n执行过程：\n\n1、初始标记：暂停所有其他的线程，快速记录与root相连接的对象\n\n2、并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象（但是这个闭包结构并不能将所有的可达对象都记录，因为用户线程在不断的更新引用域，GC线程无法保证可达分析的及时性）\n\n3、重新标记：修正并发标记的阶段因为用户线程继续运行而导致标记产生变动的那一部分对象标记记录\n\n4、清除标记：开启用户线程，同时GC线程对未标记的区域作清扫（垃圾回收）\n\n优点：并发收集，低停顿\n\n缺点：1、对CPU资源敏感。2、无法处理浮动垃圾。3、会产生大量空间碎片\n\n采用的算法：**标记-清除算法**\n\n**CMS 垃圾回收器在 Java 9 中已经被标记为过时，并在 Java 14 中被移除**\n\n#### G1收集器\n\n收集范围是新生代和老年代收，不需要结合其他收集器使用\n\n一款面向服务器的垃圾收集器，满足 GC 停顿时间要求的同时，还具备高吞吐量的特性\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region\n\n执行过程：1、初始标记。2、并发标记。3、最终标记。4、筛选回收。\n\n优点：1、并发与并行。2、分代收集。3、空间整理（整体上看是标记-整理算法，局部来看是标记-复制算法）4、可预测的停顿。\n\n**从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器**\n\n#### ZGC收集器\n\n与ParNew和G1类似，ZGC也采用标记-复制算法，但是ZGC做了重大改进：可以将暂停时间控制在几毫秒内，且暂停时间不受堆内存大小的影响\n\n## 类文件结构\n\n### 魔数\n\n每个Class文件的头4个字节称为魔数，通过这4个字节来确定一个文件的类型\n\nJava文件为kj0xcadebabe\n\n### Class文件版本号\n\n接着魔数的第5个和第6个此节表示的是**次版本号**，第7和第8个字节是**主版本号**\n\n通过这个版本号能够计算出JDK版本\n\nJDK1.2之后的版本计算方法：主版本号 - 44\n\n### 常量池\n\n接着主次版本号之后就是常量池，常量池存放：**字面量**和**符号引用**\n\n### 访问标志\n\n接常量池之后，紧挨着的两个字节代表访问标志\n\n访问标志用于识别一些类或接口的信息：这个Class是类还是接口，是 `public `还是 `private` 等\n\n### 当前类、父类、接口索引集合\n\nJava 类的继承关系由类索引、父类索引和接口索引集合三项确定\n\n### 字段表集合\n\n字段表用于描述接口或类中声明的变量，但不包括方法内的局部变量\n\n字段表结构：访问标志、名称索引、描述符索引、属性表集合\n\n### 方法集合\n\n字段表用于描述接口或类中声明的方法\n\n与字段表结构类似，但是与字段表不同的是少了 `volatile` 修饰符和 `transient` 修饰符这两个不可以修饰方法的访问标志，增加了`synchronized`、`native`、`abstract`等关键字修饰方法\n\n### 属性表集合\n\n字段表、方法表中都存在自己的属性表集合，以用于描述某些场景专有的信息\n\n## 类的加载过程\n\n### 类的生命周期\n\n加载->连接（验证->准备->解析）->初始化->使用->卸载\n\n### 加载\n\n这一阶段由**类加载器**完成，主要是完成下面三件事：\n\n1、通过全类名获取二进制流\n\n2、在方法去保存一个InstanceKClass对象，保存类的所有信息\n\n3、同时还会在堆上生成与方法区类似的java.lang.Class对象，作为方法区这些数据的访问入口\n\n加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了\n\n### 连接\n\n#### 验证\n\n检验字节码文件是否遵守了《Java虚拟机规范》的约束要求\n\n检查的部分：\n\n1、文件格式验证（Class文件格式）\n\n2、元数据验证（字节码语义）\n\n3、字节码验证（程序语义）\n\n4、符号引用验证（类的正确性）\n\n#### 准备\n\n正式的为类变量分配内存并设置类变量初始值\n\n#### 解析\n\n将常量池内的符号引用替换为直接引用\n\n### 初始化\n\n执行初始化方法（cinit）\n\n以下几种情况会进行类初始化\n\n1、当遇到 `new`、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条字节码指令时\n\n2、使用 `java.lang.reflect` 包的方法对类进行反射调用时\n\n3、初始化一个类，如果其父类还未初始化，则先触发该父类的初始化\n\n4、执行Main方法的当前类\n\n....\n\n以下几种情况不会进行类初始化\n\n1、无静态代码块且无静态变量赋值语句\n\n2、有静态变量的声明，但是没有赋值语句，如：`private static int a;`\n\n3、静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化，如：`private final static int a = 10;`\n\n### 卸载\n\n类的Class对象被GC\n\n## 类加载器\n\n### 介绍\n\n 类加载器的主要作用就是加载Java类的字节码（.Class文件）到JVM中（在内存中生成一个代表类的Class对象）\n\nJVM内置的三个重要类加载器：\n\n- **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载器，由C++实现，通常为null（因为C++实现的类加载器在Java无与之对应的类），无父类，用来加载JDK内部的核心类库\n- **`ExtensionClassLoader`(扩展类加载器)**：加载/jre/lib/ext下的类文件\n- **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类\n\n执行流程图：\n![](https://img2.imgtp.com/2024/05/20/fYIF5GzX.png)\n\n### 双亲委派模型\n\n类加载器有很多种，当我们需要加载一个类的时候需要哪一个类加载器呢？这时候就需要用到双亲委派模型了\n\n#### 执行流程\n\n执行流程集中在ClassLoader的loadClass方法中\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        //首先，检查该类是否已经加载过\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            //如果 c 为 null，则说明该类没有被加载过\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                    //当父类的加载器不为空，则通过父类的loadClass来加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                    //当父类的加载器为空，则调用启动类加载器来加载该类\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                //非空父类的类加载器无法找到相应的类，则抛出异常\n            }\n\n            if (c == null) {\n                //当父类加载器无法加载时，则调用findClass方法来加载该类\n                //用户可通过覆写该方法，来自定义类加载器\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                //用于统计类加载器相关的信息\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            //对类进行link操作\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n**总结：首先类加载器先判断自己是否已经加载过这个类了，若已经加载就直接返回，否则自己先不会加载，而是让父类加载器进行加载，只有当前父类加载器也没法加载的时候，自己才加载**\n\n由此可知，判断两个类是否相同，不但要看类的全名是否一致，还要看类加载器是否一致\n\n#### 打破双亲委派模型\n\n**1、自定义类加载器**\n\n自定义类加载器需要继承`ClassLoader`类，若不想打破双亲委派机制就重写`ClassLoder`类的`findClass`方法，若想打破，就重写`loadClass`方法（因为类加载器进行类加载的时候，会先调用父类加载器的`loadClass`方法，改变了传统双亲委派模型的执行流程）\n\n**2、线程上下文类加载器**\n\n有些时候，高层的类加载器需要加载底层的类加载才能加载的类\n\n例如：JDBC就是由启动类加载器委派应用类加载器去加载类的方式\n\n- 启动类加载器加载DriverManager\n- 在初始化DriverManager时，通过SPI机制加载jar中的msql驱动\n- SPI利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象\n\n获取线程线程上下文类加载器的代码：\n\n```java\nClassLoader cl = Thread.currentThread().getContextClassLoader();\n```\n\n**3、Osgi框架的类加载器**\n","title":" JVM知识点总结\n","category":[" Java\n"],"date":" 2024-05-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n参考文章：JavaGuidehttps://javaguide.cn/java/jvm/memoryarea.html 和 黑马程序员笔记\n\n 运行时数据区域\n\nJDK1.7\n\n1、线程共享：堆（包括字符串常量池），方法区（包括运行时常量池，使用的是永久代空间）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：直接内存\n\nJDK1.8\n\n1、线程共享：堆（包括字符串常量池）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：元空间（包括运行时常量池）、直接内存\n\n 程序计数器\n\n一小块固定的内存空间，每个线程的程序计数器不会相互影响，独立存储。随着线程的创建而创建，随着线程的结束而死亡，所以程序计数器不会出现内存溢出的情况\n\n有两个作用：\n\n 控制程序指令的进行，实现代码的流程控制\n 在多线程下，程序计数器记录了当前线程执行的位置，以便于在线程执行完后切换回来能够返回到当前位置\n\n Java虚拟机栈\n\nJava虚拟机栈中存放了一个个栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法返回地址。随着线程的创建而创建，随着线程的结束而死亡。\n\n每个方法调用都会有一个对应的栈帧压入栈中，调用结束后，都会有一个栈帧被弹出。\n\n可能出现的两种错误：\n\n 当在循环条件下进行调用的话会导致栈中被压入太多栈帧而占用空间，当超过Java虚拟机最大深度的时候会报出StackOverFlowError的错误。\n 当栈内存可以动态拓展的时候，如果虚拟机无法申请到足够的内存空间会报出OutOfMemoryError错误\n\n 局部变量表\n\n存放编译时可知的基本数据类型、对象类型。\n\n 操作数栈\n\n存放方法执行过程中产生的中间计算结果，也存放临时变量。\n\n 动态链接\n\n主要用在当一个方法调用另一个方法的时候，需要将 Class 文件常量池中的符号引用转为内存地址的直接引用。\n\n 本地方法栈\n\n与Java虚拟栈不同的是：Java虚拟机栈存放的是Java方法栈帧，而本地方法栈存放的是Native方法栈帧。\n\n 堆\n\n最大的一块内存区域，主要存放的是对象实例以及数组（局部变量表中存放的是堆上对象的引用）。\n\n几乎所有的对象都在堆上分配内存，但是随着技术升级，如果某些方法中的对象没有被外部使用或者没有被返回，那么对象可以直接在Java虚拟机栈上分配内存。\n\n 方法区\n\n方法区存放类的元信息（类的基本信息、字段信息、变量信息等），还包括运行时常量池、字符串常量池JDK7之前\n\nJDK1.8之前方法区实现是永久代空间，存放在堆区域中\n\nJDK1.8之后方法区实现是元空间，存放在直接内存区域中\n\n 方法区与永久代和元空间的关系就像是接口和实现类的关系，方法区是接口，永久代和元空间是实现类\n\n 运行时常量池\n\n方法区的一部分，存放编译期生成的各种字面量和符号引用\n\n 字符串常量池\n\n方法区的一部分，存放常量字符串内容\n\n主要目的是为了避免字符串的重复创建\n\n 与运行时常量池的关系\n\nJDK7之前：运行时常量池包括字符串常量池，方法区实现为永久代\n\nJDK7：字符串常量池从方法区拿到堆中，运行时常量池剩下的还在方法区的永久代中\n\nJDK8之后：方法区用元空间替换了永久代空间，字符串常量池还在堆中\n\n 直接内存\n\n一种特殊的内存缓冲区\n\n 垃圾回收\n\nJava的自动内存管理主要针对对象内存回收和对象内存分配，最核心的功能是堆内存中对象的回收和分配\n\nJava堆是垃圾收集器管理的主要区域，因此也被称作GC堆\n\n 堆空间基本结构\n\nJava堆分为不同的 区域，根据各个区域的特点选择合适的垃圾收集算法\n\nJDK1.7：\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、永久代：PerGen\n\nJDK1.8：\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、元空间：MetaSpace\n\n 垃圾回收流程\n\n大部分情况，对象首先在Eden区域分配内存，若在一次新生代垃圾回收后，该对象还存活，就将它放到S0或S1并将年龄加1。当再一次一次新生代垃圾回收后，若对象任然存在，那么就回将当前存活的对象放到另一个地方（若当前是 S0，就放到 S1；若是 S1，就放到 S0）并将年龄加1，当年龄增加到默认值阈值（15）的时候，会将对象晋升至老年代中。若老年代空间不足，会触发 Full GC 对整个堆进行垃圾回收。若 Full GC 无法回收老年代的对象，那么当对象继续放入老年代时，就会抛出 Out Of Memory 异常。\n\n 年龄是015的原因：年龄记录区域大小通常是4位，最大的二进制表示是1111，也就是15。\n\n 对象判断死亡的方法\n\n当一个对象可以被回收，不一定代表一定会被回收！对象回收至少需要经过两次标记的过程，可达分析法是第一次筛选，筛选的条件是对象是否有必要执行finalize方法（若对象没有覆盖finalize方法或 finalize 方法已经被虚拟机调用过，就说明没有执行的必要），将需要执行的对象放在一个队列中进行第二次筛选，当这个对象与引用链上任意一个对象相关联，就不会回收，否则就会回收。\n\n 引用计数法\n\n给对象添加一个引用计数器，当对象被引用的时候就，计数器就加1，当引用消失的时候，引用就减1。当引用为0的时候就说明对象可以被回收\n\n优点：实现简单\n\n缺点：1、每次对象引用和取消都需要维护一下，影响系统的性能。2、当出现A引用B，同时B引用A的情况，也就是循环引用时会出现无法回收的问题\n\n 可达性分析算法\n\n用一个GC ROOT座作为根节点，与每个有引用的对象相连接，若对象到GC ROOT没有连接就说明对象可以被回收。\n\n常见的GC ROOT：\n\n 虚拟机栈栈帧中的局部变量表中引用的对象\n 本地方法栈Native 方法中引用的对象\n 方法区中类静态属性引用的对象\n 方法区中常量引用的对象\n 所有被同步锁持有的对象\n JNI（Java Native Interface）引用的对象\n\n 引用类型\n\n 强引用\n\n大部分使用的引用都是强引用，垃圾回收器绝不会回收此类引用\n\n 软引用\n\n软引用通过SoftReference类实现，若系统内存不足，就会回收它，若内存足够，就不管。\n\n软引用可以用来实现内存敏感的高速缓存\n\n软引用可以和一个引用对象联合使用，若软引用的对象被垃圾回收，就会放到与之关联的引用队列中，通过遍历引用队列，将SoftReference的强引用删除\n\n 弱引用\n\n只具有弱引用的对象拥有更短暂的生命周期\n\n不管系统内存是否足够，只要发现是弱引用，就可能被垃圾回收。但是垃圾回收器是一个优先级很低的线程，不一定发现得了弱引用\n\n与软引用类似，弱引用可以和一个引用对象联合使用，若弱引用的对象被垃圾回收，就会放到与之关联的引用队列中\n\n 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n 垃圾回收算法\n\n 标记清除法\n\n标记出不需要回收的对象，在标记完后统一回收没有标记的对象\n\n优点：实现简单\n\n缺点：1、碎片化问题，没有标志的内存不连续，标记清除后会产生大量不连续的内存碎片。2、标记和清除两个过程效率都不高\n\n实现过程：\n\n1、对象被创建的时候，标记为0\n\n2、在标记阶段，将所有可达的对象标记为1\n\n3、扫描阶段，清除所有标记为0的对象\n\n 复制算法\n\n将内存分为相同的两块，每次使用其中的一块，当进行了垃圾回收后，将存活的对象移到另一块未使用的内存，然后将使用的内存一次性清除掉，这样每次回收都是内存的一半\n\n优点：解决了碎片化问题\n\n缺点：1、可用内存减小为原来的一般。2、存活对象数量多的化复制性能就变得很差\n\n 标记整理算法\n\n过程与标记清除算法类似，但是它标记后并不会回收对象，而是让存活的对象移动到另一端，清除掉段边界以外的内存\n\n 分代收集算法\n\n当前虚拟机都采用的这种算法，可以根据年代的特点进行使用不同的回收算法\n\n例如在新生代中，每次收集都会有大量对象死去，所以就采用标记复制算法（只需要少部分复制成本就能完成对象收集），老年代中的对象存活率较高，所以就采用标记整理或者标记清除算法\n\n 垃圾收集器\n\n如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是内存回收后的实现\n\n Serial收集器\n\n单线程收集器，在进行垃圾收集的时候会停止掉所有的工作线程，直到它收集结束\n\n优点就是简单高效，没有线程交互的开销\n\n采用的算法：新生代采用标记复制算法，老年代采用标记整理算法。\n\n ParNew收集器\n\nParNew收集器是Serial收集器的多线程版本\n\n采用的算法：新生代采用标记复制算法，老年代采用标记整理算法。\n\n Parallel Scavenge收集器\n\nParallel Scavenge收集器看上去和ParNew收集器都一样，不同点是Parallel Scavenge收集器关注点是吞吐量（高效率的的利用CPU），而CMS等收集器关注点是用户线程的停顿时间（提高用户体验）\n\nParallel Scavenge收集器提供很多参数供用户找到最合适的停顿时间或最大吞吐量\n\n采用的算法：新生代采用标记复制算法，老年代采用标记整理算法。\n\n Serial Old收集器\n\nSerial收集器的老年代版本，主要有两大用途：\n\n1、JDK1.5版本之前与Parallel Scavenge收集器配合使用\n\n2、作为CMS收集器的后备方案\n\n Parallel Old收集器\n\nParallel Scavenge收集器的老年代版本，使用多线程和标记整理算法\n\n 在关注吞吐量和CPU资源的场景下，可以优先考虑Parallel Scavenge收集器和Parallel Old收集器\n\n CMS收集器\n\n一款老年代收集器，可以分配新生代的 Serial 和 ParNew 收集器一起使用\n\n一种以获取最短回收时间为目的的收集器，注重用户体验，能够实现GC和用户线程（基本上）同时进行\n\n执行过程：\n\n1、初始标记：暂停所有其他的线程，快速记录与root相连接的对象\n\n2、并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象（但是这个闭包结构并不能将所有的可达对象都记录，因为用户线程在不断的更新引用域，GC线程无法保证可达分析的及时性）\n\n3、重新标记：修正并发标记的阶段因为用户线程继续运行而导致标记产生变动的那一部分对象标记记录\n\n4、清除标记：开启用户线程，同时GC线程对未标记的区域作清扫（垃圾回收）\n\n优点：并发收集，低停顿\n\n缺点：1、对CPU资源敏感。2、无法处理浮动垃圾。3、会产生大量空间碎片\n\n采用的算法：标记清除算法\n\nCMS 垃圾回收器在 Java 9 中已经被标记为过时，并在 Java 14 中被移除\n\n G1收集器\n\n收集范围是新生代和老年代收，不需要结合其他收集器使用\n\n一款面向服务器的垃圾收集器，满足 GC 停顿时间要求的同时，还具备高吞吐量的特性\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region\n\n执行过程：1、初始标记。2、并发标记。3、最终标记。4、筛选回收。\n\n优点：1、并发与并行。2、分代收集。3、空间整理（整体上看是标记整理算法，局部来看是标记复制算法）4、可预测的停顿。\n\n从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器\n\n ZGC收集器\n\n与ParNew和G1类似，ZGC也采用标记复制算法，但是ZGC做了重大改进：可以将暂停时间控制在几毫秒内，且暂停时间不受堆内存大小的影响\n\n 类文件结构\n\n 魔数\n\n每个Class文件的头4个字节称为魔数，通过这4个字节来确定一个文件的类型\n\nJava文件为kj0xcadebabe\n\n Class文件版本号\n\n接着魔数的第5个和第6个此节表示的是次版本号，第7和第8个字节是主版本号\n\n通过这个版本号能够计算出JDK版本\n\nJDK1.2之后的版本计算方法：主版本号  44\n\n 常量池\n\n接着主次版本号之后就是常量池，常量池存放：字面量和符号引用\n\n 访问标志\n\n接常量池之后，紧挨着的两个字节代表访问标志\n\n访问标志用于识别一些类或接口的信息：这个Class是类还是接口，是 public 还是 private 等\n\n 当前类、父类、接口索引集合\n\nJava 类的继承关系由类索引、父类索引和接口索引集合三项确定\n\n 字段表集合\n\n字段表用于描述接口或类中声明的变量，但不包括方法内的局部变量\n\n字段表结构：访问标志、名称索引、描述符索引、属性表集合\n\n 方法集合\n\n字段表用于描述接口或类中声明的方法\n\n与字段表结构类似，但是与字段表不同的是少了 volatile 修饰符和 transient 修饰符这两个不可以修饰方法的访问标志，增加了synchronized、native、abstract等关键字修饰方法\n\n 属性表集合\n\n字段表、方法表中都存在自己的属性表集合，以用于描述某些场景专有的信息\n\n 类的加载过程\n\n 类的生命周期\n\n加载连接（验证准备解析）初始化使用卸载\n\n 加载\n\n这一阶段由类加载器完成，主要是完成下面三件事：\n\n1、通过全类名获取二进制流\n\n2、在方法去保存一个InstanceKClass对象，保存类的所有信息\n\n3、同时还会在堆上生成与方法区类似的java.lang.Class对象，作为方法区这些数据的访问入口\n\n加载阶段与连接阶段的部分动作如一部分字节码文件格式验证动作是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了\n\n 连接\n\n 验证\n\n检验字节码文件是否遵守了《Java虚拟机规范》的约束要求\n\n检查的部分：\n\n1、文件格式验证（Class文件格式）\n\n2、元数据验证（字节码语义）\n\n3、字节码验证（程序语义）\n\n4、符号引用验证（类的正确性）\n\n 准备\n\n正式的为类变量分配内存并设置类变量初始值\n\n 解析\n\n将常量池内的符号引用替换为直接引用\n\n 初始化\n\n执行初始化方法（cinit）\n\n以下几种情况会进行类初始化\n\n1、当遇到 new、 getstatic、putstatic 或 invokestatic 这 4 条字节码指令时\n\n2、使用 java.lang.reflect 包的方法对类进行反射调用时\n\n3、初始化一个类，如果其父类还未初始化，则先触发该父类的初始化\n\n4、执行Main方法的当前类\n\n....\n\n以下几种情况不会进行类初始化\n\n1、无静态代码块且无静态变量赋值语句\n\n2、有静态变量的声明，但是没有赋值语句，如：private static int a;\n\n3、静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化，如：private final static int a = 10;\n\n 卸载\n\n类的Class对象被GC\n\n 类加载器\n\n 介绍\n\n 类加载器的主要作用就是加载Java类的字节码（.Class文件）到JVM中（在内存中生成一个代表类的Class对象）\n\nJVM内置的三个重要类加载器：\n\n BootstrapClassLoader启动类加载器：最顶层的加载器，由C++实现，通常为null（因为C++实现的类加载器在Java无与之对应的类），无父类，用来加载JDK内部的核心类库\n ExtensionClassLoader扩展类加载器：加载/jre/lib/ext下的类文件\n AppClassLoader应用程序类加载器：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类\n\n执行流程图：\nhttps://img2.imgtp.com/2024/05/20/fYIF5GzX.png\n\n 双亲委派模型\n\n类加载器有很多种，当我们需要加载一个类的时候需要哪一个类加载器呢？这时候就需要用到双亲委派模型了\n\n 执行流程\n\n执行流程集中在ClassLoader的loadClass方法中\n\njava\nprotected Class<? loadClassString name, boolean resolve\n    throws ClassNotFoundException\n{\n    synchronized getClassLoadingLockname {\n        //首先，检查该类是否已经加载过\n        Class c = findLoadedClassname;\n        if c == null {\n            //如果 c 为 null，则说明该类没有被加载过\n            long t0 = System.nanoTime;\n            try {\n                if parent = null {\n                    //当父类的加载器不为空，则通过父类的loadClass来加载该类\n                    c = parent.loadClassname, false;\n                } else {\n                    //当父类的加载器为空，则调用启动类加载器来加载该类\n                    c = findBootstrapClassOrNullname;\n                }\n            } catch ClassNotFoundException e {\n                //非空父类的类加载器无法找到相应的类，则抛出异常\n            }\n\n            if c == null {\n                //当父类加载器无法加载时，则调用findClass方法来加载该类\n                //用户可通过覆写该方法，来自定义类加载器\n                long t1 = System.nanoTime;\n                c = findClassname;\n\n                //用于统计类加载器相关的信息\n                sun.misc.PerfCounter.getParentDelegationTime.addTimet1  t0;\n                sun.misc.PerfCounter.getFindClassTime.addElapsedTimeFromt1;\n                sun.misc.PerfCounter.getFindClasses.increment;\n            }\n        }\n        if resolve {\n            //对类进行link操作\n            resolveClassc;\n        }\n        return c;\n    }\n}\n\n\n总结：首先类加载器先判断自己是否已经加载过这个类了，若已经加载就直接返回，否则自己先不会加载，而是让父类加载器进行加载，只有当前父类加载器也没法加载的时候，自己才加载\n\n由此可知，判断两个类是否相同，不但要看类的全名是否一致，还要看类加载器是否一致\n\n 打破双亲委派模型\n\n1、自定义类加载器\n\n自定义类加载器需要继承ClassLoader类，若不想打破双亲委派机制就重写ClassLoder类的findClass方法，若想打破，就重写loadClass方法（因为类加载器进行类加载的时候，会先调用父类加载器的loadClass方法，改变了传统双亲委派模型的执行流程）\n\n2、线程上下文类加载器\n\n有些时候，高层的类加载器需要加载底层的类加载才能加载的类\n\n例如：JDBC就是由启动类加载器委派应用类加载器去加载类的方式\n\n 启动类加载器加载DriverManager\n 在初始化DriverManager时，通过SPI机制加载jar中的msql驱动\n SPI利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象\n\n获取线程线程上下文类加载器的代码：\n\njava\nClassLoader cl = Thread.currentThread.getContextClassLoader;\n\n\n3、Osgi框架的类加载器\n"},{"filename":"javaweb","category":"java","md":{"topSummary":"\ntitle: JavaWeb学习笔记\ncategory: Java,Servlet\ndate: 2024-01-17\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## JDBC\n\n介绍：java用来连接和操作数据库\n\n**注意：最后千万别忘掉关闭资源**\n\n### 快速上手\n\n前提需要导入mysql jar包\n\n```\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo {\n    public static void main(String[] args) throws Exception{\n//        注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n//        获取链接\n//        useServerPrepStmts=true开启预编译功能\n        String url = \"jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"123456\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n//        执行语句\n        String sql = \"update jdbc_test set password = 12121 where username = 1\";\n//        获取执行对象\n        Statement statement = conn.createStatement();\n//        返回影响行数\n        int count = statement.executeUpdate(sql);\n        System.out.println(count);\n//        释放资源\n        conn.close();\n        statement.close();\n    }\n}\n```\n\n### API\n\n#### DriverManager\n\n通过`DriverManager.getConnection(url, username, password)`来得到一个Connection对象，代表与数据库连接成功\n\n#### Connection\n\n获取执行sql对象\n\n- 通过调用`createStatemen()`方法获取一个Statement对象\n- 通过调用`prepareStatement()`方法获取一个PrepareStatement对象\n\n事务管理\n\n- 通过调用`setAutoCommit(false)`方法来来关闭自动提交事务\n- 通过调用`sqlSession.commit()`方法来回滚事务\n- 通过调用`rollback()`方法来回滚事务\n\n事务管理就是关闭自动提交事务过后，执行的语句中若出现错误就会立刻回滚事务，一个都不执行；若语句执行完后没有提交事务，他也会回滚事务；\n\n#### Statement\n\n代表执行对象\n\n- 通过调用`executeUpdate(sql)`来对数据进行增删改，返回受影响的行数（int）\n- 通过调用`executeQuery(sql)`来对数据进行查询,返回一个ResultSet对象\n\n#### PreparedStatement\n\n代表执行对象，可以防止sql注入\n\n需要在sql语句中传参的位置用?占位符代替，调用setInt/setString(出现的位置, 需要代替的字符或者数字)来替换?，这样做的原理是使敏感字符用\\\\带转义，让它变为一个字符，不参与sql作用。\n\n例如：\n\n```\nString name = \"1\";\nString pas = \"'or '1' ='1\"; // sql注入代码\n String sql = \"select * from jdbc_test where username = '\"+name+\"' and password = '\"+pas+\"'\";\nStatement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(sql);\n```\n\n这样写的sql语句为`select * from jdbc_test where username = '1' and passwor`d = ''or '1' ='1'，这样的sql语句一定为真，导致sql注入\n\n改进过后代码\n\n```\nString sql = \"select * from jdbc_test where username = ? and password = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setString(1, name);\npreparedStatement.setString(2, pas);\n```\n\n这样的sql为`select * from jdbc_test where username = '1' and password = '\\'or \\'1\\' =\\'1\\'`就不会出现sql注入问题\n\n#### ResultSet\n\n主要有两个重要的方法\n\n- 调用`next()`来判断是否下一行数据是否存在\n- 调用`getString(\"1\")/getInt(\"id\")`来输出改行数据的第1列或者列名为id的数据\n\n## Druid\n\ndruid使阿里巴巴开源的数据库连接池，可以进行多个用户连接，一开始就开了几个Connetion连接，用完并不会关闭而是返回连接池等待下一个用户；而不是用一个开一次连接，用完就关闭，导致浪费时间。\n\n需要引入druid和mysql jar包\n\n与jdbc不同的是这里需要一个Properties配置文件来配置数据库连接池信息\n\n```\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=123456\n# 初始化连接数量\ninitialSize=5\n# 最大连接数\nmaxActive=10\n# 最大等待时间\nmaxWait=3000\n```\n\n```\n// 加载配置文件\nProperties prop = new Properties();\n// System.out.println(System.getProperty(\"user.dir\"));  获取当前目录是src\nprop.load(new FileInputStream(\"jdbc_demo/src/druid.properties\"));\n```\n\n调用`DruidDataSourceFactory.createDataSource(prop)`返回一个DataSource对象，这个DataSource可以调用`getConnection()`来获取数据库连接返回一个Connection对象，拿到这个对象后的操作方法与上面一样\n\n## Mybaits\n\nMybats是JDBC框架，免除了几乎所有JDBC代码以及设置参数和获取结果集的工作\n\n**注意：别忘记关闭SqlSession开启的资源**\n\n### 目录\n\n![](../../.vuepress/public/assets/article/javaweb/QQ图片20230106061547.png)\n\njava下单UserMapper为接口文件，resource下的UserMapper为Mapper的xml文件（存放sql数据）。\n\n### **mybatis-config的配置**\n\n放在resources目录下\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n<!-- default为默认选取的数据库，这样写可以切换不同的数据库，对应environment的id-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n<!-- 事务管理方式，采用JDBC-->\n            <transactionManager type=\"JDBC\"/>\n<!-- 数据库连接池-->\n            <dataSource type=\"POOLED\">\n<!-- 数据库的连接信息-->\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql:///test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n<!-- 加载sql映射文件-->\n<!-- <mapper resource=\"com/ljx/mapper/UserMapper.xml\"/>-->\n\n<!-- mapper代理方式，扫包，若还有多个如BrandMapper,....不需要一个一个添加sql映射文件，-->\n        <package name=\"com.ljx.mapper\"/>\n    </mappers>\n</configuration>\n```\n\n加载配置文件，获取sqlSessionFactory对象\n\n```\nString resource = \"mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\n获取SqlSession对象，继承了Conntection的事务管理\n\n```\nSqlSession sqlSession = sqlSessionFactory.openSession();\n```\n\n获得UserMapper接口代理对象\n\n```\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n```\n\n接着就可以调用UserMapper的接口了（例如）\n\n```\nList<User> users = userMapper.selectAll();\n```\n\n**注意：除了查询，其他的增删改均需要事务提交**`sqlSession.commit();`\n\n### **XXXMapper的配置**\n\n放在resources/com/ljx/mapper目录下，与java里面的目录相对应\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace命名空间：为mapper的全限名，为java目录下mapper接口的地址，用来对应mapper-->\n<!--resultType返回类型，com.ljx.pojo.User是User类的文件地址-->\n<mapper namespace=\"com.ljx.mapper.UserMapper\"></mapper>\n```\n\n#### select标签\n\n普通查找\n\n```\n<select id=\"selectAll\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user;\n</select>\n```\n\n含有敏感字符查找\n\n```\n <!-- #{}占位符，会将其替换为?，为了防止sql注入，${}占位符，拼接sql，会存在sql注入问题-->\n<!-- 如遇到特殊字符如：<，则会报错，因为xml小于是一种开始的格式，需要处理\n        1.转移字符：&lt;\n        2.CDATA区：<![CDATA[ < ]]>，其中<![CDATA[内容]]>里可以写多个字符\n-->\n    <select id=\"selectId\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user\n        where id <![CDATA[ < ]]> #{id};\n    </select>\n```\n\n多条件查询\n\n```\n<select id=\"selectMore\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user\n        where id = #{id}\n           and gender = #{gender};\n</select>\n```\n\n动态查询\n\n```\n<!--动态条件查询sql-->\n<!-- 并不是所有的参数都需要传入-->\n<!-- if标签，存在问题：第一个if若不存在就会出错。-->\n<!-- 解决：1、添加 1=1  2、用where标签替换where语句，若条件存在就会自动去掉and-->\n<select id=\"selectNiu\" resultType=\"com.ljx.pojo.User\">\n    select * from tb_user\n    <where>\n        <if test=\"username != null and username != ''\">and username = #{username}</if>\n        <if test=\"id != null\">and id = #{id}</if>\n    </where>\n</select>\n```\n\n单条件查询\n\n```\n<!--单条件动态查询-->\n<!-- choose标签相当于switch，when标签相当于case，test里放的是条件-->\n<!-- otherwise相当于default，若没有满足的条件就执行这个语句，否则不执行-->\n<select id=\"selectDan\" resultType=\"com.ljx.pojo.User\">\n    select * from tb_user\n    where\n    <choose>\n        <when test=\"username != null and username != ''\">username = #{username}</when>\n        <when test=\"id != null\">id = #{id}</when>\n        <otherwise>1 = 1</otherwise>\n        </choose>\n</select>\n```\n\n#### insert标签\n\n```\n<!-- useGeneratedKeys=\"true\" keyProperty=\"id\" 返回添加数据id-->\n<insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into tb_user (username, password, gender, addr)\n    values (#{username}, #{password}, #{gender}, #{addr})\n</insert>\n```\n\n#### updated标签\n\n普通修改\n\n```\n<update id=\"updated\">\n    update tb_user\n    set username = #{username},\n        password = #{password},\n        gender = #{gender},\n        addr = #{addr}\n    where id = #{id}\n</update>\n```\n\n动态修改\n\n```\n<update id=\"updatedDong\">\n    update tb_user\n    <set>\n        <if test=\"username != null and username != ''\">username = #{username},</if>\n        <if test=\"password != null and password != ''\">password = #{password},</if>\n        <if test=\"gender != null and gender != ''\">gender = #{gender},</if>\n        <if test=\"addr != null and addr != ''\">addr = #{addr}</if>\n    </set>\n    where id = #{id}\n</update>\n```\n\n#### delete标签\n\n普通删除\n\n```\n<delete id=\"delete\">\n    delete from tb_user where id = #{id}\n</delete>\n```\n\n批量删除\n\n```\n<!-- 用foreach循环遍历，因为一开始并不知道数组有多少长度-->\n<!-- mybatis默认将collection参数为array，只能为这个，若想改变产生名字，则必须在传参的时候用@Params注解改变默认名字-->\n<!-- 例如：void deleteFor(@Param(\"ids\") int[] ids);-->\n<delete id=\"deleteFor\">\n    delete from tb_user where id in\n    <foreach collection=\"array\" item=\"id\" separator=\",\" open=\"(\" close=\")\">\n        #{id}\n    </foreach>\n</delete>\n```\n\n### 注解方式\n\n用注解方式就不用写xml文件，极大的方便了开发，所以简单的sql语句用注解，复杂的sql语句用xml文件\n\n```\n@Select(\"select * from tb_user\")\nList<User> userAll();\n```\n\n## Servlet\n\nServlet是Java web的核心\n\n### 快速入门\n\n需要重写Servlet api中的5个方法\n\n```\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n\n@WebServlet(\"/demo1\")\npublic class servletDemo1 implements Servlet {\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"123\");\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(21);\n    }\n}\n```\n\n### Api\n\n#### init\n\n- 调用时机：默认情况下Servlet第一访问的时候创建Servlet对象，实例化后被调用\n- 调用次数：1次\n\n#### service\n\n- 调用时机：Servlet每一次被访问的时候\n- 调用次数：多次\n\n#### destroy\n\n- 调用时机：内存释放或者服务器关闭时，Servlet对象会销毁\n- 调用次数：1次\n\n### WebServlet注解配置规则\n\n`@WebServlet(urlPatterns = \"/demo2\", loadOnStartup = 1)`\n\nurlPatterns = xx， xx为路由地址，参数只有urlPatterns时可以省略只写`@WebServlet(\"xxx\")`\n\n- 1、数组，可以放多个接口\n- 2、精确匹配：`/api/demo`\n- 3、目录匹配：`/api/demo/*`\n- 4、拓展名匹配：`.do`\n- 5、任意匹配：`/` 或者 `/*`\n\nloadOnStartup为-1表示第一次访问的时候初始化，为正整数或者为0表示Servlet对象创建的时候就调用\n\n### HttpServlet\n\nHttpServlet是对Http协议进行封装的Servlet实现类\n\n需要重写doGet和doPost方法\n\n```\npublic class ServletDemo_HttpServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n```\n\n封装的原理就是通过`ServletRequest`强制转为子类`HttpServletRequest`，在调用`getMethod()`方法获取调用方法，若是get方法就调用`doGet()`，post方法就调用`doPost()`\n\n### HttpServletRequest\n\n#### 请求行\n\n- 请求方法：post/get => `req.getMethod()`\n- 访问访问路径：/api => `req.getContextPath()`\n- 统一资源定位符：http://localhost:8080/api/demo5 => `req.getRequestURL()`\n- 统一资源标识符：/api/demo5 => `req.getRequestURI()`\n\n#### 请求参数\n\n`req.getQueryString()`\n\n#### 请求头\n\n`req.getHeader(\"xxx\")`\n\n#### 通用获取参数方法\n\n```\n// 若参数// 请求获得参数的通用方法, 键值对方法，底层用了getQueryString方法\nMap<String, String[]> map = req.getParameterMap();\nfor(String s: map.keySet()){\n    System.out.print(s + \":\");\n    for(String j: map.get(s)){\n        System.out.print(j + \"\");\n    }\n    System.out.println(\"\");\n}\n// 若参数有多个，根据key获取参数值，数组\nString[] sz = req.getParameterValues(\"username\");\n// 若参数只有一个，根据key获取值\nString sd = req.getParameter(\"password\");\n```\n\n#### 乱码问题\n\nget乱码问题：tomcat进行url解码的默认字符集为ISO-8859-1\n\n解决：1、对乱码进行解码，转为字节数组。2、解码\n\n```\nbyte ss[] = reqUsername.getBytes(StandardCharsets.ISO_8859_1);\nString endUsername = new String(ss, \"utf-8\");\n```\n\npost乱码问题解决：`req.setCharacterEncoding(\"UTF-8\");`\n\n#### 资源转发\n\n特点：1、浏览地址栏不变化；2、只能转发当前服务器内部资源；3、一次请求，转发资源间数据共享\n\n```\nreq.setAttribute(\"msg\", \"hello\");\nreq.getAttribute(\"msg\");\nreq.removeAttribute(\"msg\");\n```\n\n请求转发：`req.getRequestDispatcher(\"/demo\").forward(req, resp);`\n\n### HttpServletResponse\n\n#### **重定向**\n\n特点：1、路由器地址栏发送变化；2、可以重定向任意位置（服务器内部或者外部都可以）；3、两次请求，不能在多个资源中使用request共享数据\n\n```\n// 方法一\n// 设置状态码\nresponse.setStatus(302);\n//  设置响应头\nresponse.setHeader(\"Location\", \"/servlet_demo/demo1\");\n\n// 方法二\n// 重定向简化写法\n// request.getContextPath()：获取虚拟目录\nresponse.sendRedirect(request.getContextPath() + \"/demo1\");\n```\n\n#### response响应数据\n\n##### 字符输入流\n\n```\n// 设置请求头编码为utf-8并且支持html格式\nresponse.setHeader(\"content-type\", \"text/html;charset=utf-8\");\n//  获得字符输入流\nPrintWriter printWriter = response.getWriter();\nprintWriter.write(\"<h1>你好</h1>\");\n```\n\n##### 字节输入流\n\n```\nFileInputStream file = new FileInputStream(\"C:\\\\Users\\\\lenovo\\\\Pictures\\\\Saved Pictures\\\\qq.jpg\");\nServletOutputStream servletOutputStream = response.getOutputStream();\nbyte[] b = new byte[1024];\nint len = 0;\nwhile((len = file.read(b)) != -1){\n    servletOutputStream.write(b, 0, len);\n}\nfile.close(); // 这里需要关闭资源\n```\n\n##### JSON格式\n\n需要导入fastjson包\n\n```\n<dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.2.62</version>\n</dependency>\n```\n\n例子\n\n```\nint n[] = {1,2,3,6,4,5};\nString j = JSON.toJSONString(n);\nresponse.setContentType(\"text/html;charset=utf-8\");\nresponse.getWriter().write(j);\n```\n","title":" JavaWeb学习笔记\n","category":[" Java","Servlet\n"],"date":" 2024-01-17\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n JDBC\n\n介绍：java用来连接和操作数据库\n\n注意：最后千万别忘掉关闭资源\n\n 快速上手\n\n前提需要导入mysql jar包\n\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo {\n    public static void mainString args throws Exception{\n//        注册驱动\n        Class.forName\"com.mysql.jdbc.Driver\";\n//        获取链接\n//        useServerPrepStmts=true开启预编译功能\n        String url = \"jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"123456\";\n        Connection conn = DriverManager.getConnectionurl, username, password;\n//        执行语句\n        String sql = \"update jdbctest set password = 12121 where username = 1\";\n//        获取执行对象\n        Statement statement = conn.createStatement;\n//        返回影响行数\n        int count = statement.executeUpdatesql;\n        System.out.printlncount;\n//        释放资源\n        conn.close;\n        statement.close;\n    }\n}\n\n\n API\n\n DriverManager\n\n通过DriverManager.getConnectionurl, username, password来得到一个Connection对象，代表与数据库连接成功\n\n Connection\n\n获取执行sql对象\n\n 通过调用createStatemen方法获取一个Statement对象\n 通过调用prepareStatement方法获取一个PrepareStatement对象\n\n事务管理\n\n 通过调用setAutoCommitfalse方法来来关闭自动提交事务\n 通过调用sqlSession.commit方法来回滚事务\n 通过调用rollback方法来回滚事务\n\n事务管理就是关闭自动提交事务过后，执行的语句中若出现错误就会立刻回滚事务，一个都不执行；若语句执行完后没有提交事务，他也会回滚事务；\n\n Statement\n\n代表执行对象\n\n 通过调用executeUpdatesql来对数据进行增删改，返回受影响的行数（int）\n 通过调用executeQuerysql来对数据进行查询,返回一个ResultSet对象\n\n PreparedStatement\n\n代表执行对象，可以防止sql注入\n\n需要在sql语句中传参的位置用?占位符代替，调用setInt/setString出现的位置, 需要代替的字符或者数字来替换?，这样做的原理是使敏感字符用\\\\带转义，让它变为一个字符，不参与sql作用。\n\n例如：\n\n\nString name = \"1\";\nString pas = \"'or '1' ='1\"; // sql注入代码\n String sql = \"select  from jdbctest where username = '\"+name+\"' and password = '\"+pas+\"'\";\nStatement statement = connection.createStatement;\nResultSet resultSet = statement.executeQuerysql;\n\n\n这样写的sql语句为select  from jdbctest where username = '1' and password = ''or '1' ='1'，这样的sql语句一定为真，导致sql注入\n\n改进过后代码\n\n\nString sql = \"select  from jdbctest where username = ? and password = ?\";\nPreparedStatement preparedStatement = connection.prepareStatementsql;\npreparedStatement.setString1, name;\npreparedStatement.setString2, pas;\n\n\n这样的sql为select  from jdbctest where username = '1' and password = '\\'or \\'1\\' =\\'1\\'就不会出现sql注入问题\n\n ResultSet\n\n主要有两个重要的方法\n\n 调用next来判断是否下一行数据是否存在\n 调用getString\"1\"/getInt\"id\"来输出改行数据的第1列或者列名为id的数据\n\n Druid\n\ndruid使阿里巴巴开源的数据库连接池，可以进行多个用户连接，一开始就开了几个Connetion连接，用完并不会关闭而是返回连接池等待下一个用户；而不是用一个开一次连接，用完就关闭，导致浪费时间。\n\n需要引入druid和mysql jar包\n\n与jdbc不同的是这里需要一个Properties配置文件来配置数据库连接池信息\n\n\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=123456\n 初始化连接数量\ninitialSize=5\n 最大连接数\nmaxActive=10\n 最大等待时间\nmaxWait=3000\n\n\n\n// 加载配置文件\nProperties prop = new Properties;\n// System.out.printlnSystem.getProperty\"user.dir\";  获取当前目录是src\nprop.loadnew FileInputStream\"jdbcdemo/src/druid.properties\";\n\n\n调用DruidDataSourceFactory.createDataSourceprop返回一个DataSource对象，这个DataSource可以调用getConnection来获取数据库连接返回一个Connection对象，拿到这个对象后的操作方法与上面一样\n\n Mybaits\n\nMybats是JDBC框架，免除了几乎所有JDBC代码以及设置参数和获取结果集的工作\n\n注意：别忘记关闭SqlSession开启的资源\n\n 目录\n\n../../.vuepress/public/assets/article/javaweb/QQ图片20230106061547.png\n\njava下单UserMapper为接口文件，resource下的UserMapper为Mapper的xml文件（存放sql数据）。\n\n mybatisconfig的配置\n\n放在resources目录下\n\n\n<?xml version=\"1.0\" encoding=\"UTF8\" ?\n<DOCTYPE configuration\n        PUBLIC \"//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis3config.dtd\"\n<configuration\n\n< default为默认选取的数据库，这样写可以切换不同的数据库，对应environment的id\n    <environments default=\"development\"\n        <environment id=\"development\"\n< 事务管理方式，采用JDBC\n            <transactionManager type=\"JDBC\"/\n< 数据库连接池\n            <dataSource type=\"POOLED\"\n< 数据库的连接信息\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\n                <property name=\"url\" value=\"jdbc:mysql:///test\"/\n                <property name=\"username\" value=\"root\"/\n                <property name=\"password\" value=\"123456\"/\n            </dataSource\n        </environment\n    </environments\n    <mappers\n< 加载sql映射文件\n< <mapper resource=\"com/ljx/mapper/UserMapper.xml\"/\n\n< mapper代理方式，扫包，若还有多个如BrandMapper,....不需要一个一个添加sql映射文件，\n        <package name=\"com.ljx.mapper\"/\n    </mappers\n</configuration\n\n\n加载配置文件，获取sqlSessionFactory对象\n\n\nString resource = \"mybatisconfig.xml\";\nInputStream inputStream = Resources.getResourceAsStreamresource;\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.buildinputStream;\n\n\n获取SqlSession对象，继承了Conntection的事务管理\n\n\nSqlSession sqlSession = sqlSessionFactory.openSession;\n\n\n获得UserMapper接口代理对象\n\n\nUserMapper userMapper = sqlSession.getMapperUserMapper.class;\n\n\n接着就可以调用UserMapper的接口了（例如）\n\n\nList<User users = userMapper.selectAll;\n\n\n注意：除了查询，其他的增删改均需要事务提交sqlSession.commit;\n\n XXXMapper的配置\n\n放在resources/com/ljx/mapper目录下，与java里面的目录相对应\n\n\n<?xml version=\"1.0\" encoding=\"UTF8\" ?\n<DOCTYPE mapper\n        PUBLIC \"//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis3mapper.dtd\"\n<namespace命名空间：为mapper的全限名，为java目录下mapper接口的地址，用来对应mapper\n<resultType返回类型，com.ljx.pojo.User是User类的文件地址\n<mapper namespace=\"com.ljx.mapper.UserMapper\"</mapper\n\n\n select标签\n\n普通查找\n\n\n<select id=\"selectAll\" resultType=\"com.ljx.pojo.User\"\n        select \n        from tbuser;\n</select\n\n\n含有敏感字符查找\n\n\n < {}占位符，会将其替换为?，为了防止sql注入，${}占位符，拼接sql，会存在sql注入问题\n< 如遇到特殊字符如：<，则会报错，因为xml小于是一种开始的格式，需要处理\n        1.转移字符：&lt;\n        2.CDATA区：<CDATA < ，其中<CDATA内容里可以写多个字符\n\n    <select id=\"selectId\" resultType=\"com.ljx.pojo.User\"\n        select \n        from tbuser\n        where id <CDATA <  {id};\n    </select\n\n\n多条件查询\n\n\n<select id=\"selectMore\" resultType=\"com.ljx.pojo.User\"\n        select \n        from tbuser\n        where id = {id}\n           and gender = {gender};\n</select\n\n\n动态查询\n\n\n<动态条件查询sql\n< 并不是所有的参数都需要传入\n< if标签，存在问题：第一个if若不存在就会出错。\n< 解决：1、添加 1=1  2、用where标签替换where语句，若条件存在就会自动去掉and\n<select id=\"selectNiu\" resultType=\"com.ljx.pojo.User\"\n    select  from tbuser\n    <where\n        <if test=\"username = null and username = ''\"and username = {username}</if\n        <if test=\"id = null\"and id = {id}</if\n    </where\n</select\n\n\n单条件查询\n\n\n<单条件动态查询\n< choose标签相当于switch，when标签相当于case，test里放的是条件\n< otherwise相当于default，若没有满足的条件就执行这个语句，否则不执行\n<select id=\"selectDan\" resultType=\"com.ljx.pojo.User\"\n    select  from tbuser\n    where\n    <choose\n        <when test=\"username = null and username = ''\"username = {username}</when\n        <when test=\"id = null\"id = {id}</when\n        <otherwise1 = 1</otherwise\n        </choose\n</select\n\n\n insert标签\n\n\n< useGeneratedKeys=\"true\" keyProperty=\"id\" 返回添加数据id\n<insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\"\n    insert into tbuser username, password, gender, addr\n    values {username}, {password}, {gender}, {addr}\n</insert\n\n\n updated标签\n\n普通修改\n\n\n<update id=\"updated\"\n    update tbuser\n    set username = {username},\n        password = {password},\n        gender = {gender},\n        addr = {addr}\n    where id = {id}\n</update\n\n\n动态修改\n\n\n<update id=\"updatedDong\"\n    update tbuser\n    <set\n        <if test=\"username = null and username = ''\"username = {username},</if\n        <if test=\"password = null and password = ''\"password = {password},</if\n        <if test=\"gender = null and gender = ''\"gender = {gender},</if\n        <if test=\"addr = null and addr = ''\"addr = {addr}</if\n    </set\n    where id = {id}\n</update\n\n\n delete标签\n\n普通删除\n\n\n<delete id=\"delete\"\n    delete from tbuser where id = {id}\n</delete\n\n\n批量删除\n\n\n< 用foreach循环遍历，因为一开始并不知道数组有多少长度\n< mybatis默认将collection参数为array，只能为这个，若想改变产生名字，则必须在传参的时候用@Params注解改变默认名字\n< 例如：void deleteFor@Param\"ids\" int ids;\n<delete id=\"deleteFor\"\n    delete from tbuser where id in\n    <foreach collection=\"array\" item=\"id\" separator=\",\" open=\"\" close=\"\"\n        {id}\n    </foreach\n</delete\n\n\n 注解方式\n\n用注解方式就不用写xml文件，极大的方便了开发，所以简单的sql语句用注解，复杂的sql语句用xml文件\n\n\n@Select\"select  from tbuser\"\nList<User userAll;\n\n\n Servlet\n\nServlet是Java web的核心\n\n 快速入门\n\n需要重写Servlet api中的5个方法\n\n\nimport javax.servlet.;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n\n@WebServlet\"/demo1\"\npublic class servletDemo1 implements Servlet {\n\n    @Override\n    public void initServletConfig servletConfig throws ServletException {\n\n    }\n\n    @Override\n    public void serviceServletRequest servletRequest, ServletResponse servletResponse throws ServletException, IOException {\n        System.out.println\"123\";\n    }\n\n    @Override\n    public ServletConfig getServletConfig {\n        return null;\n    }\n\n    @Override\n    public String getServletInfo {\n        return null;\n    }\n\n    @Override\n    public void destroy {\n        System.out.println21;\n    }\n}\n\n\n Api\n\n init\n\n 调用时机：默认情况下Servlet第一访问的时候创建Servlet对象，实例化后被调用\n 调用次数：1次\n\n service\n\n 调用时机：Servlet每一次被访问的时候\n 调用次数：多次\n\n destroy\n\n 调用时机：内存释放或者服务器关闭时，Servlet对象会销毁\n 调用次数：1次\n\n WebServlet注解配置规则\n\n@WebServleturlPatterns = \"/demo2\", loadOnStartup = 1\n\nurlPatterns = xx， xx为路由地址，参数只有urlPatterns时可以省略只写@WebServlet\"xxx\"\n\n 1、数组，可以放多个接口\n 2、精确匹配：/api/demo\n 3、目录匹配：/api/demo/\n 4、拓展名匹配：.do\n 5、任意匹配：/ 或者 /\n\nloadOnStartup为1表示第一次访问的时候初始化，为正整数或者为0表示Servlet对象创建的时候就调用\n\n HttpServlet\n\nHttpServlet是对Http协议进行封装的Servlet实现类\n\n需要重写doGet和doPost方法\n\n\npublic class ServletDemoHttpServlet extends HttpServlet {\n    @Override\n    protected void doGetHttpServletRequest req, HttpServletResponse resp throws ServletException, IOException {\n        super.doGetreq, resp;\n    }\n\n    @Override\n    protected void doPostHttpServletRequest req, HttpServletResponse resp throws ServletException, IOException {\n        super.doPostreq, resp;\n    }\n}\n\n\n封装的原理就是通过ServletRequest强制转为子类HttpServletRequest，在调用getMethod方法获取调用方法，若是get方法就调用doGet，post方法就调用doPost\n\n HttpServletRequest\n\n 请求行\n\n 请求方法：post/get = req.getMethod\n 访问访问路径：/api = req.getContextPath\n 统一资源定位符：http://localhost:8080/api/demo5 = req.getRequestURL\n 统一资源标识符：/api/demo5 = req.getRequestURI\n\n 请求参数\n\nreq.getQueryString\n\n 请求头\n\nreq.getHeader\"xxx\"\n\n 通用获取参数方法\n\n\n// 若参数// 请求获得参数的通用方法, 键值对方法，底层用了getQueryString方法\nMap<String, String map = req.getParameterMap;\nforString s: map.keySet{\n    System.out.prints + \":\";\n    forString j: map.gets{\n        System.out.printj + \"\";\n    }\n    System.out.println\"\";\n}\n// 若参数有多个，根据key获取参数值，数组\nString sz = req.getParameterValues\"username\";\n// 若参数只有一个，根据key获取值\nString sd = req.getParameter\"password\";\n\n\n 乱码问题\n\nget乱码问题：tomcat进行url解码的默认字符集为ISO88591\n\n解决：1、对乱码进行解码，转为字节数组。2、解码\n\n\nbyte ss = reqUsername.getBytesStandardCharsets.ISO88591;\nString endUsername = new Stringss, \"utf8\";\n\n\npost乱码问题解决：req.setCharacterEncoding\"UTF8\";\n\n 资源转发\n\n特点：1、浏览地址栏不变化；2、只能转发当前服务器内部资源；3、一次请求，转发资源间数据共享\n\n\nreq.setAttribute\"msg\", \"hello\";\nreq.getAttribute\"msg\";\nreq.removeAttribute\"msg\";\n\n\n请求转发：req.getRequestDispatcher\"/demo\".forwardreq, resp;\n\n HttpServletResponse\n\n 重定向\n\n特点：1、路由器地址栏发送变化；2、可以重定向任意位置（服务器内部或者外部都可以）；3、两次请求，不能在多个资源中使用request共享数据\n\n\n// 方法一\n// 设置状态码\nresponse.setStatus302;\n//  设置响应头\nresponse.setHeader\"Location\", \"/servletdemo/demo1\";\n\n// 方法二\n// 重定向简化写法\n// request.getContextPath：获取虚拟目录\nresponse.sendRedirectrequest.getContextPath + \"/demo1\";\n\n\n response响应数据\n\n 字符输入流\n\n\n// 设置请求头编码为utf8并且支持html格式\nresponse.setHeader\"contenttype\", \"text/html;charset=utf8\";\n//  获得字符输入流\nPrintWriter printWriter = response.getWriter;\nprintWriter.write\"<h1你好</h1\";\n\n\n 字节输入流\n\n\nFileInputStream file = new FileInputStream\"C:\\\\Users\\\\lenovo\\\\Pictures\\\\Saved Pictures\\\\qq.jpg\";\nServletOutputStream servletOutputStream = response.getOutputStream;\nbyte b = new byte1024;\nint len = 0;\nwhilelen = file.readb = 1{\n    servletOutputStream.writeb, 0, len;\n}\nfile.close; // 这里需要关闭资源\n\n\n JSON格式\n\n需要导入fastjson包\n\n\n<dependency\n      <groupIdcom.alibaba</groupId\n      <artifactIdfastjson</artifactId\n      <version1.2.62</version\n</dependency\n\n\n例子\n\n\nint n = {1,2,3,6,4,5};\nString j = JSON.toJSONStringn;\nresponse.setContentType\"text/html;charset=utf8\";\nresponse.getWriter.writej;\n\n"},{"filename":"springcloud-learn","category":"java","md":{"topSummary":"\ntitle: SpringCloud学习笔记\ncategory: Java,SpringCloud\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n笔记参考博客：\n\n- https://blog.csdn.net/u011863024/article/details/114298270\n- https://blog.csdn.net/u011863024/article/details/114298282\n- [https://blog.csdn.net/u011863024/article/details/114298288](https://blog.csdn.net/u011863024/article/details/114298288)\n\n## 环境搭建\n\n约定 > 配置 > 编码\n\n创建微服务cloud整体聚合父工程Project，有8个关键步骤：\n\n1、New Project - maven工程 - create from archetype: maven-archetype-site\n2、聚合总父工程名字\n3、Maven选版本\n4、工程名字\n5、字符编码 - Settings - File encoding\n6、注解生效激活 - Settings - Annotation Processors\n7、Java编译版本选8\n8、File Type过滤 - Settings - File Type\n\n### 复习\n\n#### DependencyManagement和Dependencies\n\nMaven使用`dependencyManagement`元素来提供了一种管理依赖版本号的方式。\n\n通常会在一个组织或者项目的最顶层的父POM 中看到`dependencyManagement`元素。\n\n使用pom.xml中的`dependencyManagement`元素能让所有在子项目中引用个依赖而不用显式的列出版本量。\n\nMaven会沿着父子层次向上走，直到找到一个拥有`dependencyManagement`元素的项目，然后它就会使用这个`dependencyManagement`元素中指定的版本号。\n\n说白了就是父项目用了版本号，子项目就可以不需要写版本号，便于维护\n\n**注意**\n\n- `dependencyManagement`里只是**声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖***。\n- 如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。\n- 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。\n\n#### Maven跳过单元测试\n\nIDEA右侧旁的Maven插件有`Toggle ' Skip Tests' Mode`按钮，这样maven可以跳过单元测试\n\n父工程创建完成执行`mvn : install`将父工程发布到仓库方便子工程 继承\n\n## Dashboard窗口\n\n1. 打开工程路径下的.idea文件夹的workspace.xml\n2. 在`<component name=\"RunDashboard\">`中修改或添加以下代码：重启即可\n\n```xml\n<option name=\"configurationTypes\">\n\t<set>\n\t\t<option value=\"SpringBootApplicationConfigurationType\"/>\n    </set>\n</option>\n```\n\n\n\n## 支付模块构建\n\n创建微服务模块套路：\n\n1. 建Module\n2. 改POM\n3. 写YML\n4. 主启动\n5. 业务类\n\n[![pPSszzn.png](https://s1.ax1x.com/2023/07/29/pPSszzn.png)](https://imgse.com/i/pPSszzn)\n\n## 消费模块构建\n\n[![pPSyCLV.png](https://s1.ax1x.com/2023/07/29/pPSyCLV.png)](https://imgse.com/i/pPSyCLV)\n\n## Restemplate\n\nRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集\n\n使用：\n\n- 使用restTemplate访问restful接口非常的简单粗暴无脑。\n- `(url, requestMap, ResponseBean.class)`这三个参数分别代表。\n- REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。\n\n```java\n// 消费模块调用支付模块接口\nrestTemplate.postForObject(\"http://localhost:8001/payment/create\", payment, CommonResult.class);\n```\n\n- getForObject() / getForEntity() - GET请求方法\n\n- getForObject()：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。\n\n- getForEntity()：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。\n\n## 工程重构\n\n观察cloud-consumer-order80与cloud-provider-payment8001两工程有重复代码（entities包下的实体）\n\n1、新建cloud-api-commons来存放公共代码和一些配置类等等\n\n2、添加pom文件\n\n3、将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移至cloud-api-commons工程下\n\n4、maven clean、install \n\n5、将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移除\n\n6、两个工程引入cloud-api-commons依赖\n\n```xml\n<dependency>\n    <groupId>com.ljx.springcloud</groupId>\n    <artifactId>cloud-api-commons</artifactId>\n    <version>${project.version}</version>\n</dependency>\n```\n\n## 知识点\n\n[![pPSgBTK.png](https://s1.ax1x.com/2023/07/29/pPSgBTK.png)](https://imgse.com/i/pPSgBTK)\n\n最终需要在上述项目基础上一点点添加这些组件\n\n## 服务注册中心\n\n### Eureka\n\n#### 基础知识\n\nEureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。\n\n![aaa.png](https://img-blog.csdnimg.cn/img_convert/3956561052b9dc3909f16f1ff26d01bb.png)\n\n**Eureka包含两个组件:Eureka Server和Eureka Client**\n\n**Eureka Server提供服务注册服务**\n\n各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n\n**EurekaClient通过注册中心进行访问**\n\n它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)\n\n#### EurekaServer服务端安装\n\neurekaServer端服务注册中心，类似物业公司\n\n1.创建名为cloud-eureka-server7001的Maven工程\n\n2.修改pom.xml\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n3.添加application.yml\n\n```yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n4.主启动\n\n```java\n@EnableEurekaServer\n```\n\n5.测试运行`EurekaMain7001`，浏览器输入`http://localhost:7001/`回车，会查看到Spring Eureka服务主页。\n\n#### 支付微服务8001入驻进EurekaServer\n\nEurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。\n\n1.创建名为cloud-eureka-server7001的Maven工程\n\n2.修改pom.xml\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n3.添加application.yml\n\n```yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n4.主启动\n\n```java\n@EnableEurekaClient\n```\n\n5.测试\n\n- 启动cloud-provider-payment8001和cloud-eureka-server7001工程（先启动）。\n\n- 浏览器输入 - http://localhost:7001/ 主页内的Instances currently registered with Eureka会显示cloud-provider-payment8001的配置文件application.yml设置的应用名`cloud-payment-service`\n\n6.自我保护机制\n\nEMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.\n\n紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。\n\n#### 订单微服务80入驻进EurekaServer\n\nEurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer，类似来上课消费的同学\n\n1.cloud-consumer-order80\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-order-service\n\neureka:\n  client:\n    #表示是否将自己注册进Eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n\n4.主启动\n\n```java\n@EnableEurekaClient\n```\n\n5.测试\n\n- 启动cloud-provider-payment8001、cloud-eureka-server7001（先启动）和cloud-consumer-order80这三工程。\n- 浏览器输入 http://localhost:7001 , 在主页的Instances currently registered with Eureka将会看到cloud-provider-payment8001、cloud-consumer-order80两个工程名。\n\n#### Eureka集群原理说明\n\n![img.png](https://img-blog.csdnimg.cn/img_convert/14570c4b7c4dd8653be6211da2675e45.png)\n\n问题：微服务RPC远程服务调用最核心的是什么？\n高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。\n\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。\n\n**互相注册，相互守望**。\n\n#### Eureka集群环境构建\n\n创建cloud-eureka-server7002工程\n\n- 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件，修改映射配置添加进hosts文件\n\n```\n127.0.0.1 eureka7001.com\n127.0.0.1 eureka7002.com\n```\n\n- 修改cloud-eureka-server7001配置文件\n\n```yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: eureka7001.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n    #集群指向其它eureka\n      defaultZone: http://eureka7002.com:7002/eureka/\n    #单机就是7001自己\n      #defaultZone: http://eureka7001.com:7001/eureka/\n```\n\n- 修改cloud-eureka-server7002配置文件\n\n```yml\nserver:\n  port: 7002\n\neureka:\n  instance:\n    hostname: eureka7002.com #eureka服务端的实例名称\n  client:\n    register-with-eureka: false     #false表示不向注册中心注册自己。\n    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    service-url:\n    #集群指向其它eureka\n      defaultZone: http://eureka7001.com:7001/eureka/\n    #单机就是7002自己\n      #defaultZone: http://eureka7002.com:7002/eureka/\n```\n\n#### 订单支付两微服务注册进Eureka集群\n\n将它们的配置文件的eureka.client.service-url.defaultZone进行修改\n\n```yml\neureka:\n  client:\n    #表示是否将自己注册进Eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #注册到集群中\n      defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka\n```\n\n1. 先要启动EurekaServer，7001/7002服务\n2. 再要启动服务提供者provider，8001\n3. 再要启动消费者，80\n4. 浏览器输入 - http://localhost/consumer/payment/get/1\n\n#### 支付微服务集群配置\n\n新建cloud-provider-payment8002参考cloud-provicer-payment8001\n\n**负载均衡**\n\ncloud-consumer-order80订单服务访问地址不能写死\n\n```java\npublic static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\";\n```\n\n使用`@LoadBalanced`注解赋予RestTemplate负载均衡的能力\n\n```java\n@Configuration\npublic class ApplicationContextConfig {\n    @Bean\n    @LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n}\n```\n\n#### actuator微服务信息完善\n\n主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）\n\n修改cloud-provider-payment8001，cloud-provider-payment8002\n\n修改部分 - YML - eureka.instance.instance-id\n\n```yml\neureka:\n  ...\n  instance:\n    instance-id: payment8001 #显示名称\n    prefer-ip-address: true #显示ip地址\n```\n\n修改之后\n\neureka主页将显示payment8001，payment8002代替原来显示的IP地址。\n\n#### 服务发现Discovery\n\n对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n#### Eureka自我保护理论知识\n\n保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n\n如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:\n\n>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE\n\n**导致原因**\n\n一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。\n\n属于CAP里面的AP分支。\n\n**为什么会产生Eureka自我保护机制?**\n\n为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除\n\n**什么是自我保护模式?**\n\n认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。\n\n![b.png](https://img-blog.csdnimg.cn/img_convert/264b66e8099a3761beaea2ba44b8fc5e.png)\n\n**在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例**\n\n它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：**好死不如赖活着**。\n\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。\n\n**禁止自我保护**\n\n出厂默认，自我保护机制是开启的\n\n```yml\neureka:\n  ...\n  server:\n    #关闭自我保护机制，保证不可用服务被及时踢除\n    enable-self-preservation: false\n    eviction-interval-timer-in-ms: 2000\n```\n\n关闭效果：spring-eureka主页会显示出一句：\n\n**THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.**\n\n### Zookeeper\n\nLinux下载\n\n```sh\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1-bin.tar.gz\n```\n\n解压\n\n```sh\ntar -zxvf apache-zookeeper-3.7.1-bin.tar.gz\n```\n\n启动\n\n```sh\n./zkServer.sh start\n```\n\n关闭防火墙\n\n```sh\nsudo systemctl stop ufw.service\n```\n\n#### 支付服务注册进zookeeper\n\n1.新建名为cloud-provider-payment8004的Maven工程。\n\n2.POM\n\n```xml\n      <!-- SpringBoot整合zookeeper客户端 -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n            <!--先排除自带的zookeeper3.5.3 防止与3.4.9起冲突-->\n            <exclusions>\n                <exclusion>\n                    <groupId>org.apache.zookeeper</groupId>\n                    <artifactId>zookeeper</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <!--添加zookeeper3.4.9版本-->\n        <dependency>\n            <groupId>org.apache.zookeeper</groupId>\n            <artifactId>zookeeper</artifactId>\n            <version>3.4.9</version>\n        </dependency>\n```\n\n3.YML\n\n```yml\n#8004表示注册到zookeeper服务器的支付服务提供者端口号\nserver:\n  port: 8004\n\n#服务别名----注册zookeeper到注册中心名称\nspring:\n  application:\n    name: cloud-provider-payment\n  cloud:\n    zookeeper:\n      connect-string: 127.0.0.1:2181 # 192.168.111.144:2181 #\n```\n\n4.主启动类\n\n```java\n@EnableDiscoveryClient//该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n```\n\n5.Controller\n\n```JAVA\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @RequestMapping(value = \"/payment/zk\")\n    public String paymentzk()\n    {\n        return \"springcloud with zookeeper: \"+serverPort+\"\\t\"+ UUID.randomUUID().toString();\n    }\n}\n```\n\n#### 订单服务注册进zookeeper\n\n1.新建cloud-consumerzk-order80（与上面类似）\n\n2.POM\n\n3.YML\n\n4.主启动\n\n5.配置类\n\n```java\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n```\n\n6.业务类\n\n```java\n@RestController\n@Slf4j\npublic class OrderZKController\n{\n    public static final String INVOKE_URL = \"http://cloud-provider-payment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(value = \"/consumer/payment/zk\")\n    public String paymentInfo()\n    {\n        String result = restTemplate.getForObject(INVOKE_URL+\"/payment/zk\",String.class);\n        return result;\n    }\n}\n```\n\n7.访问测试地址 - http://localhost/consumer/payment/zk\n\n### Consul\n\n官网链接：https://www.consul.io/\n\nConsul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。\n\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\n\n它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。\n\n**能干嘛？**\n\n- 服务发现 - 提供HTTP和DNS两种发现方式。\n- 健康监测 - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化\n- KV存储 - Key、Value的存储方式\n- 多数据中心 - Consul支持多数据中心\n- 可视化Web界面\n\n**相关命令**\n\n- 查看版本：`consul -v`\n- 开发模式启动`consul agent -dev`\n\n浏览器输入 - http://localhost:8500/ - 打开Consul控制页。\n\n#### 服务提供者注册进Consul\n\n1.新建Module支付服务provider8006\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yaml\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n```\n\n4.主启动类\n\n```java\n@EnableDiscoveryClient\n```\n\n5.业务类Controller\n\n```java\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @RequestMapping(value = \"/payment/consul\")\n    public String paymentConsul()\n    {\n        return \"springcloud with consul: \"+serverPort+\"\\t   \"+ UUID.randomUUID().toString();\n    }\n}\n```\n\n6.验证测试\n\n- http://localhost:8006/payment/consul\n- http://localhost:8500 - 会显示provider8006\n\n#### 服务消费者注册进Consul\n\n1.新建Module消费服务order80 - cloud-consumerconsul-order80\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n</dependency>\n```\n\n3.YML\n\n```java\n###consul服务端口号\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-consumer-order\n####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n```\n\n4.主启动类\n\n```java\n@EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n```\n\n5.配置Bean\n\n```java\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n```\n\n6.业务类\n\n```java\n@RestController\n@Slf4j\npublic class OrderConsulController\n{\n    public static final String INVOKE_URL = \"http://consul-provider-payment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(value = \"/consumer/payment/consul\")\n    public String paymentInfo()\n    {\n        String result = restTemplate.getForObject(INVOKE_URL+\"/payment/consul\",String.class);\n        return result;\n    }\n}\n```\n\n7.验证测试\n\n运行consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80\n\nhttp://localhost:8500/ 主页会显示出consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80三服务。\n\n8.访问测试地址 - http://localhost/consumer/payment/consul\n\n### 三个注册中心异同点\n\n| 组件名    | 语言CAP | 服务健康检查 | 对外暴露接口 | Spring Cloud集成 |\n| --------- | ------- | ------------ | ------------ | ---------------- |\n| Eureka    | Java    | AP           | 可配支持     | HTTP             |\n| Consul    | Go      | CP           | 支持         | HTTP/DNS         |\n| Zookeeper | Java    | CP           | 支持客户端   | 已集成           |\n\nCAP：\n\n- C：Consistency (强一致性)\n- A：Availability (可用性)\n- P：Partition tolerance （分区容错性)\n\n![111.png](https://img-blog.csdnimg.cn/img_convert/b41e0791c9652955dd3a2bc9d2d60983.png)\n\n**最多只能同时较好的满足两个。**\n\nCAP理论的核心是：**一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求**。\n\n因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:\n\nCA - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。\nCP - 满足一致性，分区容忍必的系统，通常性能不是特别高。\nAP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n#### AP架构（Eureka）\n\n当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\n\n结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n\n![123.png](https://img-blog.csdnimg.cn/img_convert/2d07748539300b9c466eb1d9bac5cd1b.png)\n\n#### CP架构（ZooKeeper/Consul）\n\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。\n\n结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。\n\n![e21x.png](https://img-blog.csdnimg.cn/img_convert/c6f2926a97420015fcebc89b094c5598.png)\n\nCP 与 AP 对立同一的矛盾关系。\n\n## 服务调用\n\n### Ribbon\n\nSpring Cloud Ribbon是基于Netflix Ribbon实现的一套**客户端负载均衡的工具**。\n\n简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供**客户端的软件负载均衡算法和服务调用**。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。\n\nRibbon未来可能被Spring Cloud LoadBalacer替代。\n\n**LB负载均衡(Load Balance)是什么**\n\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。\n\n常见的负载均衡有软件Nginx，LVS，硬件F5等。\n\n**Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别**\n\nNginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\nRibbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\n\n**集中式LB**\n\n即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方;\n\n**进程内LB**\n\n将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\nRibbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n一句话\n\n**负载均衡 + RestTemplate调用**\n\n#### Ribbon的负载均衡和Rest调用\n\n总结：Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。\n\n![1dc.png](https://img-blog.csdnimg.cn/img_convert/145b915e56a85383b3ad40f0bb2256e0.png)\n\nRibbon在工作时分成两步：\n\n- 第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。\n- 第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。\n\n其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。\n\n**`spring-cloud-starter-netflix-eureka-client`自带了`spring-cloud-starter-ribbon`引用**\n\n#### Ribbon默认自带的负载规则\n\nlRule：根据特定算法中从服务列表中选取一个要访问的服务\n\n![asdacg2.png](https://img-blog.csdnimg.cn/img_convert/87243c00c0aaea211819c0d8fc97e445.png)\n\n- RoundRobinRule 轮询\n- RandomRule 随机\n- RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重\n- WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择\n- BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n- AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例\n- ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器\n\n**Ribbon负载规则替换**\n\n1.修改cloud-consumer-order80\n\n2.注意配置细节\n\n官方文档明确给出了警告：**这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了（也就是说不要将Ribbon配置类与主启动类同包**）\n\n3.新建package - com.lun.myrule\n\n4.在com.ljx.myrule下新建MySelfRule规则类\n\n```java\n@Configuration\npublic class MySelfRule {\n\n    @Bean\n    public IRule myRule(){\n        return new RandomRule();\n    }\n}\n```\n\n5.主启动类添加\n\n```java\n@RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\", configuration = MySelfRule.class)\n```\n\n### OpenFeign\n\nFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。\n\n前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\n\n**Feign集成了Ribbon**\n\n利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，**通过feign只需要定义服务绑定接口且以声明式的方法**，优雅而简单的实现了服务调用。\n\n#### Feign和OpenFeign两者区别\n\n**Feign**是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-feign</artifactId>\n</dependency>\n```\n\npenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVc的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n#### OpenFeign服务调用\n\n接口+注解：微服务调用接口 + @FeignClient\n\n1.新建cloud-consumer-feign-order80\n\n2.POM\n\n```xml\n<dependency>\n     <groupId>org.springframework.cloud</groupId>\n     <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n```\n\n4.主启动\n\n```java\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderFeignMain80.class, args);\n    }\n}\n```\n\n5.业务类\n\n业务逻辑接口+@FeignClient配置调用provider服务\n\n新建PaymentFeignService接口并新增注解@FeignClient\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")\npublic interface PaymentFeignService\n{\n    @GetMapping(value = \"/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\n}\n```\n\n**注意：**若有公共前缀api的请求，需要修改为`@FeignClient(value = \"xx\", path=\"/api\")`\n\nController类\n\n```java\n@RestController\n@Slf4j\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n\n    @GetMapping(value = \"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    {\n        return paymentFeignService.getPaymentById(id);\n    }\n}\n```\n\n6.测试\n\n先启动2个eureka集群7001/7002，再启动2个微服务8001/8002，最后启动OpenFeign启动\n\n访问http://localhost/consumer/payment/get/1\n\n**Feign自带负载均衡配置项**\n\n#### OpenFeign超时控制\n\n**超时设置，故意设置超时演示出错情况**\n\n1.服务提供方8001/8002故意写暂停程序\n\n```java\n    @GetMapping(value = \"/payment/feign/timeout\")\n    public String paymentFeignTimeout()\n    {\n        // 业务逻辑处理正确，但是需要耗费3秒钟\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return serverPort;\n    }\n```\n\n2.服务消费方80添加超时方法PaymentFeignService\n\n```java\n@GetMapping(value = \"/payment/feign/timeout\")\npublic String paymentFeignTimeout();\n```\n\n3.服务消费方80添加超时方法OrderFeignController\n\n```java\n@GetMapping(value = \"/consumer/payment/feign/timeout\")\npublic String paymentFeignTimeout()\n{\n    // OpenFeign客户端一般默认等待1秒钟\n    return paymentFeignService.paymentFeignTimeout();\n}\n```\n\n4.测试：\n\n多次刷新http://localhost/consumer/payment/feign/timeout\n\n将会跳出错误Spring Boot默认错误页面，主要异常：`feign.RetryableException:Read timed out executing GET http://CLOUD-PAYMENT-SERVCE/payment/feign/timeout。`\n\n**OpenFeign默认等待1秒钟，超过后报错**\n\n**YML文件里需要开启OpenFeign客户端超时控制**\n\n```yml\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n```\n\n#### OpenFeign日志增强\n\n**日志打印功能**\n\nFeign提供了日志打印功能，我们可以通过配置来调整日恙级别，从而了解Feign 中 Http请求的细节。\n\n说白了就是对Feign接口的调用情况进行监控和输出\n\n**日志级别**\n\n- NONE：默认的，不显示任何日志;\n- BASIC：仅记录请求方法、URL、响应状态码及执行时间;\n- HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;\n- FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。\n\n**配置日志bean**\n\n```java\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel()\n    {\n        return Logger.Level.FULL;\n    }\n}\n```\n\n**YML文件里需要开启日志的Feign客户端**\n\n```yml\nlogging:\n  level:\n    # feign日志以什么级别监控哪个接口\n    com.ljx.springcloud.service.PaymentFeignService: debug\n```\n\n**后台日志查看**\n\n得到更多日志信息\n\n## 服务降级\n\n**分布式系统面临的问题**\n\n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n\n**服务雪崩**\n\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\n对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n\n所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n\n### Hystrix\n\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n\n\"断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n**主要功能**\n\n- 服务降级\n- 服务熔断\n- 接近实对的监控\n\n**服务降级**\n\n服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback\n\n哪些情况会出发降级？\n\n- 程序运行导常\n\n- 超时\n- 服务熔断触发服务降级\n- 线程池/信号量打满也会导致服务降级\n\n**服务熔断**\n\n类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。\n\n服务的降级 -> 进而熔断 -> 恢复调用链路\n\n**服务限流**\n\n秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。\n\n#### Hystrix支付微服务构建\n\n1.新建cloud-provider-hygtrix-payment8001\n\n2.POM\n\n```xml\n<dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-provider-hystrix-payment\n\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n4.主启动\n\n```java\n@EnableEurekaClient\n```\n\n5.业务类\n\nservice\n\n```java\n@Service\npublic class PaymentService {\n    /**\n     */\n    public String paymentInfo_OK(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  paymentInfo_OK,id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\";\n    }\n\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        try { TimeUnit.MILLISECONDS.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 3\";\n    }\n}\n```\n\ncontroller\n\n```java\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Resource\n    private PaymentService paymentService;\n\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentInfo_OK(id);\n        log.info(\"*****result: \"+result);\n        return result;\n    }\n\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentInfo_TimeOut(id);\n        log.info(\"*****result: \"+result);\n        return result;\n    }\n}\n```\n\n6.正常测试\n\n以上述为根基平台，从正确 -> 错误 -> 降级熔断 -> 恢复。\n\n#### JMeter高并发压测后卡顿\n\n**上述在非高并发情形下，还能勉强满足**\n\n**Jmeter压测结论**\n\n上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢\n\n#### Hystrix订单微服务\n\n1.新建 - cloud-consumer-feign-hystrix-order80\n\n2.POM\n\n```xml\n<dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n4.主启动\n\n5.业务类\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\" /*,fallback = PaymentFallbackService.class*/)\npublic interface PaymentHystrixService\n{\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\n\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\n}\n```\n\n```java\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    }\n\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n}\n```\n\n6.正常测试\n\n7.高并发测试\n\n2W个线程压8001，消费端80微服务再去访问正常的Ok微服务8001地址，消费者80被拖慢\n\n原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。\n\n正因为有上述故障或不佳表现才有我们的降级/容错/限流等技术诞生。\n\n#### 降级容错解决的维度要求\n\n超时导致服务器变慢(转圈) ---》超时不再等待\n\n出错(宕机或程序运行出错) ---》 出错要有兜底\n\n解决：\n\n- 对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。\n- 对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。\n- 对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。\n\n#### Hystrix服务降级支付fallback\n\n降级配置 - `@HystrixCommand`\n\n**设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback**。\n\n—旦调用服务方法失败并抛出了错误信息后，会自动调用`@HystrixCommand`标注好的`fallbackMethod`调用类中的指定方法\n\n```java\n@Service\npublic class PaymentService{\n\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\", commandProperties = {\n            @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")\n    })\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        //int age = 10/0;\n        try { TimeUnit.MILLISECONDS.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): \";\n    }\n\n    //用来善后的方法\n    public String paymentInfo_TimeOutHandler(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o(╥﹏╥)o\";\n    }\n    \n}\n```\n\n上面故意制造两种异常:\n\n1. int age = 10/0，计算异常\n2. 我们能接受3秒钟，它运行5秒钟，超时异常。\n\n当前服务不可用了，做服务降级，兜底的方案都是`paymentInfo_TimeOutHandler`\n\n**主启动类激活**\n\n添加新注解`@EnableCircuitBreaker`\n\n#### Hystrix服务降级订单fallback\n\n1.YML\n\n```yml\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n#开启\nfeign:\n  hystrix:\n    enabled: true\n```\n\n2.主启动添加`@EnableHystrix`\n\n3.业务类\n\n```java\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\",commandProperties = {\n            @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"1500\")\n    })\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        //int age = 10/0;\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n    \n    //善后方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\n    }\n}\n```\n\n#### Hystrix全局服务降级DefaultProperties\n\n**前问题1** 每个业务方法对应一个兜底的方法，代码膨胀\n\n**解决方法**\n\n1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明\n\n1:N除了个别重要核心业务有专属，其它普通的可以通过`@DefaultProperties(defaultFallback = “xxx”)`统一跳转到统一处理结果页面\n\n通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量\n\n```java\n@RestController\n@Slf4j\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\npublic class OrderHystirxController {\n\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    }\n\n//    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\", commandProperties = {\n//            @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")\n//    })\n    @HystrixCommand//用全局的fallback方法\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n\n    //善后方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\n    }\n\n    // 下面是全局fallback方法\n    public String payment_Global_FallbackMethod()\n    {\n        return \"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~\";\n    }\n}\n```\n\n#### Hystrix通配服务降级FeignFallback\n\n**目前问题2** 统一和自定义的分开，代码混乱\n\n**服务降级，客户端去调用服务端，碰上服务端宕机或关闭**\n\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为[Feign](https://so.csdn.net/so/search?q=Feign&spm=1001.2101.3001.7020)客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n\n**未来我们要面对的异常**\n\n- 运行\n- 超时\n- 宕机\n\n1.新建PaymentFallbackService类实现PaymentHystrixService接口\n\n```java\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackService implements PaymentHystrixService\n{\n    @Override\n    public String paymentInfo_OK(Integer id)\n    {\n        return \"-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o\";\n    }\n\n    @Override\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        return \"-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o\";\n    }\n}\n```\n\n2.YML\n\n```yml\nfeign:\n  hystrix:\n    enabled: true\n```\n\n3.PaymentHystrixService接口\n\n```java\n@Component\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\" ,\n             fallback = PaymentFallbackService.class)//指定PaymentFallbackService类\npublic interface PaymentHystrixService\n{\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\n\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\n}\n```\n\n4.测试\n\n单个eureka先启动7001，PaymentHystrixMain8001启动\n\n正常访问测试 - http://localhost/consumer/payment/hystrix/ok/1，故意关闭微服务8001\n\n客户端自己调用提示 - 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。\n\n#### Hystrix服务熔断理论\n\n断路器，相当于保险丝。\n\n**熔断机制概述**\n\n熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，只有当成功率挺高到一定阈值才会关闭。熔断机制的注解是`@HystrixCommand`。\n\n#### Hystrix之服务熔断案例\n\n[Hutool国产工具类](https://hutool.cn/)\n\n修改cloud-provider-hystrix-payment8001\n\nservice层\n\n```java\n@Service\npublic class PaymentService{    \n   \n    //=====服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n            @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),// 是否开启断路器\n            @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),// 请求次数\n            @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"), // 时间窗口期\n            @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),// 失败率达到多少后跳闸\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id) {\n        if(id < 0) {\n            throw new RuntimeException(\"******id 不能负数\");\n        }\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id) {\n        return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\n    }\n\n}\n```\n\ncontroller层\n\n```java\n@GetMapping(\"/payment/circuit/{id}\")\npublic String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n{\n    String result = paymentService.paymentCircuitBreaker(id);\n    log.info(\"****result: \"+result);\n    return result;\n}\n```\n\n**测试**\n\n多次错误，再来次正确，但错误得显示\n\n重点测试 - 多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行\n\n#### Hystrix服务熔断总结\n\n**熔断类型**\n\n- 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。\n- 熔断关闭：熔断关闭不会对服务进行熔断。\n- 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。\n\n**断路器开启或者关闭的条件**\n\n- 到达以下阀值，断路器将会开启：\n  - 当满足一定的阀值的时候（默认10秒内超过20个请求次数)\n  - 当失败率达到一定的时候（默认10秒内超过50%的请求失败)\n- 当开启的时候，所有请求都不会进行转发\n- 一段时间之后（默认是5秒)，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。\n\n**断路器打开之后**\n\n1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n\n2：原来的主逻辑要如何恢复呢？\n\n对于这一问题，hystrix也为我们实现了自动恢复功能。\n\n当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n\n**All配置**\n\n```java\n@HystrixCommand(fallbackMethod = \"fallbackMethod\", \n                groupKey = \"strGroupCommand\", \n                commandKey = \"strCommand\", \n                threadPoolKey = \"strThreadPool\",\n                \n                commandProperties = {\n                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离\n                    @HystrixProperty(name = \"execution.isolation.strategy\", value = \"THREAD\"),\n                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\n                    @HystrixProperty(name = \"execution.isolation.semaphore.maxConcurrentRequests\", value = \"10\"),\n                    // 配置命令执行的超时时间\n                    @HystrixProperty(name = \"execution.isolation.thread.timeoutinMilliseconds\", value = \"10\"),\n                    // 是否启用超时时间\n                    @HystrixProperty(name = \"execution.timeout.enabled\", value = \"true\"),\n                    // 执行超时的时候是否中断\n                    @HystrixProperty(name = \"execution.isolation.thread.interruptOnTimeout\", value = \"true\"),\n                    \n                    // 执行被取消的时候是否中断\n                    @HystrixProperty(name = \"execution.isolation.thread.interruptOnCancel\", value = \"true\"),\n                    // 允许回调方法执行的最大并发数\n                    @HystrixProperty(name = \"fallback.isolation.semaphore.maxConcurrentRequests\", value = \"10\"),\n                    // 服务降级是否启用，是否执行回调函数\n                    @HystrixProperty(name = \"fallback.enabled\", value = \"true\"),\n                    // 是否启用断路器\n                    @HystrixProperty(name = \"circuitBreaker.enabled\", value = \"true\"),\n                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\n                    @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"20\"),\n                    \n                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 \"打开\" 状态，否则就设置为 \"关闭\" 状态。\n                    @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\"),\n                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 \"半开\" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 \"打开\" 状态，如果成功就设置为 \"关闭\" 状态。\n                    @HystrixProperty(name = \"circuitBreaker.sleepWindowinMilliseconds\", value = \"5000\"),\n                    // 断路器强制打开\n                    @HystrixProperty(name = \"circuitBreaker.forceOpen\", value = \"false\"),\n                    // 断路器强制关闭\n                    @HystrixProperty(name = \"circuitBreaker.forceClosed\", value = \"false\"),\n                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\n                    @HystrixProperty(name = \"metrics.rollingStats.timeinMilliseconds\", value = \"10000\"),\n                    \n                    // 该属性用来设置滚动时间窗统计指标信息时划分\"桶\"的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 \"桶\" 来累计各度量值，每个\"桶\"记录了一段时间内的采集指标。\n                    // 比如 10 秒内拆分成 10 个\"桶\"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常\n                    @HystrixProperty(name = \"metrics.rollingStats.numBuckets\", value = \"10\"),\n                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.enabled\", value = \"false\"),\n                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.timeInMilliseconds\", value = \"60000\"),\n                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.numBuckets\", value = \"60000\"),\n                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\n                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\n                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\n                    @HystrixProperty(name = \"metrics.rollingPercentile.bucketSize\", value = \"100\"),\n                    \n                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\n                    @HystrixProperty(name = \"metrics.healthSnapshot.intervalinMilliseconds\", value = \"500\"),\n                    // 是否开启请求缓存\n                    @HystrixProperty(name = \"requestCache.enabled\", value = \"true\"),\n                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中\n                    @HystrixProperty(name = \"requestLog.enabled\", value = \"true\"),\n\n                },\n                threadPoolProperties = {\n                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\n                    @HystrixProperty(name = \"coreSize\", value = \"10\"),\n                    // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。\n                    @HystrixProperty(name = \"maxQueueSize\", value = \"-1\"),\n                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\n                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\n                    @HystrixProperty(name = \"queueSizeRejectionThreshold\", value = \"5\"),\n                }\n               )\npublic String doSomething() {\n\t...\n}\n```\n\n#### Hystrix图形化Dashboard搭建\n\n**概述**\n\n除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。\n\nNetflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\n\n**仪表盘9001**\n\n1新建cloud-consumer-hystrix-dashboard9001\n\n2.POM\n\n```xml\n<dependency>\n       <groupId>org.springframework.cloud</groupId>\n       <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 9001\n```\n\n4.HystrixDashboardMain9001+新注解`@EnableHystrixDashboard`\n\n5.所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n6.浏览器输入http://localhost:9001/hystrix\n\n#### Hystrix图形化Dashboard监控实战\n\n**修改cloud-provider-hystrix-payment8001**\n\n注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class PaymentHystrixMain8001\n{\n    public static void main(String[] args) {\n            SpringApplication.run(PaymentHystrixMain8001.class, args);\n    }\n\n\n    /**\n     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     *ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"，\n     *只要在自己的项目里配置上下面的servlet就可以了\n     *否则，Unable to connect to Command Metric Stream 404\n     */\n    @Bean\n    public ServletRegistrationBean getServlet() {\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings(\"/hystrix.stream\");\n        registrationBean.setName(\"HystrixMetricsStreamServlet\");\n        return registrationBean;\n    }\n}\n```\n\n**监控测试**\n\n启动1个eureka\n\n启动8001，9001\n\n**观察监控窗口**\n\n9001监控8001 - 填写监控地址 - http://localhost:8001/hystrix.stream 到 http://localhost:9001/hystrix页面的输入框。\n\n测试地址\n\n- http://localhost:8001/payment/circuit/1\n- http://localhost:8001/payment/circuit/-1\n- 测试通过\n- 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。\n\n## 服务网关\n\n### GateWay\n\n**概述**\n\nCloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;\n\n但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代\n\n![axh25f.png](https://img-blog.csdnimg.cn/img_convert/54b61d819aa1630bc61732de340b55b4.png)\n\nGateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。\n\n**SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty**。\n\n**作用**\n\n- 方向代理\n- 鉴权\n- 流量控制\n- 熔断\n- 日志监控\n- …\n\n**微服务架构中网关的位置**\n\n![asd14667.png](https://img-blog.csdnimg.cn/img_convert/5877d4b9035ead9cd2d037609dceb442.png)\n\n#### **Gateway工作流程**\n\n**三大核心概念**\n\n- Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；\n- Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由；\n- Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。\n  \n\n![d1c.png](https://img-blog.csdnimg.cn/img_convert/62be54501c6e2b95620b79cc918a2e9a.png)\n\n客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。\n\nHandler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post\"）执行业务逻辑。\n\nFilter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n\n核心逻辑：**路由转发 + 执行过滤器链**。\n\n#### Gateway9527搭建\n\n1.新建Mod\tule - cloud-gateway-gateway9527\n\n2.POM\n\n4.业务类 无\n\n5.主启动类\n\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class GateWayMain9527\n{\n    public static void main(String[] args) {\n        SpringApplication.run(GateWayMain9527.class, args);\n    }\n}\n```\n\n我们目前不想暴露8001端口，希望在8001外面套一层9527\n\n7.YML新增网关配置\n\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n#############################新增网关配置###########################\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\n          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n####################################################################\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n8.测试\n\n启动7001，启动8001-cloud-provider-payment8001，启动9527网关\n\n访问说明\n\n- 添加网关前 - http://localhost:8001/payment/get/1\n- 添加网关后 - http://localhost:9527/payment/get/1\n- 两者访问成功，返回相同结果（可以通过9527端口访问8001端口接口）\n\n#### Gateway配置路由的两种方式\n\n**1.在配置文件yml中配置，见上一章节**\n\n**2.代码中注入RouteLocator的Bean**\n\ncloud-gateway-gateway9527业务实现\n\n```java\n@Configuration\npublic class GateWayConfig\n{\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n\n        routes.route(\"path_route_ljx\",\n                r -> r.path(\"\")\n                        .uri(\"https://www.baidu.com\")).build();\n\n        return routes.build();\n    }\n}\n```\n\n浏览器输入http://localhost:9527，返回https://www.baidu.com相同的页面。\n\n#### GateWay配置动态路由\n\n默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建**动态路由进行转发，从而实现动态路由的功能**（不写死一个地址）\n\n**POM**\n\n cloud-gateway-gateway9527的POM中添加\n\n```xml\n<!--eureka-client-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n**YML**\n\n需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。\n\nlb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。\n\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n#############################新增网关配置###########################\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\n####################################################################\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n\n**测试**\n\n浏览器输入 - http://localhost:9527/payment/lb\n\n不停刷新页面，8001/8002两个端口切换。\n\n#### GateWay常用的Predicate\n\n**常用的Route Predicate Factory**\n\nThe After Route Predicate Factory\nThe Before Route Predicate Factory\nThe Between Route Predicate Factory\nThe Cookie Route Predicate Factory\nThe Header Route Predicate Factory\nThe Host Route Predicate Factory\nThe Method Route Predicate Factory\nThe Path Route Predicate Factory\nThe Query Route Predicate Factory\nThe RemoteAddr Route Predicate Factory\nThe weight Route Predicate Factory\n\n**The After Route Predicate Factory**\n\n**作用：只有在规定的时间之后启动才能生效**\n\n在yml中添加\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: after_route\n        uri: lb://cloud-payment-service\n        predicates:\n        - Path=/payment/get/**      \n        # 这个时间后才能起效\n        - After=2023-08-02T14:59:26.090582100+08:00[Asia/Shanghai]\n```\n\n可以通过下述方法获得上述格式的时间戳字符串\n\n```java\nZonedDateTime zbj = ZonedDateTime.now(); // 默认时区\nSystem.out.println(zbj);\n```\n\n**The Between Route Predicate Factory**\n\n**作用：只有在规定的时间范围内启动才生效**\n\n在yml中添加\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: between_route\n        uri: lb://cloud-payment-service\n        # 两个时间点之间\n        predicates:\n         - Path=/payment/get/**   \n        - Between=2024-01-20T17:42:47.789-07:00[America/Denver], 2023-08-02T14:59:26.090582100+08:00[Asia/Shanghai]\n```\n\n**The Cookie Route Predicate Factory**\n\n作用：**只有带username=ljx的cookie的请求才有效**\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: cookie_route\n        uri: lb://cloud-payment-service\n        predicates:\n        - Cookie=username,ljx\n```\n\n**he Header Route Predicate Factory**\n\n作用：只有带X-Request-Id=正整数的请求头才有效\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: header_route\n        uri: lb://cloud-payment-service\n        predicates:\n        - Header=X-Request-Id, \\d+\n```\n\n**小结**\n\nPredicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。\n\n#### GateWay的Filter\n\n路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。\n\nSpring Cloud Gateway的Filter:\n\n- 生命周期：\n  - pre\n  - post\n- 种类（具体看官方文档）：\n  - GatewayFilter - 有31种\n  - GlobalFilter - 有10种\n\n常用的GatewayFilter：`AddRequestParameter`，`GatewayFilter`\n\n自定义全局GlobalFilter：\n\n两个主要接口介绍：\n\n1. `GlobalFilter`\n2. `Ordered`\n\n能干什么：\n\n1. 全局日志记录\n2. 统一网关鉴权\n3. …\n\n代码案例：\n\nGateWay9527项目添加MyLogGateWayFilter类：\n\n```java\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    \n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    {\n        log.info(\"***********come in MyLogGateWayFilter:  \"+new Date());\n        // 处理只有带了uname的请求才能通过\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n\n        if(uname == null)\n        {\n            log.info(\"*******用户名为null，非法用户，o(╥﹏╥)o\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder()\n    {\n        return 0;\n    }\n}\n```\n\n测试，浏览器输入：\n\n- http://localhost:9527/payment/lb - 反问异常\n- http://localhost:9527/payment/lb?uname=abc - 正常反问\n\n## 服务配置\n\n### config\n\n#### Config分布式配置中心介绍\n\n**分布式系统面临的配置问题**\n\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。\n\nSpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……\n\n![dsaxcj1.png](https://img-blog.csdnimg.cn/img_convert/d5462e3b8c3a063561f5f8fc7fde327e.png)**\n\nSpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n\nSpringCloud Config分为**服务端**和客户端两部分。\n\n- 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。\n\n- 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。\n\n**能干嘛**\n\n- 集中管理配置文件\n- 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n- 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n- 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n- 将配置信息以REST接口的形式暴露 - post/crul访问刷新即可…\n  \n\n**与GitHub整合配置**\n\n由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式。\n\n#### Config配置总控中心搭建\n\n用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository。\n\n由上一步获得刚新建的git地址 - `git@github.com:abc/springcloud-config.git`。\n\n本地硬盘目录上新建git仓库并clone。\n\n- 工作目录为D:\\SpringCloud2021\n- `git clone git@github.com:abc/springcloud-config.git`\n\n此时在工作目录会创建名为springcloud-config的文件夹。\n\n在springcloud-config的文件夹种创建三个配置文件（为本次教学使用的）,随后git add .，git commit -m \"sth\"等一系列上传操作上传到springcloud-config的新Repository。\n\n- config-dev.yml\n\n```yaml\nconfig:\n  info: \"master branch,springcloud-config/config-dev.yml version=7\"\n```\n\n- config-prod.yml\n\n```yaml\nconfig:\n  info: \"master branch,springcloud-config/config-prod.yml version=1\"\n```\n\n- config-test.yml\n\n```yaml\nconfig:\n  info: \"master branch,springcloud-config/config-test.yml version=1\" \n```\n\n新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig Center\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/lijunxi666/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n          skip-ssl-validation: true\n      ####读取分支\n      label: master\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n```\n\n主启动类加上`@EnableConfigServer`\n\nwindows下修改hosts文件，增加映射\n\n```\n127.0.0.1 config-3344.com\n```\n\n**测试**\n\n启动ConfigCenterMain3344\n\n浏览器防问 - http://config-3344.com:3344/master/config-dev.yml\n\n页面返回结果：\n\n```yml\nconfig:\n  info: \"master branch,springcloud-config/config-dev.yml version=7\"\n```\n\n**访问文件的路径**\n\n重要配置细节总结\n\n- /{name}-{profiles}.yml\n- /{label}-{name}-{profiles}.yml\n- label：分支(branch)\n- name：服务名\n- profiles：环境(dev/test/prod)\n\n成功实现了用SpringCloud Config通过GitHub获取配置信息\n\n#### Config客户端配置与测试\n\n**新建cloud-config-client-3355**\n\n**POM**\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n**bootstrap.yml**\n\napplicaiton.yml是用户级的资源配置项\n\nbootstrap.yml是系统级的，优先级更加高\n\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n\n**主启动**添加`@EnableEurekaClient`\n\n**业务类**\n\n```java\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/configInfo\")\n    public String getConfigInfo()\n    {\n        return configInfo;\n    }\n}\n```\n\n**测试**\n\n- 启动Config配置中心3344微服务并自测\n  - http://config-3344.com:3344/master/config-prod.yml\n  - http://config-3344.com:3344/master/config-dev.yml\n\n- 启动3355作为Client准备访问\n  - http://localhost:3355/configlnfo\n\n**成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息可题随时而来**\n\n**分布式配置的动态刷新问题**\n\n- Linux运维修改GitHub上的配置文件内容做调整\n- 刷新3344，发现ConfigServer配置中心立刻响应\n- 刷新3355，发现ConfigClient客户端没有任何响应\n- 3355没有变化除非自己重启或者重新加载\n- 难到每次运维修改配置文件，客户端都需要重启??噩梦\n\n### Config动态刷新手动版\n\n避免每次更新配置都要重启客户端微服务3355\n\n**动态刷新步骤**：\n\n修改3355模块\n\nPOM引入actuator监控\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n修改YML，添加暴露监控端口配置：\n\n```yaml\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n业务类Controller添加`@RefreshScope`\n\n**测试**\n\n此时修改github配置文件内容 -> 访问3344 -> 访问3355：http://localhost:3355/configInfo\n\n发现3355的内容**并没**刷新\n\n**还需要一步**\n\n需要运维人员发送Post请求刷新3355\n\n```\ncurl -X POST \"http://localhost:3355/actuator/refresh\"\n```\n\n再次测试：http://localhost:3355/configInfo\n\n3355 **改了**。\n\n成功实现了客户端3355刷新到最新配置内容，避免了服务重启\n\n**存在的问题**\n\n- 假如有多个微服务客户端3355/3366/3377\n- 每个微服务都要执行—次post请求，手动刷新?\n- 可否广播，一次通知，处处生效?\n- 我们想大范围的自动刷新，求方法\n\n这时候就需要用到**消息总线**\n\n## 消息总线\n\n一言以蔽之，分布式自动刷新配置功能。\n\nSpring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。\n\n![d1xased.png](https://img-blog.csdnimg.cn/img_convert/458fd679c01274ca84f785e1f75c1336.png)\n\nSpring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\n\n**为何被称为总线**\n\n什么是总线？\n\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\n\n基本原理\n\nConfigClient实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。\n\n### RabbitMQ\n\n#### 环境配置\n\n严格遵循erlang和rabbitmq版本对应：[RabbitMQ Erlang Version Requirements — RabbitMQ](https://www.rabbitmq.com/which-erlang.html)\n\n- 安装Erlang，下载地址：http://erlang.org/download/otp_win64_21.3.exe\n\n- 安装RabbitMQ，下载地址：https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.14/rabbitmq-server-3.7.14.exe\n\n- 打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\\devSoft\\RabbitMQ Scrverk\\rabbitmq_server-3.7.14\\sbin\n\n- 输入以下命令启动管理功能`rabbitmq-plugins enable rabbitmq _management`\n\n这样就可以添加可视化插件。\n\n- 访问地址查看是否安装成功：http://localhost:15672/\n- 输入账号密码并登录：guest guest\n\n#### Bus动态刷新全局广播的设计思想和选型\n\n必须先具备良好的RabbitMQ环境先\n\n演示广播效果，增加复杂度，再以3355为模板再制作一个3366\n\n1.新建cloud-config-client-3366\n\n2.POM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n3.YML\n\n```yml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址\n\n#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n4.主启动添加`@EnableEurekaClient`\n\n5.controller\n\n```java\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/configInfo\")\n    public String configInfo()\n    {\n        return \"serverPort: \"+serverPort+\"\\t\\n\\n configInfo: \"+configInfo;\n    }\n\n}\n```\n\n**设计思想**\n\n1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置\n\n![dascx.png](https://img-blog.csdnimg.cn/img_convert/3a0975f4bac7393fe406821531e9daef.png)\n\n2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置\n\n![2150vg0.png](https://img-blog.csdnimg.cn/img_convert/e2809f728b8eb3e776883e4f905b8712.png)\n\n图二的架构显然更加适合，图—不适合的原因如下：\n\n- 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\n\n- 破坏了微服务各节点的对等性。\n\n- 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。\n\n#### Bus动态刷新全局广播配置实现\n\n**给cloud-config-center-3344配置中心服务端添加消息总线支持**\n\nPOM\n\n```xml\n<!--添加消息总线RabbitNQ支持-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-bus-amap</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org-springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloud-config.git #GitHub上面的git仓库名字\n        ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n#rabbitmq相关配置<--------------------------\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n##rabbitmq相关配置,暴露bus刷新配置的端点<--------------------------\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n```\n\n**给cloud-config-client-3355客户端添加消息总线支持**\n\nPOM\n\n```xml\n<!--添加消息总线RabbitNQ支持-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-bus-amap</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org-springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloud-config.git #GitHub上面的git仓库名字\n        ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n#rabbitmq相关配置<--------------------------\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n##rabbitmq相关配置,暴露bus刷新配置的端点<--------------------------\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n```\n\n**给cloud-config-client-3366客户端添加消息总线支持**\n\nPOM\n\n```xml\n<!--添加消息总线RabbitNQ支持-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-bus-amap</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org-springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址\n\n#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口<-----------------------\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n# 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n**测试**\n\n- 启动\n  - EurekaMain7001\n  - EurekaMain7002\n  - ConfigcenterMain3344\n  - ConfigclientMain3355\n  - ConfigclicntMain3366\n\n- 运维工程师\n  - 修改Github上配置文件内容，增加版本号\n  - 发送POST请求\n    - `curl -X POST \"http://localhost:3344/actuator/bus-refresh\"`\n    - **—次发送，处处生效**\n\n- 配置中心\n  - http://config-3344.com:3344/config-dev.yml\n- 客户端\n  - http://localhost:3355/configlnfo\n  - http://localhost:3366/configInfo\n  - 获取配置信息，发现都已经刷新了\n\n**—次修改，广播通知，处处生效**\n\n#### Bus动态刷新定点通知\n\n不想全部通知，只想定点通知\n\n- 只通知3355\n- 不通知3366\n\n简单一句话 - **指定具体某一个实例生效而不是全部**\n\n- 公式：http://localhost:3344/actuator/bus-refresh/{destination}\n- /bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例\n\n案例\n\n- 我们这里以刷新运行在3355端口上的config-client（配置文件中设定的应用名称）为例，只通知3355，不通知3366\n- `curl -X POST \"http://localhost:3344/actuator/bus-refresh/config-client:3355`\n\n**消息通知总结**\n\n![21cx0943.png](https://img-blog.csdnimg.cn/img_convert/ccd5fcc8293edec24d7e889e189d0bfe.png)\n\n## 消息驱动\n\n### Stream\n\n**什么是Spring Cloud Stream？**\n\n官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。\n\n应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。\n\n通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。\n\n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。\nSpring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。\n\n目前仅支持RabbitMQ、 Kafka。\n\n#### 设计思想\n\n![dasd04.png](https://img-blog.csdnimg.cn/img_convert/1ca02dd31581d92a7a610bcd137f6848.png)\n\n- 生产者/消费者之间靠消息媒介传递信息内容\n- 消息必须走特定的通道 - 消息通道 Message Channel\n- 消息通道里的消息如何被消费呢，谁负责收发处理 - 消息通道MessageChannel的子接口SubscribableChannel，由\n- MessageHandler消息处理器所订阅。\n\n#### 常用注解\n\n|    **组成**     |                           **说明**                           |\n| :-------------: | :----------------------------------------------------------: |\n|   Middleware    |              中间件，目前只支持RabbitMQ和Kafka               |\n|     Binder      | inder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,RabbitMQ的exchange)，这些都可以通过配置文件来实现 |\n|     @Input      |   注解标识输入通道，通过该输乎通道接收到的消息进入应用程序   |\n|     @Output     |     注解标识输出通道，发布的消息将通过该通道离开应用程序     |\n| @StreamListener |             监听队列，用于消费者的队列的消息接收             |\n| @EnableBinding  |              指信道channel和exchange绑定在一起               |\n\n **案例说明**\n\n准备RabbitMQ环境\n\n工程中新建三个子模块\n\n- cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块\n- cloud-stream-rabbitmq-consumer8802，作为消息接收模块\n- cloud-stream-rabbitmq-consumer8803，作为消息接收模块\n\n#### Stream消息驱动之生产者\n\n新建Module：cloud-stream-rabbitmq-provider8801\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n      stream:\n        binders: # 在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit: # 表示定义的名称，用于于binding整合\n            type: rabbit # 消息组件类型\n            environment: # 设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings: # 服务的整合处理\n          output: # 这个名字是一个通道的名称\n            destination: studyExchange # 表示要使用的Exchange名称定义\n            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8801.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n```\n\n主启动类StreamMQMain8801\n\n业务类\n\n1.发送消息接口\n\n```java\npublic interface IMessageProvider {\n    public String send();\n}\n```\n\n2.发送消息接口实现类\n\n```java\n@EnableBinding(Source.class) //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send()\n    {\n        String serial = UUID.randomUUID().toString();\n        output.send(MessageBuilder.withPayload(serial).build());\n        System.out.println(\"*****serial: \"+serial);\n        return null;\n    }\n}\n```\n\n3.Controller\n\n```java\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMapping(value = \"/sendMessage\")\n    public String sendMessage() {\n        return messageProvider.send();\n    }\n}\n```\n\n测试\n\n- 启动 7001eureka\n\n- 启动 RabpitMq（\n\n  79_Bus之RabbitMQ环境配置\n\n  ）\n\n  - rabbitmq-plugins enable rabbitmq_management\n  - http://localhost:15672/\n\n- 启动 8801\n\n- 访问 - http://localhost:8801/sendMessage\n\n  - 后台将打印`serial: UUID`字符串\n\n#### Stream消息驱动之消费者\n\n新建Module：cloud-stream-rabbitmq-consumer8802\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8802\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n      stream:\n        binders: # 在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit: # 表示定义的名称，用于于binding整合\n            type: rabbit # 消息组件类型\n            environment: # 设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings: # 服务的整合处理\n          input: # 这个名字是一个通道的名称\n            destination: studyExchange # 表示要使用的Exchange名称定义\n            content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n            binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n\n#### Stream之消息重复消费\n\n依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。\n\n原神，**启动**\n\n- RabbitMQ\n- 服务注册 - 8801\n- 消息生产 - 8801\n- 消息消费 - 8802\n- 消息消费 - 8802\n\n**运行后有两个问题**\n\n1. 有重复消费问题\n2. 消息持久化问题\n\n**消费**\n\n- http://localhost:8801/sendMessage\n- 目前是8802/8803同时都收到了，存在重复消费问题\n- 如何解决：分组和持久化属性group（重要）\n\n**生产实际案例**\n\n比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以**使用Stream中的消息分组来解决**。\n\n![d123654.png](https://img-blog.csdnimg.cn/img_convert/f61e83441af907a42e8886368bde59ff.png)\n\n注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的(重复消费)。\n\n简单总结：只需要每个服务处于统一group下就不会出现重复消费\n\n**解决**\n\n原理\n\n微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。\n\n不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。\n\n8802/8803都变成不同组，group两个不同\n\ngroup: A_Group、B_Group\n\n8802修改YML\n\n```yml\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n      stream:\n        binders: # 在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit: # 表示定义的名称，用于于binding整合\n            type: rabbit # 消息组件类型\n            environment: # 设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings: # 服务的整合处理\n          output: # 这个名字是一个通道的名称\n            destination: studyExchange # 表示要使用的Exchange名称定义\n            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n            group: A_Group #<----------------------------------------关键\n```\n\n8803修改YML（与8802的类似位置 `group: B_Group`）\n\n结论：**还是重复消费**\n\n8802/8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。\n\n**8802/8803都变成相同组，group两个相同**\n\ngroup: A_Group\n\n8802修改YML`group: A_Group`\n\n8803修改YML`group: A_Group`\n\n结论：同一个组的多个微服务实例，每次只会有一个拿到\n\n成功解决重复消费\n\n#### Stream之消息持久化\n\n通过上述，解决了重复消费问题，再看看持久化。\n\n停止8802/8803并去除掉8802的分组group: A_Group，8803的分组group: A_Group没有去掉。\n\n8801先发送4条消息到RabbitMq。\n\n先启动8802，**无分组属性配置**，后台没有打出来消息。\n\n再启动8803，**有分组属性配置**，后台打出来了MQ上的消息。(消息持久化体现)\n\n## 分布式请求链路跟踪\n\n### Sleuth\n\n**为什么会出现这个技术？要解决哪些问题？**\n\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\n\n**是什么**\n\n- https://github.com/spring-cloud/spring-cloud-sleuth\n- Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案\n- 在分布式系统中提供追踪解决方案并且兼容支持了zipkin\n\n#### Sleuth之zipkin搭建安装\n\n1.zipkin\n\n**下载**\n\n- SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可\n- [Central Repository: io/zipkin/zipkin-server (maven.org)](https://repo1.maven.org/maven2/io/zipkin/zipkin-server/)\n- zipkin-server-2.24.3-exec.jar\n\n**运行jar**\n\n```java\njava -jar zipkin-server-2.24.3-exec.jar\n```\n\n**运行控制台**\n\nhttp://localhost:9411/zipkin/\n\n**完整的调用链路**\n\n—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。\n\n![1d9012.png](https://img-blog.csdnimg.cn/img_convert/f75fcfd2146df03428b9c8c53d13c1f1.png)\n\n名词解释\n\n- Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n- span：表示调用链路来源，通俗的理解span就是一次请求信息\n\n#### Sleuth链路监控展现\n\n**修改cloud-provider-payment8001**\n\nPOM\n\n```xml\n<!--包含了sleuth+zipkin-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nspring:\n  application:\n    name: cloud-payment-service\n\n  zipkin: #<-------------------------------------关键 \n      base-url: http://localhost:9411\n  sleuth: #<-------------------------------------关键\n    sampler:\n    #采样率值介于 0 到 1 之间，1 则表示全部采集\n    probability: 1\n```\n\n业务类PaymentController\n\n```java\n@GetMapping(\"/payment/zipkin\")\npublic String paymentZipkin() {\n    return \"hi ,i'am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~\";\n}    \n```\n\n**修改cloue-consumer-order80**\n\nPOM\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\nYML\n\n```xml\nspring:\n    application:\n        name: cloud-order-service\n    zipkin:\n      base-url: http://localhost:9411\n    sleuth:\n      sampler:\n        probability: 1\n```\n\n业务类OrderController\n\n```java\n@GetMapping(\"/consumer/payment/zipkin\")\npublic String paymentZipkin()\n{\n    String result = restTemplate.getForObject(\"http://localhost:8001\"+\"/payment/zipkin/\", String.class);\n    return result;\n}\n```\n\n4.依次启动eureka7001/8001/80 - 80调用8001几次测试下\n\n5.打开浏览器访问: http://localhost:9411\n\n## Spring Cloud Alibaba\n\n**为什么会出现SpringCloud alibaba?**\n\nSpring Cloud Netflix项目进入维护模式\n\nhttps://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now\n\n**什么是维护模式？**\n\n将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。\n\n他们将修复block级别的 bug 以及安全问题，他们也会考虑并审查社区的小型pull request。\n\n**SpringCloud alibaba带来了什么**\n\n[spring-cloud-alibaba/README-zh.md at 2.2.x · alibaba/spring-cloud-alibaba (github.com)](https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md)\n\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n\n**能干嘛**\n\n- 服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ \n- 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\n- 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。\n- 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n- 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\n- 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。\n- 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n- 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。\n- 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\n**MAVEN**\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n            <version>2.2.5.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n- Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n- Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n- RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\n- Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。\n- Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\n- Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n- Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\n- Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\n**Spring Cloud Alibaba学习资料获取**\n\n- 官网\n\nhttps://spring.io/projects/spring-cloud-alibaba#overview\n\n- 英文\n\nhttps://github.com/alibaba/spring-cloud-alibaba\nhttps://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html\n\n- 中文\n\nhttps://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md\n\n### Nacos\n\n#### Nacos介绍\n\n**是什么**\n\n- 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n- Nacos: Dynamic Naming and Configuration Service\n- Nacos就是注册中心＋配置中心的组合 -> **Nacos = Eureka+Config+Bus**\n\n**能干嘛**\n\n- 替代Eureka做服务注册中心\n- 替代Config做服务配置中心\n\n**去哪下**\n\n- https://github.com/alibaba/nacos/releases\n- [官网文档](https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring cloud alibaba nacos_discovery)\n\n**各中注册中心比较**\n\n| 服务注册与发现框架 | CAP模型 | 控制台管理 | 社区活跃度      |\n| ------------------ | ------- | ---------- | --------------- |\n| Eureka             | AP      | 支持       | 低(2.x版本闭源) |\n| Zookeeper          | CP      | 不支持     | 中              |\n| consul             | CP      | 支持       | 高              |\n| Nacos              | AP      | 支持       | 高              |\n\n据说Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验。\n\n#### Nacos安装\n\n- 本地Java8+Maven环境已经OK先\n- 从[官网](https://github.com/alibaba/nacos/releases)下载Nacos\n- 解压安装包，直接运行bin目录下的startup.cmd\n- 命令运行成功后直接访问http://localhost:8848/nacos，默认账号密码都是nacos\n- 结果页面\n\n#### Nacos之服务提供者注册\n\n[官方文档](https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery)\n\n新建Module - cloudalibaba-provider-payment9001\n\n**POM**\n\n父POM\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <!--spring cloud alibaba 2.1.0.RELEASE-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n            <version>2.1.0.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n本模块POM\n\n```xml\n <dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n**YML**\n\n```yml\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n```\n\n主启动添加`@EnableDiscoveryClient`\n\n业务类\n\n```java\n@RestController\npublic class PaymentController {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @GetMapping(value = \"/payment/nacos/{id}\")\n    public String getPayment(@PathVariable(\"id\") Integer id) {\n        return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id;\n    }\n}\n```\n\n测试\n\n- http://localhost:9001/payment/nacos/1\n- nacos控制台\n- nacos服务注册中心+服务提供者9001都OK了\n\n再建一个新模块`cloudalibaba-provider-payment9002`\n\n#### Nacos之服务消费者注册和负载\n\n新建Module - cloudalibaba-consumer-nacos-order83\n\nPOM\n\n```xml\n <dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n为什么nacos支持负载均衡？因为spring-cloud-starter-alibaba-nacos-discovery内含netflix-ribbon包。\n\nYML\n\n```yml\nserver:\n  port: 83\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n```\n\n主启动添加`@EnableDiscoveryClient `\n\n业务类\n\nApplicationContextConfig\n\n```java\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate()\n    {\n        return new RestTemplate();\n    }\n}\n```\n\nOrderNacosController\n\n```java\n@RestController\n@Slf4j\npublic class OrderNacosController {\n    \n    @Resource\n    private RestTemplate restTemplate;\n\n    @Value(\"${service-url.nacos-user-service}\")\n    private String serverURL;\n\n    @GetMapping(value = \"/consumer/payment/nacos/{id}\")\n    public String paymentInfo(@PathVariable(\"id\") Long id)\n    {\n        return restTemplate.getForObject(serverURL+\"/payment/nacos/\"+id,String.class);\n    }\n}\n```\n\n测试\n\n- 启动nacos控制台\n- http://localhost:83/Eonsumer/payment/nacos/13\n  - 83访问9001/9002，轮询负载OK\n\n#### Nacos之服务配置中心\n\n基础配置\n\ncloudalibaba-config-nacos-client3377\n\nPOM\n\n```xml\n<!--nacos-config-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n<!--nacos-discovery-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\nYML\n\nNacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。\n\nspringboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\n\nbootstrap\n\n```yml\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #Nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n        \n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n# nacos-config-client-dev.yaml\n# nacos-config-client-test.yaml   ----> config.info\n```\n\napplication\n\n```qml\nspring:\n  profiles:\n    active: dev # 表示开发环境\n    #active: test # 表示测试环境\n    #active: info\n\n```\n\n主启动添加`@EnableDiscoveryClient`\n\n业务类\n\n```java\n@RestController\n@RefreshScope //支持Nacos的动态刷新功能。\npublic class ConfigClientController\n{\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/config/info\")\n    public String getConfigInfo() {\n        return configInfo;\n    }\n}\n```\n\n**在Nacos中添加配置信息**\n\nNacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则\n\n[官方文档](https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html)\n\n说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。\n\n在 Nacos Spring Cloud中,dataId的完整格式如下：\n\n```java\n${prefix}-${spring-profile.active}.${file-extension}\n```\n\n- prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。\n- spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension}\n- file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。\n- 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。\n\n最后公式：\n\n```java\n${spring.application.name)}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\n```\n\n![21dxw20.png](https://img-blog.csdnimg.cn/img_convert/05d45948bf637614dbd70e2bc8ce992d.png)\n\nNacos界面配置对应 - 设置DataId\n\n![c0tnVf.png](https://img-blog.csdnimg.cn/img_convert/c61619bbe5ea16f34efca8103b0f90ba.png)\n\n配置小结\n\n![202929292.png](https://img-blog.csdnimg.cn/img_convert/b3bffc4a646b30f9bf64fc649bf26f7d.png)\n\n**测试**\n\n- 启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件\n- 运行cloud-config-nacos-client3377的主启动类\n- 调用接口查看配置信息 - http://localhost:3377/config/info\n\n**自带动态刷新**\n\n修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。\n\n#### Nacos之命名空间分组和DataID三者关系\n\n**问题 - 多环境多项目管理**\n\n问题1:\n\n实际开发中，通常一个系统会准备\n\n1. dev开发环境\n2. test测试环境\n3. prod生产环境。\n\n如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?\n\n问题2:\n\n一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?\n\n**Namespace+Group+Data lD三者关系？为什么这么设计？**\n\n1是什么\n\n类似Java里面的package名和类名最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。\n\n2三者情况\n\n![321d10DKLJQ.png](https://img-blog.csdnimg.cn/img_convert/60712abd615dd86ac6c119bf132a28d6.png)\n\n默认情况：Namespace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT\n\n- Nacos默认的Namespace是public，Namespace主要用来实现隔离。\n  - 比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。\n\n- Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去\n- Service就是微服务:一个Service可以包含多个Cluster (集群)，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。\n  - 比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称(HZ) ，给广州机房的Service微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n- 最后是Instance，就是微服务的实例。\n\n#### Nacos之DataID配置\n\n指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置\n\n默认空间+默认分组+新建dev和test两个DatalD\n\n- 新建dev配置DatalD\n- 通过spring.profile.active属性就能进行多环境下配置文件的读取\n\n**测试**\n\n- http://localhost:3377/config/info\n- 配置是什么就加载什么 test/dev\n\n#### Nacos之Group分组方案\n\n通过Group实现环境区分 - 新建Group\n\n![000.png](https://img-blog.csdnimg.cn/img_convert/bdf592aa566fe50f7f454118a70ca03c.png)\n\n在nacos图形界面控制台上面新建配置文件DatalD\n\n![LSINFD.png](https://img-blog.csdnimg.cn/img_convert/28aee2b45901bbb9a6776d5c4398a6bb.png)\n\nbootstrap+application：在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST GROUP\n\n![12LADpw.png](https://img-blog.csdnimg.cn/img_convert/342a167a8bd948d8ba5cbfd760cf66a6.png)\n\n#### Nacos之Namespace空间方案\n\n新建dev/test的Namespace\n\n![Djspc1223.png](https://img-blog.csdnimg.cn/img_convert/a10c71978c75c214aca5fa7057bb2834.png)\n\n回到服务管理-服务列表查看\n\n![2143)KKJ.png](https://img-blog.csdnimg.cn/img_convert/2a9f3fa415f5cead0219d404a47131a0.png)\n\n按照域名配置填写\n\n![wqd1MNCw.png](https://img-blog.csdnimg.cn/img_convert/2177c126090c0db553a8ce77e838a7c9.png)\n\nYML\n\n```yml\n# nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n      config:\n        server-addr: localhost:8848 #Nacos作为配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n        group: DEV_GROUP\n        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4 #<------------指定namespace\n\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\n# nacos-config-client-dev.yaml\n# nacos-config-client-test.yaml   ----> config.info\n```\n\n#### Nacos持久化切换配置\n\nNacos默认自带的是嵌入式数据库derby，[nacos的pom.xml](https://blog.csdn.net/u011863024/article/details/github.com/alibaba/nacos/blob/develop/config/pom.xml)中可以看出。\n\nderby到mysql切换配置步骤：\n\n1. nacos-server-1.1.4\\nacos\\conf录下找到nacos-mysql.sql文件，执行脚本。\n2. nacos-server-1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。\n\n```pr\nspring.datasource.platform=mysql\n\ndb.num=1\ndb.url.0=jdbc:mysql://localhost:3306/nacos_devtest?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\ndb.user=root\ndb.password=1234\n```\n\n启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby。\n\n**1.4.1版本的直接打开31-41行的注释修改为自己就行**\n\n#### Nacos集群配置\n\n这里不太会，有点问题\n\n### Sentinel\n\n#### Sentinel介绍\n\n随着微服务的流行，服务和服务之间的稳定性变得越来越重要。[Sentinel](https://so.csdn.net/so/search?q=Sentinel&spm=1001.2101.3001.7020) 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\nSentinel 具有以下特征:\n\n- 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n- 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n- 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。\n- 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n![12dNucx1.png](https://img-blog.csdnimg.cn/img_convert/e4efa9c3547366ae4f747ad4007f6447.png)\n\n—句话解释，之前我们讲解过的Hystrix\n\nHystrix与Sentinel比较：\n\n- Hystrix\n  1. 需要我们程序员自己手工搭建监控平台\n  2. 没有一套web界面可以给我们进行更加细粒度化得配置流控、速率控制、服务熔断、服务降级\n- Sentinel\n  1. 单独一个组件，可以独立出来。\n  2. 直接界面化的细粒度统一配置。\n\n约定 > 配置 > 编码\n\n都可以写在代码里面，但是我们本次还是大规模的学习使用配置和注解的方式，尽量少写代码\n\n#### Sentinel下载安装运行\n\n服务使用中的各种问题：\n\n- 服务雪崩\n- 服务降级\n- 服务熔断\n- 服务限流\n\nSentinel 分为两个部分：\n\n- 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n- 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n#### Sentinel初始化监控\n\n**启动Nacos8848成功**\n\n**新建工程 - cloudalibaba-sentinel-service8401**\n\nPOM\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n<!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到-->\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-datasource-nacos</artifactId>\n</dependency>\n<!--SpringCloud ailibaba sentinel -->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n</dependency>\n<!--openfeign-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n<!-- SpringBoot整合Web组件+actuator -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        port: 8719\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\nfeign:\n  sentinel:\n    enabled: true # 激活Sentinel对Feign的支持\n```\n\n主启动类`@EnableDiscoveryClient`\n\n业务类FlowLimitController\n\n```java\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping(\"/testA\")\n    public String testA()\n    {\n        return \"------testA\";\n    }\n\n    @GetMapping(\"/testB\")\n    public String testB()\n    {\n        log.info(Thread.currentThread().getName()+\"\\t\"+\"...testB\");\n        return \"------testB\";\n    }\n}\n```\n\n**启动Sentinel8080 - `java -jar sentinel-dashboard-1.7.0.jar`**\n\n**启动微服务8401，查看sentienl控制台**\n\n- 刚启动，空空如也，啥都没有\n\n- Sentinel采用的懒加载说明\n  - 执行一次访问即可\n    - http://localhost:8401/testA\n    - http://localhost:8401/testB\n  - 效果 - sentinel8080正在监控微服务8401\n\n#### Sentinel流控规则简介\n\n![11111.png](https://img-blog.csdnimg.cn/img_convert/d8ae2bea252af0bb278332b3aeb8fb77.png)\n\n- 资源名：唯一名称，默认请求路径。\n- 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。\n- 阈值类型/单机阈值：\n  - QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。\n  - 线程数：当调用该API的线程数达到阈值的时候，进行限流。\n- 是否集群：不需要集群。\n- 流控模式：\n  - 直接：API达到限流条件时，直接限流。\n  - 关联：当关联的资源达到阈值时，就限流自己。\n  - 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。\n- 流控效果：\n  - 快速失败：直接失败，抛异常。\n  - Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。\n  - 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。\n\n#### Sentinel流控-QPS直接失败\n\n**直接 -> 快速失败（系统默认）**\n\n**配置及说明**\n\n表示1秒钟内查询1次就是OK，若超过次数1，就直接->快速失败，报默认错误\n\n**测试**\n\n快速多次点击访问http://localhost:8401/testA\n\n**结果**\n\n返回页面 Blocked by Sentinel (flow limiting)\n\n**源码**\n\ncom.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController\n\n**思考**\n\n直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?\n\n#### Sentinel流控-线程数直接失败\n\n修改FlowLimitController，给请求增加时长\n\n```java\n@GetMapping(\"/testA\")\npublic String testA()\n{\n    try {\n        TimeUnit.MILLISECONDS.sleep(800);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"------testA\";\n}\n```\n\n当有多个请求同时访问的时候搜，超过阈值就会出错\n\n#### Sentinel流控-关联\n\n- 当自己关联的资源达到阈值时，就限流自己\n- 当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）\n\n**设置testA**\n\n当关联资源/testB的QPS阀值超过1时，就限流/testA的Rest访问地址，**当关联资源到阈值后限制配置好的资源名**。\n\n![3841.png](https://img-blog.csdnimg.cn/img_convert/12cd41ae91ba50fe3b5525bab7bc3805.png)\n\nJmeter密集访问[localhost:8401/testB](http://localhost:8401/testB)，在此期间访问[localhost:8401/testA](http://localhost:8401/testA)会出现错误`Blocked by Sentinel(flow limiting)`\n\n#### Sentinel流控-预热\n\n> 默认coldFactor为3，即请求QPS 从 threshold / 3开始，经预热时长逐渐升至设定的QPS阈值。[link](https://github.com/alibaba/Sentinel/wiki/流量控制#warm-up)\n\n**源码** - com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController\n\n系统初始化的阀值为10/ 3约等于3,即阀值刚开始为3;然后过了5秒后阀值才慢慢升高恢复到10\n\n**测试**\n\n多次快速点击http://localhost:8401/testB - 刚开始不行，后续慢慢OK\n\n![IOid.png](https://img-blog.csdnimg.cn/img_convert/c26846d68d79eae1e962f37942a2c99f.png)\n\n**应用场景**\n\n如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来,慢慢的把阀值增长到设置的阀值。\n\n#### Sentinel流控-排队等待\n\n匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。\n\n设置：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。\n\n![231000.png](https://img-blog.csdnimg.cn/img_convert/0ddd217545dd0fe2b1f251dbea814ac2.png)\n\n**测试**\n\n- 添加日志记录代码到FlowLimitController的testA方法\n\n```java\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping(\"/testA\")\n    public String testA()\n    {\n        log.info(Thread.currentThread().getName()+\"\\t\"+\"...testA\");//<----\n        return \"------testA\";\n    }\n\n}\n```\n\n用Jmeter测试，发现后端输出是每隔一秒钟输出一个\n\n#### Sentinel降级简介\n\n**熔断降级概述**\n\n> 除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。\n>\n> 现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。\n\n![123ddqghbb.png](https://img-blog.csdnimg.cn/img_convert/6a002ef360a4e5f20ee2748a092f0211.png)\n\n- RT（平均响应时间，秒级）\n  - 平均响应时间 超出阈值 且 在时间窗口内通过的请求>=5，两个条件同时满足后触发降级。\n  - 窗口期过后关闭断路器。\n  - RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效）。\n- 异常比列（秒级）\n  - QPS >= 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。\n- 异常数(分钟级)\n  - 异常数(分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级\n\nSentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。\n\n当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。\n\nSentinei的断路器是没有类似Hystrix半开状态的。(Sentinei 1.8.0 已有半开状态)\n\n半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。\n\n#### Sentinel降级-RT\n\n![20202020.png](https://img-blog.csdnimg.cn/img_convert/dcf85d4362c017e543173c76b7dcc2a8.png)\n\n**注意**：Sentinel 1.7.0才有**平均响应时间**（`DEGRADE_GRADE_RT`），Sentinel 1.8.0的没有这项，取而代之的是**慢调用比例** (`SLOW_REQUEST_RATIO`)。\n\n![087rc.png](https://img-blog.csdnimg.cn/img_convert/3a608908cef3d557322967e6bc0e5696.png)\n\n用jmter测压，一秒打10个\n\ncontroller代码\n\n```java\n@GetMapping(\"/testD\")\npublic String testD() {\n    try { \n        TimeUnit.SECONDS.sleep(1); \n    } catch (InterruptedException e) { \n        e.printStackTrace(); \n    }\n    log.info(\"testD 测试RT\");\n}\n```\n\n**结论**\n\n按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。\n#### Sentinel降级-异常比例\n\n![12c23.png](https://img-blog.csdnimg.cn/img_convert/b8f35b00fffd79ef68e8f744403b92f3.png)\n\n修改controller代码\n\n```java\n@GetMapping(\"/testD\")\npublic String testD() {\n    try { \n        TimeUnit.SECONDS.sleep(1); \n    } catch (InterruptedException e) { \n        e.printStackTrace(); \n    }\n    log.info(\"testD 测试RT\");\n}\n```\n\n![120dxc.png](https://img-blog.csdnimg.cn/img_convert/ab66591ba085c32e9303d96be7b44f0d.png)\n\n按照上述配置，单独访问一次，必然来一次报错一次(int age = 10/0)，调一次错一次。\n\n开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错error而是服务降级了。\n\n#### Sentinel降级-异常数\n\n**异常数是按照分钟统计的，时间窗口一定要大于等于60秒**。\n\n![1211235.png](https://img-blog.csdnimg.cn/img_convert/d92c6a9ae5ed514b52ddf43fdf0d5f0e.png)\n\n添加controller代码\n\n```java\n@GetMapping(\"/testE\")\npublic String testE()\n{\n    log.info(\"testE 测试异常数\");\n    int age = 10/0;\n    return \"------testE 测试异常数\";\n}\n```\n\n![b0thSJ.png](https://img-blog.csdnimg.cn/img_convert/218fe52e19c07b30bbf4d994d05e6a8e.png)\n\n访问http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。\n\n#### Sentinel热点key(上)\n\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n\n- 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制\n- 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制\n\n热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n\n![312sLLL.png](https://img-blog.csdnimg.cn/img_convert/16d2ddeff96b7cb68a064b6ec05bde25.png)\n\n**承上启下复习start**\n\n兜底方法，分为系统默认和客户自定义，两种\n\n之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel (flow limiting)\n\n我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法?\n\n结论 - **从HystrixCommand到@SentinelResource**\n\n再contrller中添加\n\n```java\n@GetMapping(\"/testHotKey\")\n@SentinelResource(value = \"testHotKey\",blockHandler/*兜底方法*/ = \"deal_testHotKey\")\npublic String testHotKey(@RequestParam(value = \"p1\",required = false) String p1,\n                         @RequestParam(value = \"p2\",required = false) String p2) {\n    //int age = 10/0;\n    return \"------testHotKey\";\n}\n\n/*兜底方法*/\npublic String deal_testHotKey (String p1, String p2, BlockException exception) {\n    return \"------deal_testHotKey,o(╥﹏╥)o\";  //sentinel系统默认的提示：Blocked by Sentinel (flow limiting)\n}\n```\n\n**配置**\n\n![dsdcopp.png](https://img-blog.csdnimg.cn/img_convert/9620ee4e7e54d48ba7dda394fa1c8cd0.png)\n\n**测试**\n\n- error\n  - http://localhost:8401/testHotKey?p1=abc\n  - http://localhost:8401/testHotKey?p1=abc&p2=33\n- right\n  - http://localhost:8401/testHotKey?p2=abc\n\n若不配置`@SentinelResource(value = \"testHotKey\",blockHandler/*兜底方法*/ = \"deal_testHotKey\")`的话前端就只能看到一个报错界面 \n\n#### Sentinel热点key(下)\n\n上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流。\n\n**参数例外项**\n\n- 普通 - 超过1秒钟一个后，达到阈值1后马上被限流\n- **我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样**\n- 特例 - 假如当p1的值等于5时，它的阈值可以达到200\n\n![dsax-ca.png](https://img-blog.csdnimg.cn/img_convert/3aa08b15109cd346a6083f080a0468fa.png)\n\n**测试**\n\n- right - http://localhost:8401/testHotKey?p1=5\n- error - http://localhost:8401/testHotKey?p1=3\n- 当p1等于5的时候，阈值变为200\n- 当p1不等于5的时候，阈值就是平常的1\n\n**前提条件** - 热点参数的注意点，参数必须是基本类型或者String\n\n**其它**\n\n在`testHotKey`方法中添加`int age = 10/0;`使程序报错\n\n将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。\n\n- @SentinelResource - 处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理;\n\n- RuntimeException int age = 10/0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管\n\n总结 - @SentinelResource主管配置出错，运行出错该走异常走异常\n\n#### Sentinel系统规则\n\n就是一次性对所有接口进行限制\n\n系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\n\n- Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。\n- CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。\n- 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。\n- 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。\n- 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。\n\n#### SentinelResource配置(上)\n\n*按资源名称限流 + 后续处理*\n\n**启动Nacos成功**\n\n**启动Sentinel成功**\n\n**Module - cloudalibaba-sentinel-service8401**\n\ncontroller\n\n```java\n@RestController\npublic class RateLimitController {\n    \n    @GetMapping(\"/byResource\")\n    @SentinelResource(value = \"byResource\",blockHandler = \"handleException\")\n    public CommonResult byResource() {\n        return new CommonResult(200,\"按资源名称限流测试OK\",new Payment(2020L,\"serial001\"));\n    }\n    \n    public CommonResult handleException(BlockException exception) {\n        return new CommonResult(444,exception.getClass().getCanonicalName()+\"\\t 服务不可用\");\n    }\n}\n```\n\n**配置流控规则**\n\n配置步骤\n\n![21100101.png](https://img-blog.csdnimg.cn/img_convert/91aa0ac210011218db9557a2bfcfebd1.png)\n\n图形配置和代码关系\n\n表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流\n\n**测试**\n\n1秒钟点击1下，OK\n\n超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生\n\n```json\n{\"code\":444, \"message\":\"com.alibaba.csp.sentinel.slots.block.flow.FlowException\\t 服务不可用\", \"data\":null}\n```\n\n**额外问题**\n\n此时关闭问服务8401 -> Sentinel控制台，流控规则消失了\n\n------\n\n*按照Url地址限流 + 后续处理*\n\n**通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息**\n\n**业务类RateLimitController**\n\n```java\n@GetMapping(\"/rateLimit/byUrl\")\n@SentinelResource(value = \"byUrl\")\npublic CommonResult byUrl()\n{\n    return new CommonResult(200,\"按url限流测试OK\",new Payment(2020L,\"serial002\"));\n}\n```\n\n**Sentinel控制台配置**\n\n![1xll.png](https://img-blog.csdnimg.cn/img_convert/d6a79b7cc3f2f9c8b6dcbe3f77f78c6b.png)\n\n**测试**\n\n- 快速点击http://localhost:8401/rateLimit/byUrl\n- 结果 - 会返回Sentinel自带的限流处理结果 `Blocked by Sentinel (flow limiting)`\n\n**上面兜底方案面临的问题**\n\n1. 系统默认的，没有体现我们自己的业务要求。\n2. 依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。\n3. 每个业务方法都添加—个兜底的，那代码膨胀加剧。\n4. 全局统—的处理方法没有体现。\n\n#### SentinelResource配置(中)\n\n客户自定义限流处理逻辑\n\n自定义限流处理类 - 创建`CustomerBlockHandler`类用于自定义限流处理逻辑\n\n```java\nimport com.alibaba.csp.sentinel.slots.block.BlockException;\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\n\npublic class CustomerBlockHandler {\n    public static CommonResult handlerException(BlockException exception) {\n        return new CommonResult(4444,\"按客戶自定义,global handlerException----1\");\n    }\n    \n    public static CommonResult handlerException2(BlockException exception) {\n        return new CommonResult(4444,\"按客戶自定义,global handlerException----2\");\n    }\n}\n```\n\nRateLimitController\n\n```java\n@GetMapping(\"/rateLimit/customerBlockHandler\")\n@SentinelResource(value = \"customerBlockHandler\",\n        blockHandlerClass = CustomerBlockHandler.class,//<-------- 自定义限流处理类\n        blockHandler = \"handlerException2\")//<-----------\npublic CommonResult customerBlockHandler()\n{\n    return new CommonResult(200,\"按客戶自定义\",new Payment(2020L,\"serial003\"));\n}\n```\n\nSentinel控制台配置\n\n![1114-123d.png](https://img-blog.csdnimg.cn/img_convert/44dccf4107a74fda56f0807d39fa53f1.png)\n\n启动微服务后先调用一次 - http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。\n\n#### SentinelResource配置(下)\n\n**@SentinelResource 注解**\n\n> 注意：注解方式埋点不支持 private 方法。\n\n@SentinelResource`用于定义资源，并提供可选的异常处理和 fallback 配置项。 `@SentinelResource` 注解包含以下属性：\n\n- value：资源名称，必需项（不能为空）\n- entryType：entry 类型，可选项（默认为 EntryType.OUT）\n- blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。若本次访问被限流或服务降级，则调用blockHandler指定的接口。\n- fallback /fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若本接口出现未知异常，则调用fallback指定的接口。fallback 函数签名和位置要求：\n  - 返回值类型必须与原函数返回值类型一致；\n  - 方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n  - fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n- defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：\n  - 返回值类型必须与原函数返回值类型一致；\n  - 方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n  - defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n- `exceptionsToIgnore`（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。\n\nSentinel主要有三个核心Api：\n\n1. SphU定义资源\n2. Tracer定义统计\n3. ContextUtil定义了上下文\n\n#### Sentinel服务熔断Ribbon环境预说\n\nsentinel整合ribbon+openFeign+fallback\n\nRibbon系列\n\n- 启动nacos和sentinel\n- 提供者9003/9004\n- 消费者84\n\n------\n\n**提供者9003/9004**\n\n新建cloudalibaba-provider-payment9003/9004，两个一样的做法\n\nPOM\n\n```xml\n<dependencies>\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n        <groupId>com.atguigu.springcloud</groupId>\n        <artifactId>cloud-api-commons</artifactId>\n        <version>${project.version}</version>\n    </dependency>\n    <!-- SpringBoot整合Web组件 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <!--日常通用jar包配置-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\nYML\n\n```yml\nserver:\n  port: 9003\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n```\n\n**记得修改不同的端口号**\n\n主启动添加`@EnableDiscoveryClient`\n\n业务类\n\n```java\n@RestController\npublic class PaymentController {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    //模拟数据库\n    public static HashMap<Long,Payment> hashMap = new HashMap<>();\n    static\n    {\n        hashMap.put(1L,new Payment(1L,\"28a8c1e3bc2742d8848569891fb42181\"));\n        hashMap.put(2L,new Payment(2L,\"bba8c1e3bc2742d8848569891ac32182\"));\n        hashMap.put(3L,new Payment(3L,\"6ua8c1e3bc2742d8848569891xt92183\"));\n    }\n\n    @GetMapping(value = \"/paymentSQL/{id}\")\n    public CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id)\n    {\n        Payment payment = hashMap.get(id);\n        CommonResult<Payment> result = new CommonResult(200,\"from mysql,serverPort:  \"+serverPort,payment);\n        return result;\n    }\n}\n```\n\n测试地址 - http://localhost:9003/paymentSQL/1\n\n------\n\n**消费者84**\n\n新建cloudalibaba-consumer-nacos-order84\n\nPOM\n\n```xml\n<dependencies>\n    <!--SpringCloud openfeign -->\n    <!--\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\n    </dependency>\n\t-->\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n    </dependency>\n    <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n    <dependency>\n        <groupId>com.atguigu.springcloud</groupId>\n        <artifactId>cloud-api-commons</artifactId>\n        <version>${project.version}</version>\n    </dependency>\n    <!-- SpringBoot整合Web组件 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <!--日常通用jar包配置-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\nYML\n\n```yml\nserver:\n  port: 84\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n    sentinel:\n      transport:\n        #配置Sentinel dashboard地址\n        dashboard: localhost:8080\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\n        port: 8719\n\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n\n# 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: false\n```\n\n主启动\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients\n```\n\nApplicationContextConfig\n\n```java\n@Configuration\npublic class ApplicationContextConfig {\n\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\nCircleBreakerController\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping(\"/consumer/fallback/{id}\")\n    @SentinelResource(value = \"fallback\")//没有配置\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    \n}\n```\n\n修改后请重启微服务\n\n- 热部署对java代码级生效及时\n- 对@SentinelResource注解内属性，有时效果不好\n\n目的\n\n- fallback管运行异常\n- blockHandler管配置违规\n\n测试地址 - http://localhost:84/consumer/fallback/1\n\n没有任何配置\n\n只配置fallback\n\n只配置blockHandler\n\nfallback和blockHandler都配置\n\n忽略属性\n\n#### Sentinel服务熔断只配置fallback\n\n为了防止出现程序报错页面，添加兜底方法\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    \n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping(\"/consumer/fallback/{id}\")\n    //@SentinelResource(value = \"fallback\")//没有配置\n    @SentinelResource(value = \"fallback\", fallback = \"handlerFallback\") //fallback只负责业务异常\n    public CommonResult<Payment> fallback(@PathVariable Long id) {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    \n    //本例是fallback\n    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage(),payment);\n    }\n    \n}\n```\n\n#### Sentinel服务熔断只配置blockHandler\n\nblockHandler只负责**sentinel控制台配置违规**\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/consumer/fallback/{id}\")\n    //@SentinelResource(value = \"fallback\") //没有配置\n    //@SentinelResource(value = \"fallback\",fallback = \"handlerFallback\") //fallback只负责业务异常\n    @SentinelResource(value = \"fallback\",blockHandler = \"blockHandler\") //blockHandler只负责sentinel控制台配置违规\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    //本例是fallback\n/*    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage(),payment);\n    }*/\n    \n    //本例是blockHandler\n    public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(445,\"blockHandler-sentinel限流,无此流水: blockException  \"+blockException.getMessage(),payment);\n    }\n}\n```\n\n#### Sentinel服务熔断fallback和blockHandler都配置\n\n若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。\n\n异常访问会走handlerFallback，若设置了限流的话，多次访问会走blockHandler\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICE_URL = \"http://nacos-payment-provider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/consumer/fallback/{id}\")\n    //@SentinelResource(value = \"fallback\") //没有配置\n    //@SentinelResource(value = \"fallback\",fallback = \"handlerFallback\") //fallback只负责业务异常\n    //@SentinelResource(value = \"fallback\",blockHandler = \"blockHandler\") //blockHandler只负责sentinel控制台配置违规\n    @SentinelResource(value = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\")\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n    //本例是fallback\n    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage(),payment);\n    }\n    //本例是blockHandler\n    public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) {\n        Payment payment = new Payment(id,\"null\");\n        return new CommonResult<>(445,\"blockHandler-sentinel限流,无此流水: blockException  \"+blockException.getMessage(),payment);\n    }\n}\n```\n\n#### Sentinel服务熔断exceptionsToIgnore\n\nexceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。\n\n```java\n@RestController\n@Slf4j\npublic class CircleBreakerController    \n\n    ...\n    \n    @RequestMapping(\"/consumer/fallback/{id}\")\n    @SentinelResource(value = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\",\n            exceptionsToIgnore = {IllegalArgumentException.class})//<-------------\n    public CommonResult<Payment> fallback(@PathVariable Long id)\n    {\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id,CommonResult.class,id);\n\n        if (id == 4) {\n            //exceptionsToIgnore属性有IllegalArgumentException.class，\n            //所以IllegalArgumentException不会跳入指定的兜底程序。\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\n        }else if (result.getData() == null) {\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\n        }\n\n        return result;\n    }\n\n\t...\n}\n```\n\n#### Sentinel服务熔断OpenFeign\n\n**修改84模块**\n\n- 84消费者调用提供者9003\n- Feign组件一般是消费侧\n\nPOM\n\n```xml\n<!--SpringCloud openfeign -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\nYML\n\n```yaml\n# 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n```\n\n业务类\n\n带@Feignclient注解的业务接口，fallback = PaymentFallbackService.class\n\n```jade\n@FeignClient(value = \"nacos-payment-provider\",fallback = PaymentFallbackService.class)\npublic interface PaymentService\n{\n    @GetMapping(value = \"/paymentSQL/{id}\")\n    public CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id);\n}\n```\n\n```java\n@Component\npublic class PaymentFallbackService implements PaymentService {\n    @Override\n    public CommonResult<Payment> paymentSQL(Long id)\n    {\n        return new CommonResult<>(44444,\"服务降级返回,---PaymentFallbackService\",new Payment(id,\"errorSerial\"));\n    }\n}\n```\n\nController\n\n```java\n@Resource\nprivate PaymentService paymentService;\n@GetMapping(value = \"/consumer/paymentSQL/{id}\")\npublic CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id)\n{\n    return paymentService.paymentSQL(id);\n}\n```\n\n主启动\n\n```java\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients//<------------------------\npublic class OrderNacosMain84 {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderNacosMain84.class, args);\n    }\n}\n```\n\n测试 - http://localhost:84/consumer/paymentSQL/1\n\n测试84调用9003，此时故意关闭9003微服务提供者，**84消费侧自动降级**，不会被耗死。\n\n**熔断框架比较**\n\n[![pPFrBUP.png](https://s1.ax1x.com/2023/08/04/pPFrBUP.png)](https://imgse.com/i/pPFrBUP)\n\n#### Sentinel持久化规则\n\n**是什么**\n\n一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。\n\n**怎么玩**\n\n将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。\n\n**步骤**\n\n修改cloudalibaba-sentinel-service8401\n\nPOM\n\n```xml\n<!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到-->\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-datasource-nacos</artifactId>\n</dependency>\n```\n\nYML\n\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        port: 8719\n      datasource: #<---------------------------关注点，添加Nacos数据源配置\n        ds1:\n          nacos:\n            server-addr: localhost:8848\n            dataId: cloudalibaba-sentinel-service\n            groupId: DEFAULT_GROUP\n            data-type: json\n            rule-type: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\nfeign:\n  sentinel:\n    enabled: true # 激活Sentinel对Feign的支持\n```\n\n添加Nacos业务规则配置\n\n![214PPPP.png](https://img-blog.csdnimg.cn/img_convert/2401a6b2df715ee64f647da2f31e1eeb.png)\n\n配置内容解析\n\n```jso\n[{\n    \"resource\": \"/rateLimit/byUrl\",\n    \"limitApp\": \"default\",\n    \"grade\": 1,\n    \"count\": 1, \n    \"strategy\": 0,\n    \"controlBehavior\": 0,\n    \"clusterMode\": false\n}]\n```\n\n- resource：资源名称；\n- limitApp：来源应用；\n- grade：阈值类型，0表示线程数, 1表示QPS；\n- count：单机阈值；\n- strategy：流控模式，0表示直接，1表示关联，2表示链路；\n- controlBehavior：流控效果，0表示快速失败，\n- 1表示Warm Up，2表示排队等待；\n- clusterMode：是否集群。\n\n启动8401后刷新sentinel发现业务规则有了\n\n![0-0-0-wqq.png](https://img-blog.csdnimg.cn/img_convert/c854e986254c09d0a7866811ec1e0cb4.png)\n\n快速访问测试接口 - http://localhost:8401/rateLimit/byUrl - 页面返回`Blocked by Sentinel (flow limiting)`\n\n停止8401再看sentinel - 停机后发现流控规则没有了\n\n重新启动8401再看sentinel\n\n- 乍一看还是没有，稍等一会儿\n- 多次调用 - http://localhost:8401/rateLimit/byUrl\n- 重新配置出现了，持久化验证通过\n\n### Seata\n\n#### 分布式事务问题由来\n\n分布式前\n\n- 单机单库没这个问题\n- 从1:1 -> 1:N -> N:N\n\n单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时**每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证**。\n\n一句话：**一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题**。\n\n#### Seata术语\n\nSeata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。\n\n**能干嘛**\n\n一个典型的分布式事务过程\n\n分布式事务处理过程的一ID+三组件模型：\n\n- Transaction ID XID 全局唯一的事务ID\n- 三组件概念\n  - TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。\n  - TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n  - RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n处理过程：\n\n- TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；\n- XID在微服务调用链路的上下文中传播；\n- RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；\n- TM向TC发起针对XID的全局提交或回滚决议；\n- TC调度XID下管辖的全部分支事务完成提交或回滚请求。\n\n![cnaois.png](https://img-blog.csdnimg.cn/img_convert/2d2c6aa29c3158413f66d4ef8c1000dc.png)\n\n#### Seata-Server安装\n\n**下载**\n\n[Releases · seata/seata (github.com)](https://github.com/seata/seata/releases/)\n\n**怎么玩**\n\n本地@Transactional\n\n全局@GlobalTransactional\n**SEATA 的分布式交易解决方案**\n\n我们只需要使用一个 `@GlobalTransactional` 注解在业务方法上\n","title":" SpringCloud学习笔记\n","category":[" Java","SpringCloud\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n笔记参考博客：\n\n https://blog.csdn.net/u011863024/article/details/114298270\n https://blog.csdn.net/u011863024/article/details/114298282\n https://blog.csdn.net/u011863024/article/details/114298288https://blog.csdn.net/u011863024/article/details/114298288\n\n 环境搭建\n\n约定  配置  编码\n\n创建微服务cloud整体聚合父工程Project，有8个关键步骤：\n\n1、New Project  maven工程  create from archetype: mavenarchetypesite\n2、聚合总父工程名字\n3、Maven选版本\n4、工程名字\n5、字符编码  Settings  File encoding\n6、注解生效激活  Settings  Annotation Processors\n7、Java编译版本选8\n8、File Type过滤  Settings  File Type\n\n 复习\n\n DependencyManagement和Dependencies\n\nMaven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。\n\n通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement元素。\n\n使用pom.xml中的dependencyManagement元素能让所有在子项目中引用个依赖而不用显式的列出版本量。\n\nMaven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号。\n\n说白了就是父项目用了版本号，子项目就可以不需要写版本号，便于维护\n\n注意\n\n dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。\n 如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。\n 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。\n\n Maven跳过单元测试\n\nIDEA右侧旁的Maven插件有Toggle ' Skip Tests' Mode按钮，这样maven可以跳过单元测试\n\n父工程创建完成执行mvn : install将父工程发布到仓库方便子工程 继承\n\n Dashboard窗口\n\n1. 打开工程路径下的.idea文件夹的workspace.xml\n2. 在<component name=\"RunDashboard\"中修改或添加以下代码：重启即可\n\nxml\n<option name=\"configurationTypes\"\n\t<set\n\t\t<option value=\"SpringBootApplicationConfigurationType\"/\n    </set\n</option\n\n\n\n\n 支付模块构建\n\n创建微服务模块套路：\n\n1. 建Module\n2. 改POM\n3. 写YML\n4. 主启动\n5. 业务类\n\npPSszzn.pnghttps://s1.ax1x.com/2023/07/29/pPSszzn.pnghttps://imgse.com/i/pPSszzn\n\n 消费模块构建\n\npPSyCLV.pnghttps://s1.ax1x.com/2023/07/29/pPSyCLV.pnghttps://imgse.com/i/pPSyCLV\n\n Restemplate\n\nRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集\n\n使用：\n\n 使用restTemplate访问restful接口非常的简单粗暴无脑。\n url, requestMap, ResponseBean.class这三个参数分别代表。\n REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。\n\njava\n// 消费模块调用支付模块接口\nrestTemplate.postForObject\"http://localhost:8001/payment/create\", payment, CommonResult.class;\n\n\n getForObject / getForEntity  GET请求方法\n\n getForObject：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。\n\n getForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。\n\n 工程重构\n\n观察cloudconsumerorder80与cloudproviderpayment8001两工程有重复代码（entities包下的实体）\n\n1、新建cloudapicommons来存放公共代码和一些配置类等等\n\n2、添加pom文件\n\n3、将cloudconsumerorder80与cloudproviderpayment8001两工程的公有entities包移至cloudapicommons工程下\n\n4、maven clean、install \n\n5、将cloudconsumerorder80与cloudproviderpayment8001两工程的公有entities包移除\n\n6、两个工程引入cloudapicommons依赖\n\nxml\n<dependency\n    <groupIdcom.ljx.springcloud</groupId\n    <artifactIdcloudapicommons</artifactId\n    <version${project.version}</version\n</dependency\n\n\n 知识点\n\npPSgBTK.pnghttps://s1.ax1x.com/2023/07/29/pPSgBTK.pnghttps://imgse.com/i/pPSgBTK\n\n最终需要在上述项目基础上一点点添加这些组件\n\n 服务注册中心\n\n Eureka\n\n 基础知识\n\nEureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。\n\naaa.pnghttps://imgblog.csdnimg.cn/imgconvert/3956561052b9dc3909f16f1ff26d01bb.png\n\nEureka包含两个组件:Eureka Server和Eureka Client\n\nEureka Server提供服务注册服务\n\n各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n\nEurekaClient通过注册中心进行访问\n\n它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询roundrobin负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳默认周期为30秒。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒\n\n EurekaServer服务端安装\n\neurekaServer端服务注册中心，类似物业公司\n\n1.创建名为cloudeurekaserver7001的Maven工程\n\n2.修改pom.xml\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaserver</artifactId\n</dependency\n\n\n3.添加application.yml\n\nyml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost eureka服务端的实例名称\n  client:\n    false表示不向注册中心注册自己。\n    registerwitheureka: false\n    false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetchregistry: false\n    serviceurl:\n      设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n\n4.主启动\n\njava\n@EnableEurekaServer\n\n\n5.测试运行EurekaMain7001，浏览器输入http://localhost:7001/回车，会查看到Spring Eureka服务主页。\n\n 支付微服务8001入驻进EurekaServer\n\nEurekaClient端cloudproviderpayment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。\n\n1.创建名为cloudeurekaserver7001的Maven工程\n\n2.修改pom.xml\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaserver</artifactId\n</dependency\n\n\n3.添加application.yml\n\nyml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost eureka服务端的实例名称\n  client:\n    false表示不向注册中心注册自己。\n    registerwitheureka: false\n    false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetchregistry: false\n    serviceurl:\n      设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n\n4.主启动\n\njava\n@EnableEurekaClient\n\n\n5.测试\n\n 启动cloudproviderpayment8001和cloudeurekaserver7001工程（先启动）。\n\n 浏览器输入  http://localhost:7001/ 主页内的Instances currently registered with Eureka会显示cloudproviderpayment8001的配置文件application.yml设置的应用名cloudpaymentservice\n\n6.自我保护机制\n\nEMERGENCY EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.\n\n紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。\n\n 订单微服务80入驻进EurekaServer\n\nEurekaClient端cloudconsumerorder80将注册进EurekaServer成为服务消费者consumer，类似来上课消费的同学\n\n1.cloudconsumerorder80\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloudorderservice\n\neureka:\n  client:\n    表示是否将自己注册进Eurekaserver默认为true。\n    registerwitheureka: true\n    是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka\n\n\n4.主启动\n\njava\n@EnableEurekaClient\n\n\n5.测试\n\n 启动cloudproviderpayment8001、cloudeurekaserver7001（先启动）和cloudconsumerorder80这三工程。\n 浏览器输入 http://localhost:7001 , 在主页的Instances currently registered with Eureka将会看到cloudproviderpayment8001、cloudconsumerorder80两个工程名。\n\n Eureka集群原理说明\n\nimg.pnghttps://imgblog.csdnimg.cn/imgconvert/14570c4b7c4dd8653be6211da2675e45.png\n\n问题：微服务RPC远程服务调用最核心的是什么？\n高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。\n\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。\n\n互相注册，相互守望。\n\n Eureka集群环境构建\n\n创建cloudeurekaserver7002工程\n\n 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件，修改映射配置添加进hosts文件\n\n\n127.0.0.1 eureka7001.com\n127.0.0.1 eureka7002.com\n\n\n 修改cloudeurekaserver7001配置文件\n\nyml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: eureka7001.com eureka服务端的实例名称\n  client:\n    registerwitheureka: false     false表示不向注册中心注册自己。\n    fetchregistry: false     false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    serviceurl:\n    集群指向其它eureka\n      defaultZone: http://eureka7002.com:7002/eureka/\n    单机就是7001自己\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n\n 修改cloudeurekaserver7002配置文件\n\nyml\nserver:\n  port: 7002\n\neureka:\n  instance:\n    hostname: eureka7002.com eureka服务端的实例名称\n  client:\n    registerwitheureka: false     false表示不向注册中心注册自己。\n    fetchregistry: false     false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    serviceurl:\n    集群指向其它eureka\n      defaultZone: http://eureka7001.com:7001/eureka/\n    单机就是7002自己\n      defaultZone: http://eureka7002.com:7002/eureka/\n\n\n 订单支付两微服务注册进Eureka集群\n\n将它们的配置文件的eureka.client.serviceurl.defaultZone进行修改\n\nyml\neureka:\n  client:\n    表示是否将自己注册进Eurekaserver默认为true。\n    registerwitheureka: true\n    是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    serviceurl:\n      注册到集群中\n      defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka\n\n\n1. 先要启动EurekaServer，7001/7002服务\n2. 再要启动服务提供者provider，8001\n3. 再要启动消费者，80\n4. 浏览器输入  http://localhost/consumer/payment/get/1\n\n 支付微服务集群配置\n\n新建cloudproviderpayment8002参考cloudprovicerpayment8001\n\n负载均衡\n\ncloudconsumerorder80订单服务访问地址不能写死\n\njava\npublic static final String PAYMENTURL = \"http://CLOUDPAYMENTSERVICE\";\n\n\n使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n\njava\n@Configuration\npublic class ApplicationContextConfig {\n    @Bean\n    @LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\n    public RestTemplate getRestTemplate{\n        return new RestTemplate;\n    }\n}\n\n\n actuator微服务信息完善\n\n主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）\n\n修改cloudproviderpayment8001，cloudproviderpayment8002\n\n修改部分  YML  eureka.instance.instanceid\n\nyml\neureka:\n  ...\n  instance:\n    instanceid: payment8001 显示名称\n    preferipaddress: true 显示ip地址\n\n\n修改之后\n\neureka主页将显示payment8001，payment8002代替原来显示的IP地址。\n\n 服务发现Discovery\n\n对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n Eureka自我保护理论知识\n\n保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n\n如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:\n\nEMERGENCY EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE\n\n导致原因\n\n一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。\n\n属于CAP里面的AP分支。\n\n为什么会产生Eureka自我保护机制?\n\n为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除\n\n什么是自我保护模式?\n\n认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例默认90秒。但是当网络分区故障发生延时、卡顿、拥挤时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时可能发生了网络分区故障，那么这个节点就会进入自我保护模式。\n\nb.pnghttps://imgblog.csdnimg.cn/imgconvert/264b66e8099a3761beaea2ba44b8fc5e.png\n\n在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例\n\n它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着。\n\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。\n\n禁止自我保护\n\n出厂默认，自我保护机制是开启的\n\nyml\neureka:\n  ...\n  server:\n    关闭自我保护机制，保证不可用服务被及时踢除\n    enableselfpreservation: false\n    evictionintervaltimerinms: 2000\n\n\n关闭效果：springeureka主页会显示出一句：\n\nTHE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.\n\n Zookeeper\n\nLinux下载\n\nsh\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper3.7.1/apachezookeeper3.7.1bin.tar.gz\n\n\n解压\n\nsh\ntar zxvf apachezookeeper3.7.1bin.tar.gz\n\n\n启动\n\nsh\n./zkServer.sh start\n\n\n关闭防火墙\n\nsh\nsudo systemctl stop ufw.service\n\n\n 支付服务注册进zookeeper\n\n1.新建名为cloudproviderpayment8004的Maven工程。\n\n2.POM\n\nxml\n      < SpringBoot整合zookeeper客户端 \n        <dependency\n            <groupIdorg.springframework.cloud</groupId\n            <artifactIdspringcloudstarterzookeeperdiscovery</artifactId\n            <先排除自带的zookeeper3.5.3 防止与3.4.9起冲突\n            <exclusions\n                <exclusion\n                    <groupIdorg.apache.zookeeper</groupId\n                    <artifactIdzookeeper</artifactId\n                </exclusion\n            </exclusions\n        </dependency\n        <添加zookeeper3.4.9版本\n        <dependency\n            <groupIdorg.apache.zookeeper</groupId\n            <artifactIdzookeeper</artifactId\n            <version3.4.9</version\n        </dependency\n\n\n3.YML\n\nyml\n8004表示注册到zookeeper服务器的支付服务提供者端口号\nserver:\n  port: 8004\n\n服务别名注册zookeeper到注册中心名称\nspring:\n  application:\n    name: cloudproviderpayment\n  cloud:\n    zookeeper:\n      connectstring: 127.0.0.1:2181  192.168.111.144:2181 \n\n\n4.主启动类\n\njava\n@EnableDiscoveryClient//该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n\n\n5.Controller\n\nJAVA\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @RequestMappingvalue = \"/payment/zk\"\n    public String paymentzk\n    {\n        return \"springcloud with zookeeper: \"+serverPort+\"\\t\"+ UUID.randomUUID.toString;\n    }\n}\n\n\n 订单服务注册进zookeeper\n\n1.新建cloudconsumerzkorder80（与上面类似）\n\n2.POM\n\n3.YML\n\n4.主启动\n\n5.配置类\n\njava\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate\n    {\n        return new RestTemplate;\n    }\n}\n\n\n6.业务类\n\njava\n@RestController\n@Slf4j\npublic class OrderZKController\n{\n    public static final String INVOKEURL = \"http://cloudproviderpayment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMappingvalue = \"/consumer/payment/zk\"\n    public String paymentInfo\n    {\n        String result = restTemplate.getForObjectINVOKEURL+\"/payment/zk\",String.class;\n        return result;\n    }\n}\n\n\n7.访问测试地址  http://localhost/consumer/payment/zk\n\n Consul\n\n官网链接：https://www.consul.io/\n\nConsul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。\n\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\n\n它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。\n\n能干嘛？\n\n 服务发现  提供HTTP和DNS两种发现方式。\n 健康监测  支持多种方式，HTTP、TCP、Docker、Shell脚本定制化\n KV存储  Key、Value的存储方式\n 多数据中心  Consul支持多数据中心\n 可视化Web界面\n\n相关命令\n\n 查看版本：consul v\n 开发模式启动consul agent dev\n\n浏览器输入  http://localhost:8500/  打开Consul控制页。\n\n 服务提供者注册进Consul\n\n1.新建Module支付服务provider8006\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterconsuldiscovery</artifactId\n</dependency\n\n\n3.YML\n\nyaml\nconsul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consulproviderpayment\nconsul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        hostname: 127.0.0.1\n        servicename: ${spring.application.name}\n\n\n4.主启动类\n\njava\n@EnableDiscoveryClient\n\n\n5.业务类Controller\n\njava\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @RequestMappingvalue = \"/payment/consul\"\n    public String paymentConsul\n    {\n        return \"springcloud with consul: \"+serverPort+\"\\t   \"+ UUID.randomUUID.toString;\n    }\n}\n\n\n6.验证测试\n\n http://localhost:8006/payment/consul\n http://localhost:8500  会显示provider8006\n\n 服务消费者注册进Consul\n\n1.新建Module消费服务order80  cloudconsumerconsulorder80\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterconsuldiscovery</artifactId\n</dependency\n\n\n3.YML\n\njava\nconsul服务端口号\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloudconsumerorder\nconsul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        hostname: 127.0.0.1\n        servicename: ${spring.application.name}\n\n\n4.主启动类\n\njava\n@EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\n\n\n5.配置Bean\n\njava\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate\n    {\n        return new RestTemplate;\n    }\n}\n\n\n6.业务类\n\njava\n@RestController\n@Slf4j\npublic class OrderConsulController\n{\n    public static final String INVOKEURL = \"http://consulproviderpayment\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMappingvalue = \"/consumer/payment/consul\"\n    public String paymentInfo\n    {\n        String result = restTemplate.getForObjectINVOKEURL+\"/payment/consul\",String.class;\n        return result;\n    }\n}\n\n\n7.验证测试\n\n运行consul，cloudproviderconsulpayment8006，cloudconsumerconsulorder80\n\nhttp://localhost:8500/ 主页会显示出consul，cloudproviderconsulpayment8006，cloudconsumerconsulorder80三服务。\n\n8.访问测试地址  http://localhost/consumer/payment/consul\n\n 三个注册中心异同点\n\n 组件名     语言CAP  服务健康检查  对外暴露接口  Spring Cloud集成 \n          \n Eureka     Java     AP            可配支持      HTTP             \n Consul     Go       CP            支持          HTTP/DNS         \n Zookeeper  Java     CP            支持客户端    已集成           \n\nCAP：\n\n C：Consistency 强一致性\n A：Availability 可用性\n P：Partition tolerance （分区容错性\n\n111.pnghttps://imgblog.csdnimg.cn/imgconvert/b41e0791c9652955dd3a2bc9d2d60983.png\n\n最多只能同时较好的满足两个。\n\nCAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。\n\n因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:\n\nCA  单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。\nCP  满足一致性，分区容忍必的系统，通常性能不是特别高。\nAP  满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n AP架构（Eureka）\n\n当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\n\n结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n\n123.pnghttps://imgblog.csdnimg.cn/imgconvert/2d07748539300b9c466eb1d9bac5cd1b.png\n\n CP架构（ZooKeeper/Consul）\n\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。\n\n结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。\n\ne21x.pnghttps://imgblog.csdnimg.cn/imgconvert/c6f2926a97420015fcebc89b094c5598.png\n\nCP 与 AP 对立同一的矛盾关系。\n\n 服务调用\n\n Ribbon\n\nSpring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。\n\n简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。\n\nRibbon未来可能被Spring Cloud LoadBalacer替代。\n\nLB负载均衡Load Balance是什么\n\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA 高可用。\n\n常见的负载均衡有软件Nginx，LVS，硬件F5等。\n\nRibbon本地负载均衡客户端 VS Nginx服务端负载均衡区别\n\nNginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。\nRibbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\n\n集中式LB\n\n即在服务的消费方和提供方之间使用独立的LB设施可以是硬件，如F5, 也可以是软件，如nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方;\n\n进程内LB\n\n将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\nRibbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n一句话\n\n负载均衡 + RestTemplate调用\n\n Ribbon的负载均衡和Rest调用\n\n总结：Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。\n\n1dc.pnghttps://imgblog.csdnimg.cn/imgconvert/145b915e56a85383b3ad40f0bb2256e0.png\n\nRibbon在工作时分成两步：\n\n 第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。\n 第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。\n\n其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。\n\nspringcloudstarternetflixeurekaclient自带了springcloudstarterribbon引用\n\n Ribbon默认自带的负载规则\n\nlRule：根据特定算法中从服务列表中选取一个要访问的服务\n\nasdacg2.pnghttps://imgblog.csdnimg.cn/imgconvert/87243c00c0aaea211819c0d8fc97e445.png\n\n RoundRobinRule 轮询\n RandomRule 随机\n RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重\n WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择\n BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例\n ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器\n\nRibbon负载规则替换\n\n1.修改cloudconsumerorder80\n\n2.注意配置细节\n\n官方文档明确给出了警告：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了（也就是说不要将Ribbon配置类与主启动类同包）\n\n3.新建package  com.lun.myrule\n\n4.在com.ljx.myrule下新建MySelfRule规则类\n\njava\n@Configuration\npublic class MySelfRule {\n\n    @Bean\n    public IRule myRule{\n        return new RandomRule;\n    }\n}\n\n\n5.主启动类添加\n\njava\n@RibbonClientname = \"CLOUDPAYMENTSERVICE\", configuration = MySelfRule.class\n\n\n OpenFeign\n\nFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。\n\n前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\n\nFeign集成了Ribbon\n\n利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。\n\n Feign和OpenFeign两者区别\n\nFeign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterfeign</artifactId\n</dependency\n\n\npenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVc的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n\n\n OpenFeign服务调用\n\n接口+注解：微服务调用接口 + @FeignClient\n\n1.新建cloudconsumerfeignorder80\n\n2.POM\n\nxml\n<dependency\n     <groupIdorg.springframework.cloud</groupId\n     <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 80\n\neureka:\n  client:\n    registerwitheureka: false\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\n\n\n4.主启动\n\njava\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n    public static void mainString args {\n        SpringApplication.runOrderFeignMain80.class, args;\n    }\n}\n\n\n5.业务类\n\n业务逻辑接口+@FeignClient配置调用provider服务\n\n新建PaymentFeignService接口并新增注解@FeignClient\n\njava\n@Component\n@FeignClientvalue = \"CLOUDPAYMENTSERVICE\"\npublic interface PaymentFeignService\n{\n    @GetMappingvalue = \"/payment/get/{id}\"\n    public CommonResult<Payment getPaymentById@PathVariable\"id\" Long id;\n}\n\n\n注意：若有公共前缀api的请求，需要修改为@FeignClientvalue = \"xx\", path=\"/api\"\n\nController类\n\njava\n@RestController\n@Slf4j\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n\n    @GetMappingvalue = \"/consumer/payment/get/{id}\"\n    public CommonResult<Payment getPaymentById@PathVariable\"id\" Long id\n    {\n        return paymentFeignService.getPaymentByIdid;\n    }\n}\n\n\n6.测试\n\n先启动2个eureka集群7001/7002，再启动2个微服务8001/8002，最后启动OpenFeign启动\n\n访问http://localhost/consumer/payment/get/1\n\nFeign自带负载均衡配置项\n\n OpenFeign超时控制\n\n超时设置，故意设置超时演示出错情况\n\n1.服务提供方8001/8002故意写暂停程序\n\njava\n    @GetMappingvalue = \"/payment/feign/timeout\"\n    public String paymentFeignTimeout\n    {\n        // 业务逻辑处理正确，但是需要耗费3秒钟\n        try {\n            TimeUnit.SECONDS.sleep3;\n        } catch InterruptedException e {\n            e.printStackTrace;\n        }\n        return serverPort;\n    }\n\n\n2.服务消费方80添加超时方法PaymentFeignService\n\njava\n@GetMappingvalue = \"/payment/feign/timeout\"\npublic String paymentFeignTimeout;\n\n\n3.服务消费方80添加超时方法OrderFeignController\n\njava\n@GetMappingvalue = \"/consumer/payment/feign/timeout\"\npublic String paymentFeignTimeout\n{\n    // OpenFeign客户端一般默认等待1秒钟\n    return paymentFeignService.paymentFeignTimeout;\n}\n\n\n4.测试：\n\n多次刷新http://localhost/consumer/payment/feign/timeout\n\n将会跳出错误Spring Boot默认错误页面，主要异常：feign.RetryableException:Read timed out executing GET http://CLOUDPAYMENTSERVCE/payment/feign/timeout。\n\nOpenFeign默认等待1秒钟，超过后报错\n\nYML文件里需要开启OpenFeign客户端超时控制\n\nyml\n设置feign客户端超时时间OpenFeign默认支持ribbon单位：毫秒\nribbon:\n  指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\n  ReadTimeout: 5000\n  指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n\n\n OpenFeign日志增强\n\n日志打印功能\n\nFeign提供了日志打印功能，我们可以通过配置来调整日恙级别，从而了解Feign 中 Http请求的细节。\n\n说白了就是对Feign接口的调用情况进行监控和输出\n\n日志级别\n\n NONE：默认的，不显示任何日志;\n BASIC：仅记录请求方法、URL、响应状态码及执行时间;\n HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;\n FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。\n\n配置日志bean\n\njava\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel\n    {\n        return Logger.Level.FULL;\n    }\n}\n\n\nYML文件里需要开启日志的Feign客户端\n\nyml\nlogging:\n  level:\n     feign日志以什么级别监控哪个接口\n    com.ljx.springcloud.service.PaymentFeignService: debug\n\n\n后台日志查看\n\n得到更多日志信息\n\n 服务降级\n\n分布式系统面临的问题\n\n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n\n服务雪崩\n\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\n对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n\n所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\n\n Hystrix\n\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n\n\"断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝，向调用方返回一个符合预期的、可处理的备选响应（FallBack，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n主要功能\n\n 服务降级\n 服务熔断\n 接近实对的监控\n\n服务降级\n\n服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback\n\n哪些情况会出发降级？\n\n 程序运行导常\n\n 超时\n 服务熔断触发服务降级\n 线程池/信号量打满也会导致服务降级\n\n服务熔断\n\n类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。\n\n服务的降级  进而熔断  恢复调用链路\n\n服务限流\n\n秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。\n\n Hystrix支付微服务构建\n\n1.新建cloudproviderhygtrixpayment8001\n\n2.POM\n\nxml\n<dependency\n      <groupIdorg.springframework.cloud</groupId\n      <artifactIdspringcloudstarternetflixhystrix</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloudproviderhystrixpayment\n\neureka:\n  client:\n    registerwitheureka: true\n    fetchregistry: true\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n4.主启动\n\njava\n@EnableEurekaClient\n\n\n5.业务类\n\nservice\n\njava\n@Service\npublic class PaymentService {\n    /\n     /\n    public String paymentInfoOKInteger id\n    {\n        return \"线程池:  \"+Thread.currentThread.getName+\"  paymentInfoOK,id:  \"+id+\"\\t\"+\"O∩∩O哈哈\";\n    }\n\n    public String paymentInfoTimeOutInteger id\n    {\n        try { TimeUnit.MILLISECONDS.sleep3000; } catch InterruptedException e { e.printStackTrace; }\n        return \"线程池:  \"+Thread.currentThread.getName+\" id:  \"+id+\"\\t\"+\"O∩∩O哈哈\"+\"  耗时秒: 3\";\n    }\n}\n\n\ncontroller\n\njava\n@RestController\n@Slf4j\npublic class PaymentController\n{\n    @Resource\n    private PaymentService paymentService;\n\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @GetMapping\"/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id\n    {\n        String result = paymentService.paymentInfoOKid;\n        log.info\"result: \"+result;\n        return result;\n    }\n\n    @GetMapping\"/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id\n    {\n        String result = paymentService.paymentInfoTimeOutid;\n        log.info\"result: \"+result;\n        return result;\n    }\n}\n\n\n6.正常测试\n\n以上述为根基平台，从正确  错误  降级熔断  恢复。\n\n JMeter高并发压测后卡顿\n\n上述在非高并发情形下，还能勉强满足\n\nJmeter压测结论\n\n上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢\n\n Hystrix订单微服务\n\n1.新建  cloudconsumerfeignhystrixorder80\n\n2.POM\n\nxml\n<dependency\n      <groupIdorg.springframework.cloud</groupId\n      <artifactIdspringcloudstarternetflixhystrix</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 80\n\neureka:\n  client:\n    registerwitheureka: false\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n4.主启动\n\n5.业务类\n\njava\n@Component\n@FeignClientvalue = \"CLOUDPROVIDERHYSTRIXPAYMENT\" /,fallback = PaymentFallbackService.class/\npublic interface PaymentHystrixService\n{\n    @GetMapping\"/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id;\n\n    @GetMapping\"/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id;\n}\n\n\njava\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping\"/consumer/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id\n    {\n        String result = paymentHystrixService.paymentInfoOKid;\n        return result;\n    }\n\n    @GetMapping\"/consumer/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id {\n        String result = paymentHystrixService.paymentInfoTimeOutid;\n        return result;\n    }\n}\n\n\n6.正常测试\n\n7.高并发测试\n\n2W个线程压8001，消费端80微服务再去访问正常的Ok微服务8001地址，消费者80被拖慢\n\n原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。\n\n正因为有上述故障或不佳表现才有我们的降级/容错/限流等技术诞生。\n\n 降级容错解决的维度要求\n\n超时导致服务器变慢转圈 》超时不再等待\n\n出错宕机或程序运行出错 》 出错要有兜底\n\n解决：\n\n 对方服务8001超时了，调用者80不能一直卡死等待，必须有服务降级。\n 对方服务8001down机了，调用者80不能一直卡死等待，必须有服务降级。\n 对方服务8001OK，调用者80自己出故障或有自我要求自己的等待时间小于服务提供者，自己处理降级。\n\n Hystrix服务降级支付fallback\n\n降级配置  @HystrixCommand\n\n设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。\n\n—旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法\n\njava\n@Service\npublic class PaymentService{\n\n    @HystrixCommandfallbackMethod = \"paymentInfoTimeOutHandler\", commandProperties = {\n            @HystrixPropertyname=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\"\n    }\n    public String paymentInfoTimeOutInteger id\n    {\n        //int age = 10/0;\n        try { TimeUnit.MILLISECONDS.sleep5000; } catch InterruptedException e { e.printStackTrace; }\n        return \"线程池:  \"+Thread.currentThread.getName+\" id:  \"+id+\"\\t\"+\"O∩∩O哈哈\"+\"  耗时秒: \";\n    }\n\n    //用来善后的方法\n    public String paymentInfoTimeOutHandlerInteger id\n    {\n        return \"线程池:  \"+Thread.currentThread.getName+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o╥﹏╥o\";\n    }\n    \n}\n\n\n上面故意制造两种异常:\n\n1. int age = 10/0，计算异常\n2. 我们能接受3秒钟，它运行5秒钟，超时异常。\n\n当前服务不可用了，做服务降级，兜底的方案都是paymentInfoTimeOutHandler\n\n主启动类激活\n\n添加新注解@EnableCircuitBreaker\n\n Hystrix服务降级订单fallback\n\n1.YML\n\nyml\nserver:\n  port: 80\n\neureka:\n  client:\n    registerwitheureka: false\n    serviceurl:\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n开启\nfeign:\n  hystrix:\n    enabled: true\n\n\n2.主启动添加@EnableHystrix\n\n3.业务类\n\njava\n@RestController\n@Slf4j\npublic class OrderHystirxController {\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping\"/consumer/payment/hystrix/timeout/{id}\"\n    @HystrixCommandfallbackMethod = \"paymentTimeOutFallbackMethod\",commandProperties = {\n            @HystrixPropertyname=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"1500\"\n    }\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id {\n        //int age = 10/0;\n        String result = paymentHystrixService.paymentInfoTimeOutid;\n        return result;\n    }\n    \n    //善后方法\n    public String paymentTimeOutFallbackMethod@PathVariable\"id\" Integer id{\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o╥﹏╥o\";\n    }\n}\n\n\n Hystrix全局服务降级DefaultProperties\n\n前问题1 每个业务方法对应一个兜底的方法，代码膨胀\n\n解决方法\n\n1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明\n\n1:N除了个别重要核心业务有专属，其它普通的可以通过@DefaultPropertiesdefaultFallback = “xxx”统一跳转到统一处理结果页面\n\n通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量\n\njava\n@RestController\n@Slf4j\n@DefaultPropertiesdefaultFallback = \"paymentGlobalFallbackMethod\"\npublic class OrderHystirxController {\n\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping\"/consumer/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id\n    {\n        String result = paymentHystrixService.paymentInfoOKid;\n        return result;\n    }\n\n//    @HystrixCommandfallbackMethod = \"paymentTimeOutFallbackMethod\", commandProperties = {\n//            @HystrixPropertyname=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\"\n//    }\n    @HystrixCommand//用全局的fallback方法\n    @GetMapping\"/consumer/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id {\n        String result = paymentHystrixService.paymentInfoTimeOutid;\n        return result;\n    }\n\n    //善后方法\n    public String paymentTimeOutFallbackMethod@PathVariable\"id\" Integer id{\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o╥﹏╥o\";\n    }\n\n    // 下面是全局fallback方法\n    public String paymentGlobalFallbackMethod\n    {\n        return \"Global异常处理信息，请稍后再试，/ㄒoㄒ/\";\n    }\n}\n\n\n Hystrix通配服务降级FeignFallback\n\n目前问题2 统一和自定义的分开，代码混乱\n\n服务降级，客户端去调用服务端，碰上服务端宕机或关闭\n\n本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feignhttps://so.csdn.net/so/search?q=Feign&spm=1001.2101.3001.7020客户端定义的接口添加一个服务降级处理的实现类即可实现解耦\n\n未来我们要面对的异常\n\n 运行\n 超时\n 宕机\n\n1.新建PaymentFallbackService类实现PaymentHystrixService接口\n\njava\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class PaymentFallbackService implements PaymentHystrixService\n{\n    @Override\n    public String paymentInfoOKInteger id\n    {\n        return \"PaymentFallbackService fall backpaymentInfoOK ,o╥﹏╥o\";\n    }\n\n    @Override\n    public String paymentInfoTimeOutInteger id\n    {\n        return \"PaymentFallbackService fall backpaymentInfoTimeOut ,o╥﹏╥o\";\n    }\n}\n\n\n2.YML\n\nyml\nfeign:\n  hystrix:\n    enabled: true\n\n\n3.PaymentHystrixService接口\n\njava\n@Component\n@FeignClientvalue = \"CLOUDPROVIDERHYSTRIXPAYMENT\" ,\n             fallback = PaymentFallbackService.class//指定PaymentFallbackService类\npublic interface PaymentHystrixService\n{\n    @GetMapping\"/payment/hystrix/ok/{id}\"\n    public String paymentInfoOK@PathVariable\"id\" Integer id;\n\n    @GetMapping\"/payment/hystrix/timeout/{id}\"\n    public String paymentInfoTimeOut@PathVariable\"id\" Integer id;\n}\n\n\n4.测试\n\n单个eureka先启动7001，PaymentHystrixMain8001启动\n\n正常访问测试  http://localhost/consumer/payment/hystrix/ok/1，故意关闭微服务8001\n\n客户端自己调用提示  此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。\n\n Hystrix服务熔断理论\n\n断路器，相当于保险丝。\n\n熔断机制概述\n\n熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，只有当成功率挺高到一定阈值才会关闭。熔断机制的注解是@HystrixCommand。\n\n Hystrix之服务熔断案例\n\nHutool国产工具类https://hutool.cn/\n\n修改cloudproviderhystrixpayment8001\n\nservice层\n\njava\n@Service\npublic class PaymentService{    \n   \n    //=====服务熔断\n    @HystrixCommandfallbackMethod = \"paymentCircuitBreakerfallback\",commandProperties = {\n            @HystrixPropertyname = \"circuitBreaker.enabled\",value = \"true\",// 是否开启断路器\n            @HystrixPropertyname = \"circuitBreaker.requestVolumeThreshold\",value = \"10\",// 请求次数\n            @HystrixPropertyname = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\", // 时间窗口期\n            @HystrixPropertyname = \"circuitBreaker.errorThresholdPercentage\",value = \"60\",// 失败率达到多少后跳闸\n    }\n    public String paymentCircuitBreaker@PathVariable\"id\" Integer id {\n        ifid < 0 {\n            throw new RuntimeException\"id 不能负数\";\n        }\n        String serialNumber = IdUtil.simpleUUID;\n\n        return Thread.currentThread.getName+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreakerfallback@PathVariable\"id\" Integer id {\n        return \"id 不能负数，请稍后再试，/ㄒoㄒ/   id: \" +id;\n    }\n\n}\n\n\ncontroller层\n\njava\n@GetMapping\"/payment/circuit/{id}\"\npublic String paymentCircuitBreaker@PathVariable\"id\" Integer id\n{\n    String result = paymentService.paymentCircuitBreakerid;\n    log.info\"result: \"+result;\n    return result;\n}\n\n\n测试\n\n多次错误，再来次正确，但错误得显示\n\n重点测试  多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行\n\n Hystrix服务熔断总结\n\n熔断类型\n\n 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR平均故障处理时间，当打开时长达到所设时钟则进入半熔断状态。\n 熔断关闭：熔断关闭不会对服务进行熔断。\n 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。\n\n断路器开启或者关闭的条件\n\n 到达以下阀值，断路器将会开启：\n   当满足一定的阀值的时候（默认10秒内超过20个请求次数\n   当失败率达到一定的时候（默认10秒内超过50%的请求失败\n 当开启的时候，所有请求都不会进行转发\n 一段时间之后（默认是5秒，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。\n\n断路器打开之后\n\n1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\n\n2：原来的主逻辑要如何恢复呢？\n\n对于这一问题，hystrix也为我们实现了自动恢复功能。\n\n当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\n\nAll配置\n\njava\n@HystrixCommandfallbackMethod = \"fallbackMethod\", \n                groupKey = \"strGroupCommand\", \n                commandKey = \"strCommand\", \n                threadPoolKey = \"strThreadPool\",\n                \n                commandProperties = {\n                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离\n                    @HystrixPropertyname = \"execution.isolation.strategy\", value = \"THREAD\",\n                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\n                    @HystrixPropertyname = \"execution.isolation.semaphore.maxConcurrentRequests\", value = \"10\",\n                    // 配置命令执行的超时时间\n                    @HystrixPropertyname = \"execution.isolation.thread.timeoutinMilliseconds\", value = \"10\",\n                    // 是否启用超时时间\n                    @HystrixPropertyname = \"execution.timeout.enabled\", value = \"true\",\n                    // 执行超时的时候是否中断\n                    @HystrixPropertyname = \"execution.isolation.thread.interruptOnTimeout\", value = \"true\",\n                    \n                    // 执行被取消的时候是否中断\n                    @HystrixPropertyname = \"execution.isolation.thread.interruptOnCancel\", value = \"true\",\n                    // 允许回调方法执行的最大并发数\n                    @HystrixPropertyname = \"fallback.isolation.semaphore.maxConcurrentRequests\", value = \"10\",\n                    // 服务降级是否启用，是否执行回调函数\n                    @HystrixPropertyname = \"fallback.enabled\", value = \"true\",\n                    // 是否启用断路器\n                    @HystrixPropertyname = \"circuitBreaker.enabled\", value = \"true\",\n                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\n                    @HystrixPropertyname = \"circuitBreaker.requestVolumeThreshold\", value = \"20\",\n                    \n                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 \"打开\" 状态，否则就设置为 \"关闭\" 状态。\n                    @HystrixPropertyname = \"circuitBreaker.errorThresholdPercentage\", value = \"50\",\n                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 \"半开\" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 \"打开\" 状态，如果成功就设置为 \"关闭\" 状态。\n                    @HystrixPropertyname = \"circuitBreaker.sleepWindowinMilliseconds\", value = \"5000\",\n                    // 断路器强制打开\n                    @HystrixPropertyname = \"circuitBreaker.forceOpen\", value = \"false\",\n                    // 断路器强制关闭\n                    @HystrixPropertyname = \"circuitBreaker.forceClosed\", value = \"false\",\n                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\n                    @HystrixPropertyname = \"metrics.rollingStats.timeinMilliseconds\", value = \"10000\",\n                    \n                    // 该属性用来设置滚动时间窗统计指标信息时划分\"桶\"的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 \"桶\" 来累计各度量值，每个\"桶\"记录了一段时间内的采集指标。\n                    // 比如 10 秒内拆分成 10 个\"桶\"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常\n                    @HystrixPropertyname = \"metrics.rollingStats.numBuckets\", value = \"10\",\n                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 1。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.enabled\", value = \"false\",\n                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.timeInMilliseconds\", value = \"60000\",\n                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.numBuckets\", value = \"60000\",\n                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\n                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\n                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\n                    @HystrixPropertyname = \"metrics.rollingPercentile.bucketSize\", value = \"100\",\n                    \n                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\n                    @HystrixPropertyname = \"metrics.healthSnapshot.intervalinMilliseconds\", value = \"500\",\n                    // 是否开启请求缓存\n                    @HystrixPropertyname = \"requestCache.enabled\", value = \"true\",\n                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中\n                    @HystrixPropertyname = \"requestLog.enabled\", value = \"true\",\n\n                },\n                threadPoolProperties = {\n                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\n                    @HystrixPropertyname = \"coreSize\", value = \"10\",\n                    // 该参数用来设置线程池的最大队列大小。当设置为 1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。\n                    @HystrixPropertyname = \"maxQueueSize\", value = \"1\",\n                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\n                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\n                    @HystrixPropertyname = \"queueSizeRejectionThreshold\", value = \"5\",\n                }\n               \npublic String doSomething {\n\t...\n}\n\n\n Hystrix图形化Dashboard搭建\n\n概述\n\n除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控Hystrix Dashboard，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。\n\nNetflix通过hystrixmetricseventstream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\n\n仪表盘9001\n\n1新建cloudconsumerhystrixdashboard9001\n\n2.POM\n\nxml\n<dependency\n       <groupIdorg.springframework.cloud</groupId\n       <artifactIdspringcloudstarternetflixhystrixdashboard</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 9001\n\n\n4.HystrixDashboardMain9001+新注解@EnableHystrixDashboard\n\n5.所有Provider微服务提供类8001/8002/8003都需要监控依赖配置\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\n6.浏览器输入http://localhost:9001/hystrix\n\n Hystrix图形化Dashboard监控实战\n\n修改cloudproviderhystrixpayment8001\n\n注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径\n\njava\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class PaymentHystrixMain8001\n{\n    public static void mainString args {\n            SpringApplication.runPaymentHystrixMain8001.class, args;\n    }\n\n\n    /\n     此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"，\n     只要在自己的项目里配置上下面的servlet就可以了\n     否则，Unable to connect to Command Metric Stream 404\n     /\n    @Bean\n    public ServletRegistrationBean getServlet {\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet;\n        ServletRegistrationBean registrationBean = new ServletRegistrationBeanstreamServlet;\n        registrationBean.setLoadOnStartup1;\n        registrationBean.addUrlMappings\"/hystrix.stream\";\n        registrationBean.setName\"HystrixMetricsStreamServlet\";\n        return registrationBean;\n    }\n}\n\n\n监控测试\n\n启动1个eureka\n\n启动8001，9001\n\n观察监控窗口\n\n9001监控8001  填写监控地址  http://localhost:8001/hystrix.stream 到 http://localhost:9001/hystrix页面的输入框。\n\n测试地址\n\n http://localhost:8001/payment/circuit/1\n http://localhost:8001/payment/circuit/1\n 测试通过\n 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。\n\n 服务网关\n\n GateWay\n\n概述\n\nCloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;\n\n但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代\n\naxh25f.pnghttps://imgblog.csdnimg.cn/imgconvert/54b61d819aa1630bc61732de340b55b4.png\n\nGateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。\n\nSpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。\n\n作用\n\n 方向代理\n 鉴权\n 流量控制\n 熔断\n 日志监控\n …\n\n微服务架构中网关的位置\n\nasd14667.pnghttps://imgblog.csdnimg.cn/imgconvert/5877d4b9035ead9cd2d037609dceb442.png\n\n Gateway工作流程\n\n三大核心概念\n\n Route路由  路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；\n Predicate断言  参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容例如请求头或请求参数,如果请求与断言相匹配则进行路由；\n Filter过滤  指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。\n  \n\nd1c.pnghttps://imgblog.csdnimg.cn/imgconvert/62be54501c6e2b95620b79cc918a2e9a.png\n\n客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。\n\nHandler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前“pre”或之后“post\"）执行业务逻辑。\n\nFilter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n\n核心逻辑：路由转发 + 执行过滤器链。\n\n Gateway9527搭建\n\n1.新建Mod\tule  cloudgatewaygateway9527\n\n2.POM\n\n4.业务类 无\n\n5.主启动类\n\njava\n@SpringBootApplication\n@EnableEurekaClient\npublic class GateWayMain9527\n{\n    public static void mainString args {\n        SpringApplication.runGateWayMain9527.class, args;\n    }\n}\n\n\n我们目前不想暴露8001端口，希望在8001外面套一层9527\n\n7.YML新增网关配置\n\nyml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloudgateway\n新增网关配置\n  cloud:\n    gateway:\n      routes:\n         id: paymentrouth paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/get/          断言，路径相匹配的进行路由\n\n         id: paymentrouth2 paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/lb/          断言，路径相匹配的进行路由\n\n\neureka:\n  instance:\n    hostname: cloudgatewayservice\n  client: 服务提供者provider注册进eureka服务列表内\n    serviceurl:\n      registerwitheureka: true\n      fetchregistry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n\n\n8.测试\n\n启动7001，启动8001cloudproviderpayment8001，启动9527网关\n\n访问说明\n\n 添加网关前  http://localhost:8001/payment/get/1\n 添加网关后  http://localhost:9527/payment/get/1\n 两者访问成功，返回相同结果（可以通过9527端口访问8001端口接口）\n\n Gateway配置路由的两种方式\n\n1.在配置文件yml中配置，见上一章节\n\n2.代码中注入RouteLocator的Bean\n\ncloudgatewaygateway9527业务实现\n\njava\n@Configuration\npublic class GateWayConfig\n{\n    @Bean\n    public RouteLocator customRouteLocatorRouteLocatorBuilder routeLocatorBuilder\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes;\n\n        routes.route\"pathrouteljx\",\n                r  r.path\"\"\n                        .uri\"https://www.baidu.com\".build;\n\n        return routes.build;\n    }\n}\n\n\n浏览器输入http://localhost:9527，返回https://www.baidu.com相同的页面。\n\n GateWay配置动态路由\n\n默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能（不写死一个地址）\n\nPOM\n\n cloudgatewaygateway9527的POM中添加\n\nxml\n<eurekaclient\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\nYML\n\n需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。\n\nlb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。\n\nyml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloudgateway\n新增网关配置\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true 开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n         id: paymentrouth paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/get/          断言，路径相匹配的进行路由\n\n         id: paymentrouth2 paymentroute    路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001          匹配后提供服务的路由地址\n          uri: lb://cloudpaymentservice 匹配后提供服务的路由地址\n          predicates:\n             Path=/payment/lb/          断言，路径相匹配的进行路由\n\n\neureka:\n  instance:\n    hostname: cloudgatewayservice\n  client: 服务提供者provider注册进eureka服务列表内\n    serviceurl:\n      registerwitheureka: true\n      fetchregistry: true\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n测试\n\n浏览器输入  http://localhost:9527/payment/lb\n\n不停刷新页面，8001/8002两个端口切换。\n\n GateWay常用的Predicate\n\n常用的Route Predicate Factory\n\nThe After Route Predicate Factory\nThe Before Route Predicate Factory\nThe Between Route Predicate Factory\nThe Cookie Route Predicate Factory\nThe Header Route Predicate Factory\nThe Host Route Predicate Factory\nThe Method Route Predicate Factory\nThe Path Route Predicate Factory\nThe Query Route Predicate Factory\nThe RemoteAddr Route Predicate Factory\nThe weight Route Predicate Factory\n\nThe After Route Predicate Factory\n\n作用：只有在规定的时间之后启动才能生效\n\n在yml中添加\n\nyml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: afterroute\n        uri: lb://cloudpaymentservice\n        predicates:\n         Path=/payment/get/      \n         这个时间后才能起效\n         After=20230802T14:59:26.090582100+08:00Asia/Shanghai\n\n\n可以通过下述方法获得上述格式的时间戳字符串\n\njava\nZonedDateTime zbj = ZonedDateTime.now; // 默认时区\nSystem.out.printlnzbj;\n\n\nThe Between Route Predicate Factory\n\n作用：只有在规定的时间范围内启动才生效\n\n在yml中添加\n\nyaml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: betweenroute\n        uri: lb://cloudpaymentservice\n         两个时间点之间\n        predicates:\n          Path=/payment/get/   \n         Between=20240120T17:42:47.78907:00America/Denver, 20230802T14:59:26.090582100+08:00Asia/Shanghai\n\n\nThe Cookie Route Predicate Factory\n\n作用：只有带username=ljx的cookie的请求才有效\n\nyml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: cookieroute\n        uri: lb://cloudpaymentservice\n        predicates:\n         Cookie=username,ljx\n\n\nhe Header Route Predicate Factory\n\n作用：只有带XRequestId=正整数的请求头才有效\n\nyml\nspring:\n  cloud:\n    gateway:\n      routes:\n       id: headerroute\n        uri: lb://cloudpaymentservice\n        predicates:\n         Header=XRequestId, \\d+\n\n\n小结\n\nPredicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。\n\n GateWay的Filter\n\n路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。\n\nSpring Cloud Gateway的Filter:\n\n 生命周期：\n   pre\n   post\n 种类（具体看官方文档）：\n   GatewayFilter  有31种\n   GlobalFilter  有10种\n\n常用的GatewayFilter：AddRequestParameter，GatewayFilter\n\n自定义全局GlobalFilter：\n\n两个主要接口介绍：\n\n1. GlobalFilter\n2. Ordered\n\n能干什么：\n\n1. 全局日志记录\n2. 统一网关鉴权\n3. …\n\n代码案例：\n\nGateWay9527项目添加MyLogGateWayFilter类：\n\njava\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    \n    @Override\n    public Mono<Void filterServerWebExchange exchange, GatewayFilterChain chain\n    {\n        log.info\"come in MyLogGateWayFilter:  \"+new Date;\n        // 处理只有带了uname的请求才能通过\n        String uname = exchange.getRequest.getQueryParams.getFirst\"uname\";\n\n        ifuname == null\n        {\n            log.info\"用户名为null，非法用户，o╥﹏╥o\";\n            exchange.getResponse.setStatusCodeHttpStatus.NOTACCEPTABLE;\n            return exchange.getResponse.setComplete;\n        }\n\n        return chain.filterexchange;\n    }\n\n    @Override\n    public int getOrder\n    {\n        return 0;\n    }\n}\n\n\n测试，浏览器输入：\n\n http://localhost:9527/payment/lb  反问异常\n http://localhost:9527/payment/lb?uname=abc  正常反问\n\n 服务配置\n\n config\n\n Config分布式配置中心介绍\n\n分布式系统面临的配置问题\n\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。\n\nSpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……\n\ndsaxcj1.pnghttps://imgblog.csdnimg.cn/imgconvert/d5462e3b8c3a063561f5f8fc7fde327e.png\n\nSpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。\n\nSpringCloud Config分为服务端和客户端两部分。\n\n 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。\n\n 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。\n\n能干嘛\n\n 集中管理配置文件\n 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n 将配置信息以REST接口的形式暴露  post/crul访问刷新即可…\n  \n\n与GitHub整合配置\n\n由于SpringCloud Config默认使用Git来存储配置文件也有其它方式,比如支持SVN和本地文件，但最推荐的还是Git，而且使用的是http/https访问的形式。\n\n Config配置总控中心搭建\n\n用你自己的账号在GitHub上新建一个名为springcloudconfig的新Repository。\n\n由上一步获得刚新建的git地址  git@github.com:abc/springcloudconfig.git。\n\n本地硬盘目录上新建git仓库并clone。\n\n 工作目录为D:\\SpringCloud2021\n git clone git@github.com:abc/springcloudconfig.git\n\n此时在工作目录会创建名为springcloudconfig的文件夹。\n\n在springcloudconfig的文件夹种创建三个配置文件（为本次教学使用的）,随后git add .，git commit m \"sth\"等一系列上传操作上传到springcloudconfig的新Repository。\n\n configdev.yml\n\nyaml\nconfig:\n  info: \"master branch,springcloudconfig/configdev.yml version=7\"\n\n\n configprod.yml\n\nyaml\nconfig:\n  info: \"master branch,springcloudconfig/configprod.yml version=1\"\n\n\n configtest.yml\n\nyaml\nconfig:\n  info: \"master branch,springcloudconfig/configtest.yml version=1\" \n\n\n新建Module模块cloudconfigcenter3344，它即为Cloud的配置中心模块CloudConfig Center\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterbusamqp</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudconfigserver</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloudconfigcenter 注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/lijunxi666/springcloudconfig.git GitHub上面的git仓库名字\n          搜索目录\n          searchpaths:\n             springcloudconfig\n          skipsslvalidation: true\n      读取分支\n      label: master\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n\n主启动类加上@EnableConfigServer\n\nwindows下修改hosts文件，增加映射\n\n\n127.0.0.1 config3344.com\n\n\n测试\n\n启动ConfigCenterMain3344\n\n浏览器防问  http://config3344.com:3344/master/configdev.yml\n\n页面返回结果：\n\nyml\nconfig:\n  info: \"master branch,springcloudconfig/configdev.yml version=7\"\n\n\n访问文件的路径\n\n重要配置细节总结\n\n /{name}{profiles}.yml\n /{label}{name}{profiles}.yml\n label：分支branch\n name：服务名\n profiles：环境dev/test/prod\n\n成功实现了用SpringCloud Config通过GitHub获取配置信息\n\n Config客户端配置与测试\n\n新建cloudconfigclient3355\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterbusamqp</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudconfigserver</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\nbootstrap.yml\n\napplicaiton.yml是用户级的资源配置项\n\nbootstrap.yml是系统级的，优先级更加高\n\nyml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: configclient\n  cloud:\n    Config客户端配置\n    config:\n      label: master 分支名称\n      name: config 配置文件名称\n      profile: dev 读取后缀名称   上述3个综合：master分支上configdev.yml的配置文件被读取http://config3344.com:3344/master/configdev.yml\n      uri: http://localhost:3344 配置中心地址k\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka\n\n\n主启动添加@EnableEurekaClient\n\n业务类\n\njava\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value\"${config.info}\"\n    private String configInfo;\n\n    @GetMapping\"/configInfo\"\n    public String getConfigInfo\n    {\n        return configInfo;\n    }\n}\n\n\n测试\n\n 启动Config配置中心3344微服务并自测\n   http://config3344.com:3344/master/configprod.yml\n   http://config3344.com:3344/master/configdev.yml\n\n 启动3355作为Client准备访问\n   http://localhost:3355/configlnfo\n\n成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息可题随时而来\n\n分布式配置的动态刷新问题\n\n Linux运维修改GitHub上的配置文件内容做调整\n 刷新3344，发现ConfigServer配置中心立刻响应\n 刷新3355，发现ConfigClient客户端没有任何响应\n 3355没有变化除非自己重启或者重新加载\n 难到每次运维修改配置文件，客户端都需要重启??噩梦\n\n Config动态刷新手动版\n\n避免每次更新配置都要重启客户端微服务3355\n\n动态刷新步骤：\n\n修改3355模块\n\nPOM引入actuator监控\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\n修改YML，添加暴露监控端口配置：\n\nyaml\n 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"\"\n\n\n业务类Controller添加@RefreshScope\n\n测试\n\n此时修改github配置文件内容  访问3344  访问3355：http://localhost:3355/configInfo\n\n发现3355的内容并没刷新\n\n还需要一步\n\n需要运维人员发送Post请求刷新3355\n\n\ncurl X POST \"http://localhost:3355/actuator/refresh\"\n\n\n再次测试：http://localhost:3355/configInfo\n\n3355 改了。\n\n成功实现了客户端3355刷新到最新配置内容，避免了服务重启\n\n存在的问题\n\n 假如有多个微服务客户端3355/3366/3377\n 每个微服务都要执行—次post请求，手动刷新?\n 可否广播，一次通知，处处生效?\n 我们想大范围的自动刷新，求方法\n\n这时候就需要用到消息总线\n\n 消息总线\n\n一言以蔽之，分布式自动刷新配置功能。\n\nSpring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。\n\nd1xased.pnghttps://imgblog.csdnimg.cn/imgconvert/458fd679c01274ca84f785e1f75c1336.png\n\nSpring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\n\n为何被称为总线\n\n什么是总线？\n\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\n\n基本原理\n\nConfigClient实例都监听MQ中同一个topic默认是Spring Cloud Bus。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。\n\n RabbitMQ\n\n 环境配置\n\n严格遵循erlang和rabbitmq版本对应：RabbitMQ Erlang Version Requirements — RabbitMQhttps://www.rabbitmq.com/whicherlang.html\n\n 安装Erlang，下载地址：http://erlang.org/download/otpwin6421.3.exe\n\n 安装RabbitMQ，下载地址：https://github.com/rabbitmq/rabbitmqserver/releases/download/v3.7.14/rabbitmqserver3.7.14.exe\n\n 打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\\devSoft\\RabbitMQ Scrverk\\rabbitmqserver3.7.14\\sbin\n\n 输入以下命令启动管理功能rabbitmqplugins enable rabbitmq management\n\n这样就可以添加可视化插件。\n\n 访问地址查看是否安装成功：http://localhost:15672/\n 输入账号密码并登录：guest guest\n\n Bus动态刷新全局广播的设计思想和选型\n\n必须先具备良好的RabbitMQ环境先\n\n演示广播效果，增加复杂度，再以3355为模板再制作一个3366\n\n1.新建cloudconfigclient3366\n\n2.POM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterbusamqp</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterconfig</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n\n\n3.YML\n\nyml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: configclient\n  cloud:\n    Config客户端配置\n    config:\n      label: master 分支名称\n      name: config 配置文件名称\n      profile: dev 读取后缀名称   上述3个综合：master分支上configdev.yml的配置文件被读取http://config3344.com:3344/master/configdev.yml\n      uri: http://localhost:3344 配置中心地址\n\nrabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n\n 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"\"\n\n\n4.主启动添加@EnableEurekaClient\n\n5.controller\n\njava\n@RestController\n@RefreshScope\npublic class ConfigClientController\n{\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @Value\"${config.info}\"\n    private String configInfo;\n\n    @GetMapping\"/configInfo\"\n    public String configInfo\n    {\n        return \"serverPort: \"+serverPort+\"\\t\\n\\n configInfo: \"+configInfo;\n    }\n\n}\n\n\n设计思想\n\n1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置\n\ndascx.pnghttps://imgblog.csdnimg.cn/imgconvert/3a0975f4bac7393fe406821531e9daef.png\n\n2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置\n\n2150vg0.pnghttps://imgblog.csdnimg.cn/imgconvert/e2809f728b8eb3e776883e4f905b8712.png\n\n图二的架构显然更加适合，图—不适合的原因如下：\n\n 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\n\n 破坏了微服务各节点的对等性。\n\n 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。\n\n Bus动态刷新全局广播配置实现\n\n给cloudconfigcenter3344配置中心服务端添加消息总线支持\n\nPOM\n\nxml\n<添加消息总线RabbitNQ支持\n<dependency\n\t<groupIdorg.springframework.cloud</groupId\n\t<artifactIdspringcloudstarterbusamap</artifactId\n</dependency\n<dependency\n\t<groupIdorgspringframework.boot</groupId\n\t<artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloudconfigcenter 注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloudconfig.git GitHub上面的git仓库名字\n        搜索目录\n          searchpaths:\n             springcloudconfig\n      读取分支\n      label: master\nrabbitmq相关配置<\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\nrabbitmq相关配置,暴露bus刷新配置的端点<\nmanagement:\n  endpoints: 暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'busrefresh'\n\n\n给cloudconfigclient3355客户端添加消息总线支持\n\nPOM\n\nxml\n<添加消息总线RabbitNQ支持\n<dependency\n\t<groupIdorg.springframework.cloud</groupId\n\t<artifactIdspringcloudstarterbusamap</artifactId\n</dependency\n<dependency\n\t<groupIdorgspringframework.boot</groupId\n\t<artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name:  cloudconfigcenter 注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: git@github.com:zzyybs/springcloudconfig.git GitHub上面的git仓库名字\n        搜索目录\n          searchpaths:\n             springcloudconfig\n      读取分支\n      label: master\nrabbitmq相关配置<\nrabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\nrabbitmq相关配置,暴露bus刷新配置的端点<\nmanagement:\n  endpoints: 暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'busrefresh'\n\n\n给cloudconfigclient3366客户端添加消息总线支持\n\nPOM\n\nxml\n<添加消息总线RabbitNQ支持\n<dependency\n\t<groupIdorg.springframework.cloud</groupId\n\t<artifactIdspringcloudstarterbusamap</artifactId\n</dependency\n<dependency\n\t<groupIdorgspringframework.boot</groupId\n\t<artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 3366\n\nspring:\n  application:\n    name: configclient\n  cloud:\n    Config客户端配置\n    config:\n      label: master 分支名称\n      name: config 配置文件名称\n      profile: dev 读取后缀名称   上述3个综合：master分支上configdev.yml的配置文件被读取http://config3344.com:3344/master/configdev.yml\n      uri: http://localhost:3344 配置中心地址\n\nrabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口<\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n服务注册到eureka地址\neureka:\n  client:\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n\n 暴露监控端点\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"\"\n\n\n测试\n\n 启动\n   EurekaMain7001\n   EurekaMain7002\n   ConfigcenterMain3344\n   ConfigclientMain3355\n   ConfigclicntMain3366\n\n 运维工程师\n   修改Github上配置文件内容，增加版本号\n   发送POST请求\n     curl X POST \"http://localhost:3344/actuator/busrefresh\"\n     —次发送，处处生效\n\n 配置中心\n   http://config3344.com:3344/configdev.yml\n 客户端\n   http://localhost:3355/configlnfo\n   http://localhost:3366/configInfo\n   获取配置信息，发现都已经刷新了\n\n—次修改，广播通知，处处生效\n\n Bus动态刷新定点通知\n\n不想全部通知，只想定点通知\n\n 只通知3355\n 不通知3366\n\n简单一句话  指定具体某一个实例生效而不是全部\n\n 公式：http://localhost:3344/actuator/busrefresh/{destination}\n /bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例\n\n案例\n\n 我们这里以刷新运行在3355端口上的configclient（配置文件中设定的应用名称）为例，只通知3355，不通知3366\n curl X POST \"http://localhost:3344/actuator/busrefresh/configclient:3355\n\n消息通知总结\n\n21cx0943.pnghttps://imgblog.csdnimg.cn/imgconvert/ccd5fcc8293edec24d7e889e189d0bfe.png\n\n 消息驱动\n\n Stream\n\n什么是Spring Cloud Stream？\n\n官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。\n\n应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。\n\n通过我们配置来binding绑定，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。\n\n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。\nSpring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布订阅、消费组、分区的三个核心概念。\n\n目前仅支持RabbitMQ、 Kafka。\n\n 设计思想\n\ndasd04.pnghttps://imgblog.csdnimg.cn/imgconvert/1ca02dd31581d92a7a610bcd137f6848.png\n\n 生产者/消费者之间靠消息媒介传递信息内容\n 消息必须走特定的通道  消息通道 Message Channel\n 消息通道里的消息如何被消费呢，谁负责收发处理  消息通道MessageChannel的子接口SubscribableChannel，由\n MessageHandler消息处理器所订阅。\n\n 常用注解\n\n    组成                                说明                           \n ::  :: \n   Middleware                  中间件，目前只支持RabbitMQ和Kafka               \n     Binder       inder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型对应于Kafka的topic,RabbitMQ的exchange，这些都可以通过配置文件来实现 \n     @Input         注解标识输入通道，通过该输乎通道接收到的消息进入应用程序   \n     @Output          注解标识输出通道，发布的消息将通过该通道离开应用程序     \n @StreamListener              监听队列，用于消费者的队列的消息接收             \n @EnableBinding                指信道channel和exchange绑定在一起               \n\n 案例说明\n\n准备RabbitMQ环境\n\n工程中新建三个子模块\n\n cloudstreamrabbitmqprovider8801，作为生产者进行发消息模块\n cloudstreamrabbitmqconsumer8802，作为消息接收模块\n cloudstreamrabbitmqconsumer8803，作为消息接收模块\n\n Stream消息驱动之生产者\n\n新建Module：cloudstreamrabbitmqprovider8801\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterstreamrabbit</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloudstreamprovider\n  cloud:\n      stream:\n        binders:  在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit:  表示定义的名称，用于于binding整合\n            type: rabbit  消息组件类型\n            environment:  设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings:  服务的整合处理\n          output:  这个名字是一个通道的名称\n            destination: studyExchange  表示要使用的Exchange名称定义\n            contenttype: application/json  设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit  设置要绑定的消息服务的具体设置\n\neureka:\n  client:  客户端进行Eureka注册的配置\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    leaserenewalintervalinseconds: 2  设置心跳的时间间隔（默认是30秒）\n    leaseexpirationdurationinseconds: 5  如果现在超过了5秒的间隔（默认是90秒）\n    instanceid: send8801.com   在信息列表时显示主机名称\n    preferipaddress: true      访问的路径变为IP地址\n\n\n主启动类StreamMQMain8801\n\n业务类\n\n1.发送消息接口\n\njava\npublic interface IMessageProvider {\n    public String send;\n}\n\n\n2.发送消息接口实现类\n\njava\n@EnableBindingSource.class //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send\n    {\n        String serial = UUID.randomUUID.toString;\n        output.sendMessageBuilder.withPayloadserial.build;\n        System.out.println\"serial: \"+serial;\n        return null;\n    }\n}\n\n\n3.Controller\n\njava\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMappingvalue = \"/sendMessage\"\n    public String sendMessage {\n        return messageProvider.send;\n    }\n}\n\n\n测试\n\n 启动 7001eureka\n\n 启动 RabpitMq（\n\n  79Bus之RabbitMQ环境配置\n\n  ）\n\n   rabbitmqplugins enable rabbitmqmanagement\n   http://localhost:15672/\n\n 启动 8801\n\n 访问  http://localhost:8801/sendMessage\n\n   后台将打印serial: UUID字符串\n\n Stream消息驱动之消费者\n\n新建Module：cloudstreamrabbitmqconsumer8802\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarternetflixeurekaclient</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterstreamrabbit</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8802\n\nspring:\n  application:\n    name: cloudstreamconsumer\n  cloud:\n      stream:\n        binders:  在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit:  表示定义的名称，用于于binding整合\n            type: rabbit  消息组件类型\n            environment:  设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings:  服务的整合处理\n          input:  这个名字是一个通道的名称\n            destination: studyExchange  表示要使用的Exchange名称定义\n            contenttype: application/json  设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n            binder: defaultRabbit  设置要绑定的消息服务的具体设置\n\neureka:\n  client:  客户端进行Eureka注册的配置\n    serviceurl:\n      defaultZone: http://localhost:7001/eureka, http://localhost:7002/eureka\n  instance:\n    leaserenewalintervalinseconds: 2  设置心跳的时间间隔（默认是30秒）\n    leaseexpirationdurationinseconds: 5  如果现在超过了5秒的间隔（默认是90秒）\n    instanceid: receive8802.com   在信息列表时显示主机名称\n    preferipaddress: true      访问的路径变为IP地址\n\n\n\n Stream之消息重复消费\n\n依照8802，克隆出来一份运行8803  cloudstreamrabbitmqconsumer8803。\n\n原神，启动\n\n RabbitMQ\n 服务注册  8801\n 消息生产  8801\n 消息消费  8802\n 消息消费  8802\n\n运行后有两个问题\n\n1. 有重复消费问题\n2. 消息持久化问题\n\n消费\n\n http://localhost:8801/sendMessage\n 目前是8802/8803同时都收到了，存在重复消费问题\n 如何解决：分组和持久化属性group（重要）\n\n生产实际案例\n\n比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以使用Stream中的消息分组来解决。\n\nd123654.pnghttps://imgblog.csdnimg.cn/imgconvert/f61e83441af907a42e8886368bde59ff.png\n\n注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的重复消费。\n\n简单总结：只需要每个服务处于统一group下就不会出现重复消费\n\n解决\n\n原理\n\n微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。\n\n不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。\n\n8802/8803都变成不同组，group两个不同\n\ngroup: AGroup、BGroup\n\n8802修改YML\n\nyml\nspring:\n  application:\n    name: cloudstreamprovider\n  cloud:\n      stream:\n        binders:  在此处配置要绑定的rabbitmq的服务信息；\n          defaultRabbit:  表示定义的名称，用于于binding整合\n            type: rabbit  消息组件类型\n            environment:  设置rabbitmq的相关的环境配置\n              spring:\n                rabbitmq:\n                  host: localhost\n                  port: 5672\n                  username: guest\n                  password: guest\n        bindings:  服务的整合处理\n          output:  这个名字是一个通道的名称\n            destination: studyExchange  表示要使用的Exchange名称定义\n            contenttype: application/json  设置消息类型，本次为json，文本则设置“text/plain”\n            binder: defaultRabbit  设置要绑定的消息服务的具体设置\n            group: AGroup <关键\n\n\n8803修改YML（与8802的类似位置 group: BGroup）\n\n结论：还是重复消费\n\n8802/8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。\n\n8802/8803都变成相同组，group两个相同\n\ngroup: AGroup\n\n8802修改YMLgroup: AGroup\n\n8803修改YMLgroup: AGroup\n\n结论：同一个组的多个微服务实例，每次只会有一个拿到\n\n成功解决重复消费\n\n Stream之消息持久化\n\n通过上述，解决了重复消费问题，再看看持久化。\n\n停止8802/8803并去除掉8802的分组group: AGroup，8803的分组group: AGroup没有去掉。\n\n8801先发送4条消息到RabbitMq。\n\n先启动8802，无分组属性配置，后台没有打出来消息。\n\n再启动8803，有分组属性配置，后台打出来了MQ上的消息。消息持久化体现\n\n 分布式请求链路跟踪\n\n Sleuth\n\n为什么会出现这个技术？要解决哪些问题？\n\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\n\n是什么\n\n https://github.com/springcloud/springcloudsleuth\n Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案\n 在分布式系统中提供追踪解决方案并且兼容支持了zipkin\n\n Sleuth之zipkin搭建安装\n\n1.zipkin\n\n下载\n\n SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可\n Central Repository: io/zipkin/zipkinserver maven.orghttps://repo1.maven.org/maven2/io/zipkin/zipkinserver/\n zipkinserver2.24.3exec.jar\n\n运行jar\n\njava\njava jar zipkinserver2.24.3exec.jar\n\n\n运行控制台\n\nhttp://localhost:9411/zipkin/\n\n完整的调用链路\n\n—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。\n\n1d9012.pnghttps://imgblog.csdnimg.cn/imgconvert/f75fcfd2146df03428b9c8c53d13c1f1.png\n\n名词解释\n\n Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n span：表示调用链路来源，通俗的理解span就是一次请求信息\n\n Sleuth链路监控展现\n\n修改cloudproviderpayment8001\n\nPOM\n\nxml\n<包含了sleuth+zipkin\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterzipkin</artifactId\n</dependency\n\n\nYML\n\nyml\nspring:\n  application:\n    name: cloudpaymentservice\n\n  zipkin: <关键 \n      baseurl: http://localhost:9411\n  sleuth: <关键\n    sampler:\n    采样率值介于 0 到 1 之间，1 则表示全部采集\n    probability: 1\n\n\n业务类PaymentController\n\njava\n@GetMapping\"/payment/zipkin\"\npublic String paymentZipkin {\n    return \"hi ,i'am paymentzipkin server fall back，welcome to here, O∩∩O哈哈\";\n}    \n\n\n修改cloueconsumerorder80\n\nPOM\n\nxml\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarterzipkin</artifactId\n</dependency\n\n\nYML\n\nxml\nspring:\n    application:\n        name: cloudorderservice\n    zipkin:\n      baseurl: http://localhost:9411\n    sleuth:\n      sampler:\n        probability: 1\n\n\n业务类OrderController\n\njava\n@GetMapping\"/consumer/payment/zipkin\"\npublic String paymentZipkin\n{\n    String result = restTemplate.getForObject\"http://localhost:8001\"+\"/payment/zipkin/\", String.class;\n    return result;\n}\n\n\n4.依次启动eureka7001/8001/80  80调用8001几次测试下\n\n5.打开浏览器访问: http://localhost:9411\n\n Spring Cloud Alibaba\n\n为什么会出现SpringCloud alibaba?\n\nSpring Cloud Netflix项目进入维护模式\n\nhttps://spring.io/blog/2018/12/12/springcloudgreenwichrc1availablenow\n\n什么是维护模式？\n\n将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。\n\n他们将修复block级别的 bug 以及安全问题，他们也会考虑并审查社区的小型pull request。\n\nSpringCloud alibaba带来了什么\n\nspringcloudalibaba/READMEzh.md at 2.2.x · alibaba/springcloudalibaba github.comhttps://github.com/alibaba/springcloudalibaba/blob/2.2.x/READMEzh.md\n\nSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n\n能干嘛\n\n 服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ \n 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。\n 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。\n 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。\n 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。\n 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。\n 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerxclient）上执行。\n 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\nMAVEN\n\nxml\n<dependencyManagement\n    <dependencies\n        <dependency\n            <groupIdcom.alibaba.cloud</groupId\n            <artifactIdspringcloudalibabadependencies</artifactId\n            <version2.2.5.RELEASE</version\n            <typepom</type\n            <scopeimport</scope\n        </dependency\n    </dependencies\n</dependencyManagement\n\n\n Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\n Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。\n Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\n Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\n Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\n Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n\nSpring Cloud Alibaba学习资料获取\n\n 官网\n\nhttps://spring.io/projects/springcloudalibabaoverview\n\n 英文\n\nhttps://github.com/alibaba/springcloudalibaba\nhttps://springcloudalibabagroup.github.io/githubpages/greenwich/springcloudalibaba.html\n\n 中文\n\nhttps://github.com/alibaba/springcloudalibaba/blob/master/READMEzh.md\n\n Nacos\n\n Nacos介绍\n\n是什么\n\n 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n Nacos: Dynamic Naming and Configuration Service\n Nacos就是注册中心＋配置中心的组合  Nacos = Eureka+Config+Bus\n\n能干嘛\n\n 替代Eureka做服务注册中心\n 替代Config做服务配置中心\n\n去哪下\n\n https://github.com/alibaba/nacos/releases\n 官网文档https://springcloudalibabagroup.github.io/githubpages/greenwich/springcloudalibaba.htmlspring cloud alibaba nacosdiscovery\n\n各中注册中心比较\n\n 服务注册与发现框架  CAP模型  控制台管理  社区活跃度      \n        \n Eureka              AP       支持        低2.x版本闭源 \n Zookeeper           CP       不支持      中              \n consul              CP       支持        高              \n Nacos               AP       支持        高              \n\n据说Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验。\n\n Nacos安装\n\n 本地Java8+Maven环境已经OK先\n 从官网https://github.com/alibaba/nacos/releases下载Nacos\n 解压安装包，直接运行bin目录下的startup.cmd\n 命令运行成功后直接访问http://localhost:8848/nacos，默认账号密码都是nacos\n 结果页面\n\n Nacos之服务提供者注册\n\n官方文档https://springcloudalibabagroup.github.io/githubpages/greenwich/springcloudalibaba.htmlspringcloudalibabanacosdiscovery\n\n新建Module  cloudalibabaproviderpayment9001\n\nPOM\n\n父POM\n\nxml\n<dependencyManagement\n    <dependencies\n        <spring cloud alibaba 2.1.0.RELEASE\n        <dependency\n            <groupIdcom.alibaba.cloud</groupId\n            <artifactIdspringcloudalibabadependencies</artifactId\n            <version2.1.0.RELEASE</version\n            <typepom</type\n            <scopeimport</scope\n        </dependency\n    </dependencies\n</dependencyManagement\n\n\n本模块POM\n\nxml\n <dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 9001\n\nspring:\n  application:\n    name: nacospaymentprovider\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\n\n主启动添加@EnableDiscoveryClient\n\n业务类\n\njava\n@RestController\npublic class PaymentController {\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    @GetMappingvalue = \"/payment/nacos/{id}\"\n    public String getPayment@PathVariable\"id\" Integer id {\n        return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id;\n    }\n}\n\n\n测试\n\n http://localhost:9001/payment/nacos/1\n nacos控制台\n nacos服务注册中心+服务提供者9001都OK了\n\n再建一个新模块cloudalibabaproviderpayment9002\n\n Nacos之服务消费者注册和负载\n\n新建Module  cloudalibabaconsumernacosorder83\n\nPOM\n\nxml\n <dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n\n\n为什么nacos支持负载均衡？因为springcloudstarteralibabanacosdiscovery内含netflixribbon包。\n\nYML\n\nyml\nserver:\n  port: 83\n\nspring:\n  application:\n    name: nacosorderconsumer\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848\n\n消费者将要去访问的微服务名称注册成功进nacos的微服务提供者\nserviceurl:\n  nacosuserservice: http://nacospaymentprovider\n\n\n主启动添加@EnableDiscoveryClient \n\n业务类\n\nApplicationContextConfig\n\njava\n@Configuration\npublic class ApplicationContextConfig\n{\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate\n    {\n        return new RestTemplate;\n    }\n}\n\n\nOrderNacosController\n\njava\n@RestController\n@Slf4j\npublic class OrderNacosController {\n    \n    @Resource\n    private RestTemplate restTemplate;\n\n    @Value\"${serviceurl.nacosuserservice}\"\n    private String serverURL;\n\n    @GetMappingvalue = \"/consumer/payment/nacos/{id}\"\n    public String paymentInfo@PathVariable\"id\" Long id\n    {\n        return restTemplate.getForObjectserverURL+\"/payment/nacos/\"+id,String.class;\n    }\n}\n\n\n测试\n\n 启动nacos控制台\n http://localhost:83/Eonsumer/payment/nacos/13\n   83访问9001/9002，轮询负载OK\n\n Nacos之服务配置中心\n\n基础配置\n\ncloudalibabaconfignacosclient3377\n\nPOM\n\nxml\n<nacosconfig\n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosconfig</artifactId\n</dependency\n<nacosdiscovery\n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n\n\nYML\n\nNacos同springcloudconfig一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。\n\nspringboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\n\nbootstrap\n\nyml\n nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacosconfigclient\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n      config:\n        serveraddr: localhost:8848 Nacos作为配置中心地址\n        fileextension: yaml 指定yaml格式的配置\n        \n ${spring.application.name}${spring.profile.active}.${spring.cloud.nacos.config.fileextension}\n nacosconfigclientdev.yaml\n nacosconfigclienttest.yaml    config.info\n\n\napplication\n\nqml\nspring:\n  profiles:\n    active: dev  表示开发环境\n    active: test  表示测试环境\n    active: info\n\n\n\n主启动添加@EnableDiscoveryClient\n\n业务类\n\njava\n@RestController\n@RefreshScope //支持Nacos的动态刷新功能。\npublic class ConfigClientController\n{\n    @Value\"${config.info}\"\n    private String configInfo;\n\n    @GetMapping\"/config/info\"\n    public String getConfigInfo {\n        return configInfo;\n    }\n}\n\n\n在Nacos中添加配置信息\n\nNacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则\n\n官方文档https://nacos.io/zhcn/docs/quickstartspringcloud.html\n\n说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。\n\n在 Nacos Spring Cloud中,dataId的完整格式如下：\n\njava\n${prefix}${springprofile.active}.${fileextension}\n\n\n prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。\n spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符  也将不存在，datald 的拼接格式变成${prefix}.${fileextension}\n fileexetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.fileextension来配置。目前只支持properties和yaml类型。\n 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。\n\n最后公式：\n\njava\n${spring.application.name}${spring.profiles.active}.${spring.cloud.nacos.config.fileextension}\n\n\n21dxw20.pnghttps://imgblog.csdnimg.cn/imgconvert/05d45948bf637614dbd70e2bc8ce992d.png\n\nNacos界面配置对应  设置DataId\n\nc0tnVf.pnghttps://imgblog.csdnimg.cn/imgconvert/c61619bbe5ea16f34efca8103b0f90ba.png\n\n配置小结\n\n202929292.pnghttps://imgblog.csdnimg.cn/imgconvert/b3bffc4a646b30f9bf64fc649bf26f7d.png\n\n测试\n\n 启动前需要在nacos客户端配置管理配置管理栏目下有对应的yaml配置文件\n 运行cloudconfignacosclient3377的主启动类\n 调用接口查看配置信息  http://localhost:3377/config/info\n\n自带动态刷新\n\n修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。\n\n Nacos之命名空间分组和DataID三者关系\n\n问题  多环境多项目管理\n\n问题1:\n\n实际开发中，通常一个系统会准备\n\n1. dev开发环境\n2. test测试环境\n3. prod生产环境。\n\n如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?\n\n问题2:\n\n一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?\n\nNamespace+Group+Data lD三者关系？为什么这么设计？\n\n1是什么\n\n类似Java里面的package名和类名最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。\n\n2三者情况\n\n321d10DKLJQ.pnghttps://imgblog.csdnimg.cn/imgconvert/60712abd615dd86ac6c119bf132a28d6.png\n\n默认情况：Namespace=public，Group=DEFAULTGROUP，默认Cluster是DEFAULT\n\n Nacos默认的Namespace是public，Namespace主要用来实现隔离。\n   比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。\n\n Group默认是DEFAULTGROUP，Group可以把不同的微服务划分到同一个分组里面去\n Service就是微服务:一个Service可以包含多个Cluster 集群，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。\n   比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称HZ ，给广州机房的Service微服务起一个集群名称GZ，还可以尽量让同一个机房的微服务互相调用，以提升性能。\n\n 最后是Instance，就是微服务的实例。\n\n Nacos之DataID配置\n\n指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置\n\n默认空间+默认分组+新建dev和test两个DatalD\n\n 新建dev配置DatalD\n 通过spring.profile.active属性就能进行多环境下配置文件的读取\n\n测试\n\n http://localhost:3377/config/info\n 配置是什么就加载什么 test/dev\n\n Nacos之Group分组方案\n\n通过Group实现环境区分  新建Group\n\n000.pnghttps://imgblog.csdnimg.cn/imgconvert/bdf592aa566fe50f7f454118a70ca03c.png\n\n在nacos图形界面控制台上面新建配置文件DatalD\n\nLSINFD.pnghttps://imgblog.csdnimg.cn/imgconvert/28aee2b45901bbb9a6776d5c4398a6bb.png\n\nbootstrap+application：在config下增加一条group的配置即可。可配置为DEVGROUP或TEST GROUP\n\n12LADpw.pnghttps://imgblog.csdnimg.cn/imgconvert/342a167a8bd948d8ba5cbfd760cf66a6.png\n\n Nacos之Namespace空间方案\n\n新建dev/test的Namespace\n\nDjspc1223.pnghttps://imgblog.csdnimg.cn/imgconvert/a10c71978c75c214aca5fa7057bb2834.png\n\n回到服务管理服务列表查看\n\n2143KKJ.pnghttps://imgblog.csdnimg.cn/imgconvert/2a9f3fa415f5cead0219d404a47131a0.png\n\n按照域名配置填写\n\nwqd1MNCw.pnghttps://imgblog.csdnimg.cn/imgconvert/2177c126090c0db553a8ce77e838a7c9.png\n\nYML\n\nyml\n nacos配置\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacosconfigclient\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n      config:\n        serveraddr: localhost:8848 Nacos作为配置中心地址\n        fileextension: yaml 指定yaml格式的配置\n        group: DEVGROUP\n        namespace: 7d8f0f5a6a5347859686dd460158e5d4 <指定namespace\n\n ${spring.application.name}${spring.profile.active}.${spring.cloud.nacos.config.fileextension}\n nacosconfigclientdev.yaml\n nacosconfigclienttest.yaml    config.info\n\n\n Nacos持久化切换配置\n\nNacos默认自带的是嵌入式数据库derby，nacos的pom.xmlhttps://blog.csdn.net/u011863024/article/details/github.com/alibaba/nacos/blob/develop/config/pom.xml中可以看出。\n\nderby到mysql切换配置步骤：\n\n1. nacosserver1.1.4\\nacos\\conf录下找到nacosmysql.sql文件，执行脚本。\n2. nacosserver1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。\n\npr\nspring.datasource.platform=mysql\n\ndb.num=1\ndb.url.0=jdbc:mysql://localhost:3306/nacosdevtest?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true\ndb.user=root\ndb.password=1234\n\n\n启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby。\n\n1.4.1版本的直接打开3141行的注释修改为自己就行\n\n Nacos集群配置\n\n这里不太会，有点问题\n\n Sentinel\n\n Sentinel介绍\n\n随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinelhttps://so.csdn.net/so/search?q=Sentinel&spm=1001.2101.3001.7020 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\nSentinel 具有以下特征:\n\n 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。\n 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n12dNucx1.pnghttps://imgblog.csdnimg.cn/imgconvert/e4efa9c3547366ae4f747ad4007f6447.png\n\n—句话解释，之前我们讲解过的Hystrix\n\nHystrix与Sentinel比较：\n\n Hystrix\n  1. 需要我们程序员自己手工搭建监控平台\n  2. 没有一套web界面可以给我们进行更加细粒度化得配置流控、速率控制、服务熔断、服务降级\n Sentinel\n  1. 单独一个组件，可以独立出来。\n  2. 直接界面化的细粒度统一配置。\n\n约定  配置  编码\n\n都可以写在代码里面，但是我们本次还是大规模的学习使用配置和注解的方式，尽量少写代码\n\n Sentinel下载安装运行\n\n服务使用中的各种问题：\n\n 服务雪崩\n 服务降级\n 服务熔断\n 服务限流\n\nSentinel 分为两个部分：\n\n 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n Sentinel初始化监控\n\n启动Nacos8848成功\n\n新建工程  cloudalibabasentinelservice8401\n\nPOM\n\nxml\n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n</dependency\n<SpringCloud ailibaba sentineldatasourcenacos 后续做持久化用到\n<dependency\n    <groupIdcom.alibaba.csp</groupId\n    <artifactIdsentineldatasourcenacos</artifactId\n</dependency\n<SpringCloud ailibaba sentinel \n<dependency\n    <groupIdcom.alibaba.cloud</groupId\n    <artifactIdspringcloudstarteralibabasentinel</artifactId\n</dependency\n<openfeign\n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n< SpringBoot整合Web组件+actuator \n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarterweb</artifactId\n</dependency\n<dependency\n    <groupIdorg.springframework.boot</groupId\n    <artifactIdspringbootstarteractuator</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibabasentinelservice\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 配置Sentinel dashboard地址\n        port: 8719\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\nfeign:\n  sentinel:\n    enabled: true  激活Sentinel对Feign的支持\n\n\n主启动类@EnableDiscoveryClient\n\n业务类FlowLimitController\n\njava\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping\"/testA\"\n    public String testA\n    {\n        return \"testA\";\n    }\n\n    @GetMapping\"/testB\"\n    public String testB\n    {\n        log.infoThread.currentThread.getName+\"\\t\"+\"...testB\";\n        return \"testB\";\n    }\n}\n\n\n启动Sentinel8080  java jar sentineldashboard1.7.0.jar\n\n启动微服务8401，查看sentienl控制台\n\n 刚启动，空空如也，啥都没有\n\n Sentinel采用的懒加载说明\n   执行一次访问即可\n     http://localhost:8401/testA\n     http://localhost:8401/testB\n   效果  sentinel8080正在监控微服务8401\n\n Sentinel流控规则简介\n\n11111.pnghttps://imgblog.csdnimg.cn/imgconvert/d8ae2bea252af0bb278332b3aeb8fb77.png\n\n 资源名：唯一名称，默认请求路径。\n 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。\n 阈值类型/单机阈值：\n   QPS每秒钟的请求数量︰当调用该API的QPS达到阈值的时候，进行限流。\n   线程数：当调用该API的线程数达到阈值的时候，进行限流。\n 是否集群：不需要集群。\n 流控模式：\n   直接：API达到限流条件时，直接限流。\n   关联：当关联的资源达到阈值时，就限流自己。\n   链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流【API级别的针对来源】。\n 流控效果：\n   快速失败：直接失败，抛异常。\n   Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。\n   排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。\n\n Sentinel流控QPS直接失败\n\n直接  快速失败（系统默认）\n\n配置及说明\n\n表示1秒钟内查询1次就是OK，若超过次数1，就直接快速失败，报默认错误\n\n测试\n\n快速多次点击访问http://localhost:8401/testA\n\n结果\n\n返回页面 Blocked by Sentinel flow limiting\n\n源码\n\ncom.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController\n\n思考\n\n直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?\n\n Sentinel流控线程数直接失败\n\n修改FlowLimitController，给请求增加时长\n\njava\n@GetMapping\"/testA\"\npublic String testA\n{\n    try {\n        TimeUnit.MILLISECONDS.sleep800;\n    } catch InterruptedException e {\n        e.printStackTrace;\n    }\n    return \"testA\";\n}\n\n\n当有多个请求同时访问的时候搜，超过阈值就会出错\n\n Sentinel流控关联\n\n 当自己关联的资源达到阈值时，就限流自己\n 当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）\n\n设置testA\n\n当关联资源/testB的QPS阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名。\n\n3841.pnghttps://imgblog.csdnimg.cn/imgconvert/12cd41ae91ba50fe3b5525bab7bc3805.png\n\nJmeter密集访问localhost:8401/testBhttp://localhost:8401/testB，在此期间访问localhost:8401/testAhttp://localhost:8401/testA会出现错误Blocked by Sentinelflow limiting\n\n Sentinel流控预热\n\n 默认coldFactor为3，即请求QPS 从 threshold / 3开始，经预热时长逐渐升至设定的QPS阈值。linkhttps://github.com/alibaba/Sentinel/wiki/流量控制warmup\n\n源码  com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController\n\n系统初始化的阀值为10/ 3约等于3,即阀值刚开始为3;然后过了5秒后阀值才慢慢升高恢复到10\n\n测试\n\n多次快速点击http://localhost:8401/testB  刚开始不行，后续慢慢OK\n\nIOid.pnghttps://imgblog.csdnimg.cn/imgconvert/c26846d68d79eae1e962f37942a2c99f.png\n\n应用场景\n\n如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来,慢慢的把阀值增长到设置的阀值。\n\n Sentinel流控排队等待\n\n匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。\n\n设置：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。\n\n231000.pnghttps://imgblog.csdnimg.cn/imgconvert/0ddd217545dd0fe2b1f251dbea814ac2.png\n\n测试\n\n 添加日志记录代码到FlowLimitController的testA方法\n\njava\n@RestController\n@Slf4j\npublic class FlowLimitController {\n    @GetMapping\"/testA\"\n    public String testA\n    {\n        log.infoThread.currentThread.getName+\"\\t\"+\"...testA\";//<\n        return \"testA\";\n    }\n\n}\n\n\n用Jmeter测试，发现后端输出是每隔一秒钟输出一个\n\n Sentinel降级简介\n\n熔断降级概述\n\n 除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。\n\n 现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。\n\n123ddqghbb.pnghttps://imgblog.csdnimg.cn/imgconvert/6a002ef360a4e5f20ee2748a092f0211.png\n\n RT（平均响应时间，秒级）\n   平均响应时间 超出阈值 且 在时间窗口内通过的请求=5，两个条件同时满足后触发降级。\n   窗口期过后关闭断路器。\n   RT最大4900（更大的需要通过Dcsp.sentinel.statistic.max.rt=XXXX才能生效）。\n 异常比列（秒级）\n   QPS = 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。\n 异常数分钟级\n   异常数分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级\n\nSentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。\n\n当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。\n\nSentinei的断路器是没有类似Hystrix半开状态的。Sentinei 1.8.0 已有半开状态\n\n半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。\n\n Sentinel降级RT\n\n20202020.pnghttps://imgblog.csdnimg.cn/imgconvert/dcf85d4362c017e543173c76b7dcc2a8.png\n\n注意：Sentinel 1.7.0才有平均响应时间（DEGRADEGRADERT），Sentinel 1.8.0的没有这项，取而代之的是慢调用比例 SLOWREQUESTRATIO。\n\n087rc.pnghttps://imgblog.csdnimg.cn/imgconvert/3a608908cef3d557322967e6bc0e5696.png\n\n用jmter测压，一秒打10个\n\ncontroller代码\n\njava\n@GetMapping\"/testD\"\npublic String testD {\n    try { \n        TimeUnit.SECONDS.sleep1; \n    } catch InterruptedException e { \n        e.printStackTrace; \n    }\n    log.info\"testD 测试RT\";\n}\n\n\n结论\n\n按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。\n Sentinel降级异常比例\n\n12c23.pnghttps://imgblog.csdnimg.cn/imgconvert/b8f35b00fffd79ef68e8f744403b92f3.png\n\n修改controller代码\n\njava\n@GetMapping\"/testD\"\npublic String testD {\n    try { \n        TimeUnit.SECONDS.sleep1; \n    } catch InterruptedException e { \n        e.printStackTrace; \n    }\n    log.info\"testD 测试RT\";\n}\n\n\n120dxc.pnghttps://imgblog.csdnimg.cn/imgconvert/ab66591ba085c32e9303d96be7b44f0d.png\n\n按照上述配置，单独访问一次，必然来一次报错一次int age = 10/0，调一次错一次。\n\n开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启保险丝跳闸，微服务不可用了，不再报错error而是服务降级了。\n\n Sentinel降级异常数\n\n异常数是按照分钟统计的，时间窗口一定要大于等于60秒。\n\n1211235.pnghttps://imgblog.csdnimg.cn/imgconvert/d92c6a9ae5ed514b52ddf43fdf0d5f0e.png\n\n添加controller代码\n\njava\n@GetMapping\"/testE\"\npublic String testE\n{\n    log.info\"testE 测试异常数\";\n    int age = 10/0;\n    return \"testE 测试异常数\";\n}\n\n\nb0thSJ.pnghttps://imgblog.csdnimg.cn/imgconvert/218fe52e19c07b30bbf4d994d05e6a8e.png\n\n访问http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。\n\n Sentinel热点key上\n\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n\n 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制\n 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制\n\n热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n\n312sLLL.pnghttps://imgblog.csdnimg.cn/imgconvert/16d2ddeff96b7cb68a064b6ec05bde25.png\n\n承上启下复习start\n\n兜底方法，分为系统默认和客户自定义，两种\n\n之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel flow limiting\n\n我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法?\n\n结论  从HystrixCommand到@SentinelResource\n\n再contrller中添加\n\njava\n@GetMapping\"/testHotKey\"\n@SentinelResourcevalue = \"testHotKey\",blockHandler/兜底方法/ = \"dealtestHotKey\"\npublic String testHotKey@RequestParamvalue = \"p1\",required = false String p1,\n                         @RequestParamvalue = \"p2\",required = false String p2 {\n    //int age = 10/0;\n    return \"testHotKey\";\n}\n\n/兜底方法/\npublic String dealtestHotKey String p1, String p2, BlockException exception {\n    return \"dealtestHotKey,o╥﹏╥o\";  //sentinel系统默认的提示：Blocked by Sentinel flow limiting\n}\n\n\n配置\n\ndsdcopp.pnghttps://imgblog.csdnimg.cn/imgconvert/9620ee4e7e54d48ba7dda394fa1c8cd0.png\n\n测试\n\n error\n   http://localhost:8401/testHotKey?p1=abc\n   http://localhost:8401/testHotKey?p1=abc&p2=33\n right\n   http://localhost:8401/testHotKey?p2=abc\n\n若不配置@SentinelResourcevalue = \"testHotKey\",blockHandler/兜底方法/ = \"dealtestHotKey\"的话前端就只能看到一个报错界面 \n\n Sentinel热点key下\n\n上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流。\n\n参数例外项\n\n 普通  超过1秒钟一个后，达到阈值1后马上被限流\n 我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样\n 特例  假如当p1的值等于5时，它的阈值可以达到200\n\ndsaxca.pnghttps://imgblog.csdnimg.cn/imgconvert/3aa08b15109cd346a6083f080a0468fa.png\n\n测试\n\n right  http://localhost:8401/testHotKey?p1=5\n error  http://localhost:8401/testHotKey?p1=3\n 当p1等于5的时候，阈值变为200\n 当p1不等于5的时候，阈值就是平常的1\n\n前提条件  热点参数的注意点，参数必须是基本类型或者String\n\n其它\n\n在testHotKey方法中添加int age = 10/0;使程序报错\n\n将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。\n\n @SentinelResource  处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理;\n\n RuntimeException int age = 10/0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管\n\n总结  @SentinelResource主管配置出错，运行出错该走异常走异常\n\n Sentinel系统规则\n\n就是一次性对所有接口进行限制\n\n系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\n\n Load 自适应（仅对 Linux/Unixlike 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps  minRt 估算得出。设定参考值一般是 CPU cores  2.5。\n CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.01.0），比较灵敏。\n 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。\n 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。\n 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。\n\n SentinelResource配置上\n\n按资源名称限流 + 后续处理\n\n启动Nacos成功\n\n启动Sentinel成功\n\nModule  cloudalibabasentinelservice8401\n\ncontroller\n\njava\n@RestController\npublic class RateLimitController {\n    \n    @GetMapping\"/byResource\"\n    @SentinelResourcevalue = \"byResource\",blockHandler = \"handleException\"\n    public CommonResult byResource {\n        return new CommonResult200,\"按资源名称限流测试OK\",new Payment2020L,\"serial001\";\n    }\n    \n    public CommonResult handleExceptionBlockException exception {\n        return new CommonResult444,exception.getClass.getCanonicalName+\"\\t 服务不可用\";\n    }\n}\n\n\n配置流控规则\n\n配置步骤\n\n21100101.pnghttps://imgblog.csdnimg.cn/imgconvert/91aa0ac210011218db9557a2bfcfebd1.png\n\n图形配置和代码关系\n\n表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流\n\n测试\n\n1秒钟点击1下，OK\n\n超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生\n\njson\n{\"code\":444, \"message\":\"com.alibaba.csp.sentinel.slots.block.flow.FlowException\\t 服务不可用\", \"data\":null}\n\n\n额外问题\n\n此时关闭问服务8401  Sentinel控制台，流控规则消失了\n\n\n\n按照Url地址限流 + 后续处理\n\n通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息\n\n业务类RateLimitController\n\njava\n@GetMapping\"/rateLimit/byUrl\"\n@SentinelResourcevalue = \"byUrl\"\npublic CommonResult byUrl\n{\n    return new CommonResult200,\"按url限流测试OK\",new Payment2020L,\"serial002\";\n}\n\n\nSentinel控制台配置\n\n1xll.pnghttps://imgblog.csdnimg.cn/imgconvert/d6a79b7cc3f2f9c8b6dcbe3f77f78c6b.png\n\n测试\n\n 快速点击http://localhost:8401/rateLimit/byUrl\n 结果  会返回Sentinel自带的限流处理结果 Blocked by Sentinel flow limiting\n\n上面兜底方案面临的问题\n\n1. 系统默认的，没有体现我们自己的业务要求。\n2. 依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。\n3. 每个业务方法都添加—个兜底的，那代码膨胀加剧。\n4. 全局统—的处理方法没有体现。\n\n SentinelResource配置中\n\n客户自定义限流处理逻辑\n\n自定义限流处理类  创建CustomerBlockHandler类用于自定义限流处理逻辑\n\njava\nimport com.alibaba.csp.sentinel.slots.block.BlockException;\nimport com.atguigu.springcloud.entities.CommonResult;\nimport com.atguigu.springcloud.entities.Payment;\n\npublic class CustomerBlockHandler {\n    public static CommonResult handlerExceptionBlockException exception {\n        return new CommonResult4444,\"按客戶自定义,global handlerException1\";\n    }\n    \n    public static CommonResult handlerException2BlockException exception {\n        return new CommonResult4444,\"按客戶自定义,global handlerException2\";\n    }\n}\n\n\nRateLimitController\n\njava\n@GetMapping\"/rateLimit/customerBlockHandler\"\n@SentinelResourcevalue = \"customerBlockHandler\",\n        blockHandlerClass = CustomerBlockHandler.class,//< 自定义限流处理类\n        blockHandler = \"handlerException2\"//<\npublic CommonResult customerBlockHandler\n{\n    return new CommonResult200,\"按客戶自定义\",new Payment2020L,\"serial003\";\n}\n\n\nSentinel控制台配置\n\n1114123d.pnghttps://imgblog.csdnimg.cn/imgconvert/44dccf4107a74fda56f0807d39fa53f1.png\n\n启动微服务后先调用一次  http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。\n\n SentinelResource配置下\n\n@SentinelResource 注解\n\n 注意：注解方式埋点不支持 private 方法。\n\n@SentinelResource用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：\n\n value：资源名称，必需项（不能为空）\n entryType：entry 类型，可选项（默认为 EntryType.OUT）\n blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。若本次访问被限流或服务降级，则调用blockHandler指定的接口。\n fallback /fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若本接口出现未知异常，则调用fallback指定的接口。fallback 函数签名和位置要求：\n   返回值类型必须与原函数返回值类型一致；\n   方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n   fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：\n   返回值类型必须与原函数返回值类型一致；\n   方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n   defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。\n exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。\n\nSentinel主要有三个核心Api：\n\n1. SphU定义资源\n2. Tracer定义统计\n3. ContextUtil定义了上下文\n\n Sentinel服务熔断Ribbon环境预说\n\nsentinel整合ribbon+openFeign+fallback\n\nRibbon系列\n\n 启动nacos和sentinel\n 提供者9003/9004\n 消费者84\n\n\n\n提供者9003/9004\n\n新建cloudalibabaproviderpayment9003/9004，两个一样的做法\n\nPOM\n\nxml\n<dependencies\n    <SpringCloud ailibaba nacos \n    <dependency\n        <groupIdcom.alibaba.cloud</groupId\n        <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n    </dependency\n    <dependency< 引入自己定义的api通用包，可以使用Payment支付Entity \n        <groupIdcom.atguigu.springcloud</groupId\n        <artifactIdcloudapicommons</artifactId\n        <version${project.version}</version\n    </dependency\n    < SpringBoot整合Web组件 \n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarterweb</artifactId\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarteractuator</artifactId\n    </dependency\n    <日常通用jar包配置\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootdevtools</artifactId\n        <scoperuntime</scope\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.projectlombok</groupId\n        <artifactIdlombok</artifactId\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstartertest</artifactId\n        <scopetest</scope\n    </dependency\n</dependencies\n\n\nYML\n\nyml\nserver:\n  port: 9003\n\nspring:\n  application:\n    name: nacospaymentprovider\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 配置Nacos地址\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\n\n记得修改不同的端口号\n\n主启动添加@EnableDiscoveryClient\n\n业务类\n\njava\n@RestController\npublic class PaymentController {\n    @Value\"${server.port}\"\n    private String serverPort;\n\n    //模拟数据库\n    public static HashMap<Long,Payment hashMap = new HashMap<;\n    static\n    {\n        hashMap.put1L,new Payment1L,\"28a8c1e3bc2742d8848569891fb42181\";\n        hashMap.put2L,new Payment2L,\"bba8c1e3bc2742d8848569891ac32182\";\n        hashMap.put3L,new Payment3L,\"6ua8c1e3bc2742d8848569891xt92183\";\n    }\n\n    @GetMappingvalue = \"/paymentSQL/{id}\"\n    public CommonResult<Payment paymentSQL@PathVariable\"id\" Long id\n    {\n        Payment payment = hashMap.getid;\n        CommonResult<Payment result = new CommonResult200,\"from mysql,serverPort:  \"+serverPort,payment;\n        return result;\n    }\n}\n\n\n测试地址  http://localhost:9003/paymentSQL/1\n\n\n\n消费者84\n\n新建cloudalibabaconsumernacosorder84\n\nPOM\n\nxml\n<dependencies\n    <SpringCloud openfeign \n    <\n    <dependency\n        <groupIdorg.springframework.cloud</groupId\n        <artifactIdspringcloudstarteropenfeign</artifactId\n    </dependency\n\t\n    <SpringCloud ailibaba nacos \n    <dependency\n        <groupIdcom.alibaba.cloud</groupId\n        <artifactIdspringcloudstarteralibabanacosdiscovery</artifactId\n    </dependency\n    <SpringCloud ailibaba sentinel \n    <dependency\n        <groupIdcom.alibaba.cloud</groupId\n        <artifactIdspringcloudstarteralibabasentinel</artifactId\n    </dependency\n    < 引入自己定义的api通用包，可以使用Payment支付Entity \n    <dependency\n        <groupIdcom.atguigu.springcloud</groupId\n        <artifactIdcloudapicommons</artifactId\n        <version${project.version}</version\n    </dependency\n    < SpringBoot整合Web组件 \n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarterweb</artifactId\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstarteractuator</artifactId\n    </dependency\n    <日常通用jar包配置\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootdevtools</artifactId\n        <scoperuntime</scope\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.projectlombok</groupId\n        <artifactIdlombok</artifactId\n        <optionaltrue</optional\n    </dependency\n    <dependency\n        <groupIdorg.springframework.boot</groupId\n        <artifactIdspringbootstartertest</artifactId\n        <scopetest</scope\n    </dependency\n</dependencies\n\n\nYML\n\nyml\nserver:\n  port: 84\n\nspring:\n  application:\n    name: nacosorderconsumer\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848\n    sentinel:\n      transport:\n        配置Sentinel dashboard地址\n        dashboard: localhost:8080\n        默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\n        port: 8719\n\n消费者将要去访问的微服务名称注册成功进nacos的微服务提供者\nserviceurl:\n  nacosuserservice: http://nacospaymentprovider\n\n 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: false\n\n\n主启动\n\njava\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients\n\n\nApplicationContextConfig\n\njava\n@Configuration\npublic class ApplicationContextConfig {\n\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate {\n        return new RestTemplate;\n    }\n}\n\n\nCircleBreakerController\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping\"/consumer/fallback/{id}\"\n    @SentinelResourcevalue = \"fallback\"//没有配置\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    \n}\n\n\n修改后请重启微服务\n\n 热部署对java代码级生效及时\n 对@SentinelResource注解内属性，有时效果不好\n\n目的\n\n fallback管运行异常\n blockHandler管配置违规\n\n测试地址  http://localhost:84/consumer/fallback/1\n\n没有任何配置\n\n只配置fallback\n\n只配置blockHandler\n\nfallback和blockHandler都配置\n\n忽略属性\n\n Sentinel服务熔断只配置fallback\n\n为了防止出现程序报错页面，添加兜底方法\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController {\n    \n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n \n    @RequestMapping\"/consumer/fallback/{id}\"\n    //@SentinelResourcevalue = \"fallback\"//没有配置\n    @SentinelResourcevalue = \"fallback\", fallback = \"handlerFallback\" //fallback只负责业务异常\n    public CommonResult<Payment fallback@PathVariable Long id {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    \n    //本例是fallback\n    public CommonResult handlerFallback@PathVariable  Long id,Throwable e {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage,payment;\n    }\n    \n}\n\n\n Sentinel服务熔断只配置blockHandler\n\nblockHandler只负责sentinel控制台配置违规\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping\"/consumer/fallback/{id}\"\n    //@SentinelResourcevalue = \"fallback\" //没有配置\n    //@SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\" //fallback只负责业务异常\n    @SentinelResourcevalue = \"fallback\",blockHandler = \"blockHandler\" //blockHandler只负责sentinel控制台配置违规\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    //本例是fallback\n/    public CommonResult handlerFallback@PathVariable  Long id,Throwable e {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage,payment;\n    }/\n    \n    //本例是blockHandler\n    public CommonResult blockHandler@PathVariable  Long id,BlockException blockException {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<445,\"blockHandlersentinel限流,无此流水: blockException  \"+blockException.getMessage,payment;\n    }\n}\n\n\n Sentinel服务熔断fallback和blockHandler都配置\n\n若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。\n\n异常访问会走handlerFallback，若设置了限流的话，多次访问会走blockHandler\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController\n{\n    public static final String SERVICEURL = \"http://nacospaymentprovider\";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @RequestMapping\"/consumer/fallback/{id}\"\n    //@SentinelResourcevalue = \"fallback\" //没有配置\n    //@SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\" //fallback只负责业务异常\n    //@SentinelResourcevalue = \"fallback\",blockHandler = \"blockHandler\" //blockHandler只负责sentinel控制台配置违规\n    @SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\"\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n    //本例是fallback\n    public CommonResult handlerFallback@PathVariable  Long id,Throwable e {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<444,\"兜底异常handlerFallback,exception内容  \"+e.getMessage,payment;\n    }\n    //本例是blockHandler\n    public CommonResult blockHandler@PathVariable  Long id,BlockException blockException {\n        Payment payment = new Paymentid,\"null\";\n        return new CommonResult<445,\"blockHandlersentinel限流,无此流水: blockException  \"+blockException.getMessage,payment;\n    }\n}\n\n\n Sentinel服务熔断exceptionsToIgnore\n\nexceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。\n\njava\n@RestController\n@Slf4j\npublic class CircleBreakerController    \n\n    ...\n    \n    @RequestMapping\"/consumer/fallback/{id}\"\n    @SentinelResourcevalue = \"fallback\",fallback = \"handlerFallback\",blockHandler = \"blockHandler\",\n            exceptionsToIgnore = {IllegalArgumentException.class}//<\n    public CommonResult<Payment fallback@PathVariable Long id\n    {\n        CommonResult<Payment result = restTemplate.getForObjectSERVICEURL + \"/paymentSQL/\"+id,CommonResult.class,id;\n\n        if id == 4 {\n            //exceptionsToIgnore属性有IllegalArgumentException.class，\n            //所以IllegalArgumentException不会跳入指定的兜底程序。\n            throw new IllegalArgumentException \"IllegalArgumentException,非法参数异常....\";\n        }else if result.getData == null {\n            throw new NullPointerException \"NullPointerException,该ID没有对应记录,空指针异常\";\n        }\n\n        return result;\n    }\n\n\t...\n}\n\n\n Sentinel服务熔断OpenFeign\n\n修改84模块\n\n 84消费者调用提供者9003\n Feign组件一般是消费侧\n\nPOM\n\nxml\n<SpringCloud openfeign \n<dependency\n    <groupIdorg.springframework.cloud</groupId\n    <artifactIdspringcloudstarteropenfeign</artifactId\n</dependency\n\n\nYML\n\nyaml\n 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n\n\n业务类\n\n带@Feignclient注解的业务接口，fallback = PaymentFallbackService.class\n\njade\n@FeignClientvalue = \"nacospaymentprovider\",fallback = PaymentFallbackService.class\npublic interface PaymentService\n{\n    @GetMappingvalue = \"/paymentSQL/{id}\"\n    public CommonResult<Payment paymentSQL@PathVariable\"id\" Long id;\n}\n\n\njava\n@Component\npublic class PaymentFallbackService implements PaymentService {\n    @Override\n    public CommonResult<Payment paymentSQLLong id\n    {\n        return new CommonResult<44444,\"服务降级返回,PaymentFallbackService\",new Paymentid,\"errorSerial\";\n    }\n}\n\n\nController\n\njava\n@Resource\nprivate PaymentService paymentService;\n@GetMappingvalue = \"/consumer/paymentSQL/{id}\"\npublic CommonResult<Payment paymentSQL@PathVariable\"id\" Long id\n{\n    return paymentService.paymentSQLid;\n}\n\n\n主启动\n\njava\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableFeignClients//<\npublic class OrderNacosMain84 {\n    public static void mainString args {\n        SpringApplication.runOrderNacosMain84.class, args;\n    }\n}\n\n\n测试  http://localhost:84/consumer/paymentSQL/1\n\n测试84调用9003，此时故意关闭9003微服务提供者，84消费侧自动降级，不会被耗死。\n\n熔断框架比较\n\npPFrBUP.pnghttps://s1.ax1x.com/2023/08/04/pPFrBUP.pnghttps://imgse.com/i/pPFrBUP\n\n Sentinel持久化规则\n\n是什么\n\n一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。\n\n怎么玩\n\n将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。\n\n步骤\n\n修改cloudalibabasentinelservice8401\n\nPOM\n\nxml\n<SpringCloud ailibaba sentineldatasourcenacos 后续做持久化用到\n<dependency\n    <groupIdcom.alibaba.csp</groupId\n    <artifactIdsentineldatasourcenacos</artifactId\n</dependency\n\n\nYML\n\nyml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibabasentinelservice\n  cloud:\n    nacos:\n      discovery:\n        serveraddr: localhost:8848 Nacos服务注册中心地址\n    sentinel:\n      transport:\n        dashboard: localhost:8080 配置Sentinel dashboard地址\n        port: 8719\n      datasource: <关注点，添加Nacos数据源配置\n        ds1:\n          nacos:\n            serveraddr: localhost:8848\n            dataId: cloudalibabasentinelservice\n            groupId: DEFAULTGROUP\n            datatype: json\n            ruletype: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: ''\n\nfeign:\n  sentinel:\n    enabled: true  激活Sentinel对Feign的支持\n\n\n添加Nacos业务规则配置\n\n214PPPP.pnghttps://imgblog.csdnimg.cn/imgconvert/2401a6b2df715ee64f647da2f31e1eeb.png\n\n配置内容解析\n\njso\n{\n    \"resource\": \"/rateLimit/byUrl\",\n    \"limitApp\": \"default\",\n    \"grade\": 1,\n    \"count\": 1, \n    \"strategy\": 0,\n    \"controlBehavior\": 0,\n    \"clusterMode\": false\n}\n\n\n resource：资源名称；\n limitApp：来源应用；\n grade：阈值类型，0表示线程数, 1表示QPS；\n count：单机阈值；\n strategy：流控模式，0表示直接，1表示关联，2表示链路；\n controlBehavior：流控效果，0表示快速失败，\n 1表示Warm Up，2表示排队等待；\n clusterMode：是否集群。\n\n启动8401后刷新sentinel发现业务规则有了\n\n000wqq.pnghttps://imgblog.csdnimg.cn/imgconvert/c854e986254c09d0a7866811ec1e0cb4.png\n\n快速访问测试接口  http://localhost:8401/rateLimit/byUrl  页面返回Blocked by Sentinel flow limiting\n\n停止8401再看sentinel  停机后发现流控规则没有了\n\n重新启动8401再看sentinel\n\n 乍一看还是没有，稍等一会儿\n 多次调用  http://localhost:8401/rateLimit/byUrl\n 重新配置出现了，持久化验证通过\n\n Seata\n\n 分布式事务问题由来\n\n分布式前\n\n 单机单库没这个问题\n 从1:1  1:N  N:N\n\n单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证。\n\n一句话：一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题。\n\n Seata术语\n\nSeata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。\n\n能干嘛\n\n一个典型的分布式事务过程\n\n分布式事务处理过程的一ID+三组件模型：\n\n Transaction ID XID 全局唯一的事务ID\n 三组件概念\n   TC Transaction Coordinator  事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。\n   TM Transaction Manager  事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n   RM Resource Manager  资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n处理过程：\n\n TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；\n XID在微服务调用链路的上下文中传播；\n RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；\n TM向TC发起针对XID的全局提交或回滚决议；\n TC调度XID下管辖的全部分支事务完成提交或回滚请求。\n\ncnaois.pnghttps://imgblog.csdnimg.cn/imgconvert/2d2c6aa29c3158413f66d4ef8c1000dc.png\n\n SeataServer安装\n\n下载\n\nReleases · seata/seata github.comhttps://github.com/seata/seata/releases/\n\n怎么玩\n\n本地@Transactional\n\n全局@GlobalTransactional\nSEATA 的分布式交易解决方案\n\n我们只需要使用一个 @GlobalTransactional 注解在业务方法上\n"},{"filename":"springsecurity-learn","category":"java","md":{"topSummary":"\ntitle: SpringSecurity学习笔记\ncategory: Java,SpringSecurity\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n两个核心功能：**认证**和**授权**\n\n## 基本原理\n\n### 拦截器链\n\nSpringSecurity本质是一个过滤器链，在 SpringBoot 2.3.4.RELEASE中，共有15种拦截器，如图所示：\n\n![](../../.vuepress/public/assets/article/springsecurity-filter/dkhd21HR825.png)\n\n```\norg.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter org.springframework.security.web.context.SecurityContextPersistenceFilter  org.springframework.security.web.header.HeaderWriterFilter org.springframework.security.web.csrf.CsrfFilter org.springframework.security.web.authentication.logout.LogoutFilter  org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter  org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter  org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter org.springframework.security.web.savedrequest.RequestCacheAwareFilter org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter org.springframework.security.web.authentication.AnonymousAuthenticationFilter  org.springframework.security.web.session.SessionManagementFilter  org.springframework.security.web.access.ExceptionTranslationFilter  org.springframework.security.web.access.intercept.FilterSecurityIntercepto\n```\n\n重点三个：\n\n`FilterSecurityInterceptor`：是一个方法级的权限过滤器, 基本位于过滤链的最底部。\n\n`ExceptionTranslationFilter`：是个异常过滤器，用来处理在认证授权过程中抛出的异常\n\n`UsernamePasswordAuthenticationFilter` ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码\n\n### 主要拦截器介绍\n\n#### SecurityContextPersistenceFilter\n\n包路径：org.springframework.security.web.context\n\n负责将安全上下文存储在 HttpSession 中，以便在后续请求中访问\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    // 判断是否是第一次请求\n    if (request.getAttribute(\"__spring_security_scpf_applied\") != null) {\n        chain.doFilter(request, response);\n    } else {\n        boolean debug = this.logger.isDebugEnabled();\n        // 设置值\n        request.setAttribute(\"__spring_security_scpf_applied\", Boolean.TRUE);\n        if (this.forceEagerSessionCreation) {\n            HttpSession session = request.getSession();\n            if (debug && session.isNew()) {\n                this.logger.debug(\"Eagerly created session: \" + session.getId());\n            }\n        }\n\n        HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request, response);\n        SecurityContext contextBeforeChainExecution = this.repo.loadContext(holder);\n        boolean var13 = false;\n\n        try {\n            var13 = true;\n            // 将SecurityContext安全信息设置到SecurityContextHolder线程上下文中\n            SecurityContextHolder.setContext(contextBSecurityContextHolder中eforeChainExecution);\n            chain.doFilter(holder.getR\tequest(), holder.getResponse());\n            var13 = false;\n        } finally {\n            if (var13) {\n                SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\n                SecurityContextHolder.clearContext();\n                // 将上下文信息保存在session中\n                this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());\n                request.removeAttribute(\"__spring_security_scpf_applied\");\n                if (debug) {\n                    this.logger.debug(\"SecurityContextHolder now cleared, as request processing completed\");\n                }\n\n            }\n        }\n\n        SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\n        SecurityContextHolder.clearContext();\n        this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());\n            request.removeAttribute(\"__spring_security_scpf_applied\");\n        if (debug) {\n            this.logger.debug(\"SecurityContextHolder now cleared, as request processing completed\");\n        }\n\n    }\n}\n```\n\n#### LogoutFilter\n\n包路径：org.springframework.security.web.authentication.logout.LogoutFilter\n\n匹配URL为 /logout 的请求，实现用户退出，清除认证信息\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    if (this.requiresLogout(request, response)) { // 匹配URL\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Logging out user '\" + auth + \"' and transferring to logout destination\");\n        }\n\n        this.handler.logout(request, response, auth); // 清除认证信息\n        this.logoutSuccessHandler.onLogoutSuccess(request, response, auth); // 处理自定义退出成功逻辑\n    } else {\n        chain.doFilter(request, response);\n    }\n}\n```\n\n对于 `logoutSuccessHandler.onLogoutSuccess` 这个方法，我们可以对他进行重写，实现自己的退出成功逻辑\n\n#### UsernamePasswordAuthenticationFilter\n\n包路径：org.springframework.security.web.authentication\n\n匹配请求为 POST，且路径为` /login` 的请求，通过表单的用户名和密码进行认证，认证成功会将用户信息放到上下文中\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    if (!this.requiresAuthentication(request, response)) {\n        chain.doFilter(request, response);\n    } else {\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Request is to process authentication\");\n        }\n\n        Authentication authResult;\n        try {\n            // 调用子类的attemptAuthentication方法\n            authResult = this.attemptAuthentication(request, response);\n            // 子类未完成认证\n            if (authResult == null) {\n                return;\n            }\n\n            this.sessionStrategy.onAuthentication(authResult, request, response);\n        } catch (InternalAuthenticationServiceException var8) {\n            this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8);\n            // 认证失败\n            this.unsuccessfulAuthentication(request, response, var8);\n            return;\n        } catch (AuthenticationException var9) {\n            // 认证失败\n            this.unsuccessfulAuthentication(request, response, var9);\n            return;\n        }\n\n        if (this.continueChainBeforeSuccessfulAuthentication) {\n            chain.doFilter(request, response);\n        }\n\t\t// 认证成功\n        this.successfulAuthentication(request, response, chain, authResult);\n    }\n}\n\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n    if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n        throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n    } else {\n        String username = this.obtainUsername(request);\n        String password = this.obtainPassword(request);\n        if (username == null) {\n            username = \"\";\n        }\n\n        if (password == null) {\n            password = \"\";\n        }\n\n        username = username.trim();\n        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n        this.setDetails(request, authRequest);\n        // 核心部分，交给内部的AuthenticationManager去认证，并返回认证后的 Authentication\n        return this.getAuthenticationManager().authenticate(authRequest);\n    }\n}\n```\n\n#### DefaultLoginPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n若未自定义认证界面，过滤器会生成一个默认的认证界面\n\n```java\nprivate void init(UsernamePasswordAuthenticationFilter authFilter, AbstractAuthenticationProcessingFilter openIDFilter) {\n    this.loginPageUrl = \"/login\";\n    this.logoutSuccessUrl = \"/login?logout\";\n    this.failureUrl = \"/login?error\";\n    if (authFilter != null) { // 若自定义了，authFilter就为null\n        this.formLoginEnabled = true;\n        this.usernameParameter = authFilter.getUsernameParameter();\n        this.passwordParameter = authFilter.getPasswordParameter();\n        if (authFilter.getRememberMeServices() instanceof AbstractRememberMeServices) {\n            this.rememberMeParameter = ((AbstractRememberMeServices)authFilter.getRememberMeServices()).getParameter();\n        }\n    }\n\n    if (openIDFilter != null) {\n        this.openIdEnabled = true;\n        this.openIDusernameParameter = \"openid_identifier\";\n        if (openIDFilter.getRememberMeServices() instanceof AbstractRememberMeServices) {\n            this.openIDrememberMeParameter = ((AbstractRememberMeServices)openIDFilter.getRememberMeServices()).getParameter();\n        }\n    }\n\n}\n```\n\n#### DefaultLogoutPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n和 DefaultLogoutPageGeneratingFilter 类似，此过滤器可以生产一个默认的退出登录页面\n\n```java\nprivate void renderLogout(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String page = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"utf-8\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1, shrink-to-fit=no\\\">\\n    <meta name=\\\"description\\\" content=\\\"\\\">\\n    <meta name=\\\"author\\\" content=\\\"\\\">\\n    <title>Confirm Log Out?</title>\\n    <link href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\" integrity=\\\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\\\" crossorigin=\\\"anonymous\\\">\\n    <link href=\\\"https://getbootstrap.com/docs/4.0/examples/signin/signin.css\\\" rel=\\\"stylesheet\\\" crossorigin=\\\"anonymous\\\"/>\\n  </head>\\n  <body>\\n     <div class=\\\"container\\\">\\n      <form class=\\\"form-signin\\\" method=\\\"post\\\" action=\\\"\" + request.getContextPath() + \"/logout\\\">\\n        <h2 class=\\\"form-signin-heading\\\">Are you sure you want to log out?</h2>\\n\" + this.renderHiddenInputs(request) + \"        <button class=\\\"btn btn-lg btn-primary btn-block\\\" type=\\\"submit\\\">Log Out</button>\\n      </form>\\n    </div>\\n  </body>\\n</html>\";\n    response.setContentType(\"text/html;charset=UTF-8\");\n    response.getWriter().write(page);\n}\n```\n\n#### AnonymousAuthenticationFilter\n\n当用户没有授权认证，那么就会给他一个匿名身份\n\n\n\n#### ExceptionTranslationFilter\n\n包路径：org.springframework.security.web.access\n\n捕获并处理认证和授权过程中发生的异常\n\n\n\n#### FilterSecurityInterceptor\n\n包路径：org.springframework.security.web.access.intercept\n\n获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来决定其是否有权限\n\n\n\n## 过滤器加载流程\n\n### DelegatingFilterProxy类\n\n首先执行`doFilter`方法\n\n```java\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        Filter delegateToUse = this.delegate;\n        if (delegateToUse == null) {\n            synchronized(this.delegateMonitor) {\n                delegateToUse = this.delegate;\n                if (delegateToUse == null) {\n                    WebApplicationContext wac = this.findWebApplicationContext();\n                    if (wac == null) {\n                        throw new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?\");\n                    }\n\n                    delegateToUse = this.initDelegate(wac);\n                }\n\n                this.delegate = delegateToUse;\n            }\n        }\n```\n\n接着执行`initDelegate`\n\n```java\n protected Filter initDelegate(WebApplicationContext wac) throws ServletException {\n        String targetBeanName = this.getTargetBeanName();\n        Assert.state(targetBeanName != null, \"No target bean name set\");\n        Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);\n        if (this.isTargetFilterLifecycle()) {\n            delegate.init(this.getFilterConfig());\n        }\n\n        return delegate;\n    }\n```\n\n`targetBeanName`在`SpringSecurity`中有一个固定的名字：`FilterChainProxy`\n\n### FilterChainProxy类\n\n首先执行`doFilter`方法\n\n```java\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        boolean clearContext = request.getAttribute(FILTER_APPLIED) == null;\n        if (clearContext) {\n            try {\n                request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n                this.doFilterInternal(request, response, chain);\n            } finally {\n                SecurityContextHolder.clearContext();\n                request.removeAttribute(FILTER_APPLIED);\n            }\n        } else {\n            this.doFilterInternal(request, response, chain);\n        }\n\n    }\n```\n\n执行`doFilterInternal`方法\n\n```java\nprivate void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        FirewalledRequest fwRequest = this.firewall.getFirewalledRequest((HttpServletRequest)request);\n        HttpServletResponse fwResponse = this.firewall.getFirewalledResponse((HttpServletResponse)response);\n        List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);\n        if (filters != null && filters.size() != 0) {\n            FilterChainProxy.VirtualFilterChain vfc = new FilterChainProxy.VirtualFilterChain(fwRequest, chain, filters);\n            vfc.doFilter(fwRequest, fwResponse);\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(UrlUtils.buildRequestUrl(fwRequest) + (filters == null ? \" has no matching filters\" : \" has an empty filter list\"));\n            }\n\n            fwRequest.reset();\n            chain.doFilter(fwRequest, fwResponse);\n        }\n    }\n```\n\n`  List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);`会执行`getFilters`方法，它会把过滤器一个一个加载到过滤链中\n\n```java\nprivate List<Filter> getFilters(HttpServletRequest request) {\n      Iterator var2 = this.filterChains.iterator();\n\n      SecurityFilterChain chain;\n      do {\n          if (!var2.hasNext()) {\n              return null;\n          }\n\n          chain = (SecurityFilterChain)var2.next();\n      } while(!chain.matches(request));\n\n      return chain.getFilters();\n}\n```\n\n## 重要接口\n\n### UserDetailsService\n\n```java\npublic interface UserDetailsService {\n    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;\n}\n```\n\n> 当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 `UserDetailsService `接口即可。\n\n作用：查询数据库用户名和密码过程\n\n- 创建类继承`UsernamePasswordAuthenticationFilter`，重写三个方法\n- 创建类实现`UserDetailService`，返回`UserDetails`对象（框架提供的对象）\n\n`UserDetails`类\n\n```java\npublic interface UserDetails extends Serializable {\n  \t// 表示获取登录用户所有权限\n    Collection<? extends GrantedAuthority> getAuthorities();\n    // 表示获取密码\n    String getPassword();\n    // 表示获取用户名\n    String getUsername();\n    // 表示判断账户是否过期\n    boolean isAccountNonExpired();\n    // 表示判断账户是否被锁定\n    boolean isAccountNonLocked();\n    // 表示凭证{密码}是否过期\n    boolean isCredentialsNonExpired();\n    // 表示当前用户是否可用\n    boolean isEnabled();\n}\n```\n\n### PasswordEncoder\n\n```java\npublic interface PasswordEncoder {\n    // 表示把参数按照特定的解析规则进行解析\n    String encode(CharSequence var1);\n\t// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。\n    boolean matches(CharSequence var1, String var2);\n\t// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncoding(String encodedPassword) {\n        return false;\n    }\n}\n```\n\n接口实现\n\n`BCryptPasswordEncoder` 是 Spring Security 官方推荐的密码解析器，是对`PasswordEncoder`类的实现\n\n加密\n\n```java\npublic String encode(CharSequence rawPassword) {\n        if (rawPassword == null) {\n            throw new IllegalArgumentException(\"rawPassword cannot be null\");\n        } else {\n            String salt;\n            if (this.random != null) {\n                salt = BCrypt.gensalt(this.version.getVersion(), this.strength, this.random);\n            } else {\n                salt = BCrypt.gensalt(this.version.getVersion(), this.strength);\n            }\n\n            return BCrypt.hashpw(rawPassword.toString(), salt);\n        }\n    }\n```\n\n匹配\n\n```java\npublic boolean matches(CharSequence rawPassword, String encodedPassword) {\n        if (rawPassword == null) {\n            throw new IllegalArgumentException(\"rawPassword cannot be null\");\n        } else if (encodedPassword != null && encodedPassword.length() != 0) {\n            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {\n                this.logger.warn(\"Encoded password does not look like BCrypt\");\n                return false;\n            } else {\n                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);\n            }\n        } else {\n            this.logger.warn(\"Empty encoded password\");\n            return false;\n        }\n    }\n```\n\n## SpringSecurity Web 权限方案\n\n授权和认证两种\n\n### 设置用户名和密码\n\n方式一：配置文件实现\n\n```properties\nspring.security.user.name=ljx\nspring.security.user.password=ljx\n```\n\n方式二：配置类实现\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        BCryptPasswordEncoder cryptPasswordEncoder = new BCryptPasswordEncoder();\n        auth.inMemoryAuthentication().withUser(\"ljx\").password(cryptPasswordEncoder.encode(\"ljx\")).roles(\"user\");\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n}\n```\n\n方式三：自定义实现类\n\n创建配置类\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    /**\n     * 自定义类实现登录\n     * @param auth\n     * @throws Exception\n     */\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());\n\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n编写`userDetailService`实现类，返回`User`对象`\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<GrantedAuthority> list = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(\"ljx\", new BCryptPasswordEncoder().encode(\"ljx\"), list);\n    }\n}\n```\n\n### 整合数据库实现登录\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        User user = userMapper.queryUserByUsername(s);\n        if(s == null){\n            throw new UsernameNotFoundException(\"用户不存在\");\n        }\n        List<GrantedAuthority> list = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(user.getUsername(), new BCryptPasswordEncoder().encode(user.getPassword()), list);\n    }\n}\n```\n\n### 路径拦截路径拦截\n\n实现`configure`的另一个方法（与上面的不一样）\n\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n           http.and()\n                .authorizeRequests()\n                .antMatchers(\"/api/main/t\").permitAll() // 不需要认证\n                .anyRequest().authenticated()\n                .and().csrf().disable();  // 关闭csrf\n    }\n```\n\n## 角色权限访问控制\n\n### hasAuthority\n\n如果当前的主体具有指定的权限，则返回 true,否则返回 false\n\n```java\n.antMatchers(\"/test1\").hasAuthority(\"admin\")\n```\n\n### hasAnyAuthority\n\n如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串表）的话，返回 true\n\n```java\n.antMatchers(\"/test2\").hasAnyAuthority(\"admin, role\")\n```\n\n### hasRole\n\n如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。\n\n```java\n.antMatchers(\"/test3\").hasRole(\"sale\")\n```\n\n这个方法于之前两个不同的是底层原码是默认加了`ROLE_`前缀，所以在添加用户权限的时候需注意在角色前面加`ROLE_`\n\n```java\nprivate static String hasRole(String role) {\n        Assert.notNull(role, \"role cannot be null\");\n        if (role.startsWith(\"ROLE_\")) {\n            throw new IllegalArgumentException(\"role should not start with 'ROLE_' since it is automatically inserted. Got '\" + role + \"'\");\n        } else {\n            return \"hasRole('ROLE_\" + role + \"')\";\n        }\n    }\n```\n\n### hasAnyRole\n\n表示用户具备任何一个条件都可以访问\n\n```java\n.antMatchers(\"/test3\").hasAnyRole(\"sale\")\n```\n\n要求于`hasRole`一样\n\n### 自定义403页面\n\n```java\nhttp.exceptionHandling().accessDeniedPage(\"/unauth\");\n```\n\n```java\n@GetMapping(\"/unauth\")\n@ResponseBody\npublic String t4(){\n    return \"unauth\";\n}\n```\n\n### 注解使用\n\n#### @Secured\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(securedEnabled = true)\n```\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“\n\n在方法上加上这个注解\n\n```java\n@Secured({\"ROLE_sole\", \"ROLE_aaa\"})\n```\n\n#### @PreAuthorize\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n```\n\n注解适合进入方法前的权限验证\n\n```java\n@PreAuthorize(\"hasAnyAuthority('menu:system')\")\n// 此处hasAnyAuthority可以换成hasAnyRole，hasRole，hasAnyAuthority其中一个\n```\n\n#### @PostAuthorize\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true\n```\n\n在方法执行后再进行权限验证（接口里面方法任会被执行，只是最后会权限验证），适合验证带有返回值的权限\n\n```java\n@PostAuthorize(\"hasAnyAuthority('menu:system')\")\n```\n\n#### @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是` admin1`的数据，表达式中的 `filterObject`引用的是方法返回值 List 中的某一个元素\n\n```java\n@RequestMapping(\"getAll\")\n@PreAuthorize(\"hasRole('ROLE_role')\")\n@PostFilter(\"filterObject.username == 'admin1'\")\n@ResponseBody\npublic List<UserInfo> getAllUser(){\n ArrayList<UserInfo> list = new ArrayList<>();\n list.add(new UserInfo(1l,\"admin1\",\"6666\"));\n list.add(new UserInfo(2l,\"admin2\",\"888\"));\nreturn list;\n}\n```\n\n最终返回页面的数据\n\n```json\n[\n    {\n        \"id\": 1,\n        \"username\": \"admin1\",\n        \"num\": \"6666\"\n    }\n]\n```\n\n#### @PreFilter\n\n进入控制器之前对数据进行过滤\n\n```java\n@RequestMapping(\"getTestPreFilter\")\n@PreAuthorize(\"hasRole('ROLE_role')\")\n@PreFilter(value = \"filterObject.id % 2 == 0\")\n@ResponseBody\npublic List<UserInfo> getTestPreFilter(@RequestBody List<UserInfo> \nlist){\n list.forEach(t-> {\n System.out.println(t.getId()+\"\\t\"+t.getUsername());\n });\nreturn list;\n}\n```\n\n最终接收到的参数只有id为偶数才能被接收\n\n### 退出登录\n\n```java\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/index\").permitAll\n```\n\n## CSRF\n\n跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click  attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任\n\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。\n\n关闭csrf\n\n```java\nhttp.csrf().disable()\n```\n\n## 微服务\n\n### 数据库\n\n![image-20230726154749582](https://s1.ax1x.com/2023/07/26/pCjwOSS.png)\n\n### 搭建项目\n\n![image-20230726154749582](https://s1.ax1x.com/2023/07/26/pCjax1g.png)\n\n### 前置知识\n\n#### Nacos\n\n阿里巴巴的注册中心，网关服务（9001端口）通过注册中心转发到权限管理服务（8081端口）\n\n启动：Windows点击`startup.cmd`，Linux运行`startup.sh`\n\n访问地址：http://localhost:8848/nacos，默认用户名和密码都是nacos\n\n## 认证流程\n\n[![pCvJddf.png](https://s1.ax1x.com/2023/07/27/pCvJddf.png)](https://imgse.com/i/pCvJddf)\n\n`UsernamePasswordAuthenticationFilter`\n\n继承`AbstractAuthenticationProcessingFilter`父类\n\n查看父类的`doFilter`方法\n\n```java\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        // 判断是否是post提交\n        if (!this.requiresAuthentication(request, response)) {\n            chain.doFilter(request, response);\n        } else {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Request is to process authentication\");\n            }\n\t\t\t// 进行身份认证，认证成功将信息封装到Authentication中\n            Authentication authResult;\n            try {\n                authResult = this.attemptAuthentication(request, response);\n                if (authResult == null) {\n                    return;\n                }\t\n\t\t\t\t// session策略处理\n                this.sessionStrategy.onAuthentication(authResult, request, response);\n            } catch (InternalAuthenticationServiceException var8) {\n                // 认证失败\n                this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8);\n                this.unsuccessfulAuthentication(request, response, var8);\n                return;\n            } catch (AuthenticationException var9) {\n                this.unsuccessfulAuthentication(request, response, var9);\n                return;\n            }\n\t\t\t// 认证成功\n            // continueChainBeforeSuccessfulAuthentication默认为false\n            if (this.continueChainBeforeSuccessfulAuthentication) {\n                chain.doFilter(request, response);\n            }\n\n            this.successfulAuthentication(request, response, chain, authResult);\n        }\n    }\n```\n\n查看`UsernamePasswordAuthenticationFilter`子类中的`attemptAuthentication`方法（上述代码中的`attemptAuthentication`方法）\n\n```java\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        // 判断是否是post请求\n        if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n            throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n        } else {\n            // 检查参数书否为空\n            String username = this.obtainUsername(request);\n            String password = this.obtainPassword(request);\n            if (username == null) {\n                username = \"\";\n            }\n\n            if (password == null) {\n                password = \"\";\n            }\n\t\t\t// 去掉空格\n            username = username.trim();\n            // 使用获取数据构造对象，标记未认证\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n            // 将请求的信息设置到Authentication对象中\n            this.setDetails(request, authRequest);\n            // 进行身份验证（调用userDetailsService）\n            return this.getAuthenticationManager().authenticate(authRequest);\n        }\n    }\n```\n\n查看`ProviderManager`实现`AuthenticationManager`接口（该接口包含上述代码最后一行的的`authenticate`方法）\n\n```java\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        // 获取Authentication的类型，即UsernamePasswordAuthenticationToken.class\n        Class<? extends Authentication> toTest = authentication.getClass();\n        AuthenticationException lastException = null;\n        AuthenticationException parentException = null;\n        Authentication result = null;\n        Authentication parentResult = null;\n        boolean debug = logger.isDebugEnabled();\n        // 获取认证方式列表List<AuthenticationProvider>迭代器\n        Iterator var8 = this.getProviders().iterator();\n\n        while(var8.hasNext()) {\n            AuthenticationProvider provider = (AuthenticationProvider)var8.next();\n            // 判断当前AuthenticationProvider是否适用UsernamePasswordAuthenticationToken.class类型的Authentication\n            if (provider.supports(toTest)) {\n                if (debug) {\n                    logger.debug(\"Authentication attempt using \" + provider.getClass().getName());\n                }\n\n                try {\n                    // 认证成功会返回标记已认证的Authentication对象\n                    result = provider.authenticate(authentication);\n                    if (result != null) {\n                        // 信息拷贝到result中\n                        this.copyDetails(authentication, result);\n                        break;\n                    }\n                } catch (InternalAuthenticationServiceException | AccountStatusException var13) {\n                    this.prepareException(var13, authentication);\n                    throw var13;\n                } catch (AuthenticationException var14) {\n                    lastException = var14;\n                }\n            }\n        }\n\n        if (result == null && this.parent != null) {\n            try {\n                // 认证失败，使其父类型AuthenticationManager进行验证\n                result = parentResult = this.parent.authenticate(authentication);\n            } catch (ProviderNotFoundException var11) {\n            } catch (AuthenticationException var12) {\n                parentException = var12;\n                lastException = var12;\n            }\n        }\n\n        if (result != null) {\n            // 认证成功，去掉result铭感信息\n            if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {\n                // 去除的过程就是调用CredentialsContainer的eraseCredentials方法\n                ((CredentialsContainer)result).eraseCredentials();\n            }\n\t\t\t// 发布成功认证的事件\n            if (parentResult == null) {\n                this.eventPublisher.publishAuthenticationSuccess(result);\n            }\n\n            return result;\n        } else {\n            // 认证失败抛出异常\n            if (lastException == null) {\n                lastException = new ProviderNotFoundException(this.messages.getMessage(\"ProviderManager.providerNotFound\", new Object[]{toTest.getName()}, \"No AuthenticationProvider found for {0}\"));\n            }\n\n            if (parentException == null) {\n                this.prepareException((AuthenticationException)lastException, authentication);\n            }\n\n            throw lastException;\n        }\n    }\n```\n\n上述代码的去掉敏感信息方法\n\n```java\npublic abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer {\n    // 实现CredentialsContainer接口\n    public void eraseCredentials() {\n        // 前端传入的密码设为null\n        this.eraseSecret(this.getCredentials());\n        this.eraseSecret(this.getPrincipal());\n        this.eraseSecret(this.details);\n    }\n}\n```\n\n认证成功`successfulAuthentication`方法\n\n```java\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult);\n        }\n\t\t// 将认证成功的用户信息Authentication封装到SecurtyContext对象，并存入SecurityContextHolader\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n        // 处理RememberMe\n        this.rememberMeServices.loginSuccess(request, response, authResult);\n        if (this.eventPublisher != null) {\n            // 发布认证成功的属性\t\n            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n        }\n\t\t// 调用成功认证处理器\n        this.successHandler.onAuthenticationSuccess(request, response, authResult);\n    }\n```\n\n认证失败`unsuccessfulAuthentication`方法\n\n```java\nprotected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {\n    //清楚线程在SecurityContextHolder中的SecurtyContext对象\n    SecurityContextHolder.clearContext();\n    if (this.logger.isDebugEnabled()) {\n        this.logger.debug(\"Authentication request failed: \" + failed.toString(), failed);\n        this.logger.debug(\"Updated SecurityContextHolder to contain null Authentication\");\n        this.logger.debug(\"Delegating to authentication failure handler \" + this.failureHandler);\n    }\n\t // 处理RememberMe\n    this.rememberMeServices.loginFail(request, response);\n    // 调用认证失败处理器\n    this.failureHandler.onAuthenticationFailure(request, response, failed);\n}\n```\n\n[![pCvJGzd.png](https://s1.ax1x.com/2023/07/27/pCvJGzd.png)](https://imgse.com/i/pCvJGzd)\n","title":" SpringSecurity学习笔记\n","category":[" Java","SpringSecurity\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n两个核心功能：认证和授权\n\n 基本原理\n\n 拦截器链\n\nSpringSecurity本质是一个过滤器链，在 SpringBoot 2.3.4.RELEASE中，共有15种拦截器，如图所示：\n\n../../.vuepress/public/assets/article/springsecurityfilter/dkhd21HR825.png\n\n\norg.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter org.springframework.security.web.context.SecurityContextPersistenceFilter  org.springframework.security.web.header.HeaderWriterFilter org.springframework.security.web.csrf.CsrfFilter org.springframework.security.web.authentication.logout.LogoutFilter  org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter  org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter  org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter org.springframework.security.web.savedrequest.RequestCacheAwareFilter org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter org.springframework.security.web.authentication.AnonymousAuthenticationFilter  org.springframework.security.web.session.SessionManagementFilter  org.springframework.security.web.access.ExceptionTranslationFilter  org.springframework.security.web.access.intercept.FilterSecurityIntercepto\n\n\n重点三个：\n\nFilterSecurityInterceptor：是一个方法级的权限过滤器, 基本位于过滤链的最底部。\n\nExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常\n\nUsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码\n\n 主要拦截器介绍\n\n SecurityContextPersistenceFilter\n\n包路径：org.springframework.security.web.context\n\n负责将安全上下文存储在 HttpSession 中，以便在后续请求中访问\n\njava\npublic void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n    HttpServletRequest request = HttpServletRequestreq;\n    HttpServletResponse response = HttpServletResponseres;\n    // 判断是否是第一次请求\n    if request.getAttribute\"springsecurityscpfapplied\" = null {\n        chain.doFilterrequest, response;\n    } else {\n        boolean debug = this.logger.isDebugEnabled;\n        // 设置值\n        request.setAttribute\"springsecurityscpfapplied\", Boolean.TRUE;\n        if this.forceEagerSessionCreation {\n            HttpSession session = request.getSession;\n            if debug && session.isNew {\n                this.logger.debug\"Eagerly created session: \" + session.getId;\n            }\n        }\n\n        HttpRequestResponseHolder holder = new HttpRequestResponseHolderrequest, response;\n        SecurityContext contextBeforeChainExecution = this.repo.loadContextholder;\n        boolean var13 = false;\n\n        try {\n            var13 = true;\n            // 将SecurityContext安全信息设置到SecurityContextHolder线程上下文中\n            SecurityContextHolder.setContextcontextBSecurityContextHolder中eforeChainExecution;\n            chain.doFilterholder.getR\tequest, holder.getResponse;\n            var13 = false;\n        } finally {\n            if var13 {\n                SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext;\n                SecurityContextHolder.clearContext;\n                // 将上下文信息保存在session中\n                this.repo.saveContextcontextAfterChainExecution, holder.getRequest, holder.getResponse;\n                request.removeAttribute\"springsecurityscpfapplied\";\n                if debug {\n                    this.logger.debug\"SecurityContextHolder now cleared, as request processing completed\";\n                }\n\n            }\n        }\n\n        SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext;\n        SecurityContextHolder.clearContext;\n        this.repo.saveContextcontextAfterChainExecution, holder.getRequest, holder.getResponse;\n            request.removeAttribute\"springsecurityscpfapplied\";\n        if debug {\n            this.logger.debug\"SecurityContextHolder now cleared, as request processing completed\";\n        }\n\n    }\n}\n\n\n LogoutFilter\n\n包路径：org.springframework.security.web.authentication.logout.LogoutFilter\n\n匹配URL为 /logout 的请求，实现用户退出，清除认证信息\n\njava\npublic void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n    HttpServletRequest request = HttpServletRequestreq;\n    HttpServletResponse response = HttpServletResponseres;\n    if this.requiresLogoutrequest, response { // 匹配URL\n        Authentication auth = SecurityContextHolder.getContext.getAuthentication;\n        if this.logger.isDebugEnabled {\n            this.logger.debug\"Logging out user '\" + auth + \"' and transferring to logout destination\";\n        }\n\n        this.handler.logoutrequest, response, auth; // 清除认证信息\n        this.logoutSuccessHandler.onLogoutSuccessrequest, response, auth; // 处理自定义退出成功逻辑\n    } else {\n        chain.doFilterrequest, response;\n    }\n}\n\n\n对于 logoutSuccessHandler.onLogoutSuccess 这个方法，我们可以对他进行重写，实现自己的退出成功逻辑\n\n UsernamePasswordAuthenticationFilter\n\n包路径：org.springframework.security.web.authentication\n\n匹配请求为 POST，且路径为 /login 的请求，通过表单的用户名和密码进行认证，认证成功会将用户信息放到上下文中\n\njava\npublic void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n    HttpServletRequest request = HttpServletRequestreq;\n    HttpServletResponse response = HttpServletResponseres;\n    if this.requiresAuthenticationrequest, response {\n        chain.doFilterrequest, response;\n    } else {\n        if this.logger.isDebugEnabled {\n            this.logger.debug\"Request is to process authentication\";\n        }\n\n        Authentication authResult;\n        try {\n            // 调用子类的attemptAuthentication方法\n            authResult = this.attemptAuthenticationrequest, response;\n            // 子类未完成认证\n            if authResult == null {\n                return;\n            }\n\n            this.sessionStrategy.onAuthenticationauthResult, request, response;\n        } catch InternalAuthenticationServiceException var8 {\n            this.logger.error\"An internal error occurred while trying to authenticate the user.\", var8;\n            // 认证失败\n            this.unsuccessfulAuthenticationrequest, response, var8;\n            return;\n        } catch AuthenticationException var9 {\n            // 认证失败\n            this.unsuccessfulAuthenticationrequest, response, var9;\n            return;\n        }\n\n        if this.continueChainBeforeSuccessfulAuthentication {\n            chain.doFilterrequest, response;\n        }\n\t\t// 认证成功\n        this.successfulAuthenticationrequest, response, chain, authResult;\n    }\n}\n\npublic Authentication attemptAuthenticationHttpServletRequest request, HttpServletResponse response throws AuthenticationException {\n    if this.postOnly && request.getMethod.equals\"POST\" {\n        throw new AuthenticationServiceException\"Authentication method not supported: \" + request.getMethod;\n    } else {\n        String username = this.obtainUsernamerequest;\n        String password = this.obtainPasswordrequest;\n        if username == null {\n            username = \"\";\n        }\n\n        if password == null {\n            password = \"\";\n        }\n\n        username = username.trim;\n        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationTokenusername, password;\n        this.setDetailsrequest, authRequest;\n        // 核心部分，交给内部的AuthenticationManager去认证，并返回认证后的 Authentication\n        return this.getAuthenticationManager.authenticateauthRequest;\n    }\n}\n\n\n DefaultLoginPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n若未自定义认证界面，过滤器会生成一个默认的认证界面\n\njava\nprivate void initUsernamePasswordAuthenticationFilter authFilter, AbstractAuthenticationProcessingFilter openIDFilter {\n    this.loginPageUrl = \"/login\";\n    this.logoutSuccessUrl = \"/login?logout\";\n    this.failureUrl = \"/login?error\";\n    if authFilter = null { // 若自定义了，authFilter就为null\n        this.formLoginEnabled = true;\n        this.usernameParameter = authFilter.getUsernameParameter;\n        this.passwordParameter = authFilter.getPasswordParameter;\n        if authFilter.getRememberMeServices instanceof AbstractRememberMeServices {\n            this.rememberMeParameter = AbstractRememberMeServicesauthFilter.getRememberMeServices.getParameter;\n        }\n    }\n\n    if openIDFilter = null {\n        this.openIdEnabled = true;\n        this.openIDusernameParameter = \"openididentifier\";\n        if openIDFilter.getRememberMeServices instanceof AbstractRememberMeServices {\n            this.openIDrememberMeParameter = AbstractRememberMeServicesopenIDFilter.getRememberMeServices.getParameter;\n        }\n    }\n\n}\n\n\n DefaultLogoutPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n和 DefaultLogoutPageGeneratingFilter 类似，此过滤器可以生产一个默认的退出登录页面\n\njava\nprivate void renderLogoutHttpServletRequest request, HttpServletResponse response throws IOException {\n    String page = \"<DOCTYPE html\\n<html lang=\\\"en\\\"\\n  <head\\n    <meta charset=\\\"utf8\\\"\\n    <meta name=\\\"viewport\\\" content=\\\"width=devicewidth, initialscale=1, shrinktofit=no\\\"\\n    <meta name=\\\"description\\\" content=\\\"\\\"\\n    <meta name=\\\"author\\\" content=\\\"\\\"\\n    <titleConfirm Log Out?</title\\n    <link href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0beta/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\" integrity=\\\"sha384/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\\\" crossorigin=\\\"anonymous\\\"\\n    <link href=\\\"https://getbootstrap.com/docs/4.0/examples/signin/signin.css\\\" rel=\\\"stylesheet\\\" crossorigin=\\\"anonymous\\\"/\\n  </head\\n  <body\\n     <div class=\\\"container\\\"\\n      <form class=\\\"formsignin\\\" method=\\\"post\\\" action=\\\"\" + request.getContextPath + \"/logout\\\"\\n        <h2 class=\\\"formsigninheading\\\"Are you sure you want to log out?</h2\\n\" + this.renderHiddenInputsrequest + \"        <button class=\\\"btn btnlg btnprimary btnblock\\\" type=\\\"submit\\\"Log Out</button\\n      </form\\n    </div\\n  </body\\n</html\";\n    response.setContentType\"text/html;charset=UTF8\";\n    response.getWriter.writepage;\n}\n\n\n AnonymousAuthenticationFilter\n\n当用户没有授权认证，那么就会给他一个匿名身份\n\n\n\n ExceptionTranslationFilter\n\n包路径：org.springframework.security.web.access\n\n捕获并处理认证和授权过程中发生的异常\n\n\n\n FilterSecurityInterceptor\n\n包路径：org.springframework.security.web.access.intercept\n\n获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来决定其是否有权限\n\n\n\n 过滤器加载流程\n\n DelegatingFilterProxy类\n\n首先执行doFilter方法\n\njava\npublic void doFilterServletRequest request, ServletResponse response, FilterChain filterChain throws ServletException, IOException {\n        Filter delegateToUse = this.delegate;\n        if delegateToUse == null {\n            synchronizedthis.delegateMonitor {\n                delegateToUse = this.delegate;\n                if delegateToUse == null {\n                    WebApplicationContext wac = this.findWebApplicationContext;\n                    if wac == null {\n                        throw new IllegalStateException\"No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?\";\n                    }\n\n                    delegateToUse = this.initDelegatewac;\n                }\n\n                this.delegate = delegateToUse;\n            }\n        }\n\n\n接着执行initDelegate\n\njava\n protected Filter initDelegateWebApplicationContext wac throws ServletException {\n        String targetBeanName = this.getTargetBeanName;\n        Assert.statetargetBeanName = null, \"No target bean name set\";\n        Filter delegate = Filterwac.getBeantargetBeanName, Filter.class;\n        if this.isTargetFilterLifecycle {\n            delegate.initthis.getFilterConfig;\n        }\n\n        return delegate;\n    }\n\n\ntargetBeanName在SpringSecurity中有一个固定的名字：FilterChainProxy\n\n FilterChainProxy类\n\n首先执行doFilter方法\n\njava\n    public void doFilterServletRequest request, ServletResponse response, FilterChain chain throws IOException, ServletException {\n        boolean clearContext = request.getAttributeFILTERAPPLIED == null;\n        if clearContext {\n            try {\n                request.setAttributeFILTERAPPLIED, Boolean.TRUE;\n                this.doFilterInternalrequest, response, chain;\n            } finally {\n                SecurityContextHolder.clearContext;\n                request.removeAttributeFILTERAPPLIED;\n            }\n        } else {\n            this.doFilterInternalrequest, response, chain;\n        }\n\n    }\n\n\n执行doFilterInternal方法\n\njava\nprivate void doFilterInternalServletRequest request, ServletResponse response, FilterChain chain throws IOException, ServletException {\n        FirewalledRequest fwRequest = this.firewall.getFirewalledRequestHttpServletRequestrequest;\n        HttpServletResponse fwResponse = this.firewall.getFirewalledResponseHttpServletResponseresponse;\n        List<Filter filters = this.getFiltersHttpServletRequestfwRequest;\n        if filters = null && filters.size = 0 {\n            FilterChainProxy.VirtualFilterChain vfc = new FilterChainProxy.VirtualFilterChainfwRequest, chain, filters;\n            vfc.doFilterfwRequest, fwResponse;\n        } else {\n            if logger.isDebugEnabled {\n                logger.debugUrlUtils.buildRequestUrlfwRequest + filters == null ? \" has no matching filters\" : \" has an empty filter list\";\n            }\n\n            fwRequest.reset;\n            chain.doFilterfwRequest, fwResponse;\n        }\n    }\n\n\n  List<Filter filters = this.getFiltersHttpServletRequestfwRequest;会执行getFilters方法，它会把过滤器一个一个加载到过滤链中\n\njava\nprivate List<Filter getFiltersHttpServletRequest request {\n      Iterator var2 = this.filterChains.iterator;\n\n      SecurityFilterChain chain;\n      do {\n          if var2.hasNext {\n              return null;\n          }\n\n          chain = SecurityFilterChainvar2.next;\n      } whilechain.matchesrequest;\n\n      return chain.getFilters;\n}\n\n\n 重要接口\n\n UserDetailsService\n\njava\npublic interface UserDetailsService {\n    UserDetails loadUserByUsernameString var1 throws UsernameNotFoundException;\n}\n\n\n 当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。\n\n作用：查询数据库用户名和密码过程\n\n 创建类继承UsernamePasswordAuthenticationFilter，重写三个方法\n 创建类实现UserDetailService，返回UserDetails对象（框架提供的对象）\n\nUserDetails类\n\njava\npublic interface UserDetails extends Serializable {\n  \t// 表示获取登录用户所有权限\n    Collection<? extends GrantedAuthority getAuthorities;\n    // 表示获取密码\n    String getPassword;\n    // 表示获取用户名\n    String getUsername;\n    // 表示判断账户是否过期\n    boolean isAccountNonExpired;\n    // 表示判断账户是否被锁定\n    boolean isAccountNonLocked;\n    // 表示凭证{密码}是否过期\n    boolean isCredentialsNonExpired;\n    // 表示当前用户是否可用\n    boolean isEnabled;\n}\n\n\n PasswordEncoder\n\njava\npublic interface PasswordEncoder {\n    // 表示把参数按照特定的解析规则进行解析\n    String encodeCharSequence var1;\n\t// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。\n    boolean matchesCharSequence var1, String var2;\n\t// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncodingString encodedPassword {\n        return false;\n    }\n}\n\n\n接口实现\n\nBCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，是对PasswordEncoder类的实现\n\n加密\n\njava\npublic String encodeCharSequence rawPassword {\n        if rawPassword == null {\n            throw new IllegalArgumentException\"rawPassword cannot be null\";\n        } else {\n            String salt;\n            if this.random = null {\n                salt = BCrypt.gensaltthis.version.getVersion, this.strength, this.random;\n            } else {\n                salt = BCrypt.gensaltthis.version.getVersion, this.strength;\n            }\n\n            return BCrypt.hashpwrawPassword.toString, salt;\n        }\n    }\n\n\n匹配\n\njava\npublic boolean matchesCharSequence rawPassword, String encodedPassword {\n        if rawPassword == null {\n            throw new IllegalArgumentException\"rawPassword cannot be null\";\n        } else if encodedPassword = null && encodedPassword.length = 0 {\n            if this.BCRYPTPATTERN.matcherencodedPassword.matches {\n                this.logger.warn\"Encoded password does not look like BCrypt\";\n                return false;\n            } else {\n                return BCrypt.checkpwrawPassword.toString, encodedPassword;\n            }\n        } else {\n            this.logger.warn\"Empty encoded password\";\n            return false;\n        }\n    }\n\n\n SpringSecurity Web 权限方案\n\n授权和认证两种\n\n 设置用户名和密码\n\n方式一：配置文件实现\n\nproperties\nspring.security.user.name=ljx\nspring.security.user.password=ljx\n\n\n方式二：配置类实现\n\njava\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configureAuthenticationManagerBuilder auth throws Exception {\n        BCryptPasswordEncoder cryptPasswordEncoder = new BCryptPasswordEncoder;\n        auth.inMemoryAuthentication.withUser\"ljx\".passwordcryptPasswordEncoder.encode\"ljx\".roles\"user\";\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder{\n        return new BCryptPasswordEncoder;\n    }\n\n}\n\n\n方式三：自定义实现类\n\n创建配置类\n\njava\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    /\n      自定义类实现登录\n      @param auth\n      @throws Exception\n     /\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configureAuthenticationManagerBuilder auth throws Exception {\n        auth.userDetailsServiceuserDetailsService.passwordEncoderpasswordEncoder;\n\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder{\n        return new BCryptPasswordEncoder;\n    }\n}\n\n\n编写userDetailService实现类，返回User对象\n\njava\n@Service\"userDetailsService\"\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsernameString s throws UsernameNotFoundException {\n        List<GrantedAuthority list = AuthorityUtils.commaSeparatedStringToAuthorityList\"role\";\n        return new User\"ljx\", new BCryptPasswordEncoder.encode\"ljx\", list;\n    }\n}\n\n\n 整合数据库实现登录\n\njava\n@Service\"userDetailsService\"\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsernameString s throws UsernameNotFoundException {\n        User user = userMapper.queryUserByUsernames;\n        ifs == null{\n            throw new UsernameNotFoundException\"用户不存在\";\n        }\n        List<GrantedAuthority list = AuthorityUtils.commaSeparatedStringToAuthorityList\"role\";\n        return new Useruser.getUsername, new BCryptPasswordEncoder.encodeuser.getPassword, list;\n    }\n}\n\n\n 路径拦截路径拦截\n\n实现configure的另一个方法（与上面的不一样）\n\njava\n@Override\nprotected void configureHttpSecurity http throws Exception {\n           http.and\n                .authorizeRequests\n                .antMatchers\"/api/main/t\".permitAll // 不需要认证\n                .anyRequest.authenticated\n                .and.csrf.disable;  // 关闭csrf\n    }\n\n\n 角色权限访问控制\n\n hasAuthority\n\n如果当前的主体具有指定的权限，则返回 true,否则返回 false\n\njava\n.antMatchers\"/test1\".hasAuthority\"admin\"\n\n\n hasAnyAuthority\n\n如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串表）的话，返回 true\n\njava\n.antMatchers\"/test2\".hasAnyAuthority\"admin, role\"\n\n\n hasRole\n\n如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。\n\njava\n.antMatchers\"/test3\".hasRole\"sale\"\n\n\n这个方法于之前两个不同的是底层原码是默认加了ROLE前缀，所以在添加用户权限的时候需注意在角色前面加ROLE\n\njava\nprivate static String hasRoleString role {\n        Assert.notNullrole, \"role cannot be null\";\n        if role.startsWith\"ROLE\" {\n            throw new IllegalArgumentException\"role should not start with 'ROLE' since it is automatically inserted. Got '\" + role + \"'\";\n        } else {\n            return \"hasRole'ROLE\" + role + \"'\";\n        }\n    }\n\n\n hasAnyRole\n\n表示用户具备任何一个条件都可以访问\n\njava\n.antMatchers\"/test3\".hasAnyRole\"sale\"\n\n\n要求于hasRole一样\n\n 自定义403页面\n\njava\nhttp.exceptionHandling.accessDeniedPage\"/unauth\";\n\n\njava\n@GetMapping\"/unauth\"\n@ResponseBody\npublic String t4{\n    return \"unauth\";\n}\n\n\n 注解使用\n\n @Secured\n\n使用注解先要开启注解功能\n\njava\n@EnableGlobalMethodSecuritysecuredEnabled = true\n\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE“\n\n在方法上加上这个注解\n\njava\n@Secured{\"ROLEsole\", \"ROLEaaa\"}\n\n\n @PreAuthorize\n\n使用注解先要开启注解功能\n\njava\n@EnableGlobalMethodSecurityprePostEnabled = true\n\n\n注解适合进入方法前的权限验证\n\njava\n@PreAuthorize\"hasAnyAuthority'menu:system'\"\n// 此处hasAnyAuthority可以换成hasAnyRole，hasRole，hasAnyAuthority其中一个\n\n\n @PostAuthorize\n\n使用注解先要开启注解功能\n\njava\n@EnableGlobalMethodSecurityprePostEnabled = true\n\n\n在方法执行后再进行权限验证（接口里面方法任会被执行，只是最后会权限验证），适合验证带有返回值的权限\n\njava\n@PostAuthorize\"hasAnyAuthority'menu:system'\"\n\n\n @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是 admin1的数据，表达式中的 filterObject引用的是方法返回值 List 中的某一个元素\n\njava\n@RequestMapping\"getAll\"\n@PreAuthorize\"hasRole'ROLErole'\"\n@PostFilter\"filterObject.username == 'admin1'\"\n@ResponseBody\npublic List<UserInfo getAllUser{\n ArrayList<UserInfo list = new ArrayList<;\n list.addnew UserInfo1l,\"admin1\",\"6666\";\n list.addnew UserInfo2l,\"admin2\",\"888\";\nreturn list;\n}\n\n\n最终返回页面的数据\n\njson\n\n    {\n        \"id\": 1,\n        \"username\": \"admin1\",\n        \"num\": \"6666\"\n    }\n\n\n\n @PreFilter\n\n进入控制器之前对数据进行过滤\n\njava\n@RequestMapping\"getTestPreFilter\"\n@PreAuthorize\"hasRole'ROLErole'\"\n@PreFiltervalue = \"filterObject.id % 2 == 0\"\n@ResponseBody\npublic List<UserInfo getTestPreFilter@RequestBody List<UserInfo \nlist{\n list.forEacht {\n System.out.printlnt.getId+\"\\t\"+t.getUsername;\n };\nreturn list;\n}\n\n\n最终接收到的参数只有id为偶数才能被接收\n\n 退出登录\n\njava\nhttp.logout.logoutUrl\"/logout\".logoutSuccessUrl\"/index\".permitAll\n\n\n CSRF\n\n跨站请求伪造（英语：Crosssite request forgery），也被称为 oneclick  attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任\n\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。\n\n关闭csrf\n\njava\nhttp.csrf.disable\n\n\n 微服务\n\n 数据库\n\nimage20230726154749582https://s1.ax1x.com/2023/07/26/pCjwOSS.png\n\n 搭建项目\n\nimage20230726154749582https://s1.ax1x.com/2023/07/26/pCjax1g.png\n\n 前置知识\n\n Nacos\n\n阿里巴巴的注册中心，网关服务（9001端口）通过注册中心转发到权限管理服务（8081端口）\n\n启动：Windows点击startup.cmd，Linux运行startup.sh\n\n访问地址：http://localhost:8848/nacos，默认用户名和密码都是nacos\n\n 认证流程\n\npCvJddf.pnghttps://s1.ax1x.com/2023/07/27/pCvJddf.pnghttps://imgse.com/i/pCvJddf\n\nUsernamePasswordAuthenticationFilter\n\n继承AbstractAuthenticationProcessingFilter父类\n\n查看父类的doFilter方法\n\njava\n    public void doFilterServletRequest req, ServletResponse res, FilterChain chain throws IOException, ServletException {\n        HttpServletRequest request = HttpServletRequestreq;\n        HttpServletResponse response = HttpServletResponseres;\n        // 判断是否是post提交\n        if this.requiresAuthenticationrequest, response {\n            chain.doFilterrequest, response;\n        } else {\n            if this.logger.isDebugEnabled {\n                this.logger.debug\"Request is to process authentication\";\n            }\n\t\t\t// 进行身份认证，认证成功将信息封装到Authentication中\n            Authentication authResult;\n            try {\n                authResult = this.attemptAuthenticationrequest, response;\n                if authResult == null {\n                    return;\n                }\t\n\t\t\t\t// session策略处理\n                this.sessionStrategy.onAuthenticationauthResult, request, response;\n            } catch InternalAuthenticationServiceException var8 {\n                // 认证失败\n                this.logger.error\"An internal error occurred while trying to authenticate the user.\", var8;\n                this.unsuccessfulAuthenticationrequest, response, var8;\n                return;\n            } catch AuthenticationException var9 {\n                this.unsuccessfulAuthenticationrequest, response, var9;\n                return;\n            }\n\t\t\t// 认证成功\n            // continueChainBeforeSuccessfulAuthentication默认为false\n            if this.continueChainBeforeSuccessfulAuthentication {\n                chain.doFilterrequest, response;\n            }\n\n            this.successfulAuthenticationrequest, response, chain, authResult;\n        }\n    }\n\n\n查看UsernamePasswordAuthenticationFilter子类中的attemptAuthentication方法（上述代码中的attemptAuthentication方法）\n\njava\n    public Authentication attemptAuthenticationHttpServletRequest request, HttpServletResponse response throws AuthenticationException {\n        // 判断是否是post请求\n        if this.postOnly && request.getMethod.equals\"POST\" {\n            throw new AuthenticationServiceException\"Authentication method not supported: \" + request.getMethod;\n        } else {\n            // 检查参数书否为空\n            String username = this.obtainUsernamerequest;\n            String password = this.obtainPasswordrequest;\n            if username == null {\n                username = \"\";\n            }\n\n            if password == null {\n                password = \"\";\n            }\n\t\t\t// 去掉空格\n            username = username.trim;\n            // 使用获取数据构造对象，标记未认证\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationTokenusername, password;\n            // 将请求的信息设置到Authentication对象中\n            this.setDetailsrequest, authRequest;\n            // 进行身份验证（调用userDetailsService）\n            return this.getAuthenticationManager.authenticateauthRequest;\n        }\n    }\n\n\n查看ProviderManager实现AuthenticationManager接口（该接口包含上述代码最后一行的的authenticate方法）\n\njava\n    public Authentication authenticateAuthentication authentication throws AuthenticationException {\n        // 获取Authentication的类型，即UsernamePasswordAuthenticationToken.class\n        Class<? extends Authentication toTest = authentication.getClass;\n        AuthenticationException lastException = null;\n        AuthenticationException parentException = null;\n        Authentication result = null;\n        Authentication parentResult = null;\n        boolean debug = logger.isDebugEnabled;\n        // 获取认证方式列表List<AuthenticationProvider迭代器\n        Iterator var8 = this.getProviders.iterator;\n\n        whilevar8.hasNext {\n            AuthenticationProvider provider = AuthenticationProvidervar8.next;\n            // 判断当前AuthenticationProvider是否适用UsernamePasswordAuthenticationToken.class类型的Authentication\n            if provider.supportstoTest {\n                if debug {\n                    logger.debug\"Authentication attempt using \" + provider.getClass.getName;\n                }\n\n                try {\n                    // 认证成功会返回标记已认证的Authentication对象\n                    result = provider.authenticateauthentication;\n                    if result = null {\n                        // 信息拷贝到result中\n                        this.copyDetailsauthentication, result;\n                        break;\n                    }\n                } catch InternalAuthenticationServiceException  AccountStatusException var13 {\n                    this.prepareExceptionvar13, authentication;\n                    throw var13;\n                } catch AuthenticationException var14 {\n                    lastException = var14;\n                }\n            }\n        }\n\n        if result == null && this.parent = null {\n            try {\n                // 认证失败，使其父类型AuthenticationManager进行验证\n                result = parentResult = this.parent.authenticateauthentication;\n            } catch ProviderNotFoundException var11 {\n            } catch AuthenticationException var12 {\n                parentException = var12;\n                lastException = var12;\n            }\n        }\n\n        if result = null {\n            // 认证成功，去掉result铭感信息\n            if this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer {\n                // 去除的过程就是调用CredentialsContainer的eraseCredentials方法\n                CredentialsContainerresult.eraseCredentials;\n            }\n\t\t\t// 发布成功认证的事件\n            if parentResult == null {\n                this.eventPublisher.publishAuthenticationSuccessresult;\n            }\n\n            return result;\n        } else {\n            // 认证失败抛出异常\n            if lastException == null {\n                lastException = new ProviderNotFoundExceptionthis.messages.getMessage\"ProviderManager.providerNotFound\", new Object{toTest.getName}, \"No AuthenticationProvider found for {0}\";\n            }\n\n            if parentException == null {\n                this.prepareExceptionAuthenticationExceptionlastException, authentication;\n            }\n\n            throw lastException;\n        }\n    }\n\n\n上述代码的去掉敏感信息方法\n\njava\npublic abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer {\n    // 实现CredentialsContainer接口\n    public void eraseCredentials {\n        // 前端传入的密码设为null\n        this.eraseSecretthis.getCredentials;\n        this.eraseSecretthis.getPrincipal;\n        this.eraseSecretthis.details;\n    }\n}\n\n\n认证成功successfulAuthentication方法\n\njava\n    protected void successfulAuthenticationHttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult throws IOException, ServletException {\n        if this.logger.isDebugEnabled {\n            this.logger.debug\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult;\n        }\n\t\t// 将认证成功的用户信息Authentication封装到SecurtyContext对象，并存入SecurityContextHolader\n        SecurityContextHolder.getContext.setAuthenticationauthResult;\n        // 处理RememberMe\n        this.rememberMeServices.loginSuccessrequest, response, authResult;\n        if this.eventPublisher = null {\n            // 发布认证成功的属性\t\n            this.eventPublisher.publishEventnew InteractiveAuthenticationSuccessEventauthResult, this.getClass;\n        }\n\t\t// 调用成功认证处理器\n        this.successHandler.onAuthenticationSuccessrequest, response, authResult;\n    }\n\n\n认证失败unsuccessfulAuthentication方法\n\njava\nprotected void unsuccessfulAuthenticationHttpServletRequest request, HttpServletResponse response, AuthenticationException failed throws IOException, ServletException {\n    //清楚线程在SecurityContextHolder中的SecurtyContext对象\n    SecurityContextHolder.clearContext;\n    if this.logger.isDebugEnabled {\n        this.logger.debug\"Authentication request failed: \" + failed.toString, failed;\n        this.logger.debug\"Updated SecurityContextHolder to contain null Authentication\";\n        this.logger.debug\"Delegating to authentication failure handler \" + this.failureHandler;\n    }\n\t // 处理RememberMe\n    this.rememberMeServices.loginFailrequest, response;\n    // 调用认证失败处理器\n    this.failureHandler.onAuthenticationFailurerequest, response, failed;\n}\n\n\npCvJGzd.pnghttps://s1.ax1x.com/2023/07/27/pCvJGzd.pnghttps://imgse.com/i/pCvJGzd\n"}]