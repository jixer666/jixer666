[{"filename":"leetcode-week-398","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第398场周赛\ncategory: 算法\ndate: 2024-05-20\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 3151. 特殊数组 I\n\n简单模拟\n\n```c++\nclass Solution {\npublic:\n    bool isArraySpecial(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1){\n            return true;\n        }\n        for(int i = 1; i < len; i++){\n            if(nums[i] % 2 == nums[i - 1] % 2){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n## 特殊数组 II\n\n前缀和处理相邻特殊元素总数\n\n```c++\nclass Solution {\npublic:\n    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int len = nums.size();\n        vector<bool> res;\n        if(len == 1){\n            for(int i = 0; i < queries.size(); i++){\n                res.push_back(true);\n            }\n            return res;\n        }\n        vector<int> v(len + 1);\n        v[0] = 0;\n        for(int i = 1; i < len; i++){\n            if(nums[i] % 2 == nums[i - 1] % 2){\n                v[i] = v[i - 1] + 1;\n            } else {\n                v[i] = v[i - 1];\n            }\n        }\n        for(int i = 0; i < queries.size(); i++){\n            if(v[queries[i][1]] - v[queries[i][0]] == 0){\n                res.push_back(true);\n            } else {\n                res.push_back(false);\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 所有数对中数位不同之和\n\n拆分位运算贡献\n\n```c++\nclass Solution {\npublic:\n    long long n[100010][20];\n    long long sumDigitDifferences(vector<int>& nums) {\n        int len = nums.size();\n        long long res = 0;\n        for(int i = 0; i < len; i++){\n            int cc = nums[i], idx = 0;\n            while(cc){\n                int j = cc % 10;\n                res += i * 1ll - n[idx][j];\n                cc /= 10;   \n                n[idx][j] ++;\n                idx ++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 到达第 K 级台阶的方案数\n\n记忆化搜索\n\n灵神这题做法是用记忆存储的元素与以往题目不一样，使用 `long long p = (long long) x << 10 | num << 1 | f; `来确定元素的唯一性，这个做法tql，换我来做就需要用个二维数组来标志\n\n```c++\nclass Solution {\npublic:\n    unordered_map<long long, int> ump;\n    int dfs(int x, int num, bool f, int k){\n        if(x > k + 1 || x < 0){\n            return 0;\n        }\n        long long p = (long long) x << 10 | num << 1 | f;\n        if(ump.find(p) != ump.end()){\n            return ump[p];\n        }\n        int ss = (x == k);\n        ss += dfs(x + (1 << num), num + 1, false, k);\n        if(!f){\n            ss += dfs(x - 1, num, true, k);\n        }\n        ump[p] = ss;\n        return ss;\n    }\n    int waysToReachStair(int k) {\n        return dfs(1, 0, false, k);\n    }\n};\n```\n\n","title":" Leetcode第398场周赛\n","category":[" 算法\n"],"date":" 2024-05-20\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 3151. 特殊数组 I\n\n简单模拟\n\nc++\nclass Solution {\npublic:\n    bool isArraySpecialvector<int& nums {\n        int len = nums.size;\n        iflen == 1{\n            return true;\n        }\n        forint i = 1; i < len; i++{\n            ifnumsi % 2 == numsi  1 % 2{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n 特殊数组 II\n\n前缀和处理相邻特殊元素总数\n\nc++\nclass Solution {\npublic:\n    vector<bool isArraySpecialvector<int& nums, vector<vector<int& queries {\n        int len = nums.size;\n        vector<bool res;\n        iflen == 1{\n            forint i = 0; i < queries.size; i++{\n                res.pushbacktrue;\n            }\n            return res;\n        }\n        vector<int vlen + 1;\n        v0 = 0;\n        forint i = 1; i < len; i++{\n            ifnumsi % 2 == numsi  1 % 2{\n                vi = vi  1 + 1;\n            } else {\n                vi = vi  1;\n            }\n        }\n        forint i = 0; i < queries.size; i++{\n            ifvqueriesi1  vqueriesi0 == 0{\n                res.pushbacktrue;\n            } else {\n                res.pushbackfalse;\n            }\n        }\n        return res;\n    }\n};\n\n\n 所有数对中数位不同之和\n\n拆分位运算贡献\n\nc++\nclass Solution {\npublic:\n    long long n10001020;\n    long long sumDigitDifferencesvector<int& nums {\n        int len = nums.size;\n        long long res = 0;\n        forint i = 0; i < len; i++{\n            int cc = numsi, idx = 0;\n            whilecc{\n                int j = cc % 10;\n                res += i  1ll  nidxj;\n                cc /= 10;   \n                nidxj ++;\n                idx ++;\n            }\n        }\n        return res;\n    }\n};\n\n\n 到达第 K 级台阶的方案数\n\n记忆化搜索\n\n灵神这题做法是用记忆存储的元素与以往题目不一样，使用 long long p = long long x << 10  num << 1  f; 来确定元素的唯一性，这个做法tql，换我来做就需要用个二维数组来标志\n\nc++\nclass Solution {\npublic:\n    unorderedmap<long long, int ump;\n    int dfsint x, int num, bool f, int k{\n        ifx  k + 1  x < 0{\n            return 0;\n        }\n        long long p = long long x << 10  num << 1  f;\n        ifump.findp = ump.end{\n            return umpp;\n        }\n        int ss = x == k;\n        ss += dfsx + 1 << num, num + 1, false, k;\n        iff{\n            ss += dfsx  1, num, true, k;\n        }\n        umpp = ss;\n        return ss;\n    }\n    int waysToReachStairint k {\n        return dfs1, 0, false, k;\n    }\n};\n\n\n"},{"filename":"2022-team-select-race","category":"aigorithm","md":{"topSummary":"\ntitle: 2022年算法队选拔赛\ncategory: 算法\ndate: 2024-05-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n回顾大二打的算法队选拔的算法赛\n\n感觉现在做起来很轻松，练题还是有效果的\n\n题目地址：https://vjudge.net/contest/513277\n\n## A - Numbers\n\n签到题，很清除的记得当时没看清楚题要求，输出化简后的格式，一直没化简....\n\n ```c++\n #include<bits/stdc++.h>\n #define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int> PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n int a, b, x, y, z, res;\n \n int fun(int x, int y){\n \treturn y ? fun(y, x % y) : x;\n }\n \n int main(){\n \tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n \tcin >> a;\n \tfor(int i = 2; i <= a - 1; i ++){\n \t\tint num = a;\n \t\twhile(num){\n \t\t\tres += num % i;\n \t\t\tnum /= i;\n \t\t} \n \t}\n \tint cc = fun(res, a - 2);\n \tcout << res / cc << \"/\" << (a - 2) / cc << endl; \n \t\n \treturn 0;\n }\n ```\n\n## B - 表达式求值\n\n不用考虑括号写起来就很nice\n\n ```c++\n #include<bits/stdc++.h>\n #define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int> PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n int a, b, x, y, z;\n ll res;\n stack<ll> s1;\n stack<char> s2;\n unordered_map<char, int> ump;\n \n void init(){\n \tump['+'] = 1;\n \tump['*'] = 2;\n }\n \n void fun(char c){\n \twhile(s2.size() && s1.size() >= 2 && ump[s2.top()] >= ump[c]){\n \t\tll num1 = s1.top(), cot = 0;\n \t\ts1.pop();\n \t\tll num2 = s1.top();\n \t\ts1.pop();\n \t\tchar c = s2.top();\n \t\ts2.pop();\n \t\tif(c == '+') cot = num1 + num2;\n \t\telse cot = num1 * num2;\n \t\ts1.push(cot);\n \t}\t\n \ts2.push(c);\t\n }\n \n void end(){\n \twhile(s2.size() && s1.size() >= 2){\n \t\tll num1 = s1.top(), cot = 0;\n \t\ts1.pop();\n \t\tll num2 = s1.top();\n \t\ts1.pop();\n \t\tchar c = s2.top();\n \t\ts2.pop();\n \t\tif(c == '+') cot = num1 + num2;\n \t\telse cot = num1 * num2;\n \t\ts1.push(cot);\n \t}\t\n }\n \n int main(){\n \tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n \tinit();\n \tstring str;\n \tcin >> str;\n \tfor(int i = 0; i < str.size(); i++){\n \t\tint idx = i;\n \t\tll num = 0;\n \t\twhile(str[idx] >= '0' && str[idx] <= '9'){\n \t\t\tnum = num * 10 + str[idx] - '0';\n \t\t\tidx ++;\n \t\t}\n \t\tif(num != 0){\n \t\t\ts1.push(num);\n \t\t\ti = idx - 1;\n \t\t\tcontinue;\n \t\t}\n \t\tif(str[i] == '+' || str[i] == '*'){\n \t\t\tfun(str[i]);\n \t\t}\n \t}\n \tend();\n \tcout << s1.top() % 10000 << endl;\n \t\n \treturn 0;\n }\n ```\n\n## C - T-primes\n\n数据量很大，需要用到质数筛\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\nint n[N], st[N], idx;\n\nvoid init(){\n\tst[1] = 1;\n\tfor(int i = 2; i <= N; i ++){\n\t\tif(!st[i]) n[idx ++] = i; \n\t\tfor(int j = 0; n[j] <= N / i; j ++){\n\t\t\tst[n[j] * i] = 1;\n\t\t\tif(i % n[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tinit();\n\tcin >> a;\n\tfor(int i = 0; i < a; i++){\n\t\tll num;\n\t\tcin >> num;\n\t\tll cc = sqrt(num);\n\t\tif(cc * cc == num && !st[cc]){\n\t\t\tcout << \"YES\" << endl; \n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n```\n\n## D - New Year's Number\n\n签到题\n\n ```c++\n #include<bits/stdc++.h>\n #define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int> PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n int a, b, x, y, z;\n \n int main(){\n \tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n \tcin >> a;\n \twhile(a --){\n \t\tcin >> b;\n \t\tint flag = 0;\n \t\tfor(int i = 0; i <= b / 2020; i ++){\n \t\t\tint f = 0;\n \t\t\tfor(int j = 0; j <= b / 2021; j ++){\n \t\t\t\tint cc = i * 2020 + j * 2021;\n \t\t\t\tif(cc > b){\n \t\t\t\t\tbreak;\n \t\t\t\t} else if(cc == b){\n \t\t\t\t\tf = 1;\n \t\t\t\t\tflag = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t} \n \t\t\t}\n \t\t\tif(f){\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(flag) cout << \"YES\" << endl;\n \t\telse cout << \"NO\" << endl;\n \t} \n \t\n \treturn 0;\n }\n ```\n\n## E - 最小新整数\n\n 单调栈\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n\nstring get(stack<char> s){\n\tstring res = \"\";\n\twhile(s.size()){\n\t\tres = s.top() + res;\n\t\ts.pop();\n\t} \n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str;\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> str >> x;\n\t\tstack<char> s;\n\t\tint len = str.size(), cot = 0;\n\t\tfor(int i = 0; i < len; i++){\n\t\t\twhile(!s.empty() && s.top() > str[i] && cot < x){\n\t\t\t\tcot ++;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(str[i]);\n\t\t}\n\t\tif(cot == x){\n\t\t\tcout << get(s) << endl;\n\t\t} else {\n\t\t\tint num = x - cot;\n\t\t\tstring str = get(s);\n\t\t\tfor(int i = 0; i < str.size() - num; i++){\n\t\t\t\tcout << str[i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n```\n\n## F - Count\n\n 矩阵快速幂\n\n\n\n\n\n","title":" 2022年算法队选拔赛\n","category":[" 算法\n"],"date":" 2024-05-09\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n回顾大二打的算法队选拔的算法赛\n\n感觉现在做起来很轻松，练题还是有效果的\n\n题目地址：https://vjudge.net/contest/513277\n\n A  Numbers\n\n签到题，很清除的记得当时没看清楚题要求，输出化简后的格式，一直没化简....\n\n c++\n include<bits/stdc++.h\n define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n int a, b, x, y, z, res;\n \n int funint x, int y{\n \treturn y ? funy, x % y : x;\n }\n \n int main{\n \tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n \tcin  a;\n \tforint i = 2; i <= a  1; i ++{\n \t\tint num = a;\n \t\twhilenum{\n \t\t\tres += num % i;\n \t\t\tnum /= i;\n \t\t} \n \t}\n \tint cc = funres, a  2;\n \tcout << res / cc << \"/\" << a  2 / cc << endl; \n \t\n \treturn 0;\n }\n \n\n B  表达式求值\n\n不用考虑括号写起来就很nice\n\n c++\n include<bits/stdc++.h\n define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n int a, b, x, y, z;\n ll res;\n stack<ll s1;\n stack<char s2;\n unorderedmap<char, int ump;\n \n void init{\n \tump'+' = 1;\n \tump'' = 2;\n }\n \n void funchar c{\n \twhiles2.size && s1.size = 2 && umps2.top = umpc{\n \t\tll num1 = s1.top, cot = 0;\n \t\ts1.pop;\n \t\tll num2 = s1.top;\n \t\ts1.pop;\n \t\tchar c = s2.top;\n \t\ts2.pop;\n \t\tifc == '+' cot = num1 + num2;\n \t\telse cot = num1  num2;\n \t\ts1.pushcot;\n \t}\t\n \ts2.pushc;\t\n }\n \n void end{\n \twhiles2.size && s1.size = 2{\n \t\tll num1 = s1.top, cot = 0;\n \t\ts1.pop;\n \t\tll num2 = s1.top;\n \t\ts1.pop;\n \t\tchar c = s2.top;\n \t\ts2.pop;\n \t\tifc == '+' cot = num1 + num2;\n \t\telse cot = num1  num2;\n \t\ts1.pushcot;\n \t}\t\n }\n \n int main{\n \tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n \tinit;\n \tstring str;\n \tcin  str;\n \tforint i = 0; i < str.size; i++{\n \t\tint idx = i;\n \t\tll num = 0;\n \t\twhilestridx = '0' && stridx <= '9'{\n \t\t\tnum = num  10 + stridx  '0';\n \t\t\tidx ++;\n \t\t}\n \t\tifnum = 0{\n \t\t\ts1.pushnum;\n \t\t\ti = idx  1;\n \t\t\tcontinue;\n \t\t}\n \t\tifstri == '+'  stri == ''{\n \t\t\tfunstri;\n \t\t}\n \t}\n \tend;\n \tcout << s1.top % 10000 << endl;\n \t\n \treturn 0;\n }\n \n\n C  Tprimes\n\n数据量很大，需要用到质数筛\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\nint nN, stN, idx;\n\nvoid init{\n\tst1 = 1;\n\tforint i = 2; i <= N; i ++{\n\t\tifsti nidx ++ = i; \n\t\tforint j = 0; nj <= N / i; j ++{\n\t\t\tstnj  i = 1;\n\t\t\tifi % nj == 0 break;\n\t\t}\n\t}\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tinit;\n\tcin  a;\n\tforint i = 0; i < a; i++{\n\t\tll num;\n\t\tcin  num;\n\t\tll cc = sqrtnum;\n\t\tifcc  cc == num && stcc{\n\t\t\tcout << \"YES\" << endl; \n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n\n\n D  New Year's Number\n\n签到题\n\n c++\n include<bits/stdc++.h\n define endl \"\\n\"\n using namespace std;\n typedef long long ll;\n typedef pair<int, int PII;\n const int N = 1e6 + 10, M = 1e9 + 10;\n int ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n int a, b, x, y, z;\n \n int main{\n \tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n \tcin  a;\n \twhilea {\n \t\tcin  b;\n \t\tint flag = 0;\n \t\tforint i = 0; i <= b / 2020; i ++{\n \t\t\tint f = 0;\n \t\t\tforint j = 0; j <= b / 2021; j ++{\n \t\t\t\tint cc = i  2020 + j  2021;\n \t\t\t\tifcc  b{\n \t\t\t\t\tbreak;\n \t\t\t\t} else ifcc == b{\n \t\t\t\t\tf = 1;\n \t\t\t\t\tflag = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t} \n \t\t\t}\n \t\t\tiff{\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tifflag cout << \"YES\" << endl;\n \t\telse cout << \"NO\" << endl;\n \t} \n \t\n \treturn 0;\n }\n \n\n E  最小新整数\n\n 单调栈\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n\nstring getstack<char s{\n\tstring res = \"\";\n\twhiles.size{\n\t\tres = s.top + res;\n\t\ts.pop;\n\t} \n\treturn res;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str;\n\tcin  a;\n\twhilea {\n\t\tcin  str  x;\n\t\tstack<char s;\n\t\tint len = str.size, cot = 0;\n\t\tforint i = 0; i < len; i++{\n\t\t\twhiles.empty && s.top  stri && cot < x{\n\t\t\t\tcot ++;\n\t\t\t\ts.pop;\n\t\t\t}\n\t\t\ts.pushstri;\n\t\t}\n\t\tifcot == x{\n\t\t\tcout << gets << endl;\n\t\t} else {\n\t\t\tint num = x  cot;\n\t\t\tstring str = gets;\n\t\t\tforint i = 0; i < str.size  num; i++{\n\t\t\t\tcout << stri;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    \n\treturn 0;\n}\n\n\n F  Count\n\n 矩阵快速幂\n\n\n\n\n\n"},{"filename":"nowcoder-month-84","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛84\ncategory: 算法\ndate: 2024-05-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 打靶\n\n签到题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> b >> x >> y >> z;\n\t\tif(y > z){\n\t\t\tcout << \"No\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << (b - x >= z - y ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n## 小蓝的疑惑\n\n只有 gcd % gcd == 0 的数才有答案，否则输出-1\n\n 找出规律可以知道，要让a最小，那么只有最大公约数为a的时候最小；要让b也最小 ，a和b的最小公倍数为x，只有b为最小公倍数的时候最小\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> x >> y;\n\t\tif(y % x != 0){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tcout << x << \" \" << y << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## k级序列\n\n设当前下标为i，分两种情况\n\n- 当前数比前一个数大的时候，就取 min(v[i - 1], v[i] - k);\n- 当前数比前一个数小的时候\n  - 若 v[i] + k 任然小于 v[i - 1] 就是不满足条件的输出No\n  - 否则，就取 min(v[i] + k, v[i - 1]);\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> x >> y;\n\t\tvector<int> v(x);\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tif(x == 1){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint flag = 1;\n\t\tv[0] -= y; \n\t\tfor(int i = 1; i < x; i++){\n\t\t\tif(v[i] >= v[i - 1]){\n\t\t\t\tv[i] = max(v[i] - y, v[i - 1]);\n\t\t\t} else {\n\t\t\t\tif(v[i] + y < v[i - 1]){\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t\tv[i] = min(v[i] + y, v[i - 1]);\n\t\t\t}\n\t\t}\n\t\tcout << (flag ? \"Yes\" : \"No\") << endl;\n\n\t}\n\t\n\treturn 0;\n}\n```\n\n## Reverse\n\n先遍历找出现在有多少连续的1段，设置为 res。两端分分开判断，其次判断中间区间\n\n设当左右下标为x，y，分情况讨论，这里只讨论 v[x] != v[y]，因为相等的情况一致讨论没意义\n\n- 若 x == 1，若判断 v[x] == 1并且 v[y + 1] == v[x]，就需要 res--；若 v[x] == 0 并且 v[y + 1] != v[x]，则 res ++;\n- 若 y == a，判断同上\n- 若 v[x - 1] == v[x] 并且 v[y] == v[y + 1]，则 res --;  若v[x - 1] != v[x] 并且 v[y] != v[y + 1]，则 res ++;\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0, flag = 0;\n\tcin >> a >> b;\n\tvector<char> v(a);\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tif(v[i] == '1' && !flag){\n\t\t\tres ++, flag = 1;\n\t\t} else if(v[i ] == '0') flag = 0;\n\t}\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tint cot = res;\n\t\tif(v[x] != v[y]){\n\t\t\tif(x == 1){\n\t\t\t\tif(y != a && v[x] == '0' && v[y + 1] != v[x]) cot ++;\n\t\t\t\telse if(y != a && v[x] == '1' && v[y + 1] == v[x]) cot --;\n\t\t\t} else if(y == a){\n\t\t\t\tif(x != 1 && v[y] == '0' && v[x - 1] != v[y]) cot ++;\t\n\t\t\t\telse if(x != 1 && v[y] == '1' && v[x - 1] == v[y]) cot --;\t\t\t\n\t\t\t} else {\n\t\t\t\tif(v[x - 1] == v[x] && v[y] == v[y + 1]){\n\t\t\t\t\tcot ++; \n\t\t\t\t} else if(v[x - 1] != v[x] && v[y] != v[y + 1]){\n\t\t\t\t\tcot --;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cot << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## Dog vs Cat\n\n这题也是需要分开讨论，难就难在需要讨论个数为2的特殊情况\n\n- 当个数为2的时候\n  - 若两个数相差1，且最小的不是0，输出 Cat\n  - 否则输出Dog\n- 其他情况：算出所有数与1的差之和，设为 res；计算数组个数的一半，若是奇数需要 / 2 + 1，设为 cc；计算 res + cc 是否是奇数，若是奇数输出 Dog，否则输出 Cat\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint a;\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b);\n\t\tll res = 0;\n\t\tint cot = 0;\n\t\tfor(int i = 0; i < b; i++){\n\t\t\tcin >> v[i];\n\t\t\tif(v[i] != 0){\n\t\t\t\tres += v[i] - 1;\n\t\t\t} else {\n\t\t\t\tcot ++;\n\t\t\t}\n\t\t}\n\t\tif(b == 2){\n            sort(v.begin(),v.end());\n\t\t\tif(v[0] && v[0] + 1 == v[1]) cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl;\n\t\t\tcontinue;\n\t\t}\n        \n        int ban;\n        if(b % 2 == 0) ban = b / 2;\n        else ban = b / 2 + 1;\n\t\tif(cot >= ban){\n\t\t\tcout << \"Dog\" << endl;\n\t\t} else {\n\t\t\tint cc = ban - cot;\n\t\t\tif((res + cc) % 2 == 0) cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl; \n\t\t}\n\t\n\t}\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛84\n","category":[" 算法\n"],"date":" 2024-05-08\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 打靶\n\n签到题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea{\n\t\tcin  b  x  y  z;\n\t\tify  z{\n\t\t\tcout << \"No\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << b  x = z  y ? \"Yes\" : \"No\" << endl;\n\t}\n\n\treturn 0;\n}\n\n\n 小蓝的疑惑\n\n只有 gcd % gcd == 0 的数才有答案，否则输出1\n\n 找出规律可以知道，要让a最小，那么只有最大公约数为a的时候最小；要让b也最小 ，a和b的最小公倍数为x，只有b为最小公倍数的时候最小\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea{\n\t\tcin  x  y;\n\t\tify % x = 0{\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tcout << x << \" \" << y << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n k级序列\n\n设当前下标为i，分两种情况\n\n 当前数比前一个数大的时候，就取 minvi  1, vi  k;\n 当前数比前一个数小的时候\n   若 vi + k 任然小于 vi  1 就是不满足条件的输出No\n   否则，就取 minvi + k, vi  1;\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea{\n\t\tcin  x  y;\n\t\tvector<int vx;\n\t\tforint i = 0; i < x; i++{\n\t\t\tcin  vi;\n\t\t}\n\t\tifx == 1{\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint flag = 1;\n\t\tv0 = y; \n\t\tforint i = 1; i < x; i++{\n\t\t\tifvi = vi  1{\n\t\t\t\tvi = maxvi  y, vi  1;\n\t\t\t} else {\n\t\t\t\tifvi + y < vi  1{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t\tvi = minvi + y, vi  1;\n\t\t\t}\n\t\t}\n\t\tcout << flag ? \"Yes\" : \"No\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n\n\n Reverse\n\n先遍历找出现在有多少连续的1段，设置为 res。两端分分开判断，其次判断中间区间\n\n设当左右下标为x，y，分情况讨论，这里只讨论 vx = vy，因为相等的情况一致讨论没意义\n\n 若 x == 1，若判断 vx == 1并且 vy + 1 == vx，就需要 res；若 vx == 0 并且 vy + 1 = vx，则 res ++;\n 若 y == a，判断同上\n 若 vx  1 == vx 并且 vy == vy + 1，则 res ;  若vx  1 = vx 并且 vy = vy + 1，则 res ++;\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0, flag = 0;\n\tcin  a  b;\n\tvector<char va;\n\tforint i = 1; i <= a; i++{\n\t\tcin  vi;\n\t\tifvi == '1' && flag{\n\t\t\tres ++, flag = 1;\n\t\t} else ifvi  == '0' flag = 0;\n\t}\n\twhileb {\n\t\tcin  x  y;\n\t\tint cot = res;\n\t\tifvx = vy{\n\t\t\tifx == 1{\n\t\t\t\tify = a && vx == '0' && vy + 1 = vx cot ++;\n\t\t\t\telse ify = a && vx == '1' && vy + 1 == vx cot ;\n\t\t\t} else ify == a{\n\t\t\t\tifx = 1 && vy == '0' && vx  1 = vy cot ++;\t\n\t\t\t\telse ifx = 1 && vy == '1' && vx  1 == vy cot ;\t\t\t\n\t\t\t} else {\n\t\t\t\tifvx  1 == vx && vy == vy + 1{\n\t\t\t\t\tcot ++; \n\t\t\t\t} else ifvx  1 = vx && vy = vy + 1{\n\t\t\t\t\tcot ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cot << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n Dog vs Cat\n\n这题也是需要分开讨论，难就难在需要讨论个数为2的特殊情况\n\n 当个数为2的时候\n   若两个数相差1，且最小的不是0，输出 Cat\n   否则输出Dog\n 其他情况：算出所有数与1的差之和，设为 res；计算数组个数的一半，若是奇数需要 / 2 + 1，设为 cc；计算 res + cc 是否是奇数，若是奇数输出 Dog，否则输出 Cat\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint a;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tvector<int vb;\n\t\tll res = 0;\n\t\tint cot = 0;\n\t\tforint i = 0; i < b; i++{\n\t\t\tcin  vi;\n\t\t\tifvi = 0{\n\t\t\t\tres += vi  1;\n\t\t\t} else {\n\t\t\t\tcot ++;\n\t\t\t}\n\t\t}\n\t\tifb == 2{\n            sortv.begin,v.end;\n\t\t\tifv0 && v0 + 1 == v1 cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl;\n\t\t\tcontinue;\n\t\t}\n        \n        int ban;\n        ifb % 2 == 0 ban = b / 2;\n        else ban = b / 2 + 1;\n\t\tifcot = ban{\n\t\t\tcout << \"Dog\" << endl;\n\t\t} else {\n\t\t\tint cc = ban  cot;\n\t\t\tifres + cc % 2 == 0 cout << \"Cat\" << endl;\n\t\t\telse cout << \"Dog\" << endl; \n\t\t}\n\t\n\t}\n\t\n\treturn 0;\n}\n\n\n"},{"filename":"14th-lqb-B-1","category":"aigorithm","md":{"topSummary":"\ntitle: 第十四届蓝桥杯B组国赛\ncategory: 算法\ndate: 2024-05-05\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 子2023\n\n有两种方法，一种暴力枚举，一种动态规划\n\n暴力枚举：需要等一两分钟\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str = \"\";\n\tfor(int i = 1; i <= 2023; i++){\n\t\tstring ss = to_string(i);\n\t\tfor(int j = 0 ; j < ss.size(); j++){\n\t\t\tif(ss[j] == '2' || ss[j] == '0' || ss[j] == '3'){\n\t\t\t\tstr += ss[j];\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size();\n\tll res = 0;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] != '2') continue;\n\t\tfor(int j = i + 1; j < len; j ++){\n\t\t\tif(str[j] != '0') continue;\n\t\t\tfor(int z = j + 1; z < len; z ++){\n\t\t\t\tif(str[z] != '2') continue;\n\t\t\t\tfor(int x = z + 1; x < len; x ++){\n\t\t\t\t\tif(str[x] != '3') continue;\n\t\t\t\t\tif(str[i] == '2' && str[j] == '0' && str[z] == '2' && str[x] == '3'){\n\t\t\t\t\t\tres ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n动态规划\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\nll dp[5];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str = \"\";\n\tfor(int i = 1; i <= 2023; i++){\n\t\tstring ss = to_string(i);\n\t\tfor(int j = 0 ; j < ss.size(); j++){\n\t\t\tif(ss[j] == '2' || ss[j] == '0' || ss[j] == '3'){\n\t\t\t\tstr += ss[j];\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size();\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == '2'){\n\t\t\tdp[1] ++;\n\t\t\tdp[3] += dp[2]; \n\t\t} else if(str[i] == '0'){\n\t\t\tdp[2] += dp[1];\n\t\t} else if(str[i] == '3'){\n\t\t\tdp[4] += dp[3]; \n\t\t}\n\t}\n\tcout << dp[4] << endl;\n\t\n\treturn 0;\n}\n```\n\n\n\n## 班级活动\n\n本题需要注意一下几点：\n\n- 重复学生数量小于没有重复的数量\n- 重复学生数量大于没有重复数量，且重复数量为偶数\n- 重复学生数量大于没有重复数量，且重复数量为奇数\n\n```c++\n#include<bits/stdc++.h>a\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tunordered_map<int, int> ump;\n\tint idx = 0, idx2 = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tint num;\n\t\tcin >> num;\n\t\tump[num] ++;\n\t\tif(ump[num] == 2){\n\t\t\tidx ++;\n\t\t} else if(ump[num] > 2){\n\t\t\tidx2 ++;\n\t\t}\n\t}\n\tint cc = a - idx * 2 - idx2;\n\tif(cc >= idx2){\n\t\tcout << idx2 + (cc - idx2) / 2 << endl;\n\t} else {\n\t\tcout << idx2 << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n## 合并数列\n\n双指针，一个指向A数组最左边，一个指向B数组最左边，同时向右移动。遇到一致的跳过，不一致的停下来只让该一个指针移动直到相同为止\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<int> v1(a), v2(b);\n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v1[i];\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tcin >> v2[i];\n\t}\n\tint idx1 = 0, idx2 = 0, res = 0;\n\twhile(idx1 < a){\n\t\tint num1 = v1[idx1], num2 = v2[idx2];\n\t\twhile(num1 != num2){\n\t\t\tif(num1 > num2){\n\t\t\t\tidx2 ++;\n\t\t\t\tnum2 += v2[idx2];\n\t\t\t} else {\n\t\t\t\tidx1 ++;\n\t\t\t\tnum1 += v1[idx1];\n\t\t\t}\n\t\t\tres ++;\n\t\t}\n\t\tidx1 ++;\n\t\tidx2 ++;\n\t}\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n```\n\n## AB路线\n\nBFS模板题，注意以下测试数据\n\n```\n2 2 10\nAA\nAB\n```\n答案为10\n这题需要标记 **走过且走的次数的点**，走过的点只要次数不一致还可以再次走，所以需要用到三维数组st来标记\n\n```cpp\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res = -1;\nchar n[1010][1010];\nint st[1010][1010][12];\n\nstruct p{\n\tint x, y, cot, cc;\n};\n\nvoid bfs(int k){\n\t\n\tqueue<p> q;\n\tq.push({0, 0, 1, 0});\n\tst[0][0][1] = 1;\n\twhile(!q.empty()){\n\t\tauto top = q.front();\n\t\tq.pop();\n\t\tint x = top.x, y = top.y, cot = top.cot, cc = top.cc;\n\t\tif(x == a - 1 && y == b - 1){\n\t\t\tres = cc;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + ix[i], yy = y + iy[i];\n\t\t\tif(xx >= 0 && xx < a && yy >= 0 && yy < b){\n\t\t\t\tif(cot == k){\n\t\t\t\t\tif(n[x][y] == n[xx][yy] || st[xx][yy][1]) continue;\n\t\t\t\t\tst[xx][yy][1] = 1;\n\t\t\t\t\tq.push({xx, yy, 1, cc + 1});\n\t\t\t\t} else if(n[xx][yy] == n[x][y]){\n\t\t\t\t\tif(st[xx][yy][cot + 1]) continue;\n\t\t\t\t\tst[xx][yy][cot + 1] = 1;\n\t\t\t\t\tq.push({xx, yy, cot + 1, cc + 1});\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\t\n\t\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b >> x;\n\tfor(int i = 0; i < a; i++){\n\t\tfor(int j = 0; j < b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tbfs(x);\n\tcout << res << endl;\t\n\t\n\treturn 0;\n}\n```\n\n## 抓娃娃\n\n用前缀和的思想来做\n\n根据给出的线段的两个点，求出中点，在求助中点数组的前缀和\n\n注意：因为 l，r两个点相加除2后可能出现小数，所以这里需要变通一下改为乘2\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 2e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++){\n\t\tcin >> x >> y;\n\t\tn[x + y] ++;\n\t}\n\tfor(int i = 0; i <= N; i++){\n\t\tn[i] += n[i - 1];\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tcin >> x >> y;\n\t\tcout << n[2 * y] - n[x * 2 - 1] << endl;\n\t}\n\t\n\treturn 0;\n} \n```\n\n\n\n","title":" 第十四届蓝桥杯B组国赛\n","category":[" 算法\n"],"date":" 2024-05-05\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 子2023\n\n有两种方法，一种暴力枚举，一种动态规划\n\n暴力枚举：需要等一两分钟\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str = \"\";\n\tforint i = 1; i <= 2023; i++{\n\t\tstring ss = tostringi;\n\t\tforint j = 0 ; j < ss.size; j++{\n\t\t\tifssj == '2'  ssj == '0'  ssj == '3'{\n\t\t\t\tstr += ssj;\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size;\n\tll res = 0;\n\tforint i = 0; i < len; i++{\n\t\tifstri = '2' continue;\n\t\tforint j = i + 1; j < len; j ++{\n\t\t\tifstrj = '0' continue;\n\t\t\tforint z = j + 1; z < len; z ++{\n\t\t\t\tifstrz = '2' continue;\n\t\t\t\tforint x = z + 1; x < len; x ++{\n\t\t\t\t\tifstrx = '3' continue;\n\t\t\t\t\tifstri == '2' && strj == '0' && strz == '2' && strx == '3'{\n\t\t\t\t\t\tres ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n动态规划\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\nll dp5;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str = \"\";\n\tforint i = 1; i <= 2023; i++{\n\t\tstring ss = tostringi;\n\t\tforint j = 0 ; j < ss.size; j++{\n\t\t\tifssj == '2'  ssj == '0'  ssj == '3'{\n\t\t\t\tstr += ssj;\n\t\t\t}\n\t\t}\n\t} \n\tint len = str.size;\n\tforint i = 0; i < len; i++{\n\t\tifstri == '2'{\n\t\t\tdp1 ++;\n\t\t\tdp3 += dp2; \n\t\t} else ifstri == '0'{\n\t\t\tdp2 += dp1;\n\t\t} else ifstri == '3'{\n\t\t\tdp4 += dp3; \n\t\t}\n\t}\n\tcout << dp4 << endl;\n\t\n\treturn 0;\n}\n\n\n\n\n 班级活动\n\n本题需要注意一下几点：\n\n 重复学生数量小于没有重复的数量\n 重复学生数量大于没有重复数量，且重复数量为偶数\n 重复学生数量大于没有重复数量，且重复数量为奇数\n\nc++\ninclude<bits/stdc++.ha\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tunorderedmap<int, int ump;\n\tint idx = 0, idx2 = 0;\n\tforint i = 0; i < a; i++{\n\t\tint num;\n\t\tcin  num;\n\t\tumpnum ++;\n\t\tifumpnum == 2{\n\t\t\tidx ++;\n\t\t} else ifumpnum  2{\n\t\t\tidx2 ++;\n\t\t}\n\t}\n\tint cc = a  idx  2  idx2;\n\tifcc = idx2{\n\t\tcout << idx2 + cc  idx2 / 2 << endl;\n\t} else {\n\t\tcout << idx2 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n 合并数列\n\n双指针，一个指向A数组最左边，一个指向B数组最左边，同时向右移动。遇到一致的跳过，不一致的停下来只让该一个指针移动直到相同为止\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<int v1a, v2b;\n\tforint i = 0; i < a; i++{\n\t\tcin  v1i;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tcin  v2i;\n\t}\n\tint idx1 = 0, idx2 = 0, res = 0;\n\twhileidx1 < a{\n\t\tint num1 = v1idx1, num2 = v2idx2;\n\t\twhilenum1 = num2{\n\t\t\tifnum1  num2{\n\t\t\t\tidx2 ++;\n\t\t\t\tnum2 += v2idx2;\n\t\t\t} else {\n\t\t\t\tidx1 ++;\n\t\t\t\tnum1 += v1idx1;\n\t\t\t}\n\t\t\tres ++;\n\t\t}\n\t\tidx1 ++;\n\t\tidx2 ++;\n\t}\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n\n\n AB路线\n\nBFS模板题，注意以下测试数据\n\n\n2 2 10\nAA\nAB\n\n答案为10\n这题需要标记 走过且走的次数的点，走过的点只要次数不一致还可以再次走，所以需要用到三维数组st来标记\n\ncpp\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res = 1;\nchar n10101010;\nint st1010101012;\n\nstruct p{\n\tint x, y, cot, cc;\n};\n\nvoid bfsint k{\n\t\n\tqueue<p q;\n\tq.push{0, 0, 1, 0};\n\tst001 = 1;\n\twhileq.empty{\n\t\tauto top = q.front;\n\t\tq.pop;\n\t\tint x = top.x, y = top.y, cot = top.cot, cc = top.cc;\n\t\tifx == a  1 && y == b  1{\n\t\t\tres = cc;\n\t\t\tbreak;\n\t\t}\n\t\tforint i = 0; i < 4; i++{\n\t\t\tint xx = x + ixi, yy = y + iyi;\n\t\t\tifxx = 0 && xx < a && yy = 0 && yy < b{\n\t\t\t\tifcot == k{\n\t\t\t\t\tifnxy == nxxyy  stxxyy1 continue;\n\t\t\t\t\tstxxyy1 = 1;\n\t\t\t\t\tq.push{xx, yy, 1, cc + 1};\n\t\t\t\t} else ifnxxyy == nxy{\n\t\t\t\t\tifstxxyycot + 1 continue;\n\t\t\t\t\tstxxyycot + 1 = 1;\n\t\t\t\t\tq.push{xx, yy, cot + 1, cc + 1};\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\t\n\t\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b  x;\n\tforint i = 0; i < a; i++{\n\t\tforint j = 0; j < b; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\n\tbfsx;\n\tcout << res << endl;\t\n\t\n\treturn 0;\n}\n\n\n 抓娃娃\n\n用前缀和的思想来做\n\n根据给出的线段的两个点，求出中点，在求助中点数组的前缀和\n\n注意：因为 l，r两个点相加除2后可能出现小数，所以这里需要变通一下改为乘2\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 2e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tforint i = 0; i < a; i++{\n\t\tcin  x  y;\n\t\tnx + y ++;\n\t}\n\tforint i = 0; i <= N; i++{\n\t\tni += ni  1;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tcin  x  y;\n\t\tcout << n2  y  nx  2  1 << endl;\n\t}\n\t\n\treturn 0;\n} \n\n\n\n\n"},{"filename":"leetcode-week-396","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第396场周赛\ncategory: 算法\ndate: 2024-05-05\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本次比赛WA嘛了，最后3分钟把第三题解了，一直错本来都打算放弃了，突然就给我对了。\n\n字符串这方面还是太弱了，本场基本都是字符串的题目.....\n\n## 有效单词\n\n签到题，如果数组元素较多的的化建议用循环做\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string word) {\n        int len = word.size();\n        if(len < 3){\n            return false;\n        }\n        int f1 = 0, f2 = 0;\n        for(int i = 0; i < len; i++){\n            char c = word[i];\n            if(c == 'a' || c == 'e' || c == 'i' || c =='o' || c == 'u' ||\n              c == 'A' || c == 'E' || c == 'I' || c =='O' || c == 'U' ){\n                f1 = 1;\n            } else {\n                if(c >= 'a' && c <= 'z' || c >= '0' && c <= '9' || c >= 'A' && c <= 'Z'){\n                    if(c >= 'a' && c <= 'z' ||  c >= 'A' && c <= 'Z'){\n                         f2 = 1;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        if(f1 && f2) return true;\n        else return false;\n    }\n};\n```\n\n## K 周期字符串需要的最少操作次数\n\n一开始没读懂题目，后面发现不必要考虑两个字符串相隔的位置\n\n```c++\nclass Solution {\npublic:\n    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int len = word.size(), maxlen = 0, cot = 0, idx = 0;\n        string mstr = \"\";\n        unordered_map<string, int> ump;\n        for(int i = 0;  i < len; i++){\n            string ss = word.substr(i, k);\n            ump[ss] ++;\n            if(ump[ss] > maxlen){\n                maxlen = ump[ss];\n                mstr = ss;\n            }\n            i += k - 1;\n        }\n        idx = 0;\n        for(int i = 0;  i < len; i++){\n            string ss = word.substr(i, k);\n            if(ss == mstr){\n                cot ++;\n            }\n            i += k - 1;\n        }\n        return (len - cot * k) / k;\n    }\n};\n```\n\n## 同位字符串连接的最小长度\n\n通过求出每个元素的个数，然后求出所有个数的最大公约数来判断可以分为多少组，从而求出每组的个数\n\n个人感觉这题的数据量不是很多，我这个思路遇多多少少是有点问题的\n\n```c++\nclass Solution {\npublic:\n    int fun(int x, int y){\n        return y == 0? x : fun(y, x % y);\n    }\n    int minAnagramLength(string s) {\n        set<char> ss;\n        int len = s.size();\n        unordered_map<char, int> ump;\n        int cot = INT_MAX, f = 0, cot2 = 0, bf = 0;\n        for(int i = 0; i < len; i++){\n            ump[s[i]] ++;\n        }\n        for(auto item : ump){\n            if(bf == 0){\n                bf = item.second;\n            } else {\n                cot = min(cot, fun(bf, item.second));\n                bf = item.second;\n            }\n        }\n\n        return cot != INT_MAX ? len / cot: len / bf;\n    }\n};\n```\n\n## 使数组中所有元素相等的最小开销\n\n待补充\n","title":" Leetcode第396场周赛\n","category":[" 算法\n"],"date":" 2024-05-05\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n本次比赛WA嘛了，最后3分钟把第三题解了，一直错本来都打算放弃了，突然就给我对了。\n\n字符串这方面还是太弱了，本场基本都是字符串的题目.....\n\n 有效单词\n\n签到题，如果数组元素较多的的化建议用循环做\n\nc++\nclass Solution {\npublic:\n    bool isValidstring word {\n        int len = word.size;\n        iflen < 3{\n            return false;\n        }\n        int f1 = 0, f2 = 0;\n        forint i = 0; i < len; i++{\n            char c = wordi;\n            ifc == 'a'  c == 'e'  c == 'i'  c =='o'  c == 'u' \n              c == 'A'  c == 'E'  c == 'I'  c =='O'  c == 'U' {\n                f1 = 1;\n            } else {\n                ifc = 'a' && c <= 'z'  c = '0' && c <= '9'  c = 'A' && c <= 'Z'{\n                    ifc = 'a' && c <= 'z'   c = 'A' && c <= 'Z'{\n                         f2 = 1;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        iff1 && f2 return true;\n        else return false;\n    }\n};\n\n\n K 周期字符串需要的最少操作次数\n\n一开始没读懂题目，后面发现不必要考虑两个字符串相隔的位置\n\nc++\nclass Solution {\npublic:\n    int minimumOperationsToMakeKPeriodicstring word, int k {\n        int len = word.size, maxlen = 0, cot = 0, idx = 0;\n        string mstr = \"\";\n        unorderedmap<string, int ump;\n        forint i = 0;  i < len; i++{\n            string ss = word.substri, k;\n            umpss ++;\n            ifumpss  maxlen{\n                maxlen = umpss;\n                mstr = ss;\n            }\n            i += k  1;\n        }\n        idx = 0;\n        forint i = 0;  i < len; i++{\n            string ss = word.substri, k;\n            ifss == mstr{\n                cot ++;\n            }\n            i += k  1;\n        }\n        return len  cot  k / k;\n    }\n};\n\n\n 同位字符串连接的最小长度\n\n通过求出每个元素的个数，然后求出所有个数的最大公约数来判断可以分为多少组，从而求出每组的个数\n\n个人感觉这题的数据量不是很多，我这个思路遇多多少少是有点问题的\n\nc++\nclass Solution {\npublic:\n    int funint x, int y{\n        return y == 0? x : funy, x % y;\n    }\n    int minAnagramLengthstring s {\n        set<char ss;\n        int len = s.size;\n        unorderedmap<char, int ump;\n        int cot = INTMAX, f = 0, cot2 = 0, bf = 0;\n        forint i = 0; i < len; i++{\n            umpsi ++;\n        }\n        forauto item : ump{\n            ifbf == 0{\n                bf = item.second;\n            } else {\n                cot = mincot, funbf, item.second;\n                bf = item.second;\n            }\n        }\n\n        return cot = INTMAX ? len / cot: len / bf;\n    }\n};\n\n\n 使数组中所有元素相等的最小开销\n\n待补充\n"},{"filename":"nowcoder-month-92","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛92\ncategory: 算法\ndate: 2024-05-04\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本次算法赛主题是MC，一下就来兴趣了\n\n## 获得木头\n\n签到题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tcout << a * 8 << endl;\t\n   \n\treturn 0;\n}\n```\n\n## 采矿时间到！\n\nwa了一次，这题坑点在于会有一种这样的情况\n\n```\n#################*##\n#########*##########\n....................\n#####*######**######\n#*##########*#######\n```\n\n最外层和最内层都有矿石，此时就只需要消耗2体力就能够挖到两个矿石\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n char v[1010][1010];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint idx = 0;\n\tcin >> a >> b;\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> v[i][j];\n\t\t\tif(v[i][j] == '*') idx ++;\n\t\t}\n\t}\n\tint cot = 0, res = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tif(v[1][i] == '*') cot ++;\n\t\tif(v[3][i] == '*') cot ++; \n\t} \n\tif(cot > b){\n\t\tcout << b << endl;\n\t\treturn 0; \n\t}\n\tint cc = (b - cot) / 2;\n\tcout << min(cc, idx - cot) + cot << endl;\n\treturn 0;\n}\n```\n\n## 耕种时间到！\n\n这题是个模拟题，很容易想到模拟的过程\n\n我在赛时把分解的过程直接化了，简单的想成了小麦种子的数量为`收割次数总次数 * 2`，正解是`pow(2, 收割次数总次数 )`\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint idx = 0;\n\tcin >> a;\n\tvector<int> v(a);\n\tunordered_map<int, ll> m; \n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v[i];\n\t}\n\tcin >> b;\n\tfor(int i = 0; i < a; i++){\n\t\tll idx = 0, cnt = 1;\n\t\twhile(v[i] > b){\n\t\t\tv[i] = ceil(v[i] * 1.0 / 3);\n\t\t\tidx ++;\n\t\t\tcnt *= 2;\n\t\t}\n\t\tif(v[i] == b){\n\t\t\tm[idx] += cnt;\n\t\t}\n\t}\n\tll res = 0;\n\tfor(auto i: m){\n\t\tres = max(res, i.second);\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n## 探索的时光\n\n这题我想了很多思考思路：\n\n- 前缀和\n\n- dp\n- 推公式，找规律\n\n但是都没法实现，问题就出在了推公式，吃了没文化的亏。正解也是推公式，我遇到求和符合就卡了，不知道怎么化简\n\n最终推出来的结论：（@为+号）\n\n![](https://img2.imgtp.com/2024/05/04/ycrX8KeI.png)\n\n你以为这就结束了？这题还需要注意坑点是数据范围！！！\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a + 1);\n\tll all = 0, all2 = 0, all3 = 0, res = 0x3f3f3f3f3f3f3f3f;\n\tfor(ll i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tall += v[i];\n\t\tall2 += i * v[i];\n\t\tall3 += i * i * v[i];\n\t}\n\tfor(ll i = 1; i <= a; i++){\n\t\tres = min(res, i * i * all + all3 - 2 * i * all2);\n\t}\n\n\tcout << res << endl; \n\t\n\t\n\treturn 0;\n}\n```\n\n## 来硬的\n\n背包问题\n\n首先从数据范围上很容易看出是DP问题，需要双循环更新\n\n~~其次我知道它是DP，但我设计不出来状态转移方程，淦~~\n\n设计状态：`dp[i][j][0/1]` 表示前i个煤炭，获得j个矿石的最短时间，0/1表示是否使用过魔法\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, z;\n\nstruct p{\n\tint x, y;\n}n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<vector<vector<ll>>> dp(a + 1, vector<vector<ll>>(b + 1, vector<ll>(2, 0x3f3f3f3f3f3f3f3f)));\n\tdp[0][0][0] = 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> n[i].x >> n[i].y;\n\t}\n\tfor(int i = 1;  i <= a; i++){\n\t\tfor(int j = 0; j <= b; j++){\n\t\t\tdp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][max(j - n[i].x, 0)][0] + n[i].y);\n\t\t\tdp[i][j][1] = min({dp[i - 1][j][1], dp[i - 1][max(j - n[i].x * 2, 0)][0] + n[i].y / 2, dp[i - 1][max(j - n[i].x, 0)][1] + n[i].y});\n\t\t} \n\t}\n\t\n\tcout << min(dp[a][b][1], dp[a][b][0]) << endl;\t\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛92\n","category":[" 算法\n"],"date":" 2024-05-04\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n本次算法赛主题是MC，一下就来兴趣了\n\n 获得木头\n\n签到题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tcout << a  8 << endl;\t\n   \n\treturn 0;\n}\n\n\n 采矿时间到！\n\nwa了一次，这题坑点在于会有一种这样的情况\n\n\n\n\n....................\n\n\n\n\n最外层和最内层都有矿石，此时就只需要消耗2体力就能够挖到两个矿石\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n char v10101010;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint idx = 0;\n\tcin  a  b;\n\tforint i = 0; i < 5; i++{\n\t\tforint j = 0; j < a; j++{\n\t\t\tcin  vij;\n\t\t\tifvij == '' idx ++;\n\t\t}\n\t}\n\tint cot = 0, res = 0;\n\tforint i = 0; i < a; i++{\n\t\tifv1i == '' cot ++;\n\t\tifv3i == '' cot ++; \n\t} \n\tifcot  b{\n\t\tcout << b << endl;\n\t\treturn 0; \n\t}\n\tint cc = b  cot / 2;\n\tcout << mincc, idx  cot + cot << endl;\n\treturn 0;\n}\n\n\n 耕种时间到！\n\n这题是个模拟题，很容易想到模拟的过程\n\n我在赛时把分解的过程直接化了，简单的想成了小麦种子的数量为收割次数总次数  2，正解是pow2, 收割次数总次数 \n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint idx = 0;\n\tcin  a;\n\tvector<int va;\n\tunorderedmap<int, ll m; \n\tforint i = 0; i < a; i++{\n\t\tcin  vi;\n\t}\n\tcin  b;\n\tforint i = 0; i < a; i++{\n\t\tll idx = 0, cnt = 1;\n\t\twhilevi  b{\n\t\t\tvi = ceilvi  1.0 / 3;\n\t\t\tidx ++;\n\t\t\tcnt = 2;\n\t\t}\n\t\tifvi == b{\n\t\t\tmidx += cnt;\n\t\t}\n\t}\n\tll res = 0;\n\tforauto i: m{\n\t\tres = maxres, i.second;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n 探索的时光\n\n这题我想了很多思考思路：\n\n 前缀和\n\n dp\n 推公式，找规律\n\n但是都没法实现，问题就出在了推公式，吃了没文化的亏。正解也是推公式，我遇到求和符合就卡了，不知道怎么化简\n\n最终推出来的结论：（@为+号）\n\nhttps://img2.imgtp.com/2024/05/04/ycrX8KeI.png\n\n你以为这就结束了？这题还需要注意坑点是数据范围！！！\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<int va + 1;\n\tll all = 0, all2 = 0, all3 = 0, res = 0x3f3f3f3f3f3f3f3f;\n\tforll i = 1; i <= a; i++{\n\t\tcin  vi;\n\t\tall += vi;\n\t\tall2 += i  vi;\n\t\tall3 += i  i  vi;\n\t}\n\tforll i = 1; i <= a; i++{\n\t\tres = minres, i  i  all + all3  2  i  all2;\n\t}\n\n\tcout << res << endl; \n\t\n\t\n\treturn 0;\n}\n\n\n 来硬的\n\n背包问题\n\n首先从数据范围上很容易看出是DP问题，需要双循环更新\n\n其次我知道它是DP，但我设计不出来状态转移方程，淦\n\n设计状态：dpij0/1 表示前i个煤炭，获得j个矿石的最短时间，0/1表示是否使用过魔法\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, z;\n\nstruct p{\n\tint x, y;\n}nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<vector<vector<ll dpa + 1, vector<vector<llb + 1, vector<ll2, 0x3f3f3f3f3f3f3f3f;\n\tdp000 = 0;\n\tforint i = 1; i <= a; i++{\n\t\tcin  ni.x  ni.y;\n\t}\n\tforint i = 1;  i <= a; i++{\n\t\tforint j = 0; j <= b; j++{\n\t\t\tdpij0 = mindpi  1j0, dpi  1maxj  ni.x, 00 + ni.y;\n\t\t\tdpij1 = min{dpi  1j1, dpi  1maxj  ni.x  2, 00 + ni.y / 2, dpi  1maxj  ni.x, 01 + ni.y};\n\t\t} \n\t}\n\t\n\tcout << mindpab1, dpab0 << endl;\t\n\t\n\treturn 0;\n}\n\n\n"},{"filename":"leetcode-week-128","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第128场双周赛\ncategory: 算法\ndate: 2024-05-01\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n今日刷哔哩哔哩小羊肖恩大神10分钟都没到就AK了本场比赛，于是就想来试着做下\n\n### 字符串的分数\n\n求相邻字母的ASCALL码值之和\n\n```c++\nclass Solution {\npublic:\n    int scoreOfString(string s) {\n        int res = 0;\n        for(int i = 1; i < s.size(); i++){\n            res += fabs(s[i] - s[i - 1]);\n        }\n        return res;\n    }\n};\n```\n\n### 覆盖所有点的最少矩形数目\n\n一眼贪心，只用考虑横坐标\n\n```c++\\\nclass Solution {\npublic:\n    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        int cot = 0, res = 0;\n        vector<int> v;\n        for(int i = 0; i < points.size(); i++){\n            v.push_back(points[i][0]);\n        }\n        int len = v.size();\n        sort(v.begin(), v.end());\n        cot = -1e9 - 10;\n        for(int i = 0; i < len; i++){\n            if(v[i] - cot > w){\n                cot = v[i];\n                res ++;\n            }\n        }\n        return res;\n\n    }\n};\n```\n\n### 访问消失节点的最少时间\n\nDjakarta模板题，这里提供两种做法，一种参考灵神的，一种是yxc模板的。\n\n参考灵神做法\n\n```c++\nclass Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        vector<vector<pair<int, int>>> g(n);\n        for(int i = 0; i < edges.size(); i++){\n            g[edges[i][0]].push_back({edges[i][1], edges[i][2]});\n            g[edges[i][1]].push_back({edges[i][0], edges[i][2]});\n        }\n\n        vector<int> dis(n, 0x3f3f3f3f);\n        vector<bool> st(n ,false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dis[0] = 0;\n        pq.push({0, 0});\n        while(!pq.empty()){\n            auto [len, xx] = pq.top();\n            pq.pop();\n            if(st[xx]) continue;\n            st[xx] = 1;\n            for(auto [_ne, _w] : g[xx]){\n                if(dis[_ne] > len + _w  && len + _w < disappear[_ne]){\n                    dis[_ne] = len + _w;\n                    pq.push({dis[_ne], _ne});\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(dis[i] == 0x3f3f3f3f) dis[i] = -1;\n        }\n       \n        return dis;\n    }\n};\n```\n\nyxc模板做法\n\n```c++\nconst int N = 1e6 + 10;\nclass Solution {\npublic:\n    int n[N], ne[N], w[N], h[N], dis[N], st[N], idx;\n    void dj(vector<int>& disappear){\n        memset(dis, 0x3f3f3f3f, sizeof dis);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dis[0] = 0;\n        pq.push({0, 0});\n        while(pq.size()){\n            auto top = pq.top();\n            pq.pop();\n            int yy = top.first, xx = top.second;\n            if(st[xx]) continue;\n            st[xx] = 1;\n            for(int i = h[xx]; i != -1; i = ne[i]){\n                int j = n[i];\n                if(dis[j] > yy + w[i] && yy + w[i] < disappear[j]){\n                    dis[j] = yy + w[i];\n                    pq.push({dis[j], j});\n                }\n            }\n        }\n    }\n    void add(int x, int y, int z){\n        n[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++;\n    }\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        memset(h, -1, sizeof h);\n        for(int i = 0; i < edges.size(); i++){\n            add(edges[i][0], edges[i][1], edges[i][2]);\n            add(edges[i][1], edges[i][0], edges[i][2]);\n        }\n        dj(disappear);\n        vector<int> res;\n        for(int i = 0; i < n; i ++){\n            res.push_back((dis[i] ==  0x3f3f3f3f ? -1 : dis[i]));\n        }\n       \n        return res;\n    }\n};\n```\n\n### 边界元素是最大值的子数组数目\n\n这题只要想到单调栈就很好做啦\n\n```c++\nclass Solution {\npublic:\n    long long numberOfSubarrays(vector<int>& nums) {\n        long long res = 0;\n        int len = nums.size();\n        stack<int> s;\n        vector<int> v(len, 0);\n        for(int i = 0; i < len; i++){\n            v[i] ++;\n            while(!s.empty() && nums[s.top()] < nums[i]){\n                s.pop();\n            }\n            if(!s.empty() && nums[s.top()] == nums[i]){\n                v[i] = v[s.top()] + 1;\n            }\n            res += v[i];\n            s.push(i);\n        }\n        return res;\n    }\n};\n```\n\n","title":" Leetcode第128场双周赛\n","category":[" 算法\n"],"date":" 2024-05-01\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n今日刷哔哩哔哩小羊肖恩大神10分钟都没到就AK了本场比赛，于是就想来试着做下\n\n 字符串的分数\n\n求相邻字母的ASCALL码值之和\n\nc++\nclass Solution {\npublic:\n    int scoreOfStringstring s {\n        int res = 0;\n        forint i = 1; i < s.size; i++{\n            res += fabssi  si  1;\n        }\n        return res;\n    }\n};\n\n\n 覆盖所有点的最少矩形数目\n\n一眼贪心，只用考虑横坐标\n\nc++\\\nclass Solution {\npublic:\n    int minRectanglesToCoverPointsvector<vector<int& points, int w {\n        int cot = 0, res = 0;\n        vector<int v;\n        forint i = 0; i < points.size; i++{\n            v.pushbackpointsi0;\n        }\n        int len = v.size;\n        sortv.begin, v.end;\n        cot = 1e9  10;\n        forint i = 0; i < len; i++{\n            ifvi  cot  w{\n                cot = vi;\n                res ++;\n            }\n        }\n        return res;\n\n    }\n};\n\n\n 访问消失节点的最少时间\n\nDjakarta模板题，这里提供两种做法，一种参考灵神的，一种是yxc模板的。\n\n参考灵神做法\n\nc++\nclass Solution {\npublic:\n    vector<int minimumTimeint n, vector<vector<int& edges, vector<int& disappear {\n        vector<vector<pair<int, int gn;\n        forint i = 0; i < edges.size; i++{\n            gedgesi0.pushback{edgesi1, edgesi2};\n            gedgesi1.pushback{edgesi0, edgesi2};\n        }\n\n        vector<int disn, 0x3f3f3f3f;\n        vector<bool stn ,false;\n        priorityqueue<pair<int, int, vector<pair<int, int, greater<pair<int, int pq;\n        dis0 = 0;\n        pq.push{0, 0};\n        whilepq.empty{\n            auto len, xx = pq.top;\n            pq.pop;\n            ifstxx continue;\n            stxx = 1;\n            forauto ne, w : gxx{\n                ifdisne  len + w  && len + w < disappearne{\n                    disne = len + w;\n                    pq.push{disne, ne};\n                }\n            }\n        }\n        forint i = 0; i < n; i++{\n            ifdisi == 0x3f3f3f3f disi = 1;\n        }\n       \n        return dis;\n    }\n};\n\n\nyxc模板做法\n\nc++\nconst int N = 1e6 + 10;\nclass Solution {\npublic:\n    int nN, neN, wN, hN, disN, stN, idx;\n    void djvector<int& disappear{\n        memsetdis, 0x3f3f3f3f, sizeof dis;\n        priorityqueue<pair<int, int, vector<pair<int, int, greater<pair<int, int pq;\n        dis0 = 0;\n        pq.push{0, 0};\n        whilepq.size{\n            auto top = pq.top;\n            pq.pop;\n            int yy = top.first, xx = top.second;\n            ifstxx continue;\n            stxx = 1;\n            forint i = hxx; i = 1; i = nei{\n                int j = ni;\n                ifdisj  yy + wi && yy + wi < disappearj{\n                    disj = yy + wi;\n                    pq.push{disj, j};\n                }\n            }\n        }\n    }\n    void addint x, int y, int z{\n        nidx = y, widx = z, neidx = hx, hx = idx ++;\n    }\n    vector<int minimumTimeint n, vector<vector<int& edges, vector<int& disappear {\n        memseth, 1, sizeof h;\n        forint i = 0; i < edges.size; i++{\n            addedgesi0, edgesi1, edgesi2;\n            addedgesi1, edgesi0, edgesi2;\n        }\n        djdisappear;\n        vector<int res;\n        forint i = 0; i < n; i ++{\n            res.pushbackdisi ==  0x3f3f3f3f ? 1 : disi;\n        }\n       \n        return res;\n    }\n};\n\n\n 边界元素是最大值的子数组数目\n\n这题只要想到单调栈就很好做啦\n\nc++\nclass Solution {\npublic:\n    long long numberOfSubarraysvector<int& nums {\n        long long res = 0;\n        int len = nums.size;\n        stack<int s;\n        vector<int vlen, 0;\n        forint i = 0; i < len; i++{\n            vi ++;\n            whiles.empty && numss.top < numsi{\n                s.pop;\n            }\n            ifs.empty && numss.top == numsi{\n                vi = vs.top + 1;\n            }\n            res += vi;\n            s.pushi;\n        }\n        return res;\n    }\n};\n\n\n"},{"filename":"nowcoder-month-91","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛91\ncategory: 算法\ndate: 2024-04-29\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### Bingbong的化学世界\n\n找出几个图形不同的点，根据不同的点来输出就很简单了\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tchar n[7][7];\n\tfor(int i = 0; i < 6; i++){\n\t\tfor(int j = 0; j < 7; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\t\n\tif(n[0][3] == '.') cout << \"o\" << endl;\n\telse if(n[5][3] == '.') cout << \"m\" << endl;\n\telse cout << \"p\" << endl;\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的数数世界\n\n思维题，需要我们找出最终的胜利者\n\n只要这个数是奇数并且这个数除以2的结果也是偶数的话就是`Bing`，否则就是`Bong`\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tif(b / 2 % 2 == 1 || b % 2 == 1){\n\t\t\tcout << \"Bing\" << endl;\n\t\t} else {\n\t\t\tcout << \"Bong\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的蛋仔世界\n\n这题一看到需要向四个方位移动，我立马就想到了DFS，可是仔细读题后发现后并不需要。\n\n只需要判断某个点是否能在边界消失完到达中心点即可；该点到中心点的距离 = 横坐标之差 + 纵坐标之差\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b >> x;\n\tint midx = a / 2, midy = b / 2;\n\tint mcot = max(midx, midy);\n\twhile(x --){\n\t\tint n1, n2;\n\t\tcin >> n1 >> n2;\n\t\tn1 --, n2 --;\n\t\tint cot = fabs(n1 - midx) + fabs(n2 - midy);\n\t\tif(cot <= mcot) res ++;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### Bingbong的奇偶世界\n\n~~每次到差不多第三，四个题的位置总是会卡~~，这题我赛时的思路和题解的思路大差不差，估计某处细节没考虑不到导致一直卡。\n\n思路：比如当前点为`i`，那么这点之前的所有满足条件的个数有`pow(i - 1, 2) + 1 - 含有前导0的数` ，每次循环遍历的时候都需要判断是否是0、奇数、偶数。并且在每次循环的时候就需要维护`pow`和`前导0的数`这两个值，不能直接通过`pow`来计算因为会超时，我感觉我g应该就出在这里。\n\n我的代码\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot = 1, cc = 1;\n\tchar c;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> c;\n\t\tif((c - '0') % 2 == 0){\n\t\t\tn[i] = (n[i - 1] + cc + 1 - cot) % mod;\n\t\t\tif(c == '0'){\n\t\t\t\tcot = cot * 2 % mod;\n\t\t\t}\n\t\t} else {\n\t\t\tn[i] = n[i - 1];\n\t\t}\n\t\tcc = cc * 2 % mod;\n\t}\n\n\tcout << n[a] << endl; \n\treturn 0;\n}\n```\n\n正解\n\n思路是每次循环的时候就去掉了0的前导数的值，当不是0的时候就直接相加，不需要想我的思路那样单独来减，容易出错。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot = 0, cc = 0;\n\tchar c;\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> c;\n\t\tif(c == '0'){\n\t\t\tcot = (cot + cc + 1) % mod;\n\t\t\tcc = cc * 2 % mod; \n\t\t} else if((c - '0') % 2 == 0){\n\t\t\tcot = (cot + cc + 1) % mod;;\n\t\t\tcc = (cc * 2 + 1) % mod; \n\t\t} else {\n\t\t\tcc = (cc * 2 + 1) % mod;\n\t\t}\n\n\t}\n\n\tcout << cot << endl; \n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛91\n","category":[" 算法\n"],"date":" 2024-04-29\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n Bingbong的化学世界\n\n找出几个图形不同的点，根据不同的点来输出就很简单了\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tchar n77;\n\tforint i = 0; i < 6; i++{\n\t\tforint j = 0; j < 7; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\t\n\tifn03 == '.' cout << \"o\" << endl;\n\telse ifn53 == '.' cout << \"m\" << endl;\n\telse cout << \"p\" << endl;\n\t\n\treturn 0;\n}\n\n\n Bingbong的数数世界\n\n思维题，需要我们找出最终的胜利者\n\n只要这个数是奇数并且这个数除以2的结果也是偶数的话就是Bing，否则就是Bong\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tifb / 2 % 2 == 1  b % 2 == 1{\n\t\t\tcout << \"Bing\" << endl;\n\t\t} else {\n\t\t\tcout << \"Bong\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n\n Bingbong的蛋仔世界\n\n这题一看到需要向四个方位移动，我立马就想到了DFS，可是仔细读题后发现后并不需要。\n\n只需要判断某个点是否能在边界消失完到达中心点即可；该点到中心点的距离 = 横坐标之差 + 纵坐标之差\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b  x;\n\tint midx = a / 2, midy = b / 2;\n\tint mcot = maxmidx, midy;\n\twhilex {\n\t\tint n1, n2;\n\t\tcin  n1  n2;\n\t\tn1 , n2 ;\n\t\tint cot = fabsn1  midx + fabsn2  midy;\n\t\tifcot <= mcot res ++;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n Bingbong的奇偶世界\n\n每次到差不多第三，四个题的位置总是会卡，这题我赛时的思路和题解的思路大差不差，估计某处细节没考虑不到导致一直卡。\n\n思路：比如当前点为i，那么这点之前的所有满足条件的个数有powi  1, 2 + 1  含有前导0的数 ，每次循环遍历的时候都需要判断是否是0、奇数、偶数。并且在每次循环的时候就需要维护pow和前导0的数这两个值，不能直接通过pow来计算因为会超时，我感觉我g应该就出在这里。\n\n我的代码\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll cot = 1, cc = 1;\n\tchar c;\n\tforint i = 1; i <= a; i++{\n\t\tcin  c;\n\t\tifc  '0' % 2 == 0{\n\t\t\tni = ni  1 + cc + 1  cot % mod;\n\t\t\tifc == '0'{\n\t\t\t\tcot = cot  2 % mod;\n\t\t\t}\n\t\t} else {\n\t\t\tni = ni  1;\n\t\t}\n\t\tcc = cc  2 % mod;\n\t}\n\n\tcout << na << endl; \n\treturn 0;\n}\n\n\n正解\n\n思路是每次循环的时候就去掉了0的前导数的值，当不是0的时候就直接相加，不需要想我的思路那样单独来减，容易出错。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint mod = 1e9 + 7;\nll nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll cot = 0, cc = 0;\n\tchar c;\n\tforint i = 1; i <= a; i++{\n\t\tcin  c;\n\t\tifc == '0'{\n\t\t\tcot = cot + cc + 1 % mod;\n\t\t\tcc = cc  2 % mod; \n\t\t} else ifc  '0' % 2 == 0{\n\t\t\tcot = cot + cc + 1 % mod;;\n\t\t\tcc = cc  2 + 1 % mod; \n\t\t} else {\n\t\t\tcc = cc  2 + 1 % mod;\n\t\t}\n\n\t}\n\n\tcout << cot << endl; \n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-87","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛87\ncategory: 算法\ndate: 2024-04-25\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 小苯的石子游戏\n\n模拟两者选石头，判断最终结果\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b + 1);\n\t\tint l = 0, r = 0;\n\t\tfor(int i = 1; i <= b; i++) {\n\t\t\tcin >> v[i];\n\t\t} \n\t\tint idx = 1;\n\t\tfor(int i = b; i >= 1; i --){\n\t\t\tif(idx % 2 == 1) l += v[i];\n\t\t\telse r += v[i];\n\t\t\tidx ++;\n\t\t}\n\t\tcout << (l > r ? \"Alice\" : \"Bob\") << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的排序疑惑\n\n思维题，只需对数组的两边值进行考虑\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tvector<int> v(b);\n\t\tint minn = INT_MAX, maxx = 0; \n\t\tfor(int i = 0; i < b; i++) {\n\t\t\tcin >> v[i];\n\t\t\tif(i != 0){\n\t\t\t\tminn = min(minn, v[i]);\n\t\t\t}\n\t\t\tif(i != b - 1){\n\t\t\t\tmaxx = max(maxx, v[i]);\n\t\t\t}\n\t\t} \n\t\tcout << (v[0] <= minn || v[b - 1] >= maxx ? \"YES\" : \"NO\") << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的IDE括号问题（easy）\n\n使用两字符数组分别模拟 `I` 前后两个字符串的操作\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\nstring str, s;\nchar v[N], m[N]; \nint len1, len2, c1, c2;\n\nvoid fun1(){\n\tif(len1 >= 0 && len2 < c2){\n\t\tif(v[len1] == '(' && m[len2] == ')'){\n\t\t\tlen1 --;\n\t\t\tlen2 ++;\n\t\t} else {\n\t\t\tlen1 --;\n\t\t}\t\n\t} else {\n\t\tlen1 --;\n\t}\n\t\n}\n\nvoid fun2(){\n\tlen2 ++;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tcin >> str;\n\tint idx = 0, len = str.size();\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == 'I'){\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\tv[i] = str[i];\n\t\tc1 ++;\n\t}\n\tfor(int i = idx + 1; i < len; i++){\n\t\tm[i - idx - 1] = str[i];\n\t\tc2 ++;\n\t}\n\tlen1 = c1 - 1, len2 = 0;\n\twhile(b --){\n\t\tcin >> s;\n\t\tif(s[0] == 'b'){\n\t\t\tfun1();\n\t\t} else {\n\t\t\tfun2();\n\t\t}\n\t} \n\n\tfor(int i = 0; i <= len1; i++) cout << v[i];\n\tcout << \"I\";\n\tfor(int i = len2; i < c2; i++) cout << m[i]; \n\t\n\t\n\treturn 0;\n}\n```\n\n### 小苯的IDE括号问题（hard）\n\n这题与前一题的区别在于操作数增加了两个左移和右移，若再次使用数组的话不好模拟（需要遍历），于是采用两个双端队列进模拟（上一题也可以使用双端队列进行模拟）\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res = 0;\nstring str, s;\ndeque<char> d1, d2;\n\nvoid fun1(){\n\tint len1 = d1.size(), len2 = d2.size();\n\tif(len1 && len2){\n\t\tif(d1.back() == '(' && d2.front() == ')'){\n\t\t\td1.pop_back();\n\t\t\td2.pop_front();\n\t\t} else {\n\t\t\td1.pop_back();\n\t\t}\n\t} else if(len1) {\n\t\td1.pop_back();\n\t}\n\t\n}\n\nvoid fun2(){\n\tif(d2.size()){\n\t\td2.pop_front();\n\t}\n}\n\nvoid fun3(){\n\tif(d1.size()){\n\t\tchar c = d1.back();\n\t\td1.pop_back(); \n\t\td2.push_front(c);\n\t}\n}\n\nvoid fun4(){\n\tif(d2.size()){\n\t\tchar c = d2.front();\n\t\td2.pop_front();\n\t\td1.push_back(c);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tcin >> str;\n\tint idx = 0, len = a;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == 'I'){\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\td1.push_back(str[i]); \n\t}\n\tfor(int i = idx + 1; i < len; i++){\n\t\td2.push_back(str[i]);\n\t}\n\t\n\twhile(b --){\n\t\tcin >> s;\n\t\tif(s[0] == 'b'){\n\t\t\tfun1();\n\t\t} else if(s[0] == 'd'){\n\t\t\tfun2();\n\t\t} else if(s[0] == '<'){\n\t\t\tfun3();\n\t\t} else{\n\t\t\tfun4();\n\t\t}\n\t} \n\n\twhile(d1.size()){\n\t\tcout << d1.front();\n\t\td1.pop_front();\n\t}\n\tcout << \"I\";\n\twhile(d2.size()){\n\t\tcout << d2.front();\n\t\td2.pop_front();\n\t}\n\t\t\n\treturn 0;\n}\n```\n\n### 小苯的数组构造\n\n遍历每个数，找出每个数前的各个最大值（不断维护），相减即可\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<ll> v(a + 1);\n\tv[0] = -10e9 - 10;\n\tint flag = 1; \n\tfor(int i = 1; i <= a; i++) {\n\t\tcin >> v[i];\n\t\tif(i != 0 && v[i] < v[i - 1]){\n\t\t\tflag = 0;\n\t\t} \t\n\t}\n\tif(flag) {\n\t\tfor(int i = 1; i <= a; i++){\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tif(v[i] >= v[i - 1]) cout << 0 << \" \";\n\t\telse {\n\t\t\tcout << v[i - 1] - v[i] << \" \";\n\t\t\tv[i] = v[i - 1];\n\t\t}\n\t}\t\n\t\t\t\n\treturn 0;\n}\n```\n\n### 小苯的数组切分\n\n思维题，分别考虑 & ^ | 这三种运算符\n\n- 对于 &，无论有多少个数相互 & 操作，结果都是越来越小\n- 对于 ^，若有两个相同的数进行 ^，则结果为0\n\n只要知道上面这两个，那么就可以确定右端点这一个数进行 &，剩下的 0, a - 1区间就用维护出 ^ 和 | 这两种操作的最大之和，加上右端点的值就是结果\n\n> 对于维护 0, a - 1这个区间，可以考虑先遍历 0 , a - 1，对每个数进行取 ^ 运算得到一个结果l，再反向遍历 a - 1, 0 若想不让这个数取 ^，可以对 l 对这个数进行取 ^ ，因为开始已经取过一边了，再取一边就是0相当于没取。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll res = 0;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++) cin >> v[i]; \n\tll l = v[0], r = v[a - 2];\n\tfor(int i = 1; i < a - 1; i++) l ^= v[i];\n\tfor(int i = a - 2; i >= 0; i--){\n\t\tl ^= v[i];\n\t\tr |= v[i];\n\t\tres = max(res, l + r);\n\t}\n\t\n\tcout << res + v[a - 1] << endl;\n\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛87\n","category":[" 算法\n"],"date":" 2024-04-25\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 小苯的石子游戏\n\n模拟两者选石头，判断最终结果\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tvector<int vb + 1;\n\t\tint l = 0, r = 0;\n\t\tforint i = 1; i <= b; i++ {\n\t\t\tcin  vi;\n\t\t} \n\t\tint idx = 1;\n\t\tforint i = b; i = 1; i {\n\t\t\tifidx % 2 == 1 l += vi;\n\t\t\telse r += vi;\n\t\t\tidx ++;\n\t\t}\n\t\tcout << l  r ? \"Alice\" : \"Bob\" << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n\n\n 小苯的排序疑惑\n\n思维题，只需对数组的两边值进行考虑\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tvector<int vb;\n\t\tint minn = INTMAX, maxx = 0; \n\t\tforint i = 0; i < b; i++ {\n\t\t\tcin  vi;\n\t\t\tifi = 0{\n\t\t\t\tminn = minminn, vi;\n\t\t\t}\n\t\t\tifi = b  1{\n\t\t\t\tmaxx = maxmaxx, vi;\n\t\t\t}\n\t\t} \n\t\tcout << v0 <= minn  vb  1 = maxx ? \"YES\" : \"NO\" << endl;\n\t} \n\t\t\t\n\treturn 0;\n}\n\n\n 小苯的IDE括号问题（easy）\n\n使用两字符数组分别模拟 I 前后两个字符串的操作\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\nstring str, s;\nchar vN, mN; \nint len1, len2, c1, c2;\n\nvoid fun1{\n\tiflen1 = 0 && len2 < c2{\n\t\tifvlen1 == '' && mlen2 == ''{\n\t\t\tlen1 ;\n\t\t\tlen2 ++;\n\t\t} else {\n\t\t\tlen1 ;\n\t\t}\t\n\t} else {\n\t\tlen1 ;\n\t}\n\t\n}\n\nvoid fun2{\n\tlen2 ++;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tcin  str;\n\tint idx = 0, len = str.size;\n\tforint i = 0; i < len; i++{\n\t\tifstri == 'I'{\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\tvi = stri;\n\t\tc1 ++;\n\t}\n\tforint i = idx + 1; i < len; i++{\n\t\tmi  idx  1 = stri;\n\t\tc2 ++;\n\t}\n\tlen1 = c1  1, len2 = 0;\n\twhileb {\n\t\tcin  s;\n\t\tifs0 == 'b'{\n\t\t\tfun1;\n\t\t} else {\n\t\t\tfun2;\n\t\t}\n\t} \n\n\tforint i = 0; i <= len1; i++ cout << vi;\n\tcout << \"I\";\n\tforint i = len2; i < c2; i++ cout << mi; \n\t\n\t\n\treturn 0;\n}\n\n\n 小苯的IDE括号问题（hard）\n\n这题与前一题的区别在于操作数增加了两个左移和右移，若再次使用数组的话不好模拟（需要遍历），于是采用两个双端队列进模拟（上一题也可以使用双端队列进行模拟）\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res = 0;\nstring str, s;\ndeque<char d1, d2;\n\nvoid fun1{\n\tint len1 = d1.size, len2 = d2.size;\n\tiflen1 && len2{\n\t\tifd1.back == '' && d2.front == ''{\n\t\t\td1.popback;\n\t\t\td2.popfront;\n\t\t} else {\n\t\t\td1.popback;\n\t\t}\n\t} else iflen1 {\n\t\td1.popback;\n\t}\n\t\n}\n\nvoid fun2{\n\tifd2.size{\n\t\td2.popfront;\n\t}\n}\n\nvoid fun3{\n\tifd1.size{\n\t\tchar c = d1.back;\n\t\td1.popback; \n\t\td2.pushfrontc;\n\t}\n}\n\nvoid fun4{\n\tifd2.size{\n\t\tchar c = d2.front;\n\t\td2.popfront;\n\t\td1.pushbackc;\n\t}\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tcin  str;\n\tint idx = 0, len = a;\n\tforint i = 0; i < len; i++{\n\t\tifstri == 'I'{\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t\td1.pushbackstri; \n\t}\n\tforint i = idx + 1; i < len; i++{\n\t\td2.pushbackstri;\n\t}\n\t\n\twhileb {\n\t\tcin  s;\n\t\tifs0 == 'b'{\n\t\t\tfun1;\n\t\t} else ifs0 == 'd'{\n\t\t\tfun2;\n\t\t} else ifs0 == '<'{\n\t\t\tfun3;\n\t\t} else{\n\t\t\tfun4;\n\t\t}\n\t} \n\n\twhiled1.size{\n\t\tcout << d1.front;\n\t\td1.popfront;\n\t}\n\tcout << \"I\";\n\twhiled2.size{\n\t\tcout << d2.front;\n\t\td2.popfront;\n\t}\n\t\t\n\treturn 0;\n}\n\n\n 小苯的数组构造\n\n遍历每个数，找出每个数前的各个最大值（不断维护），相减即可\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<ll va + 1;\n\tv0 = 10e9  10;\n\tint flag = 1; \n\tforint i = 1; i <= a; i++ {\n\t\tcin  vi;\n\t\tifi = 0 && vi < vi  1{\n\t\t\tflag = 0;\n\t\t} \t\n\t}\n\tifflag {\n\t\tforint i = 1; i <= a; i++{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\treturn 0;\n\t}\n\tforint i = 1; i <= a; i++{\n\t\tifvi = vi  1 cout << 0 << \" \";\n\t\telse {\n\t\t\tcout << vi  1  vi << \" \";\n\t\t\tvi = vi  1;\n\t\t}\n\t}\t\n\t\t\t\n\treturn 0;\n}\n\n\n 小苯的数组切分\n\n思维题，分别考虑 & ^  这三种运算符\n\n 对于 &，无论有多少个数相互 & 操作，结果都是越来越小\n 对于 ^，若有两个相同的数进行 ^，则结果为0\n\n只要知道上面这两个，那么就可以确定右端点这一个数进行 &，剩下的 0, a  1区间就用维护出 ^ 和  这两种操作的最大之和，加上右端点的值就是结果\n\n 对于维护 0, a  1这个区间，可以考虑先遍历 0 , a  1，对每个数进行取 ^ 运算得到一个结果l，再反向遍历 a  1, 0 若想不让这个数取 ^，可以对 l 对这个数进行取 ^ ，因为开始已经取过一边了，再取一边就是0相当于没取。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll res = 0;\n\tvector<int va;\n\tforint i = 0; i < a; i++ cin  vi; \n\tll l = v0, r = va  2;\n\tforint i = 1; i < a  1; i++ l ^= vi;\n\tforint i = a  2; i = 0; i{\n\t\tl ^= vi;\n\t\tr = vi;\n\t\tres = maxres, l + r;\n\t}\n\t\n\tcout << res + va  1 << endl;\n\t\n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-86","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛86\ncategory: 算法\ndate: 2024-04-23\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\nABC题能够轻松通过，后面的题就卡了\n\n### 水盐平衡\n\n简单模拟题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num;\n\tcin >> num;\n\twhile(num --){\n\t\tcin >> a >> b >> x >> y;\n\t\tdouble _1 = a * 1.0 / b, _2 = x * 1.0 / y;\n\t\tif(_1 > _2) cout << \"S\" << endl;\n\t\telse cout << \"Y\" << endl; \n\t} \n\t\t\n\treturn 0;\n}\n```\n\n### 水平考试\n\n这题有个巧妙的地方在于多选题不会出现得分为5的情况，因为不可能出现部分正确，只要有部分正确小灰灰就会把他修改为全部正确\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num;\n\tcin >> num;\n\twhile(num --){\n\t\tstring s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tint len1 = s1.size(), len2 = s2.size();\n\t\tif(len1 > len2){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(len2 == 1){\n\t\t\tif(s1[0] == s2[0]) cout << \"10\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tunordered_map<char, int> ump;\n\t\tfor(int i = 0; i < len2; i++){\n\t\t\tump[s2[i]] ++;\n\t\t}\n\t\tint flag = 0, flag2 = 1;\n\t\tfor(int i = 0; i < len1; i++){\n\t\t\tif(!ump[s1[i]]){\n\t\t\t\tflag2 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag2){\n\t\t\tcout << 10 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n//\t\tflag = 0, flag2 = 1;\n//\t\tfor(int i = 0; i < len1; i++){\n//\t\t\tif(ump[s1[i]]){\n//\t\t\t\tflag = 1;\t\n//\t\t\t} else {\n//\t\t\t\tflag2 = 0;\n//\t\t\t}\n//\t\t}\n//\t\tif(flag && !flag2){\n//\t\t\tcout << 0 << endl;\n//\t\t} else if(flag && flag2){\n//\t\t\tcout << 5 << endl;\n//\t\t} else cout << 0 << endl;\n\t} \n\t\n\t\t\n\treturn 0;\n}\n```\n\n### 数组段数 \n\n模拟题，需要注意的点是若是出现当前下标的和和上一位数的和一致的时候，就说明这段是相同，需要向前找到不一致的和\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<int> v(a + 1), m(a + 1);\n\tfor(int i = 1; i <= a; i++){\n\t\tcin >> v[i];\n\t\tif(i == 1){\n\t\t\tm[i] = 1;\n\t\t} else {\n\t\t\tif(v[i] == v[i - 1]){\n\t\t\t\tm[i] = m[i - 1];\t\n\t\t\t} else {\n\t\t\t\tm[i] = m[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i = 1; i <= a; i++) cout << m[i] << \" \";\n//\tcout << endl;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\twhile(v[x] == v[x - 1]){\n\t\t\tx --;\n\t\t}\n//\t\tcout << x << \" \" << y << \" \" << m[x] << \" \" << m[y] << endl;\n\t\tcout << m[y] - m[x - 1] << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 剪纸游戏\n\n这题我的思路是默认当前点位最小x和最小y的值，然后BFS遍历，找出最大x和最大y，然后计算这块区间的所有坐标是否都标记过了。但是后面看题解发现这样是不对的。若是出现 `_|` 这种的图形就会统计出错，我的思路会将其算成一个长方形，但显然不是。\n\n正解：BFS同时算出最小x，最小y，最大x，最大y，并统计标记过了的数量，通过计算这块区间数量是否等于BFS遍历标记的数量，若相同就说明是长方形，否则就不是。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nchar v[1010][1010];\nint st[1010][1010];\nint mmx, mmy, iix, iiy;\n\nint dfs(int x, int y){\n\tmmx = max(mmx, x);\n\tmmy = max(mmy, y);\n\tiix = min(iix, x);\n\tiiy = min(iiy, y);\n\tint cot = 0;\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = x + ix[i], yy = y + iy[i];\n\t\tif(xx >= 1 && xx <= a && yy >= 1 && yy <= b && !st[xx][yy] && v[xx][yy] == '.'){\n\t\t\tst[xx][yy] = 1;\n\t\t\tcot += dfs(xx, yy) + 1;\n\t\t}\n\t}\n\treturn cot;\n}\n\nint check(int x, int y, int ex, int ey){\n\tfor(int i = x; i <= ex; i++){\n\t\tfor(int j = y; j <= ey; j++){\n\t\t\tif(!st[i][j]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\t for(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tif(v[i][j] == '.' && !st[i][j]){\n\t\t\t\tmmx = 0, mmy = 0, iix = i, iiy = j;\n\t\t\t\tst[i][j] = 1;\n\t\t\t\tint cot = dfs(i, j) + 1;\n\t\t\t\tif(cot == (mmx - iix + 1) * (mmy - iiy + 1)){\n\t\t\t\t\tres ++; \n\t\t\t\t}\n//\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << \" \" << iix << \" \" << iiy << \" \" << cot << endl;\n//\t\t\t\tif(check(i, j, mmx, mmy)){\n//\t\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << endl;\n//\t\t\t\t\tres ++;\n//\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n```\n\n### 可口蛋糕\n\n前缀和+双指针+小贪心题\n\n用l，r代表两个双指针，先找出r（第一个出现大于W的下标），不断维护 v[r] - v[l] 大于等于W的区间，找出最小可口值的前缀和（贪心），用前缀和算出区间的饱腹值，得出最大的一个。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tvector<ll> v(a + 1), m(a + 1);\n\tv[0] = 0, m[0] = 0;\n\tfor(int i = 1; i <= a; i++) cin >> v[i], v[i] += v[i - 1];\n\tfor(int i = 1; i <= a; i++) cin >> m[i], m[i] += m[i - 1];\n\tll l = 0, r = 0, minn = 1e18, res = -1e18;\n\tfor(int i = 1; i <= a; i++){\n\t\tif(v[i] >= b){\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(r <= a){\n//\t\tcout << v[r] << \" \" << v[l] << endl;\n\t\twhile(v[r] - v[l] >= b){\n\t\t\tminn = min(minn, m[l]); \n\t\t\tl ++;\n\t\t}\n//\t\tcout << minn << \" \" << m[r] << \" \" << m[r] - minn << endl;\n\t\tres = max(res, m[r] - minn);\n\t\tr ++;\n\t}\n\t\n\tcout << res << endl;\n\t\n\t\t\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛86\n","category":[" 算法\n"],"date":" 2024-04-23\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\nABC题能够轻松通过，后面的题就卡了\n\n 水盐平衡\n\n简单模拟题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint num;\n\tcin  num;\n\twhilenum {\n\t\tcin  a  b  x  y;\n\t\tdouble 1 = a  1.0 / b, 2 = x  1.0 / y;\n\t\tif1  2 cout << \"S\" << endl;\n\t\telse cout << \"Y\" << endl; \n\t} \n\t\t\n\treturn 0;\n}\n\n\n 水平考试\n\n这题有个巧妙的地方在于多选题不会出现得分为5的情况，因为不可能出现部分正确，只要有部分正确小灰灰就会把他修改为全部正确\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint num;\n\tcin  num;\n\twhilenum {\n\t\tstring s1, s2;\n\t\tcin  s1  s2;\n\t\tint len1 = s1.size, len2 = s2.size;\n\t\tiflen1  len2{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tiflen2 == 1{\n\t\t\tifs10 == s20 cout << \"10\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tunorderedmap<char, int ump;\n\t\tforint i = 0; i < len2; i++{\n\t\t\tumps2i ++;\n\t\t}\n\t\tint flag = 0, flag2 = 1;\n\t\tforint i = 0; i < len1; i++{\n\t\t\tifumps1i{\n\t\t\t\tflag2 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tifflag2{\n\t\t\tcout << 10 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n//\t\tflag = 0, flag2 = 1;\n//\t\tforint i = 0; i < len1; i++{\n//\t\t\tifumps1i{\n//\t\t\t\tflag = 1;\t\n//\t\t\t} else {\n//\t\t\t\tflag2 = 0;\n//\t\t\t}\n//\t\t}\n//\t\tifflag && flag2{\n//\t\t\tcout << 0 << endl;\n//\t\t} else ifflag && flag2{\n//\t\t\tcout << 5 << endl;\n//\t\t} else cout << 0 << endl;\n\t} \n\t\n\t\t\n\treturn 0;\n}\n\n\n 数组段数 \n\n模拟题，需要注意的点是若是出现当前下标的和和上一位数的和一致的时候，就说明这段是相同，需要向前找到不一致的和\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<int va + 1, ma + 1;\n\tforint i = 1; i <= a; i++{\n\t\tcin  vi;\n\t\tifi == 1{\n\t\t\tmi = 1;\n\t\t} else {\n\t\t\tifvi == vi  1{\n\t\t\t\tmi = mi  1;\t\n\t\t\t} else {\n\t\t\t\tmi = mi  1 + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tforint i = 1; i <= a; i++ cout << mi << \" \";\n//\tcout << endl;\n\twhileb {\n\t\tcin  x  y;\n\t\twhilevx == vx  1{\n\t\t\tx ;\n\t\t}\n//\t\tcout << x << \" \" << y << \" \" << mx << \" \" << my << endl;\n\t\tcout << my  mx  1 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n 剪纸游戏\n\n这题我的思路是默认当前点位最小x和最小y的值，然后BFS遍历，找出最大x和最大y，然后计算这块区间的所有坐标是否都标记过了。但是后面看题解发现这样是不对的。若是出现  这种的图形就会统计出错，我的思路会将其算成一个长方形，但显然不是。\n\n正解：BFS同时算出最小x，最小y，最大x，最大y，并统计标记过了的数量，通过计算这块区间数量是否等于BFS遍历标记的数量，若相同就说明是长方形，否则就不是。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nchar v10101010;\nint st10101010;\nint mmx, mmy, iix, iiy;\n\nint dfsint x, int y{\n\tmmx = maxmmx, x;\n\tmmy = maxmmy, y;\n\tiix = miniix, x;\n\tiiy = miniiy, y;\n\tint cot = 0;\n\tforint i = 0; i < 4; i++{\n\t\tint xx = x + ixi, yy = y + iyi;\n\t\tifxx = 1 && xx <= a && yy = 1 && yy <= b && stxxyy && vxxyy == '.'{\n\t\t\tstxxyy = 1;\n\t\t\tcot += dfsxx, yy + 1;\n\t\t}\n\t}\n\treturn cot;\n}\n\nint checkint x, int y, int ex, int ey{\n\tforint i = x; i <= ex; i++{\n\t\tforint j = y; j <= ey; j++{\n\t\t\tifstij{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcin  vij;\n\t\t}\n\t}\n\t forint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tifvij == '.' && stij{\n\t\t\t\tmmx = 0, mmy = 0, iix = i, iiy = j;\n\t\t\t\tstij = 1;\n\t\t\t\tint cot = dfsi, j + 1;\n\t\t\t\tifcot == mmx  iix + 1  mmy  iiy + 1{\n\t\t\t\t\tres ++; \n\t\t\t\t}\n//\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << \" \" << iix << \" \" << iiy << \" \" << cot << endl;\n//\t\t\t\tifchecki, j, mmx, mmy{\n//\t\t\t\t\tcout << i << \" \" << j << \" \" << mmx << \" \" << mmy << endl;\n//\t\t\t\t\tres ++;\n//\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tcout << res << endl;\n\t\n\t\n\treturn 0;\n}\n\n\n 可口蛋糕\n\n前缀和+双指针+小贪心题\n\n用l，r代表两个双指针，先找出r（第一个出现大于W的下标），不断维护 vr  vl 大于等于W的区间，找出最小可口值的前缀和（贪心），用前缀和算出区间的饱腹值，得出最大的一个。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tvector<ll va + 1, ma + 1;\n\tv0 = 0, m0 = 0;\n\tforint i = 1; i <= a; i++ cin  vi, vi += vi  1;\n\tforint i = 1; i <= a; i++ cin  mi, mi += mi  1;\n\tll l = 0, r = 0, minn = 1e18, res = 1e18;\n\tforint i = 1; i <= a; i++{\n\t\tifvi = b{\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhiler <= a{\n//\t\tcout << vr << \" \" << vl << endl;\n\t\twhilevr  vl = b{\n\t\t\tminn = minminn, ml; \n\t\t\tl ++;\n\t\t}\n//\t\tcout << minn << \" \" << mr << \" \" << mr  minn << endl;\n\t\tres = maxres, mr  minn;\n\t\tr ++;\n\t}\n\t\n\tcout << res << endl;\n\t\n\t\t\n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-85","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛85\ncategory: 算法\ndate: 2024-04-18\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本场比赛做下来大多都是思维题，就当是锻炼思维了\n\n### ACCEPT\n\n签到题，一开始想复杂了，想依次循环遍历来计算每个字母出现的次数，再取出最小的次数。在对于C的次数的取值上费了很长一段时间，后面灵光一线，几行代码搞定\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\nint check(unordered_map<char, int> ump){\n\treturn min(ump['A'], min(ump['C'] / 2, min(ump['E'], min(ump['P'], ump['T']))));\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> b;\n\t\tstring str;\n\t\tcin >> str;\n\t\tint res = INT_MAX, cot = 0;\n\t\tchar minc;\n\t\tunordered_map<char, int> ump; \n\t\tfor(int i = 0; i < b; i++){\n\t\t\tump[str[i]] ++;\n//\t\t\tif(ump[str[i]] == 1) cot ++;\n//\t\t\tif(ump[str[i]] == 2 && str[i] == 'C') cot ++;\n//\t\t\tif(ump[str[i]] > res){\n//\t\t\t\t\n//\t\t\t\tif(str[i] == 'C'){\n//\t\t\t\t\tif(str[i] == minc && ump[str[i]] % 2 == 0) res ++;\n//\t\t\t\t} else{\n//\t\t\t\t\tif(str[i] == minc) res ++; \n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t} else if(res > ump[str[i]]){\n//\t\t\t\tminc = str[i];\n//\t\t\t\tif(str[i] == 'C') res = 0;\n//\t\t\t\telse res = ump[str[i]];\t\n//\t\t\t}\n//\t\t\tif(str[i] == 'C'){\n//\t\t\t\tif(minc == 'C' && ump[str[i]] % 2 == 0) res ++;\n//\t\t\t\telse res = min(res, ump[str[i]] / 2);\n//\t\t\t} else {\n//\t\t\t\tres = min(ump[str[i]], res);\n//\t\t\t}\n//\t\t\tcout << res << \" \"<< ump[str[i]]<<\" \"<<minc << endl;\n\t\t}\n\t\tcout << check(ump) << endl;\n//\t\tif(cot < 6) cout << 0 << endl;\n//\t\telse cout << res << endl;\n\t}\n \n\treturn 0;\n}\t\n```\n\n### 咕呱蛙\n\n这题就是看思维了，从前几个满足条件的数中找出规律，只有 4i + 2 和 4i + 3的数满足条件，于是考虑这两个数出现位置\n\n对于 4i + 2，直接就是 2n，对于4i + 3，也是很快知道为 2n + 1\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n   \tll x;\n   \tcin >> x;\n\tif(x % 2 == 0) cout << 2 * x << endl;\n\telse cout << 2 * x  + 1 << endl; \n}\n```\n\n### 得分显示\n\n这题题意很简单，但是很难想到一点就是，因为是递增的，所以后面出现的数x对于前面出现n个数满足，每次增加都不能超过x/n。 \n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  \tcin >> a;\n  \tint num;\n  \tdouble res = 1e9 + 1;\n  \tfor(int i = 1; i <= a; i++){\n  \t\tcin >> num;\t\n  \t\tres = min(res, (num + 0.9999999999999) / i);\n\t}\n\tprintf(\"%.10lf\", res);\n}\n```\n\n### 阿里马马与四十大盗\n\n这题用了贪心的思想，对于某个0补充到最大值后，若后面的数之和都小于这个最大值，则后面的0就不用管了无需补充；于是这个某个0之前的0都需要补充到最大值\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\nint v[N];\nll m[N];\nll fun(int x){\n\treturn m[a] - m[x];\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tll res = 0, is = 0, cot = b, flag = 0;\n\tfor(int i = 1; i <= a; i ++){\n\t\tcin >> v[i]; \t\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tm[i] = m[i - 1] + v[i];\n\t}\n\tfor(int i = 1; i <= a - 1; i ++){ \n\t\tif(v[i] == 0){\n\t\t\tres += b - cot;\n\t\t\tcot = b; \t\n\t\t\tif(cot > fun(i)){\n\t\t\t\tcout << res + a - 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcot -= v[i];\n\t\t\tif(cot <= 0){\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tcout << res + a - 1 << endl;\n\t\n    return 0;\n}\n```\n\n","title":" 牛客小白月赛85\n","category":[" 算法\n"],"date":" 2024-04-18\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n本场比赛做下来大多都是思维题，就当是锻炼思维了\n\n ACCEPT\n\n签到题，一开始想复杂了，想依次循环遍历来计算每个字母出现的次数，再取出最小的次数。在对于C的次数的取值上费了很长一段时间，后面灵光一线，几行代码搞定\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\nint checkunorderedmap<char, int ump{\n\treturn minump'A', minump'C' / 2, minump'E', minump'P', ump'T';\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  b;\n\t\tstring str;\n\t\tcin  str;\n\t\tint res = INTMAX, cot = 0;\n\t\tchar minc;\n\t\tunorderedmap<char, int ump; \n\t\tforint i = 0; i < b; i++{\n\t\t\tumpstri ++;\n//\t\t\tifumpstri == 1 cot ++;\n//\t\t\tifumpstri == 2 && stri == 'C' cot ++;\n//\t\t\tifumpstri  res{\n//\t\t\t\t\n//\t\t\t\tifstri == 'C'{\n//\t\t\t\t\tifstri == minc && umpstri % 2 == 0 res ++;\n//\t\t\t\t} else{\n//\t\t\t\t\tifstri == minc res ++; \n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t} else ifres  umpstri{\n//\t\t\t\tminc = stri;\n//\t\t\t\tifstri == 'C' res = 0;\n//\t\t\t\telse res = umpstri;\t\n//\t\t\t}\n//\t\t\tifstri == 'C'{\n//\t\t\t\tifminc == 'C' && umpstri % 2 == 0 res ++;\n//\t\t\t\telse res = minres, umpstri / 2;\n//\t\t\t} else {\n//\t\t\t\tres = minumpstri, res;\n//\t\t\t}\n//\t\t\tcout << res << \" \"<< umpstri<<\" \"<<minc << endl;\n\t\t}\n\t\tcout << checkump << endl;\n//\t\tifcot < 6 cout << 0 << endl;\n//\t\telse cout << res << endl;\n\t}\n \n\treturn 0;\n}\t\n\n\n 咕呱蛙\n\n这题就是看思维了，从前几个满足条件的数中找出规律，只有 4i + 2 和 4i + 3的数满足条件，于是考虑这两个数出现位置\n\n对于 4i + 2，直接就是 2n，对于4i + 3，也是很快知道为 2n + 1\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n   \tll x;\n   \tcin  x;\n\tifx % 2 == 0 cout << 2  x << endl;\n\telse cout << 2  x  + 1 << endl; \n}\n\n\n 得分显示\n\n这题题意很简单，但是很难想到一点就是，因为是递增的，所以后面出现的数x对于前面出现n个数满足，每次增加都不能超过x/n。 \n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n  \tcin  a;\n  \tint num;\n  \tdouble res = 1e9 + 1;\n  \tforint i = 1; i <= a; i++{\n  \t\tcin  num;\t\n  \t\tres = minres, num + 0.9999999999999 / i;\n\t}\n\tprintf\"%.10lf\", res;\n}\n\n\n 阿里马马与四十大盗\n\n这题用了贪心的思想，对于某个0补充到最大值后，若后面的数之和都小于这个最大值，则后面的0就不用管了无需补充；于是这个某个0之前的0都需要补充到最大值\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\nint vN;\nll mN;\nll funint x{\n\treturn ma  mx;\n}\n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tll res = 0, is = 0, cot = b, flag = 0;\n\tforint i = 1; i <= a; i ++{\n\t\tcin  vi; \t\n\t}\n\tforint i = 1; i <= a; i++{\n\t\tmi = mi  1 + vi;\n\t}\n\tforint i = 1; i <= a  1; i ++{ \n\t\tifvi == 0{\n\t\t\tres += b  cot;\n\t\t\tcot = b; \t\n\t\t\tifcot  funi{\n\t\t\t\tcout << res + a  1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcot = vi;\n\t\t\tifcot <= 0{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tcout << res + a  1 << endl;\n\t\n    return 0;\n}\n\n\n"},{"filename":"12th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十二届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-04-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 空间\n\n单位换算题\n\n1比特 = 8位\n\n256 * 1024 * 1024 / 4\n\n### 卡片\n\n模拟题\n\n需要注意的的是答案是输出能够拼到多少，而不是拼完的那个数，所以需要答案 - 1\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint n[10];\n\tfor(int i = 0; i <= 9; i++){\n\t\tn[i] = 2021;\n\t}\t\n\tint idx = 1;\n\twhile(true){\n\t\tint c = idx, flag = 0;\n\t\twhile(c){\n\t\t\tif(n[c % 10] == 0){\n\t\t\t\tcout << idx - 1 << endl;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn[c % 10] --;\n\t\t\tc /= 10;\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tidx ++;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 直线\n\n模拟、数学题\n\n需要注意直线的公式：y = kx + b\n\n斜率：k = (y1 - y2) / (x1 - x2)\n\n截距：b = (y1 * x2 - y2 * x1) / (x2 - x1)\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<double, double>, int> mp;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tfor(int i = 0; i < 20; i++){\n\t\tres ++;\n\t}\n\tfor(int i = 0; i < 21; i++){\n\t\tres ++;\n\t}\n\t\n\tfor(int i = 0; i < 20; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tfor(int x = i + 1; x < 20; x++){\n\t\t\t\tfor(int y = 0; y < 21; y++){\n\t\t\t\t\tif(i != x && j != y){\n\t\t\t\t\t\tdouble num = (j - y) * 1.0 / (i - x);\t\n\t\t\t\t\t\tdouble val = (i * y - j * x) * 1.0 / (i - x);\n\t\t\t\t\t\tif(mp.find({num, val}) == mp.end()){\n\t\t\t\t\t\t\tmp[{num, val}] = 1;\n\t\t\t\t\t\t\tres ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 货物摆放\n\n枚举、数学知识**因数**题\n\n找出2021041820210418所有的因数，从因数中找出满足条件的即可，极大的缩减了遍历范围\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<ll, ll>, ll> map;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t vector<ll> v;\n    \n    ll a = 2021041820210418;\n    ll res = 0;\n    \n    for(ll i = 1; i * i <= a; i++){\n        if(a % i == 0) {\n            v.push_back(i);    \n            if(i * i != a){\n                v.push_back(a / i);\n            }\n        }\n    }\n    \n    for(ll i = 0; i < v.size(); i++){\n        for(ll j = 0; j < v.size(); j++){\n            for(ll m = 0; m < v.size(); m++){    \n                if(v[i] * v[j] * v[m] == a) res++;\n            }\n        }\n        \n    }\n    cout << res;\n\treturn 0;\n}\n```\n\n### 路径\n\n图论、数学知识题\n\n迪杰斯特拉模板题，最小公倍数模板\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<ll, ll>, ll> map;\nint w[N], idx, h[N], ne[N], e[N], dis[N], st[N];\n\nvoid add(int x, int y, int z){\n\te[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++;\n}\n\nint fun1(int x, int y){\n\treturn y == 0 ? x : fun1(y, x % y);\n}\n\nint fun2(int x, int y){\n\treturn x / fun1(x, y) * y;\t\n}\n\nint dj(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tpriority_queue<PII, vector<PII>, greater<PII>> pq;\n\tpq.push({1, 0});\n\twhile(!pq.empty()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tint x = top.first, y = top.second;\n\t\tif(st[x]) continue;\n\t\tst[x] = 1;\n\t\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\tif(dis[j] > y + w[i]){\n\t\t\t\tdis[j] = y + w[i];\n\t\t\t\tpq.push({j, dis[j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2021] == 0x3f3f3f3f) return -1;\n    return dis[2021];\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tmemset(h, -1, sizeof h);\n\n\tfor(int i = 1; i <= 2021; i++){\n\t\tfor(int j = i + 1; j <= 2021; j++){\n\t\t\tif(j - i <= 21){\n\t\t\t\tint c = fun2(i, j);\n\t\t\t\tadd(i, j, c);\n\t\t\t\tadd(j, i, c);\t\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} \n\tcout << dj();\n\t\n\treturn 0;\n}\n```\n\n### 时间显示\n\n单位换算题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll num;\n\tcin >> num;\n\tint dv = 1000 * 3600 * 24;\n\tnum = num % dv;\n\tint sv = num / 1000;\n\tint h = sv / 3600;\n\tint m = sv % 3600 / 60;\n\tint s = sv % 3600 % 60;\n\tprintf(\"%02d:%02d:%02d\\n\", h, m, s);\n\t\n\treturn 0;\n}\n```\n\n### 砝码称重\n\nset模拟DFS遍历，巧解此题\n\n正解为动态规划\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a);\n\tset<int> s;\n\tfor(int i = 0; i < a; i++) cin >> v[i];\n\tfor(int i = 0; i < a; i++){\n\t\tset<int> ss;\n\t\tfor(int j: s){\n\t\t\tss.insert(j + v[i]);\n\t\t\tif(j - v[i] > 0) ss.insert(j - v[i]);\n\t\t\tif(v[i] - j > 0) ss.insert(v[i] - j);\n\t\t}\n\t\tfor(int j: ss){\n\t\t\ts.insert(j);\t\n\t\t}\n\t\ts.insert(v[i]);\n\t}\n\tcout << s.size() << endl;\n\n\treturn 0;\n}\n```\n\n### 杨辉三角形\n\n技巧、二分题\n\n暴力能够 40% 的分数\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nmap<PII, int> mp; \nmap<int, int> smp;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tif(a == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmp[{1, 1}] = 1;\n\tint flag = 0;\n\tll res = 1;\n\tfor(int i = 2; ;i++){\n\t\tfor(int j = 1; j <= i;j ++){\n\t\t\tint cot;\n\t\t\tif(j == 1){\n\t\t\t\tcot = 1; \n\t\t\t} else {\n\t\t\t\tcot = mp[{i - 1, j}] + mp[{i - 1, j - 1}];\n\t\t\t}\n\t\t\tres ++;\n\t\t\tmp[{i, j}] = cot;\n\t\t\tif(cot == a && smp.find(cot) == smp.end()){\n\t\t\t\tflag = 1;\n\t\t\t\tcout << res << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n### 双向排序\n\nsort暴力能够 60% 题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++) n[i] = i + 1;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tif(x == 0){\n\t\t\tsort(n, n + y, greater<int>());\n\t\t} else {\n\t\t\tsort(n + y - 1, n + a);\n\t\t}\n\n\t}\n\t\n\tfor(int i = 0; i < a; i++) cout << n[i] << \" \"; \n\treturn 0;\n}\n```\n\n","title":" 第十二届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-04-09\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 空间\n\n单位换算题\n\n1比特 = 8位\n\n256  1024  1024 / 4\n\n 卡片\n\n模拟题\n\n需要注意的的是答案是输出能够拼到多少，而不是拼完的那个数，所以需要答案  1\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint n10;\n\tforint i = 0; i <= 9; i++{\n\t\tni = 2021;\n\t}\t\n\tint idx = 1;\n\twhiletrue{\n\t\tint c = idx, flag = 0;\n\t\twhilec{\n\t\t\tifnc % 10 == 0{\n\t\t\t\tcout << idx  1 << endl;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc % 10 ;\n\t\t\tc /= 10;\n\t\t}\n\t\tifflag{\n\t\t\tbreak;\n\t\t}\n\t\tidx ++;\n\t}\n\t\n\treturn 0;\n}\n\n\n 直线\n\n模拟、数学题\n\n需要注意直线的公式：y = kx + b\n\n斜率：k = y1  y2 / x1  x2\n\n截距：b = y1  x2  y2  x1 / x2  x1\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nmap<pair<double, double, int mp;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0;\n\tforint i = 0; i < 20; i++{\n\t\tres ++;\n\t}\n\tforint i = 0; i < 21; i++{\n\t\tres ++;\n\t}\n\t\n\tforint i = 0; i < 20; i++{\n\t\tforint j = 0; j < 21; j++{\n\t\t\tforint x = i + 1; x < 20; x++{\n\t\t\t\tforint y = 0; y < 21; y++{\n\t\t\t\t\tifi = x && j = y{\n\t\t\t\t\t\tdouble num = j  y  1.0 / i  x;\t\n\t\t\t\t\t\tdouble val = i  y  j  x  1.0 / i  x;\n\t\t\t\t\t\tifmp.find{num, val} == mp.end{\n\t\t\t\t\t\t\tmp{num, val} = 1;\n\t\t\t\t\t\t\tres ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n 货物摆放\n\n枚举、数学知识因数题\n\n找出2021041820210418所有的因数，从因数中找出满足条件的即可，极大的缩减了遍历范围\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nmap<pair<ll, ll, ll map;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\t vector<ll v;\n    \n    ll a = 2021041820210418;\n    ll res = 0;\n    \n    forll i = 1; i  i <= a; i++{\n        ifa % i == 0 {\n            v.pushbacki;    \n            ifi  i = a{\n                v.pushbacka / i;\n            }\n        }\n    }\n    \n    forll i = 0; i < v.size; i++{\n        forll j = 0; j < v.size; j++{\n            forll m = 0; m < v.size; m++{    \n                ifvi  vj  vm == a res++;\n            }\n        }\n        \n    }\n    cout << res;\n\treturn 0;\n}\n\n\n 路径\n\n图论、数学知识题\n\n迪杰斯特拉模板题，最小公倍数模板\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nmap<pair<ll, ll, ll map;\nint wN, idx, hN, neN, eN, disN, stN;\n\nvoid addint x, int y, int z{\n\teidx = y, widx = z, neidx = hx, hx = idx ++;\n}\n\nint fun1int x, int y{\n\treturn y == 0 ? x : fun1y, x % y;\n}\n\nint fun2int x, int y{\n\treturn x / fun1x, y  y;\t\n}\n\nint dj{\n\tmemsetdis, 0x3f3f3f3f, sizeof dis;\n\tpriorityqueue<PII, vector<PII, greater<PII pq;\n\tpq.push{1, 0};\n\twhilepq.empty{\n\t\tauto top = pq.top;\n\t\tpq.pop;\n\t\tint x = top.first, y = top.second;\n\t\tifstx continue;\n\t\tstx = 1;\n\t\tforint i = hx; i = 1; i = nei{\n\t\t\tint j = ei;\n\t\t\tifdisj  y + wi{\n\t\t\t\tdisj = y + wi;\n\t\t\t\tpq.push{j, disj};\n\t\t\t}\n\t\t}\n\t}\n\tifdis2021 == 0x3f3f3f3f return 1;\n    return dis2021;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tmemseth, 1, sizeof h;\n\n\tforint i = 1; i <= 2021; i++{\n\t\tforint j = i + 1; j <= 2021; j++{\n\t\t\tifj  i <= 21{\n\t\t\t\tint c = fun2i, j;\n\t\t\t\taddi, j, c;\n\t\t\t\taddj, i, c;\t\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} \n\tcout << dj;\n\t\n\treturn 0;\n}\n\n\n 时间显示\n\n单位换算题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll num;\n\tcin  num;\n\tint dv = 1000  3600  24;\n\tnum = num % dv;\n\tint sv = num / 1000;\n\tint h = sv / 3600;\n\tint m = sv % 3600 / 60;\n\tint s = sv % 3600 % 60;\n\tprintf\"%02d:%02d:%02d\\n\", h, m, s;\n\t\n\treturn 0;\n}\n\n\n 砝码称重\n\nset模拟DFS遍历，巧解此题\n\n正解为动态规划\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<int va;\n\tset<int s;\n\tforint i = 0; i < a; i++ cin  vi;\n\tforint i = 0; i < a; i++{\n\t\tset<int ss;\n\t\tforint j: s{\n\t\t\tss.insertj + vi;\n\t\t\tifj  vi  0 ss.insertj  vi;\n\t\t\tifvi  j  0 ss.insertvi  j;\n\t\t}\n\t\tforint j: ss{\n\t\t\ts.insertj;\t\n\t\t}\n\t\ts.insertvi;\n\t}\n\tcout << s.size << endl;\n\n\treturn 0;\n}\n\n\n 杨辉三角形\n\n技巧、二分题\n\n暴力能够 40% 的分数\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\n\nmap<PII, int mp; \nmap<int, int smp;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tifa == 1{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmp{1, 1} = 1;\n\tint flag = 0;\n\tll res = 1;\n\tforint i = 2; ;i++{\n\t\tforint j = 1; j <= i;j ++{\n\t\t\tint cot;\n\t\t\tifj == 1{\n\t\t\t\tcot = 1; \n\t\t\t} else {\n\t\t\t\tcot = mp{i  1, j} + mp{i  1, j  1};\n\t\t\t}\n\t\t\tres ++;\n\t\t\tmp{i, j} = cot;\n\t\t\tifcot == a && smp.findcot == smp.end{\n\t\t\t\tflag = 1;\n\t\t\t\tcout << res << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tifflag{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n 双向排序\n\nsort暴力能够 60% 题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\t\n\tcin  a  b;\n\tforint i = 0; i < a; i++ ni = i + 1;\n\twhileb {\n\t\tcin  x  y;\n\t\tifx == 0{\n\t\t\tsortn, n + y, greater<int;\n\t\t} else {\n\t\t\tsortn + y  1, n + a;\n\t\t}\n\n\t}\n\t\n\tforint i = 0; i < a; i++ cout << ni << \" \"; \n\treturn 0;\n}\n\n\n"},{"filename":"nowcoder-month-81","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛81\ncategory: 算法\ndate: 2024-04-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n做了几道练手题，感觉有一两道题颇有收获，于记一笔\n\n### 小辰打比赛\n\n贪心秒了\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t\n\tcin >> a >> b;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++){\n\t\tcin >> v[i];\n\t} \n\t\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < a; i++){\n\t\tif(v[i] < b) res += v[i];\n\t\telse break;\n\t} \n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### 小辰的圣剑\n\n这题卡了半天，后面发现数据范围很小，两个循环暴力拿下\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n//int a, b, x, y, res;\n//int n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll n, m, u, res = 0;\n\tcin >> n >> m >> u;\n\tvector<int> v(n), n1(n);\n\tfor(int i = 0; i < n; i++) cin >> v[i];\n\tfor(int i = 0; i < n; i++) cin >> n1[i];\n\tfor(int i = 0; i < n; i++){\n\t\tll cot = 0, lj = 0, ry = 0;\n\t\tfor(int j = i; j < n; j++){\n\t\t\tif(v[j] + lj <= m && n1[j] + ry <= u){\n\t\t\t\tcot ++;\n\t\t\t\tlj += v[j];\n\t\t\t\try += n1[j];\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = max(res, cot);\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n### 陶陶学算术\n\n这题参考题解，数据范围很大，除的话会超出范围，~~我一直卡在这不知道范围问题~~\n\n我们需要对这个公式进行改变\n\nres1 = x1x2x3/y1y2y3 = A / B\n\nres2 = i1i2i3/j1j2j3 = C / D\n\n=> A * D = B * C ，将除法转为乘法并用long long存放\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tll cot1 = 1, cot2 = 1;\n\twhile(a --){\n\t\tcin >> x >> y;\n\t\tif(x == 1) cot1 = cot1 * y % M;\n\t\telse cot2 = cot2 * y % M; \n\t}\n\tcin >> b;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tif(x == 1) cot2 = cot2 * y % M;\n\t\telse cot1 = cot1 * y % M; \n\t}\n\tcout << (cot1 == cot2 ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n```\n\n### 小辰的借钱计划\n\n这题用到数学期望，不会\n\n期望 = 1 / 符号条件的 * 符合条件的数\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y, res;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\twhile(a --){\n\t\tcin >> x >> y;\n\t\tint idx = 0;\n\t\tfor(int i = 1; i <= x - y; i++){\n\t\t\tif(y % i == 0 || i % y == 0){\n\t\t\t\tidx ++;\n\t\t\t}\n\t\t}\n\t\tdouble w = 0.0, ra = 1.0 / idx;\n\t\tfor(int i = 1; i <= x - y; i++){\n\t\t\tif(y % i == 0 || i % y == 0){\n\t\t\t\tw += i * ra;\n\t\t\t}\t\n\t\t}\n\t\tcout << (w > y ? \"YES\":\"NO\") << endl;\t\n\t}\n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛81\n","category":[" 算法\n"],"date":" 2024-04-09\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n做了几道练手题，感觉有一两道题颇有收获，于记一笔\n\n 小辰打比赛\n\n贪心秒了\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\t\n\tcin  a  b;\n\tvector<int va;\n\tforint i = 0; i < a; i++{\n\t\tcin  vi;\n\t} \n\t\n\tsortv.begin, v.end;\n\tforint i = 0; i < a; i++{\n\t\tifvi < b res += vi;\n\t\telse break;\n\t} \n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n 小辰的圣剑\n\n这题卡了半天，后面发现数据范围很小，两个循环暴力拿下\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n//int a, b, x, y, res;\n//int nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll n, m, u, res = 0;\n\tcin  n  m  u;\n\tvector<int vn, n1n;\n\tforint i = 0; i < n; i++ cin  vi;\n\tforint i = 0; i < n; i++ cin  n1i;\n\tforint i = 0; i < n; i++{\n\t\tll cot = 0, lj = 0, ry = 0;\n\t\tforint j = i; j < n; j++{\n\t\t\tifvj + lj <= m && n1j + ry <= u{\n\t\t\t\tcot ++;\n\t\t\t\tlj += vj;\n\t\t\t\try += n1j;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = maxres, cot;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n 陶陶学算术\n\n这题参考题解，数据范围很大，除的话会超出范围，我一直卡在这不知道范围问题\n\n我们需要对这个公式进行改变\n\nres1 = x1x2x3/y1y2y3 = A / B\n\nres2 = i1i2i3/j1j2j3 = C / D\n\n= A  D = B  C ，将除法转为乘法并用long long存放\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tll cot1 = 1, cot2 = 1;\n\twhilea {\n\t\tcin  x  y;\n\t\tifx == 1 cot1 = cot1  y % M;\n\t\telse cot2 = cot2  y % M; \n\t}\n\tcin  b;\n\twhileb {\n\t\tcin  x  y;\n\t\tifx == 1 cot2 = cot2  y % M;\n\t\telse cot1 = cot1  y % M; \n\t}\n\tcout << cot1 == cot2 ? \"YES\" : \"NO\" << endl;\n\treturn 0;\n}\n\n\n 小辰的借钱计划\n\n这题用到数学期望，不会\n\n期望 = 1 / 符号条件的  符合条件的数\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, x, y, res;\nint nN;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\twhilea {\n\t\tcin  x  y;\n\t\tint idx = 0;\n\t\tforint i = 1; i <= x  y; i++{\n\t\t\tify % i == 0  i % y == 0{\n\t\t\t\tidx ++;\n\t\t\t}\n\t\t}\n\t\tdouble w = 0.0, ra = 1.0 / idx;\n\t\tforint i = 1; i <= x  y; i++{\n\t\t\tify % i == 0  i % y == 0{\n\t\t\t\tw += i  ra;\n\t\t\t}\t\n\t\t}\n\t\tcout << w  y ? \"YES\":\"NO\" << endl;\t\n\t}\n\treturn 0;\n}\n\n\n"},{"filename":"13th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十三届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-04-08\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 九进制转十进制\n\n进制转换题\n\n2 + 2 * 9 + 2 * 9 * 9 + 2 * 9 *9 * 9\n\n### 顺子日期\n\n模拟、枚举题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \nint n[13] = {0, 31, 28, 31,30,31,30,31,31,30,31,30,31};\n\nbool fun(string kk){\n\tbool flag = 0;\n\tint idx = 1;\n\t\tfor(int j = 1; j < kk.size(); j++){\n\t\t\tif(kk[j] - '0' == kk[j - 1] - '0' + 1 ){\n\t\t\t\tidx ++;\n\t\t\t}else {\n\t\t\t\tif(idx == 3) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidx = 1;\n\t\t\t}\n\t\t}\n    \t// 注意没遍历完的也需要确认idx是否大于等于3\n\t\treturn idx >= 3 ? true : flag;\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tfor(int i = 1; i <= 12; i++){\n\t\tint num = 20220000 + i * 100, idx = 0, flag = 0;\n\t\tfor(int j = 1; j <= n[i]; j++){\n\t\t\tint cot = num + j;\n\t\t\tstring kk = to_string(cot);\n\t\t\tif(fun(kk)){\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n```\n\n### 刷题统计\n\n模拟题，这题唯一需要注意的就是数据范围，需要long long类型\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll m, a, b;\n\tcin >> a >> b >> m;\n\tll kk = a * 5 + 2 * b; \n\tll kk3 = m % kk;\n\tll res = m / kk * 7;\n\tif(kk3 <= a * 5){\n\t\tres += (ll) ceil(kk3 * 1.0 / a);\n\t} else {\n\t\tres += 5 + (ll)ceil((kk3 - a * 5) * 1.0 / b);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 修剪灌木\n\n思维题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\tfor(int i = 1; i <= x; i++){\n\t\tcout << max(2 * (x - i), 2 * (i - 1)) << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 统计子矩阵\n\n前缀和、双指针题\n\n思路：先求出二维数组的前缀和，用双循环遍历每个数，此时我们需要用另一个数来比较出当前范围的和。\n\n我们可以发现若另一个数和遍历的数的范围和小于k，那么这个数的左边的数的范围和也是小于k的。于是就可以将另一个数设置在最右边，不断让这个数的列减少行增加来算出满足条件的个数，此时时间复杂度优化至O(n^3)，能过。\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res = N;\nint v[501][501], n[501][501];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll k, res = 0;\n\tcin >> a >> b >> k;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> v[i][j];\t\n\t\t\tv[i][j] = v[i-1][j] + v[i][j-1] - v[i-1][j-1] + v[i][j];\n\t\t}\n\t} \n\t\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tint r = b;\n\t\t\tfor(int l = i; l <= a; l++){\n\t\t\t\twhile(r >= j && v[l][r] - v[i - 1][r] - v[l][j - 1] + v[i - 1][j - 1] > k){\n\t\t\t\t\tr --;\n\t\t\t\t}\n\t\t\t\tif(j > r){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += r - j + 1;\n\t\t\t}\n\t\t}\n\t} \n\tcout << res << endl;\t\n}\t\n```\n\n### 积木画\n\n动态规划题\n\n这题很难推出状态的转移方程\n\n假设当前点为i，用v[i]表示当前满足的个数\n\n- 若i-1全部铺满，则v[i] = v[i-1]\n- 若i-1一个都没有铺，则v[i] = v[i - 2]\n- 若i-1只铺满了一半，则v[i] = v[i - 3] * 2，同理也可以推出 v[i] = v[i - 4] * 2\n\n于是：\n\nv[i] = v[i - 1] + v[i - 2] + v[i - 3] * 2 + v[i - 4] * 2 + ... + 2 * v[1]\n\nv[i - 1] = v[i - 2] + v[i - 3] + v[i - 4] * 2 + ... + 2 * v[1]\n\n两式相减得出：**v[i] = v[i - 1] * 2 + v[i - 3]** \n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res = N;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a);\n\tv[1] = 1, v[2] = 2, v[3] = 5;  \n\tfor(int i = 4; i <= a; i++){\n\t\tv[i] = (2 * v[i - 1] % 1000000007  + v[i - 3] % 1000000007) % 1000000007;\n\t}\n\n\tcout << v[a] << endl;\n\t\n\treturn 0;\n}\t\n```\n\n### 扫雷\n\nBFS 暴力法能过 40% 的样例\n\n优化是在队列遍历的进行二分查找，~~我就不会了~~\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res;\nstruct p{\n\tint x, y, num;\n}n[N],v[N];\nint flag[N];\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    scanf(\"%d%d\",&a, &b);\n    queue<pair<int, int>> q;\n    for(int i = 0; i < a; i++){\n    \tscanf(\"%lld%lld%lld\",&n[i].x, &n[i].y, &n[i].num);\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tscanf(\"%lld%lld%lld\",&v[i].x, &v[i].y, &v[i].num);\n\t\tq.push({i, 1});\t\n\t}\n\twhile(!q.empty()){\n\t\tauto top = q.front();\n\t\tq.pop();\n\t\tint f = top.first, s = top.second;\n\t\tint xx, yy, rr;\n\t\tif(s == 1){\n\t\t\txx = v[f].x, yy = v[f].y, rr = v[f].num;\n\t\t} else {\n\t\t\txx = n[f].x, yy = n[f].y, rr = n[f].num;\n\t\t}\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tif(!flag[i] && (ll)(n[i].x - xx)*(n[i].x - xx) + (ll)(n[i].y - yy) * (n[i].y - yy) <= (ll)rr*rr){\n\t\t\t\tflag[i] = 1;\n\t\t\t\tq.push({i, 2});\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\tprintf(\"%d\", res);\n\t\t\n    return 0;\n}\n```\n\n\n\n### 李白打酒加强版\n\n记忆化搜索 + 剪枝\n\n此题不难想到用DFS，可是只用用DFS的话注意题干条件：**由于答案很大，输出模1000000007**，这时候就需要用其他条件辅助\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\nlong long res = 0;\nll n[101][101][101];\nint mod = 1000000007;\n\nint dfs(int x, int y, int num){\n    // num + a - x >  b - y 剪枝，满足当前剩余的数加上需要相乘的数必须小于需要相减的数\n    if(x > a || y > b || num < 0 || num + a - x > b - y){\n        return 0;\n    }\n    if(x == a && y == b - 1 && num == 1){\n        return 1;\n    }\n    if(n[x][y][num]){\n    \treturn n[x][y][num];\n\t}\n\tif(num > 0){\n\t\tn[x][y][num] = (dfs(x + 1, y, num * 2) % mod + dfs(x, y + 1, num - 1) % mod) % mod;\n\t} else {\n\t\tn[x][y][num] = dfs(x + 1, y, num * 2) % mod;\n\t}\n\treturn n[x][y][num];\n}\n\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> a >> b;\n    cout << dfs(0, 0, 2) << endl;\n    \n    return 0;\n}\n```\n\n","title":" 第十三届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-04-08\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 九进制转十进制\n\n进制转换题\n\n2 + 2  9 + 2  9  9 + 2  9 9  9\n\n 顺子日期\n\n模拟、枚举题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \nint n13 = {0, 31, 28, 31,30,31,30,31,31,30,31,30,31};\n\nbool funstring kk{\n\tbool flag = 0;\n\tint idx = 1;\n\t\tforint j = 1; j < kk.size; j++{\n\t\t\tifkkj  '0' == kkj  1  '0' + 1 {\n\t\t\t\tidx ++;\n\t\t\t}else {\n\t\t\t\tifidx == 3 {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidx = 1;\n\t\t\t}\n\t\t}\n    \t// 注意没遍历完的也需要确认idx是否大于等于3\n\t\treturn idx = 3 ? true : flag;\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0;\n\tforint i = 1; i <= 12; i++{\n\t\tint num = 20220000 + i  100, idx = 0, flag = 0;\n\t\tforint j = 1; j <= ni; j++{\n\t\t\tint cot = num + j;\n\t\t\tstring kk = tostringcot;\n\t\t\tiffunkk{\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n\n 刷题统计\n\n模拟题，这题唯一需要注意的就是数据范围，需要long long类型\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll m, a, b;\n\tcin  a  b  m;\n\tll kk = a  5 + 2  b; \n\tll kk3 = m % kk;\n\tll res = m / kk  7;\n\tifkk3 <= a  5{\n\t\tres += ll ceilkk3  1.0 / a;\n\t} else {\n\t\tres += 5 + llceilkk3  a  5  1.0 / b;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n 修剪灌木\n\n思维题\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\tforint i = 1; i <= x; i++{\n\t\tcout << max2  x  i, 2  i  1 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n 统计子矩阵\n\n前缀和、双指针题\n\n思路：先求出二维数组的前缀和，用双循环遍历每个数，此时我们需要用另一个数来比较出当前范围的和。\n\n我们可以发现若另一个数和遍历的数的范围和小于k，那么这个数的左边的数的范围和也是小于k的。于是就可以将另一个数设置在最右边，不断让这个数的列减少行增加来算出满足条件的个数，此时时间复杂度优化至On^3，能过。\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res = N;\nint v501501, n501501;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tll k, res = 0;\n\tcin  a  b  k;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcin  vij;\t\n\t\t\tvij = vi1j + vij1  vi1j1 + vij;\n\t\t}\n\t} \n\t\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tint r = b;\n\t\t\tforint l = i; l <= a; l++{\n\t\t\t\twhiler = j && vlr  vi  1r  vlj  1 + vi  1j  1  k{\n\t\t\t\t\tr ;\n\t\t\t\t}\n\t\t\t\tifj  r{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += r  j + 1;\n\t\t\t}\n\t\t}\n\t} \n\tcout << res << endl;\t\n}\t\n\n\n 积木画\n\n动态规划题\n\n这题很难推出状态的转移方程\n\n假设当前点为i，用vi表示当前满足的个数\n\n 若i1全部铺满，则vi = vi1\n 若i1一个都没有铺，则vi = vi  2\n 若i1只铺满了一半，则vi = vi  3  2，同理也可以推出 vi = vi  4  2\n\n于是：\n\nvi = vi  1 + vi  2 + vi  3  2 + vi  4  2 + ... + 2  v1\n\nvi  1 = vi  2 + vi  3 + vi  4  2 + ... + 2  v1\n\n两式相减得出：vi = vi  1  2 + vi  3 \n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res = N;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tvector<int va;\n\tv1 = 1, v2 = 2, v3 = 5;  \n\tforint i = 4; i <= a; i++{\n\t\tvi = 2  vi  1 % 1000000007  + vi  3 % 1000000007 % 1000000007;\n\t}\n\n\tcout << va << endl;\n\t\n\treturn 0;\n}\t\n\n\n 扫雷\n\nBFS 暴力法能过 40% 的样例\n\n优化是在队列遍历的进行二分查找，我就不会了\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res;\nstruct p{\n\tint x, y, num;\n}nN,vN;\nint flagN;\n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n    scanf\"%d%d\",&a, &b;\n    queue<pair<int, int q;\n    forint i = 0; i < a; i++{\n    \tscanf\"%lld%lld%lld\",&ni.x, &ni.y, &ni.num;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tscanf\"%lld%lld%lld\",&vi.x, &vi.y, &vi.num;\n\t\tq.push{i, 1};\t\n\t}\n\twhileq.empty{\n\t\tauto top = q.front;\n\t\tq.pop;\n\t\tint f = top.first, s = top.second;\n\t\tint xx, yy, rr;\n\t\tifs == 1{\n\t\t\txx = vf.x, yy = vf.y, rr = vf.num;\n\t\t} else {\n\t\t\txx = nf.x, yy = nf.y, rr = nf.num;\n\t\t}\n\t\tforint i = 0; i < a; i++{\n\t\t\tifflagi && llni.x  xxni.x  xx + llni.y  yy  ni.y  yy <= llrrrr{\n\t\t\t\tflagi = 1;\n\t\t\t\tq.push{i, 2};\n\t\t\t\tres ++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\tprintf\"%d\", res;\n\t\t\n    return 0;\n}\n\n\n\n\n 李白打酒加强版\n\n记忆化搜索 + 剪枝\n\n此题不难想到用DFS，可是只用用DFS的话注意题干条件：由于答案很大，输出模1000000007，这时候就需要用其他条件辅助\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\nlong long res = 0;\nll n101101101;\nint mod = 1000000007;\n\nint dfsint x, int y, int num{\n    // num + a  x   b  y 剪枝，满足当前剩余的数加上需要相乘的数必须小于需要相减的数\n    ifx  a  y  b  num < 0  num + a  x  b  y{\n        return 0;\n    }\n    ifx == a && y == b  1 && num == 1{\n        return 1;\n    }\n    ifnxynum{\n    \treturn nxynum;\n\t}\n\tifnum  0{\n\t\tnxynum = dfsx + 1, y, num  2 % mod + dfsx, y + 1, num  1 % mod % mod;\n\t} else {\n\t\tnxynum = dfsx + 1, y, num  2 % mod;\n\t}\n\treturn nxynum;\n}\n\n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n    cin  a  b;\n    cout << dfs0, 0, 2 << endl;\n    \n    return 0;\n}\n\n\n"},{"filename":"2023-team-ladder-race","category":"aigorithm","md":{"topSummary":"\ntitle: 2023年团体程序设计天梯赛\ncategory: 算法\ndate: 2024-03-27\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### **L1-089 最好的文档**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    printf(\"Good code is its own best documentation.\"); \n    return 0;\n}\n```\n\n### **L1-090 什么是机器学习**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tres = a + b;\n\tcout << res - 16 << endl;\n\tcout << res - 3 << endl;\n\tcout << res - 1 << endl;\n\tcout << res << endl; \n\t\n\treturn 0;\n}\t\n```\n\n### **L1-091 程序员买包子**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring x;\n\tint n, m, k;\n\tcin >> n >> x >> m >> k;\n\tif(k == n){\n\t\tcout << \"mei you mai \" << x << \" de\" << endl;\n\t} else if(k == m){\n\t\tcout << \"kan dao le mai \" << x << \" de\" << endl;\n\t} else cout << \"wang le zhao mai \" << x << \" de\" << endl;\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-092 进化论**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\twhile(x--){\n\t\tint m, n, k;\n\t\tcin >> m >> n >> k;\n\t\tif(m * n == k) cout << \"Lv Yan\" << endl;\n\t\telse if(m + n == k) cout << \"Tu Dou\" << endl;\n\t\telse cout << \"zhe du shi sha ya!\" << endl; \n\t}\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-093 猜帽子游戏**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\tvector<int> v(x);\n\tfor(int i = 0; i < x; i++) cin >> v[i];\n\tint y;\n\tcin >> y;\n\twhile(y--){\n\t\tint cot = 0, flag = 1;\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tif(num == 0) cot ++;\n\t\t\tif(num != 0 && num != v[i]) flag = 0;\n\t\t}\n\t\tif(flag && cot != x) cout << \"Da Jiang!!!\" << endl;\n\t\t else cout << \"Ai Ya\" << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-094 剪切粘贴**\n\n这题是最花费时间的，难度不难，就是字符串的边界取值太折磨人了\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tstring str;\n\tcin >> str >> a;\n\tint len = str.size();\n\twhile(a--){\n\t\tstring s1, s2;\n\t\tint m, n;\n\t\tcin >> m >> n >> s1 >> s2;\n\t\tstring sq = str.substr(m - 1, n - m + 1);\n\t\tstring res_ = str.substr(0, m - 1) + str.substr(n, len);\n\t\tstring all = s1 + s2;\n\t\tint f = res_.find(s1), s = res_.find(s2), fs = res_.find(all);\n\t\tif(fs == -1){\n\t\t\tstr = res_ + sq;\n\t\t} else {\n\t\t\tstring ss1 = res_.substr(0, fs), ss2 = res_.substr(fs + all.size(), res_.size());\n\t\t\tstr = ss1 + s1 + sq + s2 + ss2;\n\t\t}\n\t}\n\tcout << str << endl; \n    \n\treturn 0;\n}\t\n\n```\n\n### **L1-095 分寝室**\n\n这题没考虑到 `不允许单人住一间寝室` 这一条件和浮点数问题(分母为0了)。\n\n加个边界判断`i <= x - 1` 解决了浮点数问题，` a != i && b != x - i` 解决单人住一间的问题\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tres = 100010; \n\tint x, r = 0, l = 0;\n\tcin >> a >> b >> x;\n\tfor(int i = 1; i <= x - 1; i++){\n\t\tif(a % i == 0 && b % (x - i) == 0 && a != i && b != x - i){\n\t\t\tint cot = fabs(a / i - b / (x - i)); \n\t\t\tif(cot < res){\n\t\t\t\tres = cot;\n\t\t\t\tr = i, l = x - i;\n\t\t\t}\n\t\t}\n\t}\n\tif(l == 0 && r == 0) cout << \"No Solution\" << endl;\n\telse cout << r << \" \" << l << endl;\n\t\n\t\n\treturn 0;\n}\t\n```\n\n### **L1-096 谁管谁叫爹**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, res; \n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint x;\n\tcin >> x;\n\twhile(x --){\n\t\tchar res;\n\t\tint cot = 0, flag = 0;\n\t\tcin >> a >> b;\n\t\tint a_ = a, b_ = b;\n\t\twhile(a_){\n\t\t\tcot += a_ % 10;\n\t\t\ta_ /= 10;\n\t\t}\n\t\tif(b % cot == 0){\n\t\t\tres = 'B';\n\t\t\tflag ++;\n\t\t}\n\t\tcot = 0;\n\t\twhile(b_){\n\t\t\tcot += b_ % 10;\n\t\t\tb_ /= 10;\t\n\t\t}\n\t\tif(a % cot == 0){\n\t\t\tres = 'A';\n\t\t\tflag ++;\t\n\t\t} \n\t\tif(flag == 1){\n\t\t\tcout << res << endl;\n\t\t} else {\n\t\t\tcout <<  (a > b ? \"A\" : \"B\") << endl ; \n\t\t}\n\t}\n\t\n\treturn 0;\n}\t\n```\n\n### **L2-045 堆宝塔**\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint num = 0, maxx = 0;\n\tcin >> a;\n\tstack<int> s, s2;\n\tvector<int> v(a);\n\tfor(int i = 0; i < a; i++) cin >> v[i];\n\tfor(int i = 0; i < a; i++){\n\t\tif(!s.empty()){\n\t\t\tif(s.top() > v[i]) s.push(v[i]);\n\t\t\telse {\n\t\t\t\tif(s2.size()){\n\t\t\t\t\tif(s2.top() < v[i]){\n\t\t\t\t\t\ts2.push(v[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cot = 0;\n\t\t\t\t\t\twhile(s.size()){\n\t\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\t\tcot ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxx = max(maxx, cot);\n\t\t\t\t\t\tnum ++;\n\t\t\t\t\t\twhile(s2.size() && s2.top() > v[i]){\n\t\t\t\t\t\t\ts.push(s2.top());\n\t\t\t\t\t\t\ts2.pop();\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.push(v[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts2.push(v[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\tint cot = s.size();\n\tif(cot){\n\t\tnum ++;\n\t\tmaxx = max(maxx, cot);\n\t}\n\tcot = s2.size();\n\tif(cot){\n\t\tnum ++;\n\t\tmaxx = max(maxx, cot); \n\t}\n\tcout << num << \" \" << maxx << endl;\n\n \n\treturn 0;\n}\n```\n\n### **L2-046 天梯赛的赛场安排**\n\n理解题意还是能混点分的\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tint res = 0;\n\tpriority_queue<int> q;\n\tfor(int i = 0; i < a; i++){\n\t\tstring str;\n\t\tint num;\n\t\tcin >> str >> num;\n\t\tq.push(num % b);\n\t\tres += num / b;\n\t\tcout << str << \" \" << ceil(num * 1.0 / b) << endl;\n\t}\n\tint cot = 0, flag = 1;\n\twhile(q.size()){\n\t\tint num = q.top();\n\t\tq.pop();\n\t\tif(cot + num <= b){\n\t\t\tcot += num;\n\t\t\tflag = 1;\n\t\t} else {\n\t\t\tres ++;\n\t\t\tcot = num;\n\t\t\tflag = 0;\n\t\t}\n\t}\n\tif(!flag){\n\t\tres ++;\n\t}\n\tcout << res << endl;\n \n\treturn 0;\n}\n```\n\n### **L2-048 寻宝图**\n\ndfs模板题\n\n```c++\n#include<bits/stdc++.h>\n#define line printf(\"------\\n\")\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, flag; \nchar n[1000][1000];\nint st[1000][1000];\n\nvoid dfs(int x, int y){\n\tif(n[x][y] > '1'){\n\t\tflag = 1;\n\t}\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = ix[i] + x, yy = iy[i] + y;\n\t\tif(xx >= 0 && xx < a && yy >= 0 && yy < b && !st[xx][yy] && n[xx][yy] >= '1'){\n\t\t\tst[xx][yy] = 1;\n\t\t\tdfs(xx, yy);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a >> b;\n\tint res = 0, cot = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tfor(int j = 0; j < b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < a; i++){\n\t\tfor(int j = 0; j < b; j++){\n\t\t\tif(n[i][j] >= '1' && !st[i][j]){\n\t\t\t\tflag = 0;\n\t\t\t\tst[i][j] = 1;\n\t\t\t\tdfs(i, j);\n\t\t\t\tres ++;\n\t\t\t\tif(flag){\n\t\t\t\t\tcot ++;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\tcout << res << \" \" << cot << endl;\n\n \n\treturn 0;\n}\n```\n\n","title":" 2023年团体程序设计天梯赛\n","category":[" 算法\n"],"date":" 2024-03-27\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n L1089 最好的文档\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n    ios::syncwithstdiofalse, cin.tie0, cout.tie0;\n    printf\"Good code is its own best documentation.\"; \n    return 0;\n}\n\n\n L1090 什么是机器学习\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tres = a + b;\n\tcout << res  16 << endl;\n\tcout << res  3 << endl;\n\tcout << res  1 << endl;\n\tcout << res << endl; \n\t\n\treturn 0;\n}\t\n\n\n L1091 程序员买包子\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring x;\n\tint n, m, k;\n\tcin  n  x  m  k;\n\tifk == n{\n\t\tcout << \"mei you mai \" << x << \" de\" << endl;\n\t} else ifk == m{\n\t\tcout << \"kan dao le mai \" << x << \" de\" << endl;\n\t} else cout << \"wang le zhao mai \" << x << \" de\" << endl;\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1092 进化论\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\twhilex{\n\t\tint m, n, k;\n\t\tcin  m  n  k;\n\t\tifm  n == k cout << \"Lv Yan\" << endl;\n\t\telse ifm + n == k cout << \"Tu Dou\" << endl;\n\t\telse cout << \"zhe du shi sha ya\" << endl; \n\t}\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1093 猜帽子游戏\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\tvector<int vx;\n\tforint i = 0; i < x; i++ cin  vi;\n\tint y;\n\tcin  y;\n\twhiley{\n\t\tint cot = 0, flag = 1;\n\t\tforint i = 0; i < x; i++{\n\t\t\tint num;\n\t\t\tcin  num;\n\t\t\tifnum == 0 cot ++;\n\t\t\tifnum = 0 && num = vi flag = 0;\n\t\t}\n\t\tifflag && cot = x cout << \"Da Jiang\" << endl;\n\t\t else cout << \"Ai Ya\" << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1094 剪切粘贴\n\n这题是最花费时间的，难度不难，就是字符串的边界取值太折磨人了\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tstring str;\n\tcin  str  a;\n\tint len = str.size;\n\twhilea{\n\t\tstring s1, s2;\n\t\tint m, n;\n\t\tcin  m  n  s1  s2;\n\t\tstring sq = str.substrm  1, n  m + 1;\n\t\tstring res = str.substr0, m  1 + str.substrn, len;\n\t\tstring all = s1 + s2;\n\t\tint f = res.finds1, s = res.finds2, fs = res.findall;\n\t\tiffs == 1{\n\t\t\tstr = res + sq;\n\t\t} else {\n\t\t\tstring ss1 = res.substr0, fs, ss2 = res.substrfs + all.size, res.size;\n\t\t\tstr = ss1 + s1 + sq + s2 + ss2;\n\t\t}\n\t}\n\tcout << str << endl; \n    \n\treturn 0;\n}\t\n\n\n\n L1095 分寝室\n\n这题没考虑到 不允许单人住一间寝室 这一条件和浮点数问题分母为0了。\n\n加个边界判断i <= x  1 解决了浮点数问题， a = i && b = x  i 解决单人住一间的问题\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tres = 100010; \n\tint x, r = 0, l = 0;\n\tcin  a  b  x;\n\tforint i = 1; i <= x  1; i++{\n\t\tifa % i == 0 && b % x  i == 0 && a = i && b = x  i{\n\t\t\tint cot = fabsa / i  b / x  i; \n\t\t\tifcot < res{\n\t\t\t\tres = cot;\n\t\t\t\tr = i, l = x  i;\n\t\t\t}\n\t\t}\n\t}\n\tifl == 0 && r == 0 cout << \"No Solution\" << endl;\n\telse cout << r << \" \" << l << endl;\n\t\n\t\n\treturn 0;\n}\t\n\n\n L1096 谁管谁叫爹\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, res; \n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint x;\n\tcin  x;\n\twhilex {\n\t\tchar res;\n\t\tint cot = 0, flag = 0;\n\t\tcin  a  b;\n\t\tint a = a, b = b;\n\t\twhilea{\n\t\t\tcot += a % 10;\n\t\t\ta /= 10;\n\t\t}\n\t\tifb % cot == 0{\n\t\t\tres = 'B';\n\t\t\tflag ++;\n\t\t}\n\t\tcot = 0;\n\t\twhileb{\n\t\t\tcot += b % 10;\n\t\t\tb /= 10;\t\n\t\t}\n\t\tifa % cot == 0{\n\t\t\tres = 'A';\n\t\t\tflag ++;\t\n\t\t} \n\t\tifflag == 1{\n\t\t\tcout << res << endl;\n\t\t} else {\n\t\t\tcout <<  a  b ? \"A\" : \"B\" << endl ; \n\t\t}\n\t}\n\t\n\treturn 0;\n}\t\n\n\n L2045 堆宝塔\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint num = 0, maxx = 0;\n\tcin  a;\n\tstack<int s, s2;\n\tvector<int va;\n\tforint i = 0; i < a; i++ cin  vi;\n\tforint i = 0; i < a; i++{\n\t\tifs.empty{\n\t\t\tifs.top  vi s.pushvi;\n\t\t\telse {\n\t\t\t\tifs2.size{\n\t\t\t\t\tifs2.top < vi{\n\t\t\t\t\t\ts2.pushvi;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cot = 0;\n\t\t\t\t\t\twhiles.size{\n\t\t\t\t\t\t\ts.pop;\n\t\t\t\t\t\t\tcot ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxx = maxmaxx, cot;\n\t\t\t\t\t\tnum ++;\n\t\t\t\t\t\twhiles2.size && s2.top  vi{\n\t\t\t\t\t\t\ts.pushs2.top;\n\t\t\t\t\t\t\ts2.pop;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.pushvi;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts2.pushvi;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pushvi;\n\t\t}\n\t}\n\tint cot = s.size;\n\tifcot{\n\t\tnum ++;\n\t\tmaxx = maxmaxx, cot;\n\t}\n\tcot = s2.size;\n\tifcot{\n\t\tnum ++;\n\t\tmaxx = maxmaxx, cot; \n\t}\n\tcout << num << \" \" << maxx << endl;\n\n \n\treturn 0;\n}\n\n\n L2046 天梯赛的赛场安排\n\n理解题意还是能混点分的\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tint res = 0;\n\tpriorityqueue<int q;\n\tforint i = 0; i < a; i++{\n\t\tstring str;\n\t\tint num;\n\t\tcin  str  num;\n\t\tq.pushnum % b;\n\t\tres += num / b;\n\t\tcout << str << \" \" << ceilnum  1.0 / b << endl;\n\t}\n\tint cot = 0, flag = 1;\n\twhileq.size{\n\t\tint num = q.top;\n\t\tq.pop;\n\t\tifcot + num <= b{\n\t\t\tcot += num;\n\t\t\tflag = 1;\n\t\t} else {\n\t\t\tres ++;\n\t\t\tcot = num;\n\t\t\tflag = 0;\n\t\t}\n\t}\n\tifflag{\n\t\tres ++;\n\t}\n\tcout << res << endl;\n \n\treturn 0;\n}\n\n\n L2048 寻宝图\n\ndfs模板题\n\nc++\ninclude<bits/stdc++.h\ndefine line printf\"\\n\"\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b, flag; \nchar n10001000;\nint st10001000;\n\nvoid dfsint x, int y{\n\tifnxy  '1'{\n\t\tflag = 1;\n\t}\n\t\n\tforint i = 0; i < 4; i++{\n\t\tint xx = ixi + x, yy = iyi + y;\n\t\tifxx = 0 && xx < a && yy = 0 && yy < b && stxxyy && nxxyy = '1'{\n\t\t\tstxxyy = 1;\n\t\t\tdfsxx, yy;\n\t\t}\n\t}\n}\n\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a  b;\n\tint res = 0, cot = 0;\n\tforint i = 0; i < a; i++{\n\t\tforint j = 0; j < b; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\n\tforint i = 0; i < a; i++{\n\t\tforint j = 0; j < b; j++{\n\t\t\tifnij = '1' && stij{\n\t\t\t\tflag = 0;\n\t\t\t\tstij = 1;\n\t\t\t\tdfsi, j;\n\t\t\t\tres ++;\n\t\t\t\tifflag{\n\t\t\t\t\tcot ++;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\tcout << res << \" \" << cot << endl;\n\n \n\treturn 0;\n}\n\n\n"},{"filename":"14th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十四届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-03-12\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 日期统计\n\n> 此题蓝桥杯官网没说清除，子序列按道理来说应该是连续的，而这个题却不是\n>\n> 思路：暴力法遍历8个数，找出符合条件的即可\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\nint a, b;\nint n[101];\n\nint v[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nset<int> s;\nint main(){\n\tint res = 0;\n\tfor(int i = 0; i < 100; i++) cin >> n[i];\n\tfor(int i = 0; i < 100; i++){\n\t\tif(n[i] == 2){\n\t\t\tfor(int i2 = i + 1; i2 < 100; i2++){\n\t\t\t\tif(n[i2] == 0){\n\t\t\t\t\tfor(int i3 = i2 + 1; i3 < 100; i3++){\n\t\t\t\t\t\tif(n[i3] == 2){\n\t\t\t\t\t\t\tfor(int i4 = i3 + 1; i4 < 100; i4++){\n\t\t\t\t\t\t\t\tif(n[i4] == 3){\n\t\t\t\t\t\t\t\t\tfor(int i5 = i4 + 1; i5 < 100; i5++){\n\t\t\t\t\t\t\t\t\t\tfor(int i6 = i5 + 1; i6 < 100; i6++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int i7 = i6 + 1; i7 < 100; i7++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int i8 = i7 + 1; i8 < 100; i8++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tint moth = n[i5] * 10 + n[i6], day = n[i7] * 10 + n[i8];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(moth >= 1 && moth <= 12 && day >= 1 && day <= v[moth]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(s.find(moth * 100 + day) == s.end()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts.insert(moth * 100 + day);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s.size() << endl;\n\t \n\n\treturn 0;\n}\n```\n\n### 01串的熵\n\n暴力枚举\n\n```c++\n#include<bits/stdc++.h>\n#include<math.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tint cot = 23333333;\n\tfor(int i = 1; i < cot; i++){\n\t\tint j = cot - i;\n\t\tdouble a = 1.0 * i / cot;\n\t\tdouble b = 1.0 * j / cot;\n\t\tdouble res = -a * log2(a) * i - b * log2(b) * j;  \t \n\t\tif(fabs(res - 11625907.5798) < 0.0001){\n\t\t\tcout << min(i, cot - i) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 冶炼金属\n\n> 唯一会做的简单题。。。\n>\n> 思路：每次循环都求出最大和最小的边界，注意考虑最大最小边界【根据题意笔画一下】\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\t\n\tint a, _max = 1e9, _min = 0;\n\tcin >> a;\n\twhile(a--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t_max = min(_max, x / y);\n\t\t_min = max(_min, x / (y + 1) + 1); \n\t}\n\tcout << _min << \" \" << _max << endl;\n\t\n\treturn 0;\n}\n```\n\n### 飞机降落\n\n> 原先第一看就使用贪心，后看题解需使用 DFS + 剪枝（原因是因为数据范围只有10）\n>\n> 思路：从下标0开始搜索，每次搜索都遍历一次数组，从第一个没遍历到的下标下手，继续搜索，这里需要用额外的数组标识是否已经遍历过了。当搜索的下标到最后时，也就是下标等于数组时，就说明能完成降落，因为如果无法完成降落，就不会进行下一次的搜索\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a, b;\nbool res = false;\nint flag[11];\n\nstruct p{\n\tint x, y, z;\n} n[11];\n\nvoid dfs(int x, int s){\n\tif(res){\n\t\treturn;\n\t}\n\tif(x == b){\n\t\tres = true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tif(!flag[i] && s <= n[i].x + n[i].y){\n\t\t\tflag[i] = 1;\n            // 此处用了一点点贪心，尽可能保证本次的开始是满足条件的\n            // 也就是必须都要满足时间是从上一次结束和这一次开始，取个最大值就行\n\t\t\tdfs(x + 1, max(s, n[i].x) + n[i].z);\n\t\t\tflag[i] = 0;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n   \tcin >> a;\n   \twhile(a--){\n   \t\tres = false;\n\t\tcin >> b;\n\t\tfor(int i = 0; i < b; i++) cin >> n[i].x >> n[i].y >> n[i].z;\n\t\tdfs(0, 0);\n\t\tif(res) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n```\n\n### 接龙数列\n\n> 最少删除数 = 总长度- 最长接龙数总长度  \n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \nint dp[10];\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tint res = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tstring num;\n\t\tcin >> num;\n\t\tint x = num[0] - '0', y = num[num.size() - 1] - '0';\n\t\tdp[y] = max(dp[x] + 1, dp[y]);\n\t\tres = max(res, dp[y]);\n\t}\n\tcout << a - res << endl;\n\n\n\treturn 0;\n}\n```\n\n### 子串简写\n\n此题唯一需要注意的是数据范围需要用 long long\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[9] = {1,-1,0,0}, iy[9] = {0,0,1,-1};\nint a, b;\nint n[5001][5001];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tstring str;\n\tchar x, y;\n\tcin >> str >> x >> y;\n\tll len = str.size(), cot = 0, res = 0;\n\tqueue<int> pq;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == x) pq.push(i);\n\t\telse if(str[i] == y){\n\t\t\tres += cot;\n\t\t\twhile(pq.size() && i - pq.front() + 1 >= a){\n\t\t\t\tcot ++;\n\t\t\t\tpq.pop();\n\t\t\t\tres ++;\n\t\t\t}\n\t\t\t\n\t\t} \n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 个人感受\n\n重温一下去年蓝桥杯省赛，依稀记得去年只做了一个C题，一些题用暴力骗分，填空题全军覆没\n\n现在任感觉难度颇高，技术有待提高\n","title":" 第十四届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-03-12\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 日期统计\n\n 此题蓝桥杯官网没说清除，子序列按道理来说应该是连续的，而这个题却不是\n\n 思路：暴力法遍历8个数，找出符合条件的即可\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\nint a, b;\nint n101;\n\nint v13 = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nset<int s;\nint main{\n\tint res = 0;\n\tforint i = 0; i < 100; i++ cin  ni;\n\tforint i = 0; i < 100; i++{\n\t\tifni == 2{\n\t\t\tforint i2 = i + 1; i2 < 100; i2++{\n\t\t\t\tifni2 == 0{\n\t\t\t\t\tforint i3 = i2 + 1; i3 < 100; i3++{\n\t\t\t\t\t\tifni3 == 2{\n\t\t\t\t\t\t\tforint i4 = i3 + 1; i4 < 100; i4++{\n\t\t\t\t\t\t\t\tifni4 == 3{\n\t\t\t\t\t\t\t\t\tforint i5 = i4 + 1; i5 < 100; i5++{\n\t\t\t\t\t\t\t\t\t\tforint i6 = i5 + 1; i6 < 100; i6++{\n\t\t\t\t\t\t\t\t\t\t\tforint i7 = i6 + 1; i7 < 100; i7++{\n\t\t\t\t\t\t\t\t\t\t\t\tforint i8 = i7 + 1; i8 < 100; i8++{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint moth = ni5  10 + ni6, day = ni7  10 + ni8;\n\t\t\t\t\t\t\t\t\t\t\t\t\tifmoth = 1 && moth <= 12 && day = 1 && day <= vmoth{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tifs.findmoth  100 + day == s.end{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts.insertmoth  100 + day;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s.size << endl;\n\t \n\n\treturn 0;\n}\n\n\n 01串的熵\n\n暴力枚举\n\nc++\ninclude<bits/stdc++.h\ninclude<math.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tint res = 0;\n\tint cot = 23333333;\n\tforint i = 1; i < cot; i++{\n\t\tint j = cot  i;\n\t\tdouble a = 1.0  i / cot;\n\t\tdouble b = 1.0  j / cot;\n\t\tdouble res = a  log2a  i  b  log2b  j;  \t \n\t\tiffabsres  11625907.5798 < 0.0001{\n\t\t\tcout << mini, cot  i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n 冶炼金属\n\n 唯一会做的简单题。。。\n\n 思路：每次循环都求出最大和最小的边界，注意考虑最大最小边界【根据题意笔画一下】\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nint main{\n\t\n\tint a, max = 1e9, min = 0;\n\tcin  a;\n\twhilea{\n\t\tint x, y;\n\t\tcin  x  y;\n\t\tmax = minmax, x / y;\n\t\tmin = maxmin, x / y + 1 + 1; \n\t}\n\tcout << min << \" \" << max << endl;\n\t\n\treturn 0;\n}\n\n\n 飞机降落\n\n 原先第一看就使用贪心，后看题解需使用 DFS + 剪枝（原因是因为数据范围只有10）\n\n 思路：从下标0开始搜索，每次搜索都遍历一次数组，从第一个没遍历到的下标下手，继续搜索，这里需要用额外的数组标识是否已经遍历过了。当搜索的下标到最后时，也就是下标等于数组时，就说明能完成降落，因为如果无法完成降落，就不会进行下一次的搜索\n\nc++\ninclude<bits/stdc++.h\nusing namespace std;\nint a, b;\nbool res = false;\nint flag11;\n\nstruct p{\n\tint x, y, z;\n} n11;\n\nvoid dfsint x, int s{\n\tifres{\n\t\treturn;\n\t}\n\tifx == b{\n\t\tres = true;\n\t\treturn;\n\t}\n\tforint i = 0; i < b; i++{\n\t\tifflagi && s <= ni.x + ni.y{\n\t\t\tflagi = 1;\n            // 此处用了一点点贪心，尽可能保证本次的开始是满足条件的\n            // 也就是必须都要满足时间是从上一次结束和这一次开始，取个最大值就行\n\t\t\tdfsx + 1, maxs, ni.x + ni.z;\n\t\t\tflagi = 0;\n\t\t}\n\t}\n}\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n   \tcin  a;\n   \twhilea{\n   \t\tres = false;\n\t\tcin  b;\n\t\tforint i = 0; i < b; i++ cin  ni.x  ni.y  ni.z;\n\t\tdfs0, 0;\n\t\tifres cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n\n\n 接龙数列\n\n 最少删除数 = 总长度 最长接龙数总长度  \n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix4 = {1,1,0,0}, iy4 = {0,0,1,1};\nint a, b; \nint dp10;\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tint res = 0;\n\tforint i = 0; i < a; i++{\n\t\tstring num;\n\t\tcin  num;\n\t\tint x = num0  '0', y = numnum.size  1  '0';\n\t\tdpy = maxdpx + 1, dpy;\n\t\tres = maxres, dpy;\n\t}\n\tcout << a  res << endl;\n\n\n\treturn 0;\n}\n\n\n 子串简写\n\n此题唯一需要注意的是数据范围需要用 long long\n\nc++\ninclude<bits/stdc++.h\ndefine endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix9 = {1,1,0,0}, iy9 = {0,0,1,1};\nint a, b;\nint n50015001;\n\nint main{\n\tios::syncwithstdiofalse, cin.tie0, cout.tie0;\n\tcin  a;\n\tstring str;\n\tchar x, y;\n\tcin  str  x  y;\n\tll len = str.size, cot = 0, res = 0;\n\tqueue<int pq;\n\tforint i = 0; i < len; i++{\n\t\tifstri == x pq.pushi;\n\t\telse ifstri == y{\n\t\t\tres += cot;\n\t\t\twhilepq.size && i  pq.front + 1 = a{\n\t\t\t\tcot ++;\n\t\t\t\tpq.pop;\n\t\t\t\tres ++;\n\t\t\t}\n\t\t\t\n\t\t} \n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n 个人感受\n\n重温一下去年蓝桥杯省赛，依稀记得去年只做了一个C题，一些题用暴力骗分，填空题全军覆没\n\n现在任感觉难度颇高，技术有待提高\n"},{"filename":"nowcoder-month-88","category":"aigorithm","md":{"topSummary":"\ntitle: 牛客小白月赛88\ncategory: 算法\ndate: 2024-03-11\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n老年人康复训练第一场\n\n链接：https://ac.nowcoder.com/acm/contest/77299\n\n### 超级闪光牛可乐\n\n> 思路：只用根据最大值来判断即可\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\tint a, n;\n\tcin >> a >> n;\n\tif(n == 0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint max_ = 0;\n\tchar maxc;\n\tfor(int i = 0; i < n; i++){\n\t\tchar c;\n\t\tint x;\n\t\tcin >> c >> x;\n\t\tif(x > max_){\n\t\t\tmax_ = x;\n\t\t\tmaxc = c;\n\t\t}\n\t}\n\tint cc = ceil(a * 1.0 / max_);\n\tif(cc > 1000) cout << -1 << endl;\n\telse if (cc == 0){\n\t\tcout << maxc << endl;\n\t}\n\telse {\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < cc; i++) str += maxc;\n\t\tcout << str << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n### 人列计算机\n\n> 简单模拟\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\tchar n[6][11];\n\tfor(int i = 0; i < 5; i++){\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\tn[i][j] = str[j];\n\t\t}\n\t}\n\tif(n[2][5] == '&'){\n\t\tchar a = n[1][0], b = n[3][0];\n\t\tcout << ((a - '0') & (b - '0')) << endl;\n\t} else if(n[2][5] == '='){\n\t\tchar a = n[1][0], b = n[3][0];\n\t\tcout << ((a - '0') | (b - '0')) << endl;\n\t} else {\n\t\tchar a = n[2][0];\n\t\tcout << ((a - '0') == 1 ? 0 : 1) << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n### 时间管理大师\n\n> 简单模拟\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nstruct p{\n\tint x, y;\n}n[1001];\n\nset<pair<int, int>> s;\n\nint main(){\n\tint a, idx = 0;\n\tcin >> a;\n\twhile(a--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(y < 1){\n\t\t\ts.insert({x-1, 60 + (y - 1)});\n\t\t} else {\n\t\t\ts.insert({x, y-1});\n\t\t}\n\t\t\n\t\tif(y < 3){\n\t\t\ts.insert({x-1, 60 + (y - 3)});\n\t\t} else {\n\t\t\ts.insert({x, y-3});\n\t\t}\n\t\t\n\t\tif(y < 5){\n\t\t\ts.insert({x-1, 60 + (y - 5)});\n\t\t} else {\n\t\t\ts.insert({x, y-5});\n\t\t}\n\t\t\n\t}\n\t\n\tcout << s.size() << endl;\n\tfor(auto i: s){\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n### 我不是大富翁\n\n> 好家伙，从这就开始上强度了。一开始使用bfs和set模拟两种方法都超时；看题解需要使用二维dp。\n>\n> 思路：不断刷新数组v的状态\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\nint a, b;\n\nint main(){\n\tcin >> a >> b;\n\tvector<int> v(a), n[5001];\n\tfor(int i = 0; i < b; i++){\n\t\tcin >> n[i]; \n\t}\n\tv[0] = 1;\n\tfor(int i = 0; i < b; i++){\n\t\tvector<int> tmp(a);\n\t\tn[i] %= a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tif(v[j] == 1){\n\t\t\t\ttmp[(j + n[i]) % a] = 1;\n\t\t\t\ttmp[(j - n[i] + a) % a] = 1;\n\t\t\t}\n\t\t}\t\n\t\tv.swap(tmp);\n\t}\n\tif(v[0] == 1){\n\t\tcout << \"YES\" << endl;\n\t} else{\n\t\tcout << \"NO\" << endl;\n\t}\n\t \n\treturn 0;\n}\n```\n\n","title":" 牛客小白月赛88\n","category":[" 算法\n"],"date":" 2024-03-11\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n老年人康复训练第一场\n\n链接：https://ac.nowcoder.com/acm/contest/77299\n\n 超级闪光牛可乐\n\n 思路：只用根据最大值来判断即可\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nint main{\n\tint a, n;\n\tcin  a  n;\n\tifn == 0{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint max = 0;\n\tchar maxc;\n\tforint i = 0; i < n; i++{\n\t\tchar c;\n\t\tint x;\n\t\tcin  c  x;\n\t\tifx  max{\n\t\t\tmax = x;\n\t\t\tmaxc = c;\n\t\t}\n\t}\n\tint cc = ceila  1.0 / max;\n\tifcc  1000 cout << 1 << endl;\n\telse if cc == 0{\n\t\tcout << maxc << endl;\n\t}\n\telse {\n\t\tstring str = \"\";\n\t\tforint i = 0; i < cc; i++ str += maxc;\n\t\tcout << str << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n 人列计算机\n\n 简单模拟\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nint main{\n\tchar n611;\n\tforint i = 0; i < 5; i++{\n\t\tstring str;\n\t\tgetlinecin, str;\n\t\tforint j = 0; j < str.size; j++{\n\t\t\tnij = strj;\n\t\t}\n\t}\n\tifn25 == '&'{\n\t\tchar a = n10, b = n30;\n\t\tcout << a  '0' & b  '0' << endl;\n\t} else ifn25 == '='{\n\t\tchar a = n10, b = n30;\n\t\tcout << a  '0'  b  '0' << endl;\n\t} else {\n\t\tchar a = n20;\n\t\tcout << a  '0' == 1 ? 0 : 1 << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n 时间管理大师\n\n 简单模拟\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\n\nstruct p{\n\tint x, y;\n}n1001;\n\nset<pair<int, int s;\n\nint main{\n\tint a, idx = 0;\n\tcin  a;\n\twhilea{\n\t\tint x, y;\n\t\tcin  x  y;\n\t\tify < 1{\n\t\t\ts.insert{x1, 60 + y  1};\n\t\t} else {\n\t\t\ts.insert{x, y1};\n\t\t}\n\t\t\n\t\tify < 3{\n\t\t\ts.insert{x1, 60 + y  3};\n\t\t} else {\n\t\t\ts.insert{x, y3};\n\t\t}\n\t\t\n\t\tify < 5{\n\t\t\ts.insert{x1, 60 + y  5};\n\t\t} else {\n\t\t\ts.insert{x, y5};\n\t\t}\n\t\t\n\t}\n\t\n\tcout << s.size << endl;\n\tforauto i: s{\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n 我不是大富翁\n\n 好家伙，从这就开始上强度了。一开始使用bfs和set模拟两种方法都超时；看题解需要使用二维dp。\n\n 思路：不断刷新数组v的状态\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\nint a, b;\n\nint main{\n\tcin  a  b;\n\tvector<int va, n5001;\n\tforint i = 0; i < b; i++{\n\t\tcin  ni; \n\t}\n\tv0 = 1;\n\tforint i = 0; i < b; i++{\n\t\tvector<int tmpa;\n\t\tni %= a;\n\t\tforint j = 0; j < a; j++{\n\t\t\tifvj == 1{\n\t\t\t\ttmpj + ni % a = 1;\n\t\t\t\ttmpj  ni + a % a = 1;\n\t\t\t}\n\t\t}\t\n\t\tv.swaptmp;\n\t}\n\tifv0 == 1{\n\t\tcout << \"YES\" << endl;\n\t} else{\n\t\tcout << \"NO\" << endl;\n\t}\n\t \n\treturn 0;\n}\n\n\n"},{"filename":"leetcode-hot-100","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode热题100\ncategory: 算法\ndate: 2024-02-25\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 哈希\n\n### 两数之和\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.find(target - nums[i]) != mp.end()){\n                int cc = mp[target - nums[i]];\n                if(cc == i) continue;\n                return {i, mp[target - nums[i]]};\n            }   \n        }\n        return {};\n    }\n};\n```\n\n### 字母异位词分组\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> res;\n        unordered_map<string, vector<string>> ump; \n        for(int i = 0; i < strs.size(); i ++){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            ump[str].push_back(strs[i]);\n        }\n        for (auto it = ump.begin(); it != ump.end(); it ++) {\n            res.push_back(it->second);\n        }\n        return res;\n    }\n};\n```\n\n### 最长连续序列\n\n> 思路：先存入set，再判断是否连续\n>\n> 知识点：set.count()用于判断set中是否存在某个值\n\n```java\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> s;\n        int res = 0, cot = 1;\n        for(int i: nums) s.insert(i);\n        for(int i: s){\n           if(s.count(i - 1)){\n               cot ++;\n           } else {\n               cot = 1;\n           }\n            res = max(res, cot);\n        }\n        return res;\n    }\n};\n```\n\n## 双指针\n\n### 移动零\n\n> 思路：一个指针指向0的下标，一个指向非0下标，不断向后移，遇到非0就交换标记的0的那个数\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int len = nums.size(), l = 0, r = 0;\n        while(r < len){\n            if(nums[r]){\n                swap(nums[l], nums[r]);\n                l ++;\n            }\n            r ++;\n        }\n    }\n};\n```\n\n### 盛最多水的容器\n\n> 思路：一个指针指向左端点，一个指针指向右端点，不断向中间靠拢，每次靠拢都计算一下左右圈起来的面积；若左端点长度小， 就+1，否则右端点就减一\n\n```c++\nclass Solution {\npublic:\n    int maxArea(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1, res = 0;\n        for(int i: nums){\n            int num = 0;\n            if(nums[l] < nums[r]){\n                num = (r - l) * nums[l];\n                l ++;\n            } else {\n                num = (r - l) * nums[r];\n                r --; \n            }\n            res = max(num, res);\n        }\n        return res;\n    }\n};\n```\n\n### 三数之和\n\n> 思路：先需要排序，再来两重循环，要使a+b+c=0，a,b已经确定了，就差c，让c从往前遍历，因为是不断递增的所以a<b<c ，第二次循环b1时，b1>b，所以c1必须小于c才能使得总和为0。满足这个特性，我们就可以用双指针解决。虽然第二重循环中有个for循环，但其实它的循环是对第二重循环遍历r生效的，所以并不影响总的时间复杂度为0(N^2)。\n\n```java\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> res;\n        int len = nums.size();\n        sort(nums.begin(), nums.end());\n        for(int i = 0; i < len; i++){\n            // 需要和上次不同\n            if(i > 0 && nums[i] == nums[i -1]){\n                continue;\n            }\n            int r = len - 1;\n            for(int j = i + 1; j < len; j ++){\n                // 需要和上次不同\n                if(j > i + 1 && nums[j] == nums[j - 1]){\n                    continue;\n                } \n                // 不断相减，找到满足和接近0的r下标\n                while(j < r && nums[i] + nums[j] + nums[r] > 0){\n                    r --;\n                }\n                // j和r下标重合了，说明后续的循环是无效的无需遍历了\n                if(r == j){\n                    break;\n                }\n                if(nums[i] + nums[j] + nums[r] == 0){\n                    res.push_back({nums[r], nums[i], nums[j]});\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 接雨水\n\n> 思路：先从左边考虑，从左往右不断遍历，维护一个左端最大值，若小于这个最大值，就用差算出需要接的雨水。但如果一直这样维护到右半端会出问题【因为可能不知道右端是否存在边，若右边根本就没有边就无需遍历了】，右半端需要维护右端的最大值。所以就左右一起维护往中间靠拢，期间不断维护左右端点的最大值。\n\n```java\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int l = 0, r = height.size() - 1, rmax = 0, lmax = 0, res = 0;\n        while(l < r){\n            lmax = max(lmax, height[l]);\n            rmax = max(rmax, height[r]);\n            if(height[l] < height[r]){\n                res += lmax - height[l];\n                l ++;\n            } else {\n                res += rmax - height[r];\n                r --;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 滑动窗口\n\n### 无重复字符的最长子串\n\n> 思路：依次向右遍历，遇到没出现过的字符写入map中，若出现过就不断弹出队列，直到弹出的字符与当前遍历到的字符一致未知，并且不断维护队列的最大值。最后也别忘了维护最大值，防止出现都是不一致的字符的情况\n\n```java\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        queue<char> q;\n        map<char, int> mp;\n        int res = 0;\n        for(int i = 0; i < s.size(); i++){\n            if(!mp[s[i]]){\n                mp[s[i]] = 1;\n                q.push(s[i]);\n            } else{\n                int len = q.size();\n                res = max(res, len);\n                while(q.size() && q.front() != s[i]){\n                    mp[q.front()] = 0;\n                    q.pop();\n                }\n                q.pop();\n                q.push(s[i]);\n            }\n        }\n        int len = q.size();\n        res = max(res, len);\n        return res;\n    }\n};\n```\n\n### 找到字符串中所有字母异位词\n\n> 思路：用vector来维护字符串中每个字符的个数，若确认两个字符串是一致，则vector也是一样的，用滑动窗口不断右遍历来维护vector\n>\n> 知识点：vector之间可以相等来判断是否一致；想用vector下标法之前必须指定vector个数【前提是该下标要存在】\n\n```java\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int len1 = s.size(), len2 = p.size();\n        if(len1 < len2){\n            return vector<int>();\n        }\n        vector<int> v1(26);\n        vector<int> v2(26);\n        vector<int> res;\n        for(int i = 0; i < len2; i++){\n            v1[s[i] - 'a'] ++;\n            v2[p[i] - 'a'] ++;\n        }\n        if(v1 == v2){\n            res.push_back(0);\n        }\n        for(int i = 0; i < len1 - len2; i++){\n            v1[s[i] - 'a'] --;\n            v1[s[i + len2] - 'a'] ++;\n            if(v1 == v2){\n                res.push_back(i + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 字串\n\n### 和为 K 的子数组\n\n> 思路：用map存放前缀和的各个值，循环遍历一次每次就判断当前的前缀和的值-k是否在map中存在，存在就加一\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int, int> ump;\n        ump[0] = 1;\n        int res = 0, cot = 0;\n        for(int i: nums){\n            cot += i;\n            if(ump.find(cot - k) != ump.end()){\n                res += ump[cot - k];\n            }\n            ump[cot] ++;\n        }\n        return res;\n    }\n};\n```\n\n### 滑动窗口最大值\n\n> 思路：用双端队列维护一个单调队列，每次都会判断队列的尾部是否比当前的nums[i]小，小的话就需要弹出，因为只要有这个元素在，前面的元素永远也不是最大的一个。\n>\n> 知识点：单调队列\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        // 存放下标\n        deque<int> q;\n        vector<int> v;\n        for(int i = 0; i < nums.size(); i++){\n            // 当队列最后一个值小于当前nums[i]时，需要弹出末尾的元素\n            // 因为只要有这个元素在，前面的元素永远也不是最大的一个\n            while(q.size() && nums[q.back()] < nums[i]) q.pop_back();\n            q.push_back(i);\n            // 当超过队列的元素的时候需要弹出队列头\n            if(i - q.front() >= k) q.pop_front();\n            // 当下标超过规定的k的时候就代表可以进行计算\n            if(i >= k - 1) v.push_back(nums[q.front()]);   \n        }\n        return v;\n    }\n};\n```\n\n## 普通数组\n\n### 最大子数组和\n\n> 思路：每次遍历都需要前缀和的值加上当前的值和当前的值进行比较，选出最大的值赋值给前缀和值\n>\n> 知识点：前缀和\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int res = nums[0], cot = nums[0];\n        for(int i = 1; i < nums.size(); i++){\n            cot = max(nums[i], cot + nums[i]);\n            res = max(res, cot);\n        }\n        return res;\n    }\n};\n```\n\n### 合并区间\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<vector<int>> res;\n        sort(intervals.begin(), intervals.end());\n        int len = intervals.size(), minL = intervals[0][0], minR = intervals[0][1];\n        for(int i = 1; i < len; i++){\n            int l = intervals[i][0], r = intervals[i][1];\n            if(l > minR){\n                res.push_back({minL, minR});\n                minL = l;\n            }\n            minR = max(minR, r);\n        }\n        res.push_back({minL, minR});\n        return res;\n    }\n};\n```\n\n### 轮转数组\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int len = nums.size();\n        unordered_map<int, int> mp;\n        for(int i = 0; i < len; i++){\n            mp[i] = nums[i];\n        }\n        for(int i = 0; i < len; i++){\n            nums[(i + k) % len] = mp[i];\n        }\n    }\n};\n```\n\n### 除自身以外数组的乘积\n\n```c++\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int all = nums[0], is = 0, len = nums.size();\n        vector<int> res;\n        if(all == 0){\n            is ++;\n            all = 1;\n        }\n        for(int i = 1; i < len; i++){\n            if(nums[i] == 0) {\n                is ++;\n                continue;\n            }\n            all *= nums[i];\n        }\n        for(int i: nums){\n            if(i == 0){\n                if(is > 1) res.push_back(0);\n                else res.push_back(all);\n            } else {\n                if(is == 1) res.push_back(0);\n                else if(is > 1) res.push_back(0);\n                else res.push_back(all / i);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 缺失的第一个正数\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int res = -100000000, minNum = 0;\n        unordered_map<int, int> ump;\n        priority_queue<int, vector<int>, greater<int>> pq;\n        set<int> s;\n        for(int i: nums) {\n           if(i > 0) s.insert(i);\n        }\n        for(int i: s) {\n            pq.push(i);\n        }\n        int idx = 1;\n        if(pq.size() && pq.top() == 1){\n            while(pq.size()){\n                pq.pop();\n                if(pq.top() != ++idx){\n                    break;\n                } \n            }\n        }\n        return idx;\n\n    }\n};\n```\n\n## 图论\n\n### 岛屿的数量\n\n> 思路：采用DFS遍历，将每个遍历到的为1的点设置标记，下次遍历的时候只遍历没标记的点；把标记的区域数量相加就是结果\n>\n> 知识点：DFS\n\n```c++\nclass Solution {\npublic:\n    vector<vector<char>> num;\n    int lenx, leny;\n    int flag[301][301];\n    int ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    void dfs(int x, int y){\n        if(num[x][y] == '0'){\n            return;\n        }\n        for(int i = 0; i < 4; i++){\n            int _x = ix[i] + x, _y = iy[i] + y;\n            if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && !flag[_x][_y]){\n                flag[_x][_y] = 1;\n                dfs(_x, _y);\n            }\n        }\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int cot = 0;\n        num = grid;\n        lenx = num.size(), leny = grid[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(!flag[i][j] && grid[i][j] == '1'){\n                    dfs(i, j);\n                    cot ++;\n                }\n            }\n        }\n        return cot;\n    }\n};\n```\n\n### 腐烂的橘子\n\n> 思路：先将每个腐烂的橘子加入到队列中，再进行BFS遍历；这里遍历有个关键点就是只遍历没有腐烂的句子，已腐烂的句子无需遍历，因为已经腐烂的句子也会进行传播，而且他的传播用时比现在的短\n>\n> 知识点：多源BFS\n\n```c++\nclass Solution {\npublic:\n    int lenx = 0, leny = 0, cot = 0;\n    int flag[11][11], ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    queue<pair<int, int>> q;\n    int bfs(vector<vector<int>>& grid){\n        int res = 0;\n        while(q.size()){\n            auto top = q.front();\n            q.pop();\n            int xx = top.first, yy = top.second;\n            for(int i = 0; i < 4; i++){\n                int _x = ix[i] + xx, _y = iy[i] + yy;\n                if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && grid[_x][_y] == 1 && !flag[_x][_y]){\n                    flag[_x][_y] = flag[xx][yy] + 1;\n                    q.push({_x, _y});\n                    if(grid[_x][_y] == 1){\n                        cot --;\n                        res = flag[_x][_y];\n                        if(!cot){\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return cot == 0 ? res : -1;\n    }\n    int orangesRotting(vector<vector<int>>& grid) {\n        lenx = grid.size(), leny = grid[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(grid[i][j] == 2){\n                    q.push({i, j});\n                    flag[i][j] = 0;\n                } else if(grid[i][j] == 1){\n                    cot ++;\n                }\n            }\n        }\n        return bfs(grid);\n    }\n};\n```\n\n### 课程表\n\n> 思路：用n来标志状态（0表示未选，1表示正在选，2表示已选），见注释\n>\n> 知识点：DFS\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> num;\n    vector<int> n;\n    bool flag = true;\n    void dfs(int x) {\n        // 标记正在选\n        n[x] = 1;\n        // 假设当前x已经正在选，遍历需要依赖它的课程编号\n        for(int i: num[x]){\n            // 未选就遍历\n            if(!n[i]){\n                dfs(i);\n                if(!flag){\n                    return;\n                }\n             // 正在选说明出现重复依赖，就直接return\n            } else if(n[i] == 1){\n                flag = false;\n                return;\n            }\n        }\n        // 标记已选\n        n[x] = 2;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int len = prerequisites.size();\n        num.resize(numCourses);\n        n.resize(numCourses);\n        for (int i = 0; i < len; i++) {\n            int _1 = prerequisites[i][0], _2 = prerequisites[i][1];\n            num[_2].push_back(_1);\n        }\n        for (int i = 0; i < numCourses; i++) {\n           \t// 只遍历未选的\n            if(!n[i]){\n                dfs(i);\n            }\n        }\n        return flag;\n    }\n};\n```\n\n## 回溯\n\n### 全排列\n\n> 知识点：回溯\n\n```c++\nclass Solution {\npublic:\n    vector<int> num;\n    vector<vector<int>> res;\n    int len = 0;\n    int n[7];\n    void dfs(int x, vector<int> v){\n        if(v.size() == len){\n            res.push_back(v);\n            return;\n        }\n        for(int i = 0; i < len; i++){\n            if(!n[i]){\n                n[i] = 1;\n                v.push_back(num[i]);\n                dfs(i, v);\n                n[i] = 0;\n                v.pop_back();\n            }\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        num = nums;\n        len = nums.size();\n        dfs(0, {});\n        return res;\n    }\n};\n```\n\n### 子集\n\n```c++\nclass Solution {\npublic:\n    vector<int> num;\n    int len = 0;\n    vector<vector<int>> res;\n    void dfs(int x, vector<int> v){\n        if(x == len){\n            res.push_back(v);\n            return;\n        }\n        dfs(x + 1, v);\n        v.push_back(num[x]);\n        dfs(x + 1, v);\n        v.pop_back();\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        num = nums;\n        len = nums.size();\n        dfs(0, {});\n        return res;\n    }\n};\n```\n\n### 电话号码的字母组合\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, vector<char>> ump;\n    vector<string> res;\n    int len = 0;\n    void init(){\n        ump['2'] = {'a','b','c'};\n        ump['3'] = {'d','e','f'};\n        ump['4'] = {'g','h','i'};\n        ump['5'] = {'j','k','l'};\n        ump['6'] = {'m','n','o'};\n        ump['7'] = {'p','q','r','s'};\n        ump['8'] = {'t','u','v'};\n        ump['9'] = {'w','x','y','z'};\n    }\n    void dfs(int x, string str, string digit){\n        if(x == len){\n            res.push_back(str);\n            return;\n        }\n        char c = digit[x];\n        for(int i = 0; i < ump[c].size(); i++){\n            dfs(x + 1, str + ump[c][i], digit);\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        len = digits.size();\n        if(len == 0){\n            return {};\n        }\n        init();\n        dfs(0, \"\", digits);\n\n        return res;\n    }\n};\n```\n\n### 组合总和\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> num;\n    int len = 0;\n    void dfs(int x, int n, vector<int> v, int total){\n        if(n > total){\n            return;\n        }\n        if(n == total){\n            res.push_back(v);\n            return;\n        }\n        v.push_back(num[x]);\n        dfs(x, n + num[x], v, total);\n        v.pop_back();\n        if(x + 1 < len){\n            dfs(x + 1, n, v, total);\n        }\n       \n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        len = candidates.size();\n        num = candidates;\n        dfs(0, 0, {}, target);\n        return res;\n    }\n};\n```\n\n### 括号生成\n\n```c++\nclass Solution {\npublic:\n    vector<string> res;\n    void dfs(int x, int y, string str, int n){\n        if(x > n || y > n){\n            return;\n        }\n        if(x == n){\n            res.push_back(str);\n            return;\n        }\n        dfs(x, y + 1, str + \"(\", n);\n        if(x < y){\n            dfs(x + 1, y, str + \")\", n);\n        }\n\n    }\n    vector<string> generateParenthesis(int n) {\n        dfs(0, 0, \"\", n);\n        return res;\n    }\n};\n```\n\n### 单词搜索\n\n```c++\nclass Solution {\npublic:\n    vector<vector<char>> num;\n    int lenx = 0, leny = 0;\n    bool flag = false;\n    int f[7][7];\n    int ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    bool find(string s, string w){\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] != w[i]) return false;\n        }\n        return true;\n    }\n    void dfs(int x, int y, string s, string w, int f[][7]){\n        if(s == w){\n            flag = true;\n            return;\n        }\n        for(int i = 0; i < 4; i++){\n            int _x = ix[i] + x, _y = iy[i] + y;\n            if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && !f[_x][_y] && find(s + num[_x][_y], w)){\n                f[_x][_y] = 1;\n                dfs(_x, _y, s + num[_x][_y], w, f);\n                f[_x][_y] = 0;\n            }\n        }\n        \n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        num = board;\n        lenx = board.size(), leny = board[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(board[i][j] == word[0]){\n                    memset(f, 0, sizeof f);\n                    string ss = \"\";\n                    ss.append(1, word[0]);\n                    f[i][j] = 1;\n                    dfs(i, j, ss, word, f);\n                    if(flag){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n### 分割回文串\n\n> 思路：用二维数组n来标记i，j是否是回文串，先将n全部赋值为1，找出不是回文串的区间。最后用BFS找出回文串\n>\n> 知识点：BFS，动态规划\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> res;\n    int n[17][17];\n    int len = 0;\n    void dfs(string s, int x, vector<string> v){\n        if(x > len) return;\n        if(x == len){\n            res.push_back(v);\n            return;\n        }\n        for(int i = x; i < len; i++){\n            if(n[x][i]){\n                v.push_back(s.substr(x, i - x + 1));\n                dfs(s, i + 1, v);\n                v.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> partition(string s) {\n        len = s.size();\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++){\n                n[i][j] = 1;\n            }\n        }\n        for(int i = 0; i < len; i++){\n            for(int j = i - 1; j >= 0; j--){\n                n[j][i] = s[i] == s[j] && n[j + 1][i - 1];\n            }\n        }\n        dfs(s, 0, {});\n        return res;\n    }\n};\n```\n\n### N 皇后\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> res;\n    vector<char> v;\n    // 分别表示45°，-45°，y轴标志数组，看是否已经存在\n    int fx[100], fy[100], line[100];\n    void dfs(int x, int n, vector<string> strv){\n        if(x == n){\n            res.push_back(strv);\n            return;\n        }\n        for(int i = 0; i < n; i++){\n            if(!line[i] && !fx[i - x + n] && !fy[i + x]){\n                fy[i + x] = 1;\n                fx[i - x + n] = 1;\n                line[i] = 1;\n                strv[x][i] = 'Q';\n                dfs(x + 1, n, strv);\n                fy[i + x] = 0;\n                fx[i - x + n] = 0;\n                line[i] = 0;\n                strv[x][i] = '.';\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<string> strv;\n        for(int i = 0; i < n; i++){\n            string str = \"\";\n            for(int j = 0; j < n; j++){\n                str += '.';\n            }\n            strv.push_back(str);\n        }\n        dfs(0, n, strv);\n        return res;\n    }\n};\n```\n\n### 零钱兑换\n\n> 知识点：BFS + 记忆化搜索 + 剪枝\n\n```c++\nclass Solution {\npublic:\n    int bfs(vector<int>& coins, int amount){\n        int len = coins.size(), res = INT_MAX;\n        queue<pair<long long, int>> q;\n        unordered_set<long long> s;\n        q.push({0, 0});\n        while(q.size()){\n            auto top = q.front();\n            q.pop();\n            long long x = top.first;\n            int y = top.second;\n            if(x > amount){\n                // 剪枝\n                continue;\n            } else if(x == amount){\n                res = min(res, y);\n                continue;\n            }\n            for(int i = 0; i < len; i++){\n                long long cc = x + coins[i];\n                // 记忆化搜索，已经搜索过了的不再重复记录\n                if(s.find(cc) == s.end()){\n                    s.insert(cc);\n                    q.push({cc, y + 1});\n                }\n            }\n        }\n        return res == INT_MAX ? -1 : res;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        return bfs(coins, amount);\n    }\n};\n```\n\n## 二分\n\n**二分模板**\n\n```c++\n// 左边距\nint get_l(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n        int mid = (l + r ) / 2;\n        if(n[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\nint get_r(int x){\n   int l = 0, r = a - 1;\n   while(l < r){\n   \tint mid = (l + r + 1) / 2;\n       if(n[mid] <= x) l = mid;\n       else r = mid - 1;\n   }\n   return r;\n}\n```\n\n### 搜索插入位置\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size();\n        while(l < r){\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n### 在排序数组中查找元素的第一个和最后一个位置\n\n> 左右边距模板题\n\n```c++\nclass Solution {\npublic:\n    int len = 0;\n    int left(vector<int>& nums, int target){\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l >= 0 && l < len && nums[l] == target ? l : -1;\n    }\n    int right(vector<int>& nums, int target){\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = l + r + 1 >> 1;\n            if(nums[mid] <= target) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return r >= 0 && r < len && nums[r] == target ? r : -1;\n    }\n    vector<int> searchRange(vector<int>& nums, int target) {\n        len = nums.size();\n        return {left(nums, target), right(nums, target)};\n    }\n};\n```\n\n### 搜索二维矩阵\n\n> 思路：将二维转为一维，再用二分查找\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int lenx = matrix.size(), leny = matrix[0].size();\n        vector<int> v;\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                v.push_back(matrix[i][j]);\n            }\n        }\n        int l = 0, r = v.size() - 1;\n        while(l < r){\n            int mid = l + r >> 1;\n            if(v[mid] >= target){\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return (l >= 0 && l < v.size() && v[l] == target) ? true : false;\n    }\n};\n```\n\n### 搜索旋转排序数组\n\n> 思路：中间值与第一个值比较便能知道在左区间还是在右区间，分别在区间内进行讨论即可\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1;\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] >= nums[0]){\n                if(nums[mid] > target && nums[0] <= target){\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else{\n                if(nums[mid] < target && nums[0] > target){\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```\n\n### 寻找旋转排序数组中的最小值\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] >= nums[0]){\n                if(nums[mid] > nums[len - 1]) l = mid + 1;\n                else r = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n\n## 栈\n\n### 有效的括号\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> ss;\n        bool flag = false;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '(' || s[i] == '[' || s[i] == '{') ss.push(s[i]);\n            else {\n                if(ss.size() && ss.top() == '(' && s[i] == ')') ss.pop();\n                else if(ss.size() && ss.top() == '{' && s[i] == '}') ss.pop();\n                else if(ss.size() && ss.top() == '[' && s[i] == ']') ss.pop();\n                else return false;\n            }\n        }\n        return ss.size() == 0 ? true: false;\n    }\n};\n```\n\n### 字符串解码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> ss;\n        stack<int> cc;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] >= '0' && s[i] <= '9') {\n               int q = i, num = 0;\n               while(s[q] >= '0' && s[q] <= '9'){\n                    num = num * 10 + s[q] - '0';\n                    q ++;\n               }\n               cc.push(num);\n               i = q - 1;\n            }\n            else {\n                if(s[i] == ']'){\n                    string str = \"\", rstr = \"\";\n                    while(ss.size()){\n                        if(ss.top() == \"[\") {\n                            ss.pop();\n                            break;\n                        }\n                        str = ss.top() + str;\n                        ss.pop();\n                    }\n                    int cot = cc.top();\n                    cc.pop();\n                    for(int j = 0; j < cot; j++) rstr += str;\n                    ss.push(rstr);\n\n                }\n                else{\n                    string cstr = \"\";\n                    cstr.append(1, s[i]);\n                    ss.push(cstr);\n                }\n            }\n        }\n        string res = \"\";\n        while(ss.size()){\n            res = ss.top() + res;\n            ss.pop();\n        }\n        return res;\n    }\n};\n```\n\n### 每日温度\n\n> 思路：维护一个递减的单调栈\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int len = temperatures.size();\n        stack<int> s;\n        vector<int> res(len, 0);\n        for(int i = 0; i < len; i++){\n            while(s.size() && temperatures[s.top()] < temperatures[i]){\n                res[s.top()] = i - s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n        return res;\n        \n    }\n};\n```\n\n## 堆\n\n### 数组中的第K个最大元素\n\n> 知识点：优先队列\n\n```c++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int idx = 0, res = 1;\n        priority_queue<int, vector<int>, less<int>> pq;\n        for(int i = 0; i < nums.size(); i++){\n            pq.push(nums[i]);\n        }\n        while(pq.size()){\n            int top = pq.top();\n            idx ++;\n            pq.pop();\n            if(idx == k){\n                res = top;\n                break;\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 前 K 个高频元素\n\n> 知识点：并查集\n\n```c++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n[100010];\n    unordered_map<int, int> mp;\n    static bool cmp(p a1, p b1){\n        return a1.y > b1.y;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        int len = nums.size();\n        vector<int> res;\n        for(int i = 0; i < len; i++){\n            int index = i;\n            if(mp.find(nums[i]) != mp.end()){\n                index = mp[nums[i]];\n            }\n            n[index].x = nums[index];\n            n[index].y ++;\n            mp[nums[i]] = index;\n        }\n        sort(n, n + len, cmp);\n        for(int i = 0; i < k; i++){\n            res.push_back(n[i].x);\n        }\n        return res;\n    }\n};\n```\n\n## 贪心\n\n### 买卖股票的最佳时机\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size(), maxx = 0, res = 0;\n        vector<int> v(len);\n        for(int i = len - 1; i >= 0; i--){\n            maxx = max(prices[i], maxx);\n            v[i] = maxx;\n        }\n        for(int i = 0; i < len; i++){\n            res = max(res, v[i] - prices[i]);\n        }\n        return res;\n    }\n};\n```\n\n### 跳跃游戏\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int len = nums.size(), maxx = 0;\n        vector<bool> v(len, false);\n        for(int i = 0; i < len; i++){\n            if(i > maxx){\n                return false;\n            }\n            maxx = max(maxx, i + nums[i]);\n            v[i] = true;\n        }\n        return v[len - 1];\n    }a\n};\n```\n\n### <u>* 跳跃游戏 II</u>\n\n```c++\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int len = nums.size(), maxx= 0, end = 0, res = 0;\n        // * 循环遍历到 len - 1\n        for(int i = 0; i < len - 1; i++){ \n            maxx = max(maxx, nums[i] + i);\n            if(end == i){\n                end = maxx;\n                res ++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 划分字母区间\n\n```c++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n[27];\n    vector<int> partitionLabels(string s) {\n        vector<int> res;\n        int len = s.size();\n        for(int i = 0; i < len; i++){\n            n[s[i] - 'a'].x = min(n[s[i] - 'a'].x, i);\n            n[s[i] - 'a'].y = max(n[s[i] - 'a'].y, i);\n        }\n        int minL = 0, maxL = 0;\n        for(int i = 0; i < len; i++){\n            maxL = max(n[s[i] - 'a'].y, maxL);\n            if(maxL == i){\n                res.push_back(maxL - minL + 1);\n                minL = i + 1;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 动态规划\n\n### 爬楼梯\n\n> 思路：斐波拉且数列\n\n```c++\nclass Solution {\npublic:\n    int nums[46];\n    int climbStairs(int n) {\n        nums[0] = 1;\n        nums[1] = 1;\n        for(int i = 2; i <= n; i++){\n            nums[i] = nums[i - 1] + nums[i - 2]; \n        }\n        return nums[n];\n    }\n};\n```\n\n### 杨辉三角\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> res(numRows);\n        res[0] = {1};\n        for(int i = 1; i < numRows; i++){\n            vector<int> v(i + 1, 1);\n            for(int j = 1; j <= i - 1; j++){\n                v[j] = res[i - 1][j] + res[i - 1][j - 1]; \n            }\n            res[i] = v;\n        }\n        return res;\n    }\n};\n```\n\n### 打家劫舍\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size(), res = 0;\n        vector<int> v(len + 1);\n        for(int i = 1; i <= len; i++){\n            v[i] = nums[i - 1];\n            res = max(v[i], res);\n        }\n        for(int i = 3; i <= len; i++){    \n            v[i] = v[i] + max(v[i - 2], v[i - 3]);\n            res = max(res, v[i]);\n        }\n        return res;\n\n    }\n};\n```\n\n### 完全平方数\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> v(n + 1);\n        v[1] = 1;\n        for(int i = 2; i <= n; i++){\n            int num = INT_MAX;\n            for(int j = 1; j * j <= i; j++){\n                // 此处为关键点，从完全平方数开始找，找出想要最小凑出完全平凡数的数的结果\n                num = min(num, v[i - j * j]);\n            }\n            // 最后加上完全平凡数的结果1\n            v[i] = num + 1;\n        }\n        return v[n];\n    }\n};\n```\n\n\n\n\n\n## 常用算法总结\n\n- 二分\n\n- 哈希\n\n- 双指针\n\n- 思维\n\n- 模拟\n\n- 贪心\n\n- 前缀和(一维、二维)，后缀和\n\n- 队列\n  - 滑动窗口[双端队列]\n  - 优先队列\n  \n- 栈\n  - 单调栈\n\n- 搜索\n  - DFS\n  - BFS\n  - 多源BFS\n\n- 动态规划\n\n- 数学知识\n\n  - 哈夫顿距离：d(i,j)=|xi-xj|+|yi-yj|\n\n    - 哈夫顿距离转为切比雪夫距离：|xi-xj| + |yi-yj| =  max(|x1'-x2'|, |y1'-y2'|)\n\n      原坐标(x, y)与(x', y')的关系：(x', y') = (x + y, y - x)\n\n  - 欧氏距离：d(i,j)=(xi-xj) ^ 2 + (yi - yj) ^ 2\n\n  - 直线公式：y = (y2-y1)/(x2-x1) * x - (x2 * y1 - x1 * y2)/(x2-x1)\n  \n  - 质数\n  \n  - 因数\n  \n  - 容斥原理\n  \n- 图论\n\n  - 迪杰斯特拉\n\n","title":" Leetcode热题100\n","category":[" 算法\n"],"date":" 2024-02-25\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 哈希\n\n 两数之和\n\nc++\nclass Solution {\npublic:\n    vector<int twoSumvector<int& nums, int target {\n        unorderedmap<int, int mp;\n        forint i = 0; i < nums.size; i++ mpnumsi = i;\n        forint i = 0; i < nums.size; i++{\n            ifmp.findtarget  numsi = mp.end{\n                int cc = mptarget  numsi;\n                ifcc == i continue;\n                return {i, mptarget  numsi};\n            }   \n        }\n        return {};\n    }\n};\n\n\n 字母异位词分组\n\nc++\nclass Solution {\npublic:\n    vector<vector<string groupAnagramsvector<string& strs {\n        vector<vector<string res;\n        unorderedmap<string, vector<string ump; \n        forint i = 0; i < strs.size; i ++{\n            string str = strsi;\n            sortstr.begin, str.end;\n            umpstr.pushbackstrsi;\n        }\n        for auto it = ump.begin; it = ump.end; it ++ {\n            res.pushbackitsecond;\n        }\n        return res;\n    }\n};\n\n\n 最长连续序列\n\n 思路：先存入set，再判断是否连续\n\n 知识点：set.count用于判断set中是否存在某个值\n\njava\nclass Solution {\npublic:\n    int longestConsecutivevector<int& nums {\n        set<int s;\n        int res = 0, cot = 1;\n        forint i: nums s.inserti;\n        forint i: s{\n           ifs.counti  1{\n               cot ++;\n           } else {\n               cot = 1;\n           }\n            res = maxres, cot;\n        }\n        return res;\n    }\n};\n\n\n 双指针\n\n 移动零\n\n 思路：一个指针指向0的下标，一个指向非0下标，不断向后移，遇到非0就交换标记的0的那个数\n\nc++\nclass Solution {\npublic:\n    void moveZeroesvector<int& nums {\n        int len = nums.size, l = 0, r = 0;\n        whiler < len{\n            ifnumsr{\n                swapnumsl, numsr;\n                l ++;\n            }\n            r ++;\n        }\n    }\n};\n\n\n 盛最多水的容器\n\n 思路：一个指针指向左端点，一个指针指向右端点，不断向中间靠拢，每次靠拢都计算一下左右圈起来的面积；若左端点长度小， 就+1，否则右端点就减一\n\nc++\nclass Solution {\npublic:\n    int maxAreavector<int& nums {\n        int l = 0, r = nums.size  1, res = 0;\n        forint i: nums{\n            int num = 0;\n            ifnumsl < numsr{\n                num = r  l  numsl;\n                l ++;\n            } else {\n                num = r  l  numsr;\n                r ; \n            }\n            res = maxnum, res;\n        }\n        return res;\n    }\n};\n\n\n 三数之和\n\n 思路：先需要排序，再来两重循环，要使a+b+c=0，a,b已经确定了，就差c，让c从往前遍历，因为是不断递增的所以a<b<c ，第二次循环b1时，b1b，所以c1必须小于c才能使得总和为0。满足这个特性，我们就可以用双指针解决。虽然第二重循环中有个for循环，但其实它的循环是对第二重循环遍历r生效的，所以并不影响总的时间复杂度为0N^2。\n\njava\nclass Solution {\npublic:\n    vector<vector<int threeSumvector<int& nums {\n        vector<vector<int res;\n        int len = nums.size;\n        sortnums.begin, nums.end;\n        forint i = 0; i < len; i++{\n            // 需要和上次不同\n            ifi  0 && numsi == numsi 1{\n                continue;\n            }\n            int r = len  1;\n            forint j = i + 1; j < len; j ++{\n                // 需要和上次不同\n                ifj  i + 1 && numsj == numsj  1{\n                    continue;\n                } \n                // 不断相减，找到满足和接近0的r下标\n                whilej < r && numsi + numsj + numsr  0{\n                    r ;\n                }\n                // j和r下标重合了，说明后续的循环是无效的无需遍历了\n                ifr == j{\n                    break;\n                }\n                ifnumsi + numsj + numsr == 0{\n                    res.pushback{numsr, numsi, numsj};\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n 接雨水\n\n 思路：先从左边考虑，从左往右不断遍历，维护一个左端最大值，若小于这个最大值，就用差算出需要接的雨水。但如果一直这样维护到右半端会出问题【因为可能不知道右端是否存在边，若右边根本就没有边就无需遍历了】，右半端需要维护右端的最大值。所以就左右一起维护往中间靠拢，期间不断维护左右端点的最大值。\n\njava\nclass Solution {\npublic:\n    int trapvector<int& height {\n        int l = 0, r = height.size  1, rmax = 0, lmax = 0, res = 0;\n        whilel < r{\n            lmax = maxlmax, heightl;\n            rmax = maxrmax, heightr;\n            ifheightl < heightr{\n                res += lmax  heightl;\n                l ++;\n            } else {\n                res += rmax  heightr;\n                r ;\n            }\n        }\n        return res;\n    }\n};\n\n\n 滑动窗口\n\n 无重复字符的最长子串\n\n 思路：依次向右遍历，遇到没出现过的字符写入map中，若出现过就不断弹出队列，直到弹出的字符与当前遍历到的字符一致未知，并且不断维护队列的最大值。最后也别忘了维护最大值，防止出现都是不一致的字符的情况\n\njava\nclass Solution {\npublic:\n    int lengthOfLongestSubstringstring s {\n        queue<char q;\n        map<char, int mp;\n        int res = 0;\n        forint i = 0; i < s.size; i++{\n            ifmpsi{\n                mpsi = 1;\n                q.pushsi;\n            } else{\n                int len = q.size;\n                res = maxres, len;\n                whileq.size && q.front = si{\n                    mpq.front = 0;\n                    q.pop;\n                }\n                q.pop;\n                q.pushsi;\n            }\n        }\n        int len = q.size;\n        res = maxres, len;\n        return res;\n    }\n};\n\n\n 找到字符串中所有字母异位词\n\n 思路：用vector来维护字符串中每个字符的个数，若确认两个字符串是一致，则vector也是一样的，用滑动窗口不断右遍历来维护vector\n\n 知识点：vector之间可以相等来判断是否一致；想用vector下标法之前必须指定vector个数【前提是该下标要存在】\n\njava\nclass Solution {\npublic:\n    vector<int findAnagramsstring s, string p {\n        int len1 = s.size, len2 = p.size;\n        iflen1 < len2{\n            return vector<int;\n        }\n        vector<int v126;\n        vector<int v226;\n        vector<int res;\n        forint i = 0; i < len2; i++{\n            v1si  'a' ++;\n            v2pi  'a' ++;\n        }\n        ifv1 == v2{\n            res.pushback0;\n        }\n        forint i = 0; i < len1  len2; i++{\n            v1si  'a' ;\n            v1si + len2  'a' ++;\n            ifv1 == v2{\n                res.pushbacki + 1;\n            }\n        }\n        return res;\n    }\n};\n\n\n 字串\n\n 和为 K 的子数组\n\n 思路：用map存放前缀和的各个值，循环遍历一次每次就判断当前的前缀和的值k是否在map中存在，存在就加一\n\nc++\nclass Solution {\npublic:\n    int subarraySumvector<int& nums, int k {\n        unorderedmap<int, int ump;\n        ump0 = 1;\n        int res = 0, cot = 0;\n        forint i: nums{\n            cot += i;\n            ifump.findcot  k = ump.end{\n                res += umpcot  k;\n            }\n            umpcot ++;\n        }\n        return res;\n    }\n};\n\n\n 滑动窗口最大值\n\n 思路：用双端队列维护一个单调队列，每次都会判断队列的尾部是否比当前的numsi小，小的话就需要弹出，因为只要有这个元素在，前面的元素永远也不是最大的一个。\n\n 知识点：单调队列\n\nc++\nclass Solution {\npublic:\n    vector<int maxSlidingWindowvector<int& nums, int k {\n        // 存放下标\n        deque<int q;\n        vector<int v;\n        forint i = 0; i < nums.size; i++{\n            // 当队列最后一个值小于当前numsi时，需要弹出末尾的元素\n            // 因为只要有这个元素在，前面的元素永远也不是最大的一个\n            whileq.size && numsq.back < numsi q.popback;\n            q.pushbacki;\n            // 当超过队列的元素的时候需要弹出队列头\n            ifi  q.front = k q.popfront;\n            // 当下标超过规定的k的时候就代表可以进行计算\n            ifi = k  1 v.pushbacknumsq.front;   \n        }\n        return v;\n    }\n};\n\n\n 普通数组\n\n 最大子数组和\n\n 思路：每次遍历都需要前缀和的值加上当前的值和当前的值进行比较，选出最大的值赋值给前缀和值\n\n 知识点：前缀和\n\nc++\nclass Solution {\npublic:\n    int maxSubArrayvector<int& nums {\n        int res = nums0, cot = nums0;\n        forint i = 1; i < nums.size; i++{\n            cot = maxnumsi, cot + numsi;\n            res = maxres, cot;\n        }\n        return res;\n    }\n};\n\n\n 合并区间\n\nc++\nclass Solution {\npublic:\n    vector<vector<int mergevector<vector<int& intervals {\n        vector<vector<int res;\n        sortintervals.begin, intervals.end;\n        int len = intervals.size, minL = intervals00, minR = intervals01;\n        forint i = 1; i < len; i++{\n            int l = intervalsi0, r = intervalsi1;\n            ifl  minR{\n                res.pushback{minL, minR};\n                minL = l;\n            }\n            minR = maxminR, r;\n        }\n        res.pushback{minL, minR};\n        return res;\n    }\n};\n\n\n 轮转数组\n\nc++\nclass Solution {\npublic:\n    void rotatevector<int& nums, int k {\n        int len = nums.size;\n        unorderedmap<int, int mp;\n        forint i = 0; i < len; i++{\n            mpi = numsi;\n        }\n        forint i = 0; i < len; i++{\n            numsi + k % len = mpi;\n        }\n    }\n};\n\n\n 除自身以外数组的乘积\n\nc++\nclass Solution {\npublic:\n    vector<int productExceptSelfvector<int& nums {\n        int all = nums0, is = 0, len = nums.size;\n        vector<int res;\n        ifall == 0{\n            is ++;\n            all = 1;\n        }\n        forint i = 1; i < len; i++{\n            ifnumsi == 0 {\n                is ++;\n                continue;\n            }\n            all = numsi;\n        }\n        forint i: nums{\n            ifi == 0{\n                ifis  1 res.pushback0;\n                else res.pushbackall;\n            } else {\n                ifis == 1 res.pushback0;\n                else ifis  1 res.pushback0;\n                else res.pushbackall / i;\n            }\n        }\n        return res;\n    }\n};\n\n\n 缺失的第一个正数\n\nc++\nclass Solution {\npublic:\n    int firstMissingPositivevector<int& nums {\n        int res = 100000000, minNum = 0;\n        unorderedmap<int, int ump;\n        priorityqueue<int, vector<int, greater<int pq;\n        set<int s;\n        forint i: nums {\n           ifi  0 s.inserti;\n        }\n        forint i: s {\n            pq.pushi;\n        }\n        int idx = 1;\n        ifpq.size && pq.top == 1{\n            whilepq.size{\n                pq.pop;\n                ifpq.top = ++idx{\n                    break;\n                } \n            }\n        }\n        return idx;\n\n    }\n};\n\n\n 图论\n\n 岛屿的数量\n\n 思路：采用DFS遍历，将每个遍历到的为1的点设置标记，下次遍历的时候只遍历没标记的点；把标记的区域数量相加就是结果\n\n 知识点：DFS\n\nc++\nclass Solution {\npublic:\n    vector<vector<char num;\n    int lenx, leny;\n    int flag301301;\n    int ix4 = {0,0,1,1}, iy4 = {1,1,0,0};\n    void dfsint x, int y{\n        ifnumxy == '0'{\n            return;\n        }\n        forint i = 0; i < 4; i++{\n            int x = ixi + x, y = iyi + y;\n            ifx = 0 && x < lenx && y = 0 && y < leny && flagxy{\n                flagxy = 1;\n                dfsx, y;\n            }\n        }\n    }\n    int numIslandsvector<vector<char& grid {\n        int cot = 0;\n        num = grid;\n        lenx = num.size, leny = grid0.size;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                ifflagij && gridij == '1'{\n                    dfsi, j;\n                    cot ++;\n                }\n            }\n        }\n        return cot;\n    }\n};\n\n\n 腐烂的橘子\n\n 思路：先将每个腐烂的橘子加入到队列中，再进行BFS遍历；这里遍历有个关键点就是只遍历没有腐烂的句子，已腐烂的句子无需遍历，因为已经腐烂的句子也会进行传播，而且他的传播用时比现在的短\n\n 知识点：多源BFS\n\nc++\nclass Solution {\npublic:\n    int lenx = 0, leny = 0, cot = 0;\n    int flag1111, ix4 = {0,0,1,1}, iy4 = {1,1,0,0};\n    queue<pair<int, int q;\n    int bfsvector<vector<int& grid{\n        int res = 0;\n        whileq.size{\n            auto top = q.front;\n            q.pop;\n            int xx = top.first, yy = top.second;\n            forint i = 0; i < 4; i++{\n                int x = ixi + xx, y = iyi + yy;\n                ifx = 0 && x < lenx && y = 0 && y < leny && gridxy == 1 && flagxy{\n                    flagxy = flagxxyy + 1;\n                    q.push{x, y};\n                    ifgridxy == 1{\n                        cot ;\n                        res = flagxy;\n                        ifcot{\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return cot == 0 ? res : 1;\n    }\n    int orangesRottingvector<vector<int& grid {\n        lenx = grid.size, leny = grid0.size;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                ifgridij == 2{\n                    q.push{i, j};\n                    flagij = 0;\n                } else ifgridij == 1{\n                    cot ++;\n                }\n            }\n        }\n        return bfsgrid;\n    }\n};\n\n\n 课程表\n\n 思路：用n来标志状态（0表示未选，1表示正在选，2表示已选），见注释\n\n 知识点：DFS\n\nc++\nclass Solution {\npublic:\n    vector<vector<int num;\n    vector<int n;\n    bool flag = true;\n    void dfsint x {\n        // 标记正在选\n        nx = 1;\n        // 假设当前x已经正在选，遍历需要依赖它的课程编号\n        forint i: numx{\n            // 未选就遍历\n            ifni{\n                dfsi;\n                ifflag{\n                    return;\n                }\n             // 正在选说明出现重复依赖，就直接return\n            } else ifni == 1{\n                flag = false;\n                return;\n            }\n        }\n        // 标记已选\n        nx = 2;\n    }\n    bool canFinishint numCourses, vector<vector<int& prerequisites {\n        int len = prerequisites.size;\n        num.resizenumCourses;\n        n.resizenumCourses;\n        for int i = 0; i < len; i++ {\n            int 1 = prerequisitesi0, 2 = prerequisitesi1;\n            num2.pushback1;\n        }\n        for int i = 0; i < numCourses; i++ {\n           \t// 只遍历未选的\n            ifni{\n                dfsi;\n            }\n        }\n        return flag;\n    }\n};\n\n\n 回溯\n\n 全排列\n\n 知识点：回溯\n\nc++\nclass Solution {\npublic:\n    vector<int num;\n    vector<vector<int res;\n    int len = 0;\n    int n7;\n    void dfsint x, vector<int v{\n        ifv.size == len{\n            res.pushbackv;\n            return;\n        }\n        forint i = 0; i < len; i++{\n            ifni{\n                ni = 1;\n                v.pushbacknumi;\n                dfsi, v;\n                ni = 0;\n                v.popback;\n            }\n        }\n    }\n    vector<vector<int permutevector<int& nums {\n        num = nums;\n        len = nums.size;\n        dfs0, {};\n        return res;\n    }\n};\n\n\n 子集\n\nc++\nclass Solution {\npublic:\n    vector<int num;\n    int len = 0;\n    vector<vector<int res;\n    void dfsint x, vector<int v{\n        ifx == len{\n            res.pushbackv;\n            return;\n        }\n        dfsx + 1, v;\n        v.pushbacknumx;\n        dfsx + 1, v;\n        v.popback;\n    }\n    vector<vector<int subsetsvector<int& nums {\n        num = nums;\n        len = nums.size;\n        dfs0, {};\n        return res;\n    }\n};\n\n\n 电话号码的字母组合\n\nc++\nclass Solution {\npublic:\n    unorderedmap<int, vector<char ump;\n    vector<string res;\n    int len = 0;\n    void init{\n        ump'2' = {'a','b','c'};\n        ump'3' = {'d','e','f'};\n        ump'4' = {'g','h','i'};\n        ump'5' = {'j','k','l'};\n        ump'6' = {'m','n','o'};\n        ump'7' = {'p','q','r','s'};\n        ump'8' = {'t','u','v'};\n        ump'9' = {'w','x','y','z'};\n    }\n    void dfsint x, string str, string digit{\n        ifx == len{\n            res.pushbackstr;\n            return;\n        }\n        char c = digitx;\n        forint i = 0; i < umpc.size; i++{\n            dfsx + 1, str + umpci, digit;\n        }\n    }\n    vector<string letterCombinationsstring digits {\n        len = digits.size;\n        iflen == 0{\n            return {};\n        }\n        init;\n        dfs0, \"\", digits;\n\n        return res;\n    }\n};\n\n\n 组合总和\n\nc++\nclass Solution {\npublic:\n    vector<vector<int res;\n    vector<int num;\n    int len = 0;\n    void dfsint x, int n, vector<int v, int total{\n        ifn  total{\n            return;\n        }\n        ifn == total{\n            res.pushbackv;\n            return;\n        }\n        v.pushbacknumx;\n        dfsx, n + numx, v, total;\n        v.popback;\n        ifx + 1 < len{\n            dfsx + 1, n, v, total;\n        }\n       \n    }\n    vector<vector<int combinationSumvector<int& candidates, int target {\n        len = candidates.size;\n        num = candidates;\n        dfs0, 0, {}, target;\n        return res;\n    }\n};\n\n\n 括号生成\n\nc++\nclass Solution {\npublic:\n    vector<string res;\n    void dfsint x, int y, string str, int n{\n        ifx  n  y  n{\n            return;\n        }\n        ifx == n{\n            res.pushbackstr;\n            return;\n        }\n        dfsx, y + 1, str + \"\", n;\n        ifx < y{\n            dfsx + 1, y, str + \"\", n;\n        }\n\n    }\n    vector<string generateParenthesisint n {\n        dfs0, 0, \"\", n;\n        return res;\n    }\n};\n\n\n 单词搜索\n\nc++\nclass Solution {\npublic:\n    vector<vector<char num;\n    int lenx = 0, leny = 0;\n    bool flag = false;\n    int f77;\n    int ix4 = {0,0,1,1}, iy4 = {1,1,0,0};\n    bool findstring s, string w{\n        forint i = 0; i < s.size; i++{\n            ifsi = wi return false;\n        }\n        return true;\n    }\n    void dfsint x, int y, string s, string w, int f7{\n        ifs == w{\n            flag = true;\n            return;\n        }\n        forint i = 0; i < 4; i++{\n            int x = ixi + x, y = iyi + y;\n            ifx = 0 && x < lenx && y = 0 && y < leny && fxy && finds + numxy, w{\n                fxy = 1;\n                dfsx, y, s + numxy, w, f;\n                fxy = 0;\n            }\n        }\n        \n    }\n    bool existvector<vector<char& board, string word {\n        num = board;\n        lenx = board.size, leny = board0.size;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                ifboardij == word0{\n                    memsetf, 0, sizeof f;\n                    string ss = \"\";\n                    ss.append1, word0;\n                    fij = 1;\n                    dfsi, j, ss, word, f;\n                    ifflag{\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n\n\n 分割回文串\n\n 思路：用二维数组n来标记i，j是否是回文串，先将n全部赋值为1，找出不是回文串的区间。最后用BFS找出回文串\n\n 知识点：BFS，动态规划\n\nc++\nclass Solution {\npublic:\n    vector<vector<string res;\n    int n1717;\n    int len = 0;\n    void dfsstring s, int x, vector<string v{\n        ifx  len return;\n        ifx == len{\n            res.pushbackv;\n            return;\n        }\n        forint i = x; i < len; i++{\n            ifnxi{\n                v.pushbacks.substrx, i  x + 1;\n                dfss, i + 1, v;\n                v.popback;\n            }\n        }\n    }\n    vector<vector<string partitionstring s {\n        len = s.size;\n        forint i = 0; i < len; i++{\n            forint j = 0; j < len; j++{\n                nij = 1;\n            }\n        }\n        forint i = 0; i < len; i++{\n            forint j = i  1; j = 0; j{\n                nji = si == sj && nj + 1i  1;\n            }\n        }\n        dfss, 0, {};\n        return res;\n    }\n};\n\n\n N 皇后\n\nc++\nclass Solution {\npublic:\n    vector<vector<string res;\n    vector<char v;\n    // 分别表示45°，45°，y轴标志数组，看是否已经存在\n    int fx100, fy100, line100;\n    void dfsint x, int n, vector<string strv{\n        ifx == n{\n            res.pushbackstrv;\n            return;\n        }\n        forint i = 0; i < n; i++{\n            iflinei && fxi  x + n && fyi + x{\n                fyi + x = 1;\n                fxi  x + n = 1;\n                linei = 1;\n                strvxi = 'Q';\n                dfsx + 1, n, strv;\n                fyi + x = 0;\n                fxi  x + n = 0;\n                linei = 0;\n                strvxi = '.';\n            }\n        }\n    }\n    vector<vector<string solveNQueensint n {\n        vector<string strv;\n        forint i = 0; i < n; i++{\n            string str = \"\";\n            forint j = 0; j < n; j++{\n                str += '.';\n            }\n            strv.pushbackstr;\n        }\n        dfs0, n, strv;\n        return res;\n    }\n};\n\n\n 零钱兑换\n\n 知识点：BFS + 记忆化搜索 + 剪枝\n\nc++\nclass Solution {\npublic:\n    int bfsvector<int& coins, int amount{\n        int len = coins.size, res = INTMAX;\n        queue<pair<long long, int q;\n        unorderedset<long long s;\n        q.push{0, 0};\n        whileq.size{\n            auto top = q.front;\n            q.pop;\n            long long x = top.first;\n            int y = top.second;\n            ifx  amount{\n                // 剪枝\n                continue;\n            } else ifx == amount{\n                res = minres, y;\n                continue;\n            }\n            forint i = 0; i < len; i++{\n                long long cc = x + coinsi;\n                // 记忆化搜索，已经搜索过了的不再重复记录\n                ifs.findcc == s.end{\n                    s.insertcc;\n                    q.push{cc, y + 1};\n                }\n            }\n        }\n        return res == INTMAX ? 1 : res;\n    }\n    int coinChangevector<int& coins, int amount {\n        return bfscoins, amount;\n    }\n};\n\n\n 二分\n\n二分模板\n\nc++\n// 左边距\nint getlint x{\n    int l = 0, r = a  1;\n    whilel < r{\n        int mid = l + r  / 2;\n        ifnmid = x r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\nint getrint x{\n   int l = 0, r = a  1;\n   whilel < r{\n   \tint mid = l + r + 1 / 2;\n       ifnmid <= x l = mid;\n       else r = mid  1;\n   }\n   return r;\n}\n\n\n 搜索插入位置\n\nc++\nclass Solution {\npublic:\n    int searchInsertvector<int& nums, int target {\n        int l = 0, r = nums.size;\n        whilel < r{\n            int mid = l + r  1;\n            ifnumsmid = target {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n\n\n 在排序数组中查找元素的第一个和最后一个位置\n\n 左右边距模板题\n\nc++\nclass Solution {\npublic:\n    int len = 0;\n    int leftvector<int& nums, int target{\n        int l = 0, r = len  1;\n        whilel < r{\n            int mid = l + r  1;\n            ifnumsmid = target {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l = 0 && l < len && numsl == target ? l : 1;\n    }\n    int rightvector<int& nums, int target{\n        int l = 0, r = len  1;\n        whilel < r{\n            int mid = l + r + 1  1;\n            ifnumsmid <= target {\n                l = mid;\n            } else {\n                r = mid  1;\n            }\n        }\n        return r = 0 && r < len && numsr == target ? r : 1;\n    }\n    vector<int searchRangevector<int& nums, int target {\n        len = nums.size;\n        return {leftnums, target, rightnums, target};\n    }\n};\n\n\n 搜索二维矩阵\n\n 思路：将二维转为一维，再用二分查找\n\nc++\nclass Solution {\npublic:\n    bool searchMatrixvector<vector<int& matrix, int target {\n        int lenx = matrix.size, leny = matrix0.size;\n        vector<int v;\n        forint i = 0; i < lenx; i++{\n            forint j = 0; j < leny; j++{\n                v.pushbackmatrixij;\n            }\n        }\n        int l = 0, r = v.size  1;\n        whilel < r{\n            int mid = l + r  1;\n            ifvmid = target{\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l = 0 && l < v.size && vl == target ? true : false;\n    }\n};\n\n\n 搜索旋转排序数组\n\n 思路：中间值与第一个值比较便能知道在左区间还是在右区间，分别在区间内进行讨论即可\n\nc++\nclass Solution {\npublic:\n    int searchvector<int& nums, int target {\n        int n = nums.size;\n        int l = 0, r = n  1;\n        whilel <= r{\n            int mid = l + r  1;\n            ifnumsmid == target return mid;\n            ifnumsmid = nums0{\n                ifnumsmid  target && nums0 <= target{\n                    r = mid  1;\n                } else {\n                    l = mid + 1;\n                }\n            } else{\n                ifnumsmid < target && nums0  target{\n                    l = mid + 1;\n                } else {\n                    r = mid  1;\n                }\n            }\n        }\n        return 1;\n    }\n};\n\n\n 寻找旋转排序数组中的最小值\n\nc++\nclass Solution {\npublic:\n    int findMinvector<int& nums {\n        int len = nums.size;\n        int l = 0, r = len  1;\n        whilel < r{\n            int mid = l + r  1;\n            ifnumsmid = nums0{\n                ifnumsmid  numslen  1 l = mid + 1;\n                else r = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return numsl;\n    }\n};\n\n\n 栈\n\n 有效的括号\n\nc++\nclass Solution {\npublic:\n    bool isValidstring s {\n        stack<char ss;\n        bool flag = false;\n        forint i = 0; i < s.size; i++{\n            ifsi == ''  si == ''  si == '{' ss.pushsi;\n            else {\n                ifss.size && ss.top == '' && si == '' ss.pop;\n                else ifss.size && ss.top == '{' && si == '}' ss.pop;\n                else ifss.size && ss.top == '' && si == '' ss.pop;\n                else return false;\n            }\n        }\n        return ss.size == 0 ? true: false;\n    }\n};\n\n\n 字符串解码\n\nc++\nclass Solution {\npublic:\n    string decodeStringstring s {\n        stack<string ss;\n        stack<int cc;\n        forint i = 0; i < s.size; i++{\n            ifsi = '0' && si <= '9' {\n               int q = i, num = 0;\n               whilesq = '0' && sq <= '9'{\n                    num = num  10 + sq  '0';\n                    q ++;\n               }\n               cc.pushnum;\n               i = q  1;\n            }\n            else {\n                ifsi == ''{\n                    string str = \"\", rstr = \"\";\n                    whiless.size{\n                        ifss.top == \"\" {\n                            ss.pop;\n                            break;\n                        }\n                        str = ss.top + str;\n                        ss.pop;\n                    }\n                    int cot = cc.top;\n                    cc.pop;\n                    forint j = 0; j < cot; j++ rstr += str;\n                    ss.pushrstr;\n\n                }\n                else{\n                    string cstr = \"\";\n                    cstr.append1, si;\n                    ss.pushcstr;\n                }\n            }\n        }\n        string res = \"\";\n        whiless.size{\n            res = ss.top + res;\n            ss.pop;\n        }\n        return res;\n    }\n};\n\n\n 每日温度\n\n 思路：维护一个递减的单调栈\n\nc++\nclass Solution {\npublic:\n    vector<int dailyTemperaturesvector<int& temperatures {\n        int len = temperatures.size;\n        stack<int s;\n        vector<int reslen, 0;\n        forint i = 0; i < len; i++{\n            whiles.size && temperaturess.top < temperaturesi{\n                ress.top = i  s.top;\n                s.pop;\n            }\n            s.pushi;\n        }\n        return res;\n        \n    }\n};\n\n\n 堆\n\n 数组中的第K个最大元素\n\n 知识点：优先队列\n\nc++\nclass Solution {\npublic:\n    int findKthLargestvector<int& nums, int k {\n        int idx = 0, res = 1;\n        priorityqueue<int, vector<int, less<int pq;\n        forint i = 0; i < nums.size; i++{\n            pq.pushnumsi;\n        }\n        whilepq.size{\n            int top = pq.top;\n            idx ++;\n            pq.pop;\n            ifidx == k{\n                res = top;\n                break;\n            }\n        }\n        return res;\n    }\n};\n\n\n 前 K 个高频元素\n\n 知识点：并查集\n\nc++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n100010;\n    unorderedmap<int, int mp;\n    static bool cmpp a1, p b1{\n        return a1.y  b1.y;\n    }\n    vector<int topKFrequentvector<int& nums, int k {\n        int len = nums.size;\n        vector<int res;\n        forint i = 0; i < len; i++{\n            int index = i;\n            ifmp.findnumsi = mp.end{\n                index = mpnumsi;\n            }\n            nindex.x = numsindex;\n            nindex.y ++;\n            mpnumsi = index;\n        }\n        sortn, n + len, cmp;\n        forint i = 0; i < k; i++{\n            res.pushbackni.x;\n        }\n        return res;\n    }\n};\n\n\n 贪心\n\n 买卖股票的最佳时机\n\nc++\nclass Solution {\npublic:\n    int maxProfitvector<int& prices {\n        int len = prices.size, maxx = 0, res = 0;\n        vector<int vlen;\n        forint i = len  1; i = 0; i{\n            maxx = maxpricesi, maxx;\n            vi = maxx;\n        }\n        forint i = 0; i < len; i++{\n            res = maxres, vi  pricesi;\n        }\n        return res;\n    }\n};\n\n\n 跳跃游戏\n\nc++\nclass Solution {\npublic:\n    bool canJumpvector<int& nums {\n        int len = nums.size, maxx = 0;\n        vector<bool vlen, false;\n        forint i = 0; i < len; i++{\n            ifi  maxx{\n                return false;\n            }\n            maxx = maxmaxx, i + numsi;\n            vi = true;\n        }\n        return vlen  1;\n    }a\n};\n\n\n <u 跳跃游戏 II</u\n\nc++\nclass Solution {\npublic:\n    int jumpvector<int& nums {\n        int len = nums.size, maxx= 0, end = 0, res = 0;\n        //  循环遍历到 len  1\n        forint i = 0; i < len  1; i++{ \n            maxx = maxmaxx, numsi + i;\n            ifend == i{\n                end = maxx;\n                res ++;\n            }\n        }\n        return res;\n    }\n};\n\n\n 划分字母区间\n\nc++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n27;\n    vector<int partitionLabelsstring s {\n        vector<int res;\n        int len = s.size;\n        forint i = 0; i < len; i++{\n            nsi  'a'.x = minnsi  'a'.x, i;\n            nsi  'a'.y = maxnsi  'a'.y, i;\n        }\n        int minL = 0, maxL = 0;\n        forint i = 0; i < len; i++{\n            maxL = maxnsi  'a'.y, maxL;\n            ifmaxL == i{\n                res.pushbackmaxL  minL + 1;\n                minL = i + 1;\n            }\n        }\n        return res;\n    }\n};\n\n\n 动态规划\n\n 爬楼梯\n\n 思路：斐波拉且数列\n\nc++\nclass Solution {\npublic:\n    int nums46;\n    int climbStairsint n {\n        nums0 = 1;\n        nums1 = 1;\n        forint i = 2; i <= n; i++{\n            numsi = numsi  1 + numsi  2; \n        }\n        return numsn;\n    }\n};\n\n\n 杨辉三角\n\nc++\nclass Solution {\npublic:\n    vector<vector<int generateint numRows {\n        vector<vector<int resnumRows;\n        res0 = {1};\n        forint i = 1; i < numRows; i++{\n            vector<int vi + 1, 1;\n            forint j = 1; j <= i  1; j++{\n                vj = resi  1j + resi  1j  1; \n            }\n            resi = v;\n        }\n        return res;\n    }\n};\n\n\n 打家劫舍\n\nc++\nclass Solution {\npublic:\n    int robvector<int& nums {\n        int len = nums.size, res = 0;\n        vector<int vlen + 1;\n        forint i = 1; i <= len; i++{\n            vi = numsi  1;\n            res = maxvi, res;\n        }\n        forint i = 3; i <= len; i++{    \n            vi = vi + maxvi  2, vi  3;\n            res = maxres, vi;\n        }\n        return res;\n\n    }\n};\n\n\n 完全平方数\n\nc++\nclass Solution {\npublic:\n    int numSquaresint n {\n        vector<int vn + 1;\n        v1 = 1;\n        forint i = 2; i <= n; i++{\n            int num = INTMAX;\n            forint j = 1; j  j <= i; j++{\n                // 此处为关键点，从完全平方数开始找，找出想要最小凑出完全平凡数的数的结果\n                num = minnum, vi  j  j;\n            }\n            // 最后加上完全平凡数的结果1\n            vi = num + 1;\n        }\n        return vn;\n    }\n};\n\n\n\n\n\n\n 常用算法总结\n\n 二分\n\n 哈希\n\n 双指针\n\n 思维\n\n 模拟\n\n 贪心\n\n 前缀和一维、二维，后缀和\n\n 队列\n   滑动窗口双端队列\n   优先队列\n  \n 栈\n   单调栈\n\n 搜索\n   DFS\n   BFS\n   多源BFS\n\n 动态规划\n\n 数学知识\n\n   哈夫顿距离：di,j=xixj+yiyj\n\n     哈夫顿距离转为切比雪夫距离：xixj + yiyj =  maxx1'x2', y1'y2'\n\n      原坐标x, y与x', y'的关系：x', y' = x + y, y  x\n\n   欧氏距离：di,j=xixj ^ 2 + yi  yj ^ 2\n\n   直线公式：y = y2y1/x2x1  x  x2  y1  x1  y2/x2x1\n  \n   质数\n  \n   因数\n  \n   容斥原理\n  \n 图论\n\n   迪杰斯特拉\n\n"},{"filename":"acwing-basic","category":"aigorithm","md":{"topSummary":"\ntitle: Acwing基础课\ncategory: 算法\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 基础算法\n\n### 快速排序\n\n#### AcWing 785. 快速排序\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> v;\n    int a;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    for(int i = 0; i < a; i++){\n        cout << v[i] << \" \";\n    }\n\n  return 0;\n}\n```\n\n#### 第k个数\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    vector<int> v;\n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    cout << v[b-1];\n\n  return 0;\n}\n```\n\n### 归并排序\n\n#### AcWing 787. 归并排序\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> v;\n    int a;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        int m;\n        cin >> m;\n        v.push_back(m);\n    }\n    sort(v.begin(), v.end());\n    for(int i = 0; i < a; i++){\n        cout << v[i] << \" \";\n    }\n\n  return 0;\n}\n```\n\n### 二分\n\n可以直接用STL中的lower\\_bound和upper\\_bound\n\n- lower\\_bound(n, n+a, target)\n- upper\\_bound(n, n+a, target)\n\n**举例**（转载：[博客链接](https://blog.csdn.net/qq_40160605/article/details/80150252)）\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100000+10;\nconst int INF=2*int(1e9)+10;\n#define LL long long\nint cmd(int a,int b){\n\treturn a>b;\n}\nint main(){\n\tint num[6]={1,2,4,7,15,34}; \n\tsort(num,num+6);                           //按从小到大排序 \n\tint pos1=lower_bound(num,num+6,7)-num;    //返回数组中第一个大于或等于被查数的值 \n\tint pos2=upper_bound(num,num+6,7)-num;    //返回数组中第一个大于被查数的值\n\tcout<<pos1<<\" \"<<num[pos1]<<endl;\n\tcout<<pos2<<\" \"<<num[pos2]<<endl;\n\tsort(num,num+6,cmd);                      //按从大到小排序\n\tint pos3=lower_bound(num,num+6,7,greater<int>())-num;  //返回数组中第一个小于或等于被查数的值 \n\tint pos4=upper_bound(num,num+6,7,greater<int>())-num;  //返回数组中第一个小于被查数的值 \n\tcout<<pos3<<\" \"<<num[pos3]<<endl;\n\tcout<<pos4<<\" \"<<num[pos4]<<endl;\n\treturn 0;\t\n} \n```\n\n#### AcWing 789. 数的范围\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint n[100010];\nint a, b;\n\n// 左边距\nint get_l(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n        int mid = (l + r ) / 2;\n        if(n[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\n int get_r(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n    \tint mid = (l + r + 1) / 2;\n        if(n[mid] <= x) l = mid;\n        else r = mid - 1;\n    }\n    return r;\n }\n\nint main(){\n    \n    cin >> a >> b;\n    for(int i = 0; i < a; i++) cin >> n[i];\n    for(int i = 0; i < b; i++){\n        int m;\n        cin >> m;\n        int l = get_l(m);\n        if(n[l] != m) cout << -1 << \" \" << -1 << endl;\n\t\telse {\n\t\t\tint r = get_r(m);\n\t\t\tif(n[r] != m) cout << -1 << \" \" << -1 << endl;\n\t\t\telse cout << l << \" \" << r << endl; \n\t\t} \n    }\n\t\n    return 0;\n}\n```\n\n#### AcWing 790. 数的三次方根  \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\ndouble getS(double x){\n    return x * x * x;\n}\n\ndouble fun(double x){\n    double l = -10000, r = 10000;\n    while(l < r){\n        double mid = (l + r) / 2;\n        double res = getS(mid);\n        if(fabs(res - x) < 0.0000000001){\n        \treturn mid;\n\t\t}\n        if(res <= x) l = mid;\n        else r = mid;\n    }\n}\n\nint main(){\n    double a;\n    cin >> a;\n\tprintf(\"%.6lf\", fun(a));\n    \n    return 0;\n}\n```\n\n### 高精度\n\n#### AcWing 791. 高精度加法\n\n```\na = int(input())\nb = int(input())\nprint(a + b)\n```\n\n#### AcWing 792. 高精度减法\n\n```\na = int(input())\nb = int(input())\nprint(a - b)\n```\n\n#### AcWing 793. 高精度乘法\n\n```\na = int(input())\nb = int(input())\nprint(a * b)\n```\n\n#### AcWing 794. 高精度除法\n\n```\na = int(input())\nb = int(input())\nprint(a // b)\nprint(a % b)\n```\n\n### 前缀和与差分\n\n#### AcWing 795. 前缀和\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\n\nint main(){\n    \n    int a, b;\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++){\n       cin >> n[i];\n       m[i] = n[i] + m[i - 1];\n    }\n    \n    while(b--){\n        int x, y;\n        cin >> x >> y;\n        cout << m[y] - m[x - 1] << endl;\n    }\n    \n    return 0;\n}\n```\n\n#### AcWing 796. 子矩阵的和 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[1001][1001], m[1001][1001];\n\nint main(){\n    \n    int a, b, c;\n    cin >> a >> b >> c;\n    for(int i = 1; i <= a; i++){\n        for(int j = 1; j <= b; j++){\n            cin >> n[i][j];\n            m[i][j] = n[i][j] + m[i-1][j] + m[i][j-1] - m[i-1][j-1];\n        }\n    }\n    while(c--){\n        int q, w, e, r;\n        cin >> q >> w >> e >> r;\n        cout << m[e][r] + m[q-1][w-1] - m[q-1][r] - m[e][w-1] << endl;\n    }\n    \n\n    return 0;\n}\n```\n\n#### AcWing 797. 差分 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\n\nint main(){\n   int a, b;\n   cin >> a >> b;\n   for(int i = 1; i <= a; i++){\n       cin >> n[i];\n       m[i] = n[i] - n[i-1];\n   }\n   while(b--){\n       int x, y ,z;\n       cin >> x >> y >> z;\n       m[x] += z;\n       m[y+1] -= z;\n   }\n   for(int i = 1; i <= a; i++){\n       n[i] = m[i] + n[i-1];\n       cout << n[i] << \" \";\n   }\n   \n   return 0;\n}\n```\n\n#### AcWing 798. 差分矩阵\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[1010][1010], m[1010][1010];\n\nint main(){\n  \n   int a, b, c;\n   cin >> a >> b >> c;\n   for(int i = 1; i <= a; i++){\n       for(int j = 1; j <= b; j++){\n           cin >> n[i][j];\n           m[i][j] = n[i][j] - n[i-1][j] - n[i][j-1] + n[i-1][j-1];\n       }\n   }\n   while(c--){\n       int q, w, e, r, t;\n       cin >> q >> w >> e >> r >> t;\n       m[q][w] += t;\n       m[e+1][r+1] += t;\n       m[e+1][w] -= t;\n       m[q][r+1] -= t;\n   }\n  for(int i = 1; i <= a; i++){\n      for(int j = 1; j <= b; j++){\n          n[i][j] = n[i-1][j] + n[i][j-1] - n[i-1][j-1] + m[i][j];\n          cout << n[i][j] << \" \";\n      }\n      cout << endl;\n  }\n   \n   return 0;\n}\n```\n\n### 双指针算法\n\n#### AcWing 799. 最长连续不重复子序列 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N];\n\nint main(){\n    \n    int a, l, r, res = 0;\n    map<int, int> is;\n    cin >> a;\n    for(int i = 0, j = 0; i < a; i++){\n        cin >> n[i];\n        is[n[i]] ++;\n        while(is[n[i]] > 1){\n            is[n[j]] --;\n            j ++;\n        }\n        res = max(res, i - j + 1);\n    }\n    cout << res << endl;\n  \n    return 0;\n}\n```\n\n#### AcWing 800. 数组元素的目标和\n\n哈希方法\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\nunordered_map<int, int> ump;\n\nint main(){\n    \n    int a, b, c, r1 = 0, r2 = 0;\n    cin >> a >> b >> c;\n    for(int i = 0; i < a; i++) {\n        cin >> n[i];\n        ump[n[i]] = i;\n    }\n    for(int j = 0; j < b; j++) {\n        cin >> m[j];\n        if(ump.count(c - m[j])){\n            r1 = ump[c - m[j]], r2 = j;\n        }\n    }\n\n    cout << r1 << \" \" << r2 << endl;\n  \n    return 0;\n}\n```\n\n#### AcWing 2816. 判断子序列\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n[N], m[N];\nunordered_map<int, int> ump;\n\nint main(){\n    \n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++) cin >> n[i];\n    for(int j = 0; j < b; j++) cin >> m[j];\n   \n    int x = 0, y = 0;\n    while(x < a && y < b){\n        if(n[x] == m[y]) x ++;\n        y ++;\n    }\n    \n    if(x == a) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  \n    return 0;\n}\n```\n\n### 位运算\n\n#### AcWing 801. 二进制中1的个数\n\n> 小知识：n的二进制表示中第k位是几？  \n> 答案：n >> k & 1  \n> n右移k位&1后得出二进制数的最后一位\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// 返回x的最后一位1\n// 比如10010的最后一位就是10\nint lowbit(int x){\n    return x & -x;    \n}\n\nint main(){\n        \n    int a, b, res;\n    cin >> a;\n    for(int i = 0; i < a; i++){\n        cin >> b;\n        res = 0;\n        while(b){\n            b -= lowbit(b);\n            res ++;\n        }\n        cout << res << \" \";\n    }\n        \n    return 0;\n}\n```\n\n### 离散化\n\n#### AcWing 802. 区间和  \n\n> 小知识  \n> 离散化：将100，2000，30000，4000000映射为1，2，3，4的过程\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n// 此处不是1e5+10\n// 极端情况下第一排输入会有1e5的数据，第二排会有2e5的数据\nconst int N = 3e5 + 10 ;\n\nint s[N], f[N];\n\nvector<int> v;\nvector<pair<int, int> > q, w;\n// 二分查找元素下标\nint find(int x){\n    int l = 0, r = v.size() - 1;\n    while(l < r){\n        int mid = l + r >> 1;\n        if(v[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l + 1;\n}\n\nint main(){\n    \n    int a, b, m, n;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++){\n        cin >> m >> n;\n        q.push_back({m, n});\n        v.push_back(m);\n    }\n    for(int j = 0; j < b; j++){\n        cin >> m >> n;\n        w.push_back({m, n});\n        v.push_back(m);\n        v.push_back(n);\n    }\n    sort(v.begin(), v.end());\n    // 去重\n    v.erase(unique(v.begin(), v.end()), v.end());\n    // 离散化处理\n    for(auto i: q){\n        int x = find(i.first);\n        s[x] += i.second;\n    }\n    // 预处理前缀和\n    for(int i = 1; i <= v.size(); i++){\n        f[i] = f[i-1] + s[i];\n    }\n    // 查询结果\n    for(auto i: w){\n        int l = find(i.first), r = find(i.second);\n        cout << f[r] - f[l-1] << endl;\n    }\n    \n    return 0;\n}\n```\n\n![图片描述](http://www.lijunxi.site:4000/api/file/download/6261dfbb-afd5-42b9-bcdf-46091f5b8e0f.jpg)\n\n数据范围分析\n\n### 区间合并\n\n#### AcWing 803. 区间合并\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ; \n\nstruct point{\n    int x, y;\n} n[N];\n\nbool cmp(point a, point b){\n    if(a.x == b.x) return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main(){\n    \n    int a, idx = 0;\n    cin >> a;\n    for(int i = 0; i < a; i++) cin >> n[i].x >> n[i].y;\n    sort(n, n+a, cmp);\n    int langm = n[0].y;\n    for(int i = 1; i < a; i++){\n        langm = max(langm, n[i-1].y);\n        if(langm < n[i].x) idx++;\n    }\n    cout << idx + 1 << endl;\n  \n    return 0;\n}\n```\n\n## 数据结构\n\n### 单链表\n\n#### AcWing 826. 单链表\n\n数组模拟单链表\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\n// 头指针（用下表指针辅助），下标指针\nint hidx = -1, idx = 0;\n// 元素值，元素下表\nint n[N], ne[N];\n\nvoid insert(int k, int x){\n    // 新节点值赋值\n    n[idx] = x;\n    // 将新结点下一个结点赋值为插入位置的下一个结点\n    ne[idx] = ne[k];\n    // 将插入位置的一下个节点指向新节点\n    ne[k] = idx;\n    idx++;\n}\n\nvoid addHead(int x){\n    // 头节点赋值\n    n[idx] = x;\n    // 指向头指针\n    ne[idx] = hidx;\n    // 更改头指针为当前下表\n    hidx = idx;\n    idx++;\n}\n\nvoid del(int idx){\n    ne[idx] = ne[ne[idx]];   \n}\n\nint main(){\n    \n    int x, k, num; \n    char s;\n    cin >> x;\n    while(x--){\n        cin >> s;\n        if(s == 'H'){\n            cin >> num;\n            addHead(num);\n        }\n        else if(s == 'D'){\n            cin >> k;\n            //判断是否删除的为头节点\n            if(!k) hidx = ne[hidx];  \n            del(k-1);\n        }\n        else{\n            cin >> k >> num;\n            insert(k-1, num);\n        }\n    }\n    while(hidx != -1){\n        cout << n[hidx] << \" \";\n        hidx = ne[hidx];\n    }\n    \n    return 0;\n}\n```\n\n### 双链表\n\n### 栈\n\n#### AcAcWing 3302. 表达式求值\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nstack<int> s;\nstack<char> f;\nunordered_map<char, int> ump;\n\nvoid init_map(){\n\tump['*'] = 2;\n\tump['/'] = 2;\n\tump['+'] = 1;\n\tump['-'] = 1;\n}\n\nvoid eval(){\n\tint num = 0;\n\tint x = s.top(); s.pop();\n\tint y = s.top(); s.pop();\n\tchar op = f.top(); f.pop();\n\tif(op == '+') num = x + y;\n\telse if(op == '-') num = y - x;\n\telse if(op == '*') num = x * y;\n\telse num = y / x;\n\ts.push(num);\n}\n\nint main(){\n    init_map();\n    string str;\n    int num, idx = 0;\n    char c;\n    cin >> str;\n    int len = str.size();\n    for(int i = 0; i < len; i++){\n        if(str[i] >= '0' && str[i] <= '9'){\n            idx = i;\n            num = 0;\n            while(str[idx] >= '0' && str[idx] <= '9' && idx < len){\n                num = num * 10 + str[idx] - '0';\n                idx++; \n            }\n            s.push(num);\n            i = idx - 1;\n        }\n        else if(str[i] == '(') f.push(str[i]);\n        else if(str[i] == ')'){\n       \t\twhile(f.size() && s.size() >= 2 && ump[str[i]] <= ump[f.top()] && f.top() != '(') eval();\n       \t\tf.pop();\n        }\n        else{\n        \twhile(f.size() && s.size() >= 2 && ump[str[i]] <= ump[f.top()]) eval();\n            f.push(str[i]);\n        }\n    }\n    while(f.size()) eval();\n\tcout << s.top() << endl; \n    \n    return 0;\n}\n```\n\n### 队列\n\n#### AcWing 829. 模拟队列\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nqueue<int> q;\n\nint main(){\n    int a, num;\n    string s;\n    cin >> a;\n    while(a--){\n        cin >> s;\n        if(s == \"push\"){\n            cin >> num;\n            q.push(num);\n        }\n        else if(s == \"pop\"){\n            q.pop();\n        }\n        else if(s == \"empty\"){\n            if(q.empty()) cout <<\"YES\"<<endl;\n            else cout <<\"NO\" << endl;\n        }\n        else{\n            cout << q.front() << endl;\n        }\n    }\n   \n    return 0;\n}\n```\n\n### 单调栈\n\n#### AcWing 830. 单调栈\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nstack<int> s;\n\nint main(){\n    \n    int a, num;\n    cin >> a;\n    for(int i = 0; i < a; i++) {\n        cin >> num;\n        while(s.size() && s.top() >= num) s.pop();\n        if(!s.size()) cout << -1 << \" \";\n        else cout << s.top() << \" \";\n        s.push(num);\n    }\n    \n    return 0;\n}\n```\n\n### 单调队列\n\n#### AcWing 154. 滑动窗口\n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10 ;\n\n// deque没法直接获取下表的元素值，所以需要用一个数组来维护 \nint n[N];\ndeque<int> dq; \n\nint main(){\n  \n    int a, b, num;\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++) cin >> n[i];\n    for(int i = 1; i <= a; i++){\n    \t// 当尾元素比n[i]大时，需要弹出 \n    \twhile(dq.size() && n[dq.back()] > n[i]) dq.pop_back();\n    \tdq.push_back(i);\n    \t// 当队列的个数满足b时们需要弹出首元素\n\t\t// 这里不能用dq.size()来判断是否满足个数，因为可能出现首元素到i之间有些元素已经弹出了但size总数任然小于b情况 \n    \tif(dq.size() && i - dq.front() >= b) dq.pop_front();\n    \t// 当i大于b时候就能开始输出了，这里也不能用dq.size()来判断，因为存在整个过程都小于b的情况，这样就没有输出了 \n\t\tif(i >= b) cout << n[dq.front()] << \" \";\n\t}\n\tdq.clear();\n\tputs(\"\");\n      for(int i = 1; i <= a; i++){\n    \twhile(dq.size() && n[dq.back()] < n[i]) dq.pop_back();\n    \tdq.push_back(i);\n    \tif(dq.size() && i - dq.front() >= b) dq.pop_front();\n\t\tif(i >= b) cout << n[dq.front()] << \" \";\n\t}\n    \n    return 0;\n}\n```\n\n### KMP\n\n### Tire\n\n#### AcWing 835. Trie字符串统计\n\n> Trie树（字典树）：高效存储和查找字符串集合的数据结合\n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// son[][]存储子节点的位置，分支最多26条\n// cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）\n// idx表示当前要插入的节点是第几个,每创建一个节点值+1\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(string str){\n\t// 类似指针，指向当前节点\n\tint p = 0;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tint s = str[i] - 'a';\n\t\t// 该字符不存在就创建一个 \n\t\tif(!son[p][s]) son[p][s] = ++idx;\n\t\t// \tp指向下一个节点\n\t\tp = son[p][s];\n\t}\n\t// 统计字符串个数 \n\tcnt[p] ++;\n} \n\nint query(string str){\n\tint p = 0;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tint s = str[i] - 'a';\n\t\tif(!son[p][s]) return 0;\n\t\tp = son[p][s]; \n\t}\n\treturn cnt[p];\n}\n\n\nint main(){\n \n\tint a;\n\tchar c;\n\tstring str;\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> c;\n\t\tcin >> str;\n\t\tif(c == 'I') insert(str);\n\t\telse cout << query(str) << endl;\n\t}\n    \n    return 0;\n}\n```\n\n#### AcWing 143. 最大异或对  \n\n```\n#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n// 最多有1e5个数，每个数的二进制数有31位，极限情况下就1e5 * 31\nconst int N = 31e5 + 10 ;\n\nint son[N][2], n[N], idx = 0;\n\n// 将数字插入trie树中 \nvoid insert(int x){\n\tint p = 0;\n\t// 数的范围为小于2e31次方 \n\tfor(int i = 30; i >= 0; i --){\n\t\tint s = x >> i & 1;\n\t\tif(!son[p][s]) son[p][s] = ++idx;\n\t\tp = son[p][s];\n\t}\n}\n\nint query(int x){\n\tint p = 0, res = 0;\n\tfor(int i = 30; i >= 0; i--){\n\t\t// x二进制第i位上的数 \n\t\tint s = x >> i & 1;\n\t\t// 若存在相反的数 \n\t\tif(son[p][!s]){\n\t\t\tp = son[p][!s];\n\t\t\t// 1左移i位就是2^(30-i)次方 \n\t\t\tres += 1 << i;\n\t\t}\n\t\telse{\n\t\t\tp = son[p][s];\n\t\t\tres += 0 << i;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint a, res = 0;\n\tcin >> a;\n\tfor(int i = 0; i < a; i++) {\n\t\tcin >> n[i];\n\t\tinsert(n[i]);\n\t}\n\tfor(int i = 0; i < a; i++) res = max(res, query(n[i]));\n\tcout << res << endl;\n\t\n    return 0;\n}\n```\n\n### 并查集\n\n#### AcWing 836. 合并集合\n\n```\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\nint n[N];\n\n// 找到祖宗结点\nint find(int x){\n    // 修改结点，避免重复查找\n   if(n[x] != x) n[x] = find(n[x]);\n   return n[x];\n}\n\nint main(){\n    int a, b;\n    cin >> a >> b;\n    for(int i = 0; i < a; i++) n[i] = i;\n    for(int i = 0; i < b; i++){\n        char x;\n        int o, p;\n        cin >> x >> o >> p;\n        if(x == 'M'){\n            n[find(o)] = find(p);\n        }\n        else{\n            if(find(o) == find(p)) cout << \"Yes\" << endl;\n            else cout << \"No\" << endl;\n        }\n    }\n     \n    return 0;\n}\n```\n\n### 堆\n\n> 堆：优先队列\n\n#### AcWing 838. 堆排序\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint n[N];\n// 从小到大排序，从大到小就为less<int>，与sort相反\npriority_queue<int, vector<int>, greater<int>> pq;\nint main(){\n    \n    int a, b, num;\n    cin>> a >> b;\n    for(int i = 0; i < a; i++){\n        cin >> num;\n        pq.push(num);\n    }\n    int idx = 0;\n    while(idx != b){\n        idx ++;\n        cout << pq.top() << \" \";\n        pq.pop();\n    }\n    \n    return 0;\n}\n```\n\n### 哈希表\n\n## 搜索与图论\n\n### DFS\n\n#### AcWing 842. 排列数字 \n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nint is[N];\nvector<int> v;\n\nvoid dfs(int x){\n    if(x == 0) return; \n    if(v.size() == a){\n    \tfor(int i = 0; i < a; i++) cout << v[i] << \" \";\n    \tcout << endl;\n\t}\n\tfor(int i = 1; i <= a; i++){\n\t\tif(!is[i]){\n\t\t\tis[i] = 1;\n\t\t\tv.push_back(i);\n\t\t\tdfs(i);\n\t\t\tv.pop_back();\n\t\t\tis[i] = 0;\n\t\t}\n\t}\n}\n\nint main(){\n    cin >> a;\n    dfs(a);\n    return 0;\n}\n```\n\n#### AcWing 843. n-皇后问题\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nchar n[11][11];\nint l[11], xie[11], fx[11];\n\nvoid print(){\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= a; j++){\n\t\t\tcout << n[i][j];\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n} \n\nvoid dfs(int x){\n\tif(x == a + 1){\n\t\tprint();\n\t\treturn;\n\t}\n    for(int i = 1; i <= a; i++){\n    \t// \ti - x + a是为了避免出现下标是负数的情况 \n    \tif(!l[i] && !xie[i - x + a] && !fx[i + x]){\n    \t\tn[x][i] = 'Q';\n    \t\txie[i - x + a] = 1;\n    \t\tfx[i + x] = 1;\n    \t\tl[i] = 1;\n    \t\tdfs(x + 1);\n    \t\tn[x][i] = '.';\n    \t\txie[i - x + a] = 0;\n    \t\tfx[i + x] = 0;\n    \t\tl[i] = 0;\n\t\t}\n\t\n\t}\n\n}\n\nint main(){\n  \t\n\tcin >> a;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= a; j++){\n\t\t\tn[i][j] = '.';\n\t\t}\n\t}\n    dfs(1);\n    \n    return 0;\n}\n```\n\n### BFS\n\n#### AcWing 844. 走迷宫 \n\n```\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint a, b;\nint n[1010][1010], is[1001][1001];\nint ix[4] = {1, -1, 0 ,0}, iy[4] = {0, 0, 1, -1};\n\nvoid bfs(int x, int y){\n    queue<pair<int, int>> q;\n    map<pair<int, int>, int> mp;\n    q.push({0, 0});\n    mp[{0, 0}] = 0;\n    while(!q.empty()){\n    \tauto top = q.front();\n    \tq.pop();\n    \tint xx = top.first, yy = top.second;\n    \tif(xx == a - 1 && yy == b - 1){\n    \t\tcout << mp[{xx, yy}] << endl;\n    \t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint x = xx + ix[i], y = yy + iy[i];\n\t\t\tif(!n[x][y] && !is[x][y] && x >= 0 && x < a && y >= 0 && y < b){\n\t\t\t\tis[x][y] = 1;\n\t\t\t\tq.push({x, y});\n\t\t\t\tmp[{x, y}] = mp[{xx, yy}] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n  \t\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++){\n\t    for(int j = 0; j < b; j++){\n\t        cin >> n[i][j];\n\t    }\n\t}\n\tbfs(0, 0);\n    \n    return 0;\n}\n```\n\n### 树与图的深度优先遍历\n\n#### AcWing 846. 树的重心\n\n图的存储采用数组模拟邻接表\n\n思路：邻接表dfs\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint h[N];\n// 存储元素 \nint e[N];\n// 下个节点值\nint ne[N];\n// 结点是否访问过\nint st[N]; \n// 单链表指针 \nint idx = 0; \nint a, ans = N; \n\nvoid add(int x, int y){\n\te[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nint dfs(int x){\n\tint res = 0, sum = 1;\n\tst[x] = 1;\t\n\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\tint j = e[i];\n\t\tif(!st[j]){\n\t\t\tint s = dfs(j);\n\t\t\t// 子图最大结点数 \n\t\t\tres = max(res, s);\n\t\t\t// j为根的节点总数 \n\t\t\tsum += s;\t\t\n\t\t}\n\t}\n\t// a - sum：另一部分的节点总数 \n\tres = max(res, a - sum);\n\t// 选取最小的最大结点数 \n\tans = min(ans, res);\n\treturn sum;\n}\n\n\nint main(){\n  \t//初始化h数组 -1表示尾节\n\tmemset(h, -1, sizeof h); \n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n    cin >> a;\n    // 创建邻接表 \n    for(int i = 0; i < a - 1; i++){\n    \tint m, n;\n    \tcin >> m >> n;\n    \tadd(m, n);\n    \tadd(n, m);\n\t}\n    dfs(1);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n### 树与图的广度优先遍历\n\n#### AcWing 847. 图中点的层次\n\n思路：邻接表bfs\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint h[N];\n// 存储元素 \nint e[N];\n// 下个节点值\nint ne[N];\n// 结点是否访问过\nint st[N]; \n// 单链表指针 \nint idx = 0; \nint a, b, ans = N; \n\nvoid add(int x, int y){\n\te[idx] = y, ne[idx] = h[x], h[x] = idx, idx ++;\n}\n\nvoid dfs(int x){\n    queue<pair<int, int>> q;\n    map<pair<int, int>, int> ump;\n    q.push({1, 1});\n    ump[{1, 1}] = 0;\n    while(!q.empty()){\n        auto top = q.front();\n        q.pop();\n        int xx = top.first, yy = top.second;\n        if(yy == a){\n        \tcout << ump[{xx, yy}] << endl;\n        \treturn;\n\t\t}\n\t\tfor(int i = h[yy]; i != -1; i = ne[i]){\n\t\t\tif(ump.find({yy, e[i]}) == ump.end()){\n\t\t\t\tq.push({yy, e[i]});\n\t\t\t\tump[{yy, e[i]}] = ump[{xx, yy}] + 1;\n\t\t\t}\n\t\t}\n    }   \n\tcout << -1 << endl; \n \n}\n\nint main(){\n  \t//初始化h数组 -1表示尾节\n\tmemset(h, -1, sizeof h); \n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n    cin >> a >> b;\n    // 创建邻接表 \n    for(int i = 0; i < b; i++){\n    \tint m, n;\n    \tcin >> m >> n;\n    \tadd(m, n);\n\t}\n    dfs(1);\n\n    return 0;\n}\n```\n\n### 拓扑排序\n\n#### AcWing 848. 有向图的拓扑序列\n\n思路：邻接表找入度为0的结点\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint h[N], e[N], ne[N], idx, a, b;\nqueue<int> q;\n// 保存各个点的入度\nint d[N]; \n// v存放答案\nvector<int> v;\n\nvoid add(int x, int y){\n    e[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nbool topsort(){\n    // 找出入读为0的点\n    for(int i = 1; i <= a; i++){\n    \tif(!d[i]) q.push(i); \n\t}\t\n\twhile(q.size()){\n\t\tint top = q.front();\n\t\tq.pop();\n\t\tv.push_back(top);\n\t\t// 每次循环减去一条边\n\t\tfor(int i = h[top]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\td[j] --;\n\t\t\t// 当减去后的入读为0则入队列\n\t\t\tif(!d[j]) q.push(j);\n\t\t}\n\t}\n\treturn v.size() == a;\n}\n\nint main(){\n  \t\n  \tmemset(h, -1, sizeof h);\n  \tcin >> a >> b;\n  \twhile(b--){\n  \t    int x, y;\n  \t    cin >> x >> y;\n  \t    add(x, y);\n  \t    d[y] ++;\n  \t}\n  \tif(topsort()){\n  \t\tfor(int i = 0; i < v.size(); i++) cout << v[i] << \" \";\n\t}\n\telse puts(\"-1\");\n  \t\n    return 0;\n}\n```\n\n### Dijkstra\n\n稠密图：临界矩阵（点较少）  \n稀疏图：邻接表（点较多）\n\n#### AcWing 849. Dijkstra求最短路 I\n\n**朴素版（暴力）**\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint m, n;\n// 为稠密阵所以用邻接矩阵存储\nint num[501][501];\n// 用于记录每一个点距离第一个点的距离\nint dis[N];\n// 用于记录该点的最短距离是否已经确定\nint st[N];\n\nint dijkstra(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tdis[1] = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tint t = -1;\n\t\t// 找到没有确定最短路径的节点中距离源点最近的点t \n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tif(!st[j] && (t == -1 || dis[t] > dis[j])){\n\t\t\t\tt = j;\n\t\t\t}\n\t\t}\n\t\tst[t] = 1;\n\t\t// 更新到其他点的距离 \n\t\tfor(int k = 1; k <= m; k++){\n\t\t\tdis[k] = min(dis[k], dis[t] + num[t][k]);\n\t\t}\n\t}\n\tif(dis[m]==0x3f3f3f3f) return -1;\n    return dis[m];\n}\n\nint main(){\n\tmemset(num, 0x3f3f3f3f, sizeof num);\n\tcin >> m >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tnum[x][y] = min(num[x][y], z);\n\t}\n  \tcout << dijkstra() << endl;\n    return 0;\n}\n```\n\n#### AcWing 850. Dijkstra求最短路 II \n\n**临界表法**\n\n```\n#include<bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\ntypedef pair<int, int> PII;\n\nint e[N], ne[N], idx, h[N], dis[N], st[N];\nint w[N]; // 存放权重 \nint a, b;\n\nvoid add(int x, int y, int z){\n\tw[idx] = z, e[idx] = y, ne[idx] = h[x], h[x] = idx++;\n}\n\nint dj(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tpriority_queue<PII, vector<PII>, greater<PII>> heap;\n\t// 插入距离和结点编号 \n\theap.push({0, 1});\n\twhile(!heap.empty()){\n\t\tauto top = heap.top();\n\t\theap.pop();\n\t\tint x = top.second, y = top.first;\n\t\tif(st[x]) continue;\n\t\tst[x] = 1;\n\t\t// 遍历该节点的每个临界结点，给每个选出最短距离 \n\t\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\tif(dis[j] > dis[x] + w[i]){\n\t\t\t\tdis[j] = dis[x] + w[i];\n\t\t\t\theap.push({dis[j], j});\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[a] == 0x3f3f3f3f) return -1;\n\treturn dis[a];\n}\n\nint main(){\n\tmemset(h, -1, sizeof h);\n\tcin >> a >> b;\n\twhile(b--){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t}\n\tcout << dj() << endl;\n\n    return 0;\n}\n```\n\n### Floyd\n\n与迪杰斯特拉的区别：\n\n- 迪杰斯特拉算法适用于非负权，用于查找1到n 的最短距离，数据范围大\n- 弗洛伊德算法适用于含有负权，用于查找每个点之间的最短距离，数据范围较少\n\n#### AcWing 854. Floyd求最短路\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int> PII;\n\nint n, m, k;\nint e[201][201];\n\nvoid floyd(){\n\t//  f[i, j, k]表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]。\n    // 因此在计算第k层的f[i, j]的时候必须先将第k - 1层的所有状态计算出来，所以需要把k放在最外层。 \n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\te[i][j] = min(e[i][j], e[i][k] + e[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> n >> m >> k; \n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i == j) e[i][j] = 0;\n\t\t\telse e[i][j] = INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\te[x][y] = min(e[x][y], z);\n\t}\n\tfloyd();\n\twhile(k--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t// 不能e[x][y] == INF，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可 \n\t\tif(e[x][y] > INF / 2) cout << \"impossible\"<<endl;\n\t\telse cout << e[x][y] <<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 数学知识\n\n### 质数\n\n#### AcWing 867. 分解质因数\n\n主要需要开方来避免超时\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main(){\n\t\n\tint n, m;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> m;\n\t\tint mm = m, flag = 0;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\tint idx = 0;\n\t\t\twhile(mm % i == 0){\n\t\t\t\tidx ++;\n\t\t\t\tmm /= i;\n\t\t\t}\n\t\t\tif(idx != 0){\n\t\t\t    flag = 1;\n\t\t\t    cout << i << \" \" << idx << endl;\n\t\t\t} \n\t\t}\n\t\tif(flag){\n\t        if(mm != 1) cout << mm << \" \" << 1 << endl;\n\t        cout << endl;\n\t\t}\n\t\telse {\n\t\t    cout << m << \" \" << 1 << endl;\n\t\t    cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n#### AcWing 868. 筛质数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nint n[N], st[N], idx;\n\nvoid init(){\n\tfor(int i = 2; i <= N; i++){\n\t\tif(!st[i]) n[idx++] = i;\n\t\tfor(int j = 0; n[j] <= N / i; j++){\n\t\t\tst[n[j] * i] = 1;\n\t\t\tif(i % n[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nint main(){\n\tinit();\n\tint a, res = 0;\n\tcin >> a;\n\tfor(int i = 2; i <= a; i++){\n\t\tif(!st[i]){\n\t\t\tres ++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 约数\n\n![图片描述](http://www.lijunxi.site:4000/api/file/download/bd17a18c-0c3c-475c-87f2-30830d333ee3.png)\n\n#### AcWing 870. 约数个数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\tset<int> s;\n\tmap<int, int> mp;\n\tll a, b, res = 1;\n\tcin >> a;\n\twhile(a--){\n\t\tcin >> b;\n\t\tint xx = b;\n\t\tfor(int i = 2; i <= b / i; i++){\n\t\t\twhile(xx % i == 0){\n\t\t\t\txx /= i; \n\t\t\t\tmp[i] ++;\n\t\t\t}\n\t\t}\n                // x的最大公约数可能大于sqrt(x);\n\t\tif(xx > 1) mp[xx] ++;\n\t}\n\tfor(auto i: mp){\n\t\tres = (res * (i.second + 1)) % M; \n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n```\n\n#### AcWing 871. 约数之和\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\tmap<ll, ll> mp;\n\tint a;\n\tll res = 1;\n\tcin >> a;\n\twhile(a--){\n\t\tint m;\n\t\tcin >> m;\n\t\tint c = m;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\tll cot = 0;\n\t\t\twhile(c % i == 0){\n\t\t\t\tc /= i;\n\t\t\t\tmp[i] ++;\n\t\t\t}\n\t\t}\n\t\tif(c > 1) mp[c] ++;\t\n\t}\n\tfor(auto i: mp){\n\t\tll x = i.first, y = i.second, cot1 = 1, cot2 = 1;\n\t\twhile(y--){ \n\t\t\tcot2 = cot2 * x % M;\n\t\t\tcot1 = (cot1 + cot2) % M;\n\t\t}\n\t\tres = (res * cot1) % M;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n#### AcWing 872. 最大公约数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n// 最大公约数\nll fun1(int x, int y){\n\treturn y ? fun1(y, x % y) : x;\n}\n// 最小公倍数\nll fun2(int x, int y){\n\treturn x * fun1(x, y) / y;\n}\n\nint main(){\n\t\n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tcout << fun1(m, n) << endl;\n\t}\n\n\n\treturn 0;\n}\n```\n\n### 欧拉函数\n\n> 1∼N 中与 N 互质的数的个数被称为欧拉函数，称为O(n)  \n> 若N = p1^a\\*p2^b\\*p3^c\\*.....  \n> 则O(N) = N \\* (p1-1)/p1 \\* (p2-1)/p2 \\* (p3-1)/p3 \\*.....\n\n#### AcWing 873. 欧拉函数\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main(){\n\t\n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m;\n\t\tcin >> m;\n\t\tll res = m; \n\t\tmap<int, ll> mp;\n\t\tfor(int i = 2; i <= m / i; i++){\n\t\t\twhile(m % i == 0){\n\t\t\t\tm /= i;\n\t\t\t\tmp[i] ++;\n\t\t\t} \n\t\t}\n\t\tif(m > 1) mp[m] ++;\n\t\tfor(auto i: mp){\n\t\t\tint x = i.first;\n\t\t\tres = res * (x - 1) / x;\n\t\t} \n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n### 组合数\n\n#### AcWing 885. 求组合数 I\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10, M = 1e9 + 7;\n\nint e[2010][2010];\n\nvoid init(){\n    // 类似于DP\n    // e[i][j]就代表的是Cij\n\tfor(int i = 0; i < 2010; i++){\n\t\tfor(int j = 0; j <= i; j++){\n\t\t    // Ci0为1\n\t\t\tif(!j) e[i][j] = 1;\n\t\t\telse e[i][j] = (e[i-1][j-1] + e[i-1][j]) % M;\n\t\t}\n\t}\n} \n\nint main(){\n\t\n\tinit(); \n\tint a;\n\tcin >> a;\n\twhile(a--){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tcout << e[m][n] << endl;\n\t}\n\n\treturn 0;\n}\n```\n\n### 容斥原理\n\n#### AcWing 890. 能被整除的数\n\n若给出的待求的数组都是互质\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint v[20];\nint main(){\n\n    int a, b, res = 0;\n    cin >> a >> b;\n    for(int i = 0; i < b; i ++){\n        cin >> v[i];\n    }\n    for(int i = 1; i < 1 << b; i ++){\n        int cot = 0, t = 1;\n        for(int j = 0; j < b; j ++){\n            if(i >> j & 1){\n                cot ++;\n                if((ll) t * v[j] > a){\n                    t = -1;\n                    break;\n                }\n                t *= v[j];\n            }\n        }\n        if(t != -1){\n            if(cot % 2 == 0){\n                res -= a / t;\n            } else {\n                res += a / t;\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n```\n\n否则，修改乘积为求最小公倍数\n\n参考Leetcode：[单面值组合的第 K 小金额](https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/)\n\n```c++\nclass Solution {\npublic:\n    int len;\n    long long fun(long long x, vector<int>& v){\n        long long res = 0;\n        for(int i = 1; i < 1 << len; i++){\n            long long cot = 0, t = 1;\n            for(int j = 0; j < len; j++){\n                if(i >> j & 1){\n                    long long ccc = t / gcd(t, v[j]) * v[j]; //《-------------修改这里\n                    if(ccc > x){\n                        t = -1;\n                        break;\n                    }\n                    cot ++;\n                    t = ccc;\n                }\n            }\n            if(t != -1){\n                if(cot % 2 == 1) res += x / t;\n                else res -= x / t;\n            }\n        }\n        return res;\n    }\n    long long findKthSmallest(vector<int>& coins, int k) {\n        len = coins.size();\n        long long l = 1, r = 1e12;\n        while(l < r){\n            long long mid = (l + r) >> 1;\n            if(fun(mid, coins) >= k) r = mid;\n            else l = mid + 1;\n        }\n\n        return l;\n\n    }\n};\n```\n\n\n\n## 动态规划\n\n### 记忆化搜索\n\n#### AcWing 901. 滑雪\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint a, b;\nint n[310][310], cot[310][310];\nint ix[4] = {-1,0,1,0};\nint iy[4] = {0,1,0,-1};\n\nint dfs(int x, int y){\n\tif(cot[x][y] != -1) return cot[x][y];\n\tcot[x][y] = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tint xx = ix[i] + x, yy = iy[i] + y;\n\t\tif(xx >= 1 && xx <= a && yy >= 1 && yy <= b && n[x][y] > n[xx][yy]){\n\t\t\tcot[x][y] = max(cot[x][y], dfs(xx, yy) + 1);\n\t\t}\n\t}\n\treturn cot[x][y];\n}\n\n\nint main(){\n    memset(cot, -1, sizeof cot);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcin >> n[i][j];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tans = max(ans, dfs(i, j));\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n```\n\n### 线性DP\n\n#### AcWing 898. 数字三角形\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 510, M = 1e5 + 10;\t\nint n[N][N]; \nint cot[N][N];\nint a;\n\nint dfs(int x, int y){\n\tif(x < 1 || x > a || y < 1 || y > a) return 0;\n\tif(cot[x][y] != -1) return cot[x][y];\n\tint _1 = dfs(x + 1, y), _2 = dfs(x + 1, y + 1);\n\tcot[x][y] = max(_1, _2) + n[x][y]; \n\treturn cot[x][y]; \n}\n\nint main(){\n\tmemset(cot, -1, sizeof cot);\n\tcin >> a;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= i; j++){\n\t\t\tcin >> n[i][j];\t\n\t\t}\n\t}\n\tcout << dfs(1, 1) << endl;\n\t\n\treturn 0;\n}\n```\n\n#### AcWing 896. 最长上升子序列\n\n```\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\nint n[N];\nint a;\nvector<int> v; \n\nint main(){\n\n\tint a;\n\tcin >> a;\n\tfor(int i = 0; i < a; i++) cin >> n[i];\n\tfor(int i = 0; i < a; i++){\n\t\tif(v.empty() || n[i] > v.back()){\n\t\t\tv.push_back(n[i]);\n\t\t}\n\t\telse{\n\t\t\t*lower_bound(v.begin(), v.end(), n[i]) = n[i];\n\t\t}\n\t}\n\tcout << v.size() << endl;\n\t\n\treturn 0;\n}\n```\n\n#### AcWing 897. 最长公共子序列\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\n\nchar n1[N], n2[N];\n// n[i][j]记录前i个n1和前j个n2的公共子串的最大长度\nint n[1010][1010];\n \nint main(){\n\t\n\tint a, b;\n\tcin >> a >> b >> n1 + 1 >> n2 + 1;\n\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tif(n1[i] == n2[j]){\n\t\t\t\tn[i][j] = n[i-1][j-1] + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tn[i][j] = max(n[i-1][j], n[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\tfor(int i = 1; i <= a; i++){\n\t\tfor(int j = 1; j <= b; j++){\n\t\t\tcout << n[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << n[a][b] << endl;\n\t\n\treturn 0;\n}\n```","title":" Acwing基础课\n","category":[" 算法\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 基础算法\n\n 快速排序\n\n AcWing 785. 快速排序\n\n\ninclude <bits/stdc++.h\nusing namespace std;\n\nint main\n{\n\tvector<int v;\n    int a;\n    cin  a;\n    forint i = 0; i < a; i++{\n        int m;\n        cin  m;\n        v.pushbackm;\n    }\n    sortv.begin, v.end;\n    forint i = 0; i < a; i++{\n        cout << vi << \" \";\n    }\n\n  return 0;\n}\n\n\n 第k个数\n\n\ninclude <bits/stdc++.h\nusing namespace std;\n\nint main\n{\n    vector<int v;\n    int a, b;\n    cin  a  b;\n    forint i = 0; i < a; i++{\n        int m;\n        cin  m;\n        v.pushbackm;\n    }\n    sortv.begin, v.end;\n    cout << vb1;\n\n  return 0;\n}\n\n\n 归并排序\n\n AcWing 787. 归并排序\n\n\ninclude <bits/stdc++.h\nusing namespace std;\n\nint main\n{\n\tvector<int v;\n    int a;\n    cin  a;\n    forint i = 0; i < a; i++{\n        int m;\n        cin  m;\n        v.pushbackm;\n    }\n    sortv.begin, v.end;\n    forint i = 0; i < a; i++{\n        cout << vi << \" \";\n    }\n\n  return 0;\n}\n\n\n 二分\n\n可以直接用STL中的lower\\bound和upper\\bound\n\n lower\\boundn, n+a, target\n upper\\boundn, n+a, target\n\n举例（转载：博客链接https://blog.csdn.net/qq40160605/article/details/80150252）\n\n\ninclude<bits/stdc++.h\nusing namespace std;\nconst int maxn=100000+10;\nconst int INF=2int1e9+10;\ndefine LL long long\nint cmdint a,int b{\n\treturn ab;\n}\nint main{\n\tint num6={1,2,4,7,15,34}; \n\tsortnum,num+6;                           //按从小到大排序 \n\tint pos1=lowerboundnum,num+6,7num;    //返回数组中第一个大于或等于被查数的值 \n\tint pos2=upperboundnum,num+6,7num;    //返回数组中第一个大于被查数的值\n\tcout<<pos1<<\" \"<<numpos1<<endl;\n\tcout<<pos2<<\" \"<<numpos2<<endl;\n\tsortnum,num+6,cmd;                      //按从大到小排序\n\tint pos3=lowerboundnum,num+6,7,greater<intnum;  //返回数组中第一个小于或等于被查数的值 \n\tint pos4=upperboundnum,num+6,7,greater<intnum;  //返回数组中第一个小于被查数的值 \n\tcout<<pos3<<\" \"<<numpos3<<endl;\n\tcout<<pos4<<\" \"<<numpos4<<endl;\n\treturn 0;\t\n} \n\n\n AcWing 789. 数的范围\n\n\ninclude <bits/stdc++.h\nusing namespace std;\nint n100010;\nint a, b;\n\n// 左边距\nint getlint x{\n    int l = 0, r = a  1;\n    whilel < r{\n        int mid = l + r  / 2;\n        ifnmid = x r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\n int getrint x{\n    int l = 0, r = a  1;\n    whilel < r{\n    \tint mid = l + r + 1 / 2;\n        ifnmid <= x l = mid;\n        else r = mid  1;\n    }\n    return r;\n }\n\nint main{\n    \n    cin  a  b;\n    forint i = 0; i < a; i++ cin  ni;\n    forint i = 0; i < b; i++{\n        int m;\n        cin  m;\n        int l = getlm;\n        ifnl = m cout << 1 << \" \" << 1 << endl;\n\t\telse {\n\t\t\tint r = getrm;\n\t\t\tifnr = m cout << 1 << \" \" << 1 << endl;\n\t\t\telse cout << l << \" \" << r << endl; \n\t\t} \n    }\n\t\n    return 0;\n}\n\n\n AcWing 790. 数的三次方根  \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\ndouble getSdouble x{\n    return x  x  x;\n}\n\ndouble fundouble x{\n    double l = 10000, r = 10000;\n    whilel < r{\n        double mid = l + r / 2;\n        double res = getSmid;\n        iffabsres  x < 0.0000000001{\n        \treturn mid;\n\t\t}\n        ifres <= x l = mid;\n        else r = mid;\n    }\n}\n\nint main{\n    double a;\n    cin  a;\n\tprintf\"%.6lf\", funa;\n    \n    return 0;\n}\n\n\n 高精度\n\n AcWing 791. 高精度加法\n\n\na = intinput\nb = intinput\nprinta + b\n\n\n AcWing 792. 高精度减法\n\n\na = intinput\nb = intinput\nprinta  b\n\n\n AcWing 793. 高精度乘法\n\n\na = intinput\nb = intinput\nprinta  b\n\n\n AcWing 794. 高精度除法\n\n\na = intinput\nb = intinput\nprinta // b\nprinta % b\n\n\n 前缀和与差分\n\n AcWing 795. 前缀和\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\n\nint main{\n    \n    int a, b;\n    cin  a  b;\n    forint i = 1; i <= a; i++{\n       cin  ni;\n       mi = ni + mi  1;\n    }\n    \n    whileb{\n        int x, y;\n        cin  x  y;\n        cout << my  mx  1 << endl;\n    }\n    \n    return 0;\n}\n\n\n AcWing 796. 子矩阵的和 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n10011001, m10011001;\n\nint main{\n    \n    int a, b, c;\n    cin  a  b  c;\n    forint i = 1; i <= a; i++{\n        forint j = 1; j <= b; j++{\n            cin  nij;\n            mij = nij + mi1j + mij1  mi1j1;\n        }\n    }\n    whilec{\n        int q, w, e, r;\n        cin  q  w  e  r;\n        cout << mer + mq1w1  mq1r  mew1 << endl;\n    }\n    \n\n    return 0;\n}\n\n\n AcWing 797. 差分 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\n\nint main{\n   int a, b;\n   cin  a  b;\n   forint i = 1; i <= a; i++{\n       cin  ni;\n       mi = ni  ni1;\n   }\n   whileb{\n       int x, y ,z;\n       cin  x  y  z;\n       mx += z;\n       my+1 = z;\n   }\n   forint i = 1; i <= a; i++{\n       ni = mi + ni1;\n       cout << ni << \" \";\n   }\n   \n   return 0;\n}\n\n\n AcWing 798. 差分矩阵\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint n10101010, m10101010;\n\nint main{\n  \n   int a, b, c;\n   cin  a  b  c;\n   forint i = 1; i <= a; i++{\n       forint j = 1; j <= b; j++{\n           cin  nij;\n           mij = nij  ni1j  nij1 + ni1j1;\n       }\n   }\n   whilec{\n       int q, w, e, r, t;\n       cin  q  w  e  r  t;\n       mqw += t;\n       me+1r+1 += t;\n       me+1w = t;\n       mqr+1 = t;\n   }\n  forint i = 1; i <= a; i++{\n      forint j = 1; j <= b; j++{\n          nij = ni1j + nij1  ni1j1 + mij;\n          cout << nij << \" \";\n      }\n      cout << endl;\n  }\n   \n   return 0;\n}\n\n\n 双指针算法\n\n AcWing 799. 最长连续不重复子序列 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN;\n\nint main{\n    \n    int a, l, r, res = 0;\n    map<int, int is;\n    cin  a;\n    forint i = 0, j = 0; i < a; i++{\n        cin  ni;\n        isni ++;\n        whileisni  1{\n            isnj ;\n            j ++;\n        }\n        res = maxres, i  j + 1;\n    }\n    cout << res << endl;\n  \n    return 0;\n}\n\n\n AcWing 800. 数组元素的目标和\n\n哈希方法\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\nunorderedmap<int, int ump;\n\nint main{\n    \n    int a, b, c, r1 = 0, r2 = 0;\n    cin  a  b  c;\n    forint i = 0; i < a; i++ {\n        cin  ni;\n        umpni = i;\n    }\n    forint j = 0; j < b; j++ {\n        cin  mj;\n        ifump.countc  mj{\n            r1 = umpc  mj, r2 = j;\n        }\n    }\n\n    cout << r1 << \" \" << r2 << endl;\n  \n    return 0;\n}\n\n\n AcWing 2816. 判断子序列\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nint nN, mN;\nunorderedmap<int, int ump;\n\nint main{\n    \n    int a, b;\n    cin  a  b;\n    forint i = 0; i < a; i++ cin  ni;\n    forint j = 0; j < b; j++ cin  mj;\n   \n    int x = 0, y = 0;\n    whilex < a && y < b{\n        ifnx == my x ++;\n        y ++;\n    }\n    \n    ifx == a cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  \n    return 0;\n}\n\n\n 位运算\n\n AcWing 801. 二进制中1的个数\n\n 小知识：n的二进制表示中第k位是几？  \n 答案：n  k & 1  \n n右移k位&1后得出二进制数的最后一位\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// 返回x的最后一位1\n// 比如10010的最后一位就是10\nint lowbitint x{\n    return x & x;    \n}\n\nint main{\n        \n    int a, b, res;\n    cin  a;\n    forint i = 0; i < a; i++{\n        cin  b;\n        res = 0;\n        whileb{\n            b = lowbitb;\n            res ++;\n        }\n        cout << res << \" \";\n    }\n        \n    return 0;\n}\n\n\n 离散化\n\n AcWing 802. 区间和  \n\n 小知识  \n 离散化：将100，2000，30000，4000000映射为1，2，3，4的过程\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\n// 此处不是1e5+10\n// 极端情况下第一排输入会有1e5的数据，第二排会有2e5的数据\nconst int N = 3e5 + 10 ;\n\nint sN, fN;\n\nvector<int v;\nvector<pair<int, int  q, w;\n// 二分查找元素下标\nint findint x{\n    int l = 0, r = v.size  1;\n    whilel < r{\n        int mid = l + r  1;\n        ifvmid = x r = mid;\n        else l = mid + 1;\n    }\n    return l + 1;\n}\n\nint main{\n    \n    int a, b, m, n;\n    cin  a  b;\n    forint i = 0; i < a; i++{\n        cin  m  n;\n        q.pushback{m, n};\n        v.pushbackm;\n    }\n    forint j = 0; j < b; j++{\n        cin  m  n;\n        w.pushback{m, n};\n        v.pushbackm;\n        v.pushbackn;\n    }\n    sortv.begin, v.end;\n    // 去重\n    v.eraseuniquev.begin, v.end, v.end;\n    // 离散化处理\n    forauto i: q{\n        int x = findi.first;\n        sx += i.second;\n    }\n    // 预处理前缀和\n    forint i = 1; i <= v.size; i++{\n        fi = fi1 + si;\n    }\n    // 查询结果\n    forauto i: w{\n        int l = findi.first, r = findi.second;\n        cout << fr  fl1 << endl;\n    }\n    \n    return 0;\n}\n\n\n图片描述http://www.lijunxi.site:4000/api/file/download/6261dfbbafd542b9bcdf46091f5b8e0f.jpg\n\n数据范围分析\n\n 区间合并\n\n AcWing 803. 区间合并\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ; \n\nstruct point{\n    int x, y;\n} nN;\n\nbool cmppoint a, point b{\n    ifa.x == b.x return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main{\n    \n    int a, idx = 0;\n    cin  a;\n    forint i = 0; i < a; i++ cin  ni.x  ni.y;\n    sortn, n+a, cmp;\n    int langm = n0.y;\n    forint i = 1; i < a; i++{\n        langm = maxlangm, ni1.y;\n        iflangm < ni.x idx++;\n    }\n    cout << idx + 1 << endl;\n  \n    return 0;\n}\n\n\n 数据结构\n\n 单链表\n\n AcWing 826. 单链表\n\n数组模拟单链表\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\n// 头指针（用下表指针辅助），下标指针\nint hidx = 1, idx = 0;\n// 元素值，元素下表\nint nN, neN;\n\nvoid insertint k, int x{\n    // 新节点值赋值\n    nidx = x;\n    // 将新结点下一个结点赋值为插入位置的下一个结点\n    neidx = nek;\n    // 将插入位置的一下个节点指向新节点\n    nek = idx;\n    idx++;\n}\n\nvoid addHeadint x{\n    // 头节点赋值\n    nidx = x;\n    // 指向头指针\n    neidx = hidx;\n    // 更改头指针为当前下表\n    hidx = idx;\n    idx++;\n}\n\nvoid delint idx{\n    neidx = neneidx;   \n}\n\nint main{\n    \n    int x, k, num; \n    char s;\n    cin  x;\n    whilex{\n        cin  s;\n        ifs == 'H'{\n            cin  num;\n            addHeadnum;\n        }\n        else ifs == 'D'{\n            cin  k;\n            //判断是否删除的为头节点\n            ifk hidx = nehidx;  \n            delk1;\n        }\n        else{\n            cin  k  num;\n            insertk1, num;\n        }\n    }\n    whilehidx = 1{\n        cout << nhidx << \" \";\n        hidx = nehidx;\n    }\n    \n    return 0;\n}\n\n\n 双链表\n\n 栈\n\n AcAcWing 3302. 表达式求值\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nstack<int s;\nstack<char f;\nunorderedmap<char, int ump;\n\nvoid initmap{\n\tump'' = 2;\n\tump'/' = 2;\n\tump'+' = 1;\n\tump'' = 1;\n}\n\nvoid eval{\n\tint num = 0;\n\tint x = s.top; s.pop;\n\tint y = s.top; s.pop;\n\tchar op = f.top; f.pop;\n\tifop == '+' num = x + y;\n\telse ifop == '' num = y  x;\n\telse ifop == '' num = x  y;\n\telse num = y / x;\n\ts.pushnum;\n}\n\nint main{\n    initmap;\n    string str;\n    int num, idx = 0;\n    char c;\n    cin  str;\n    int len = str.size;\n    forint i = 0; i < len; i++{\n        ifstri = '0' && stri <= '9'{\n            idx = i;\n            num = 0;\n            whilestridx = '0' && stridx <= '9' && idx < len{\n                num = num  10 + stridx  '0';\n                idx++; \n            }\n            s.pushnum;\n            i = idx  1;\n        }\n        else ifstri == '' f.pushstri;\n        else ifstri == ''{\n       \t\twhilef.size && s.size = 2 && umpstri <= umpf.top && f.top = '' eval;\n       \t\tf.pop;\n        }\n        else{\n        \twhilef.size && s.size = 2 && umpstri <= umpf.top eval;\n            f.pushstri;\n        }\n    }\n    whilef.size eval;\n\tcout << s.top << endl; \n    \n    return 0;\n}\n\n\n 队列\n\n AcWing 829. 模拟队列\n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nqueue<int q;\n\nint main{\n    int a, num;\n    string s;\n    cin  a;\n    whilea{\n        cin  s;\n        ifs == \"push\"{\n            cin  num;\n            q.pushnum;\n        }\n        else ifs == \"pop\"{\n            q.pop;\n        }\n        else ifs == \"empty\"{\n            ifq.empty cout <<\"YES\"<<endl;\n            else cout <<\"NO\" << endl;\n        }\n        else{\n            cout << q.front << endl;\n        }\n    }\n   \n    return 0;\n}\n\n\n 单调栈\n\n AcWing 830. 单调栈\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\nstack<int s;\n\nint main{\n    \n    int a, num;\n    cin  a;\n    forint i = 0; i < a; i++ {\n        cin  num;\n        whiles.size && s.top = num s.pop;\n        ifs.size cout << 1 << \" \";\n        else cout << s.top << \" \";\n        s.pushnum;\n    }\n    \n    return 0;\n}\n\n\n 单调队列\n\n AcWing 154. 滑动窗口\n\n\ninclude<iostream\ninclude<algorithm\ninclude<deque\ninclude<vector\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10 ;\n\n// deque没法直接获取下表的元素值，所以需要用一个数组来维护 \nint nN;\ndeque<int dq; \n\nint main{\n  \n    int a, b, num;\n    cin  a  b;\n    forint i = 1; i <= a; i++ cin  ni;\n    forint i = 1; i <= a; i++{\n    \t// 当尾元素比ni大时，需要弹出 \n    \twhiledq.size && ndq.back  ni dq.popback;\n    \tdq.pushbacki;\n    \t// 当队列的个数满足b时们需要弹出首元素\n\t\t// 这里不能用dq.size来判断是否满足个数，因为可能出现首元素到i之间有些元素已经弹出了但size总数任然小于b情况 \n    \tifdq.size && i  dq.front = b dq.popfront;\n    \t// 当i大于b时候就能开始输出了，这里也不能用dq.size来判断，因为存在整个过程都小于b的情况，这样就没有输出了 \n\t\tifi = b cout << ndq.front << \" \";\n\t}\n\tdq.clear;\n\tputs\"\";\n      forint i = 1; i <= a; i++{\n    \twhiledq.size && ndq.back < ni dq.popback;\n    \tdq.pushbacki;\n    \tifdq.size && i  dq.front = b dq.popfront;\n\t\tifi = b cout << ndq.front << \" \";\n\t}\n    \n    return 0;\n}\n\n\n KMP\n\n Tire\n\n AcWing 835. Trie字符串统计\n\n Trie树（字典树）：高效存储和查找字符串集合的数据结合\n\n\ninclude<iostream\ninclude<algorithm\ninclude<deque\ninclude<vector\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\n\n// son存储子节点的位置，分支最多26条\n// cnt存储以某节点结尾的字符串个数（同时也起标记作用）\n// idx表示当前要插入的节点是第几个,每创建一个节点值+1\nint sonN26, cntN, idx = 0;\n\nvoid insertstring str{\n\t// 类似指针，指向当前节点\n\tint p = 0;\n\tforint i = 0; i < str.size; i++{\n\t\tint s = stri  'a';\n\t\t// 该字符不存在就创建一个 \n\t\tifsonps sonps = ++idx;\n\t\t// \tp指向下一个节点\n\t\tp = sonps;\n\t}\n\t// 统计字符串个数 \n\tcntp ++;\n} \n\nint querystring str{\n\tint p = 0;\n\tforint i = 0; i < str.size; i++{\n\t\tint s = stri  'a';\n\t\tifsonps return 0;\n\t\tp = sonps; \n\t}\n\treturn cntp;\n}\n\n\nint main{\n \n\tint a;\n\tchar c;\n\tstring str;\n\tcin  a;\n\twhilea{\n\t\tcin  c;\n\t\tcin  str;\n\t\tifc == 'I' insertstr;\n\t\telse cout << querystr << endl;\n\t}\n    \n    return 0;\n}\n\n\n AcWing 143. 最大异或对  \n\n\ninclude<iostream\ninclude<algorithm\ninclude<deque\ninclude<vector\nusing namespace std;\ntypedef long long ll;\n// 最多有1e5个数，每个数的二进制数有31位，极限情况下就1e5  31\nconst int N = 31e5 + 10 ;\n\nint sonN2, nN, idx = 0;\n\n// 将数字插入trie树中 \nvoid insertint x{\n\tint p = 0;\n\t// 数的范围为小于2e31次方 \n\tforint i = 30; i = 0; i {\n\t\tint s = x  i & 1;\n\t\tifsonps sonps = ++idx;\n\t\tp = sonps;\n\t}\n}\n\nint queryint x{\n\tint p = 0, res = 0;\n\tforint i = 30; i = 0; i{\n\t\t// x二进制第i位上的数 \n\t\tint s = x  i & 1;\n\t\t// 若存在相反的数 \n\t\tifsonps{\n\t\t\tp = sonps;\n\t\t\t// 1左移i位就是2^30i次方 \n\t\t\tres += 1 << i;\n\t\t}\n\t\telse{\n\t\t\tp = sonps;\n\t\t\tres += 0 << i;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main{\n\n\tint a, res = 0;\n\tcin  a;\n\tforint i = 0; i < a; i++ {\n\t\tcin  ni;\n\t\tinsertni;\n\t}\n\tforint i = 0; i < a; i++ res = maxres, queryni;\n\tcout << res << endl;\n\t\n    return 0;\n}\n\n\n 并查集\n\n AcWing 836. 合并集合\n\n\ninclude<iostream\ninclude<algorithm\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10 ;\nint nN;\n\n// 找到祖宗结点\nint findint x{\n    // 修改结点，避免重复查找\n   ifnx = x nx = findnx;\n   return nx;\n}\n\nint main{\n    int a, b;\n    cin  a  b;\n    forint i = 0; i < a; i++ ni = i;\n    forint i = 0; i < b; i++{\n        char x;\n        int o, p;\n        cin  x  o  p;\n        ifx == 'M'{\n            nfindo = findp;\n        }\n        else{\n            iffindo == findp cout << \"Yes\" << endl;\n            else cout << \"No\" << endl;\n        }\n    }\n     \n    return 0;\n}\n\n\n 堆\n\n 堆：优先队列\n\n AcWing 838. 堆排序\n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint nN;\n// 从小到大排序，从大到小就为less<int，与sort相反\npriorityqueue<int, vector<int, greater<int pq;\nint main{\n    \n    int a, b, num;\n    cin a  b;\n    forint i = 0; i < a; i++{\n        cin  num;\n        pq.pushnum;\n    }\n    int idx = 0;\n    whileidx = b{\n        idx ++;\n        cout << pq.top << \" \";\n        pq.pop;\n    }\n    \n    return 0;\n}\n\n\n 哈希表\n\n 搜索与图论\n\n DFS\n\n AcWing 842. 排列数字 \n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nint isN;\nvector<int v;\n\nvoid dfsint x{\n    ifx == 0 return; \n    ifv.size == a{\n    \tforint i = 0; i < a; i++ cout << vi << \" \";\n    \tcout << endl;\n\t}\n\tforint i = 1; i <= a; i++{\n\t\tifisi{\n\t\t\tisi = 1;\n\t\t\tv.pushbacki;\n\t\t\tdfsi;\n\t\t\tv.popback;\n\t\t\tisi = 0;\n\t\t}\n\t}\n}\n\nint main{\n    cin  a;\n    dfsa;\n    return 0;\n}\n\n\n AcWing 843. n皇后问题\n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n    \nint a;\nchar n1111;\nint l11, xie11, fx11;\n\nvoid print{\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= a; j++{\n\t\t\tcout << nij;\n\t\t}\n\t\tputs\"\";\n\t}\n\tputs\"\";\n} \n\nvoid dfsint x{\n\tifx == a + 1{\n\t\tprint;\n\t\treturn;\n\t}\n    forint i = 1; i <= a; i++{\n    \t// \ti  x + a是为了避免出现下标是负数的情况 \n    \tifli && xiei  x + a && fxi + x{\n    \t\tnxi = 'Q';\n    \t\txiei  x + a = 1;\n    \t\tfxi + x = 1;\n    \t\tli = 1;\n    \t\tdfsx + 1;\n    \t\tnxi = '.';\n    \t\txiei  x + a = 0;\n    \t\tfxi + x = 0;\n    \t\tli = 0;\n\t\t}\n\t\n\t}\n\n}\n\nint main{\n  \t\n\tcin  a;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= a; j++{\n\t\t\tnij = '.';\n\t\t}\n\t}\n    dfs1;\n    \n    return 0;\n}\n\n\n BFS\n\n AcWing 844. 走迷宫 \n\n\ninclude<bits/stdc++.h\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint a, b;\nint n10101010, is10011001;\nint ix4 = {1, 1, 0 ,0}, iy4 = {0, 0, 1, 1};\n\nvoid bfsint x, int y{\n    queue<pair<int, int q;\n    map<pair<int, int, int mp;\n    q.push{0, 0};\n    mp{0, 0} = 0;\n    whileq.empty{\n    \tauto top = q.front;\n    \tq.pop;\n    \tint xx = top.first, yy = top.second;\n    \tifxx == a  1 && yy == b  1{\n    \t\tcout << mp{xx, yy} << endl;\n    \t\treturn;\n\t\t}\n\t\tforint i = 0; i < 4; i++{\n\t\t\tint x = xx + ixi, y = yy + iyi;\n\t\t\tifnxy && isxy && x = 0 && x < a && y = 0 && y < b{\n\t\t\t\tisxy = 1;\n\t\t\t\tq.push{x, y};\n\t\t\t\tmp{x, y} = mp{xx, yy} + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main{\n  \t\n\tcin  a  b;\n\tforint i = 0; i < a; i++{\n\t    forint j = 0; j < b; j++{\n\t        cin  nij;\n\t    }\n\t}\n\tbfs0, 0;\n    \n    return 0;\n}\n\n\n 树与图的深度优先遍历\n\n AcWing 846. 树的重心\n\n图的存储采用数组模拟邻接表\n\n思路：邻接表dfs\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint hN;\n// 存储元素 \nint eN;\n// 下个节点值\nint neN;\n// 结点是否访问过\nint stN; \n// 单链表指针 \nint idx = 0; \nint a, ans = N; \n\nvoid addint x, int y{\n\teidx = y, neidx = hx, hx = idx++;\n}\n\nint dfsint x{\n\tint res = 0, sum = 1;\n\tstx = 1;\t\n\tforint i = hx; i = 1; i = nei{\n\t\tint j = ei;\n\t\tifstj{\n\t\t\tint s = dfsj;\n\t\t\t// 子图最大结点数 \n\t\t\tres = maxres, s;\n\t\t\t// j为根的节点总数 \n\t\t\tsum += s;\t\t\n\t\t}\n\t}\n\t// a  sum：另一部分的节点总数 \n\tres = maxres, a  sum;\n\t// 选取最小的最大结点数 \n\tans = minans, res;\n\treturn sum;\n}\n\n\nint main{\n  \t//初始化h数组 1表示尾节\n\tmemseth, 1, sizeof h; \n    cin.tie0;cout.tie0;ios::syncwithstdiofalse;\n    cin  a;\n    // 创建邻接表 \n    forint i = 0; i < a  1; i++{\n    \tint m, n;\n    \tcin  m  n;\n    \taddm, n;\n    \taddn, m;\n\t}\n    dfs1;\n    cout << ans << endl;\n    return 0;\n}\n\n\n 树与图的广度优先遍历\n\n AcWing 847. 图中点的层次\n\n思路：邻接表bfs\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 10;\n\n// 邻接表头结点 \nint hN;\n// 存储元素 \nint eN;\n// 下个节点值\nint neN;\n// 结点是否访问过\nint stN; \n// 单链表指针 \nint idx = 0; \nint a, b, ans = N; \n\nvoid addint x, int y{\n\teidx = y, neidx = hx, hx = idx, idx ++;\n}\n\nvoid dfsint x{\n    queue<pair<int, int q;\n    map<pair<int, int, int ump;\n    q.push{1, 1};\n    ump{1, 1} = 0;\n    whileq.empty{\n        auto top = q.front;\n        q.pop;\n        int xx = top.first, yy = top.second;\n        ifyy == a{\n        \tcout << ump{xx, yy} << endl;\n        \treturn;\n\t\t}\n\t\tforint i = hyy; i = 1; i = nei{\n\t\t\tifump.find{yy, ei} == ump.end{\n\t\t\t\tq.push{yy, ei};\n\t\t\t\tump{yy, ei} = ump{xx, yy} + 1;\n\t\t\t}\n\t\t}\n    }   \n\tcout << 1 << endl; \n \n}\n\nint main{\n  \t//初始化h数组 1表示尾节\n\tmemseth, 1, sizeof h; \n    cin.tie0;cout.tie0;ios::syncwithstdiofalse;\n    cin  a  b;\n    // 创建邻接表 \n    forint i = 0; i < b; i++{\n    \tint m, n;\n    \tcin  m  n;\n    \taddm, n;\n\t}\n    dfs1;\n\n    return 0;\n}\n\n\n 拓扑排序\n\n AcWing 848. 有向图的拓扑序列\n\n思路：邻接表找入度为0的结点\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint hN, eN, neN, idx, a, b;\nqueue<int q;\n// 保存各个点的入度\nint dN; \n// v存放答案\nvector<int v;\n\nvoid addint x, int y{\n    eidx = y, neidx = hx, hx = idx++;\n}\n\nbool topsort{\n    // 找出入读为0的点\n    forint i = 1; i <= a; i++{\n    \tifdi q.pushi; \n\t}\t\n\twhileq.size{\n\t\tint top = q.front;\n\t\tq.pop;\n\t\tv.pushbacktop;\n\t\t// 每次循环减去一条边\n\t\tforint i = htop; i = 1; i = nei{\n\t\t\tint j = ei;\n\t\t\tdj ;\n\t\t\t// 当减去后的入读为0则入队列\n\t\t\tifdj q.pushj;\n\t\t}\n\t}\n\treturn v.size == a;\n}\n\nint main{\n  \t\n  \tmemseth, 1, sizeof h;\n  \tcin  a  b;\n  \twhileb{\n  \t    int x, y;\n  \t    cin  x  y;\n  \t    addx, y;\n  \t    dy ++;\n  \t}\n  \tiftopsort{\n  \t\tforint i = 0; i < v.size; i++ cout << vi << \" \";\n\t}\n\telse puts\"1\";\n  \t\n    return 0;\n}\n\n\n Dijkstra\n\n稠密图：临界矩阵（点较少）  \n稀疏图：邻接表（点较多）\n\n AcWing 849. Dijkstra求最短路 I\n\n朴素版（暴力）\n\n\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint m, n;\n// 为稠密阵所以用邻接矩阵存储\nint num501501;\n// 用于记录每一个点距离第一个点的距离\nint disN;\n// 用于记录该点的最短距离是否已经确定\nint stN;\n\nint dijkstra{\n\tmemsetdis, 0x3f3f3f3f, sizeof dis;\n\tdis1 = 0;\n\tforint i = 0; i < m; i++{\n\t\tint t = 1;\n\t\t// 找到没有确定最短路径的节点中距离源点最近的点t \n\t\tforint j = 1; j <= m; j++{\n\t\t\tifstj && t == 1  dist  disj{\n\t\t\t\tt = j;\n\t\t\t}\n\t\t}\n\t\tstt = 1;\n\t\t// 更新到其他点的距离 \n\t\tforint k = 1; k <= m; k++{\n\t\t\tdisk = mindisk, dist + numtk;\n\t\t}\n\t}\n\tifdism==0x3f3f3f3f return 1;\n    return dism;\n}\n\nint main{\n\tmemsetnum, 0x3f3f3f3f, sizeof num;\n\tcin  m  n;\n\tforint i = 0; i < n; i++{\n\t\tint x, y, z;\n\t\tcin  x  y  z;\n\t\tnumxy = minnumxy, z;\n\t}\n  \tcout << dijkstra << endl;\n    return 0;\n}\n\n\n AcWing 850. Dijkstra求最短路 II \n\n临界表法\n\n\ninclude<bits/stdc++.h\n \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\ntypedef pair<int, int PII;\n\nint eN, neN, idx, hN, disN, stN;\nint wN; // 存放权重 \nint a, b;\n\nvoid addint x, int y, int z{\n\twidx = z, eidx = y, neidx = hx, hx = idx++;\n}\n\nint dj{\n\tmemsetdis, 0x3f3f3f3f, sizeof dis;\n\tpriorityqueue<PII, vector<PII, greater<PII heap;\n\t// 插入距离和结点编号 \n\theap.push{0, 1};\n\twhileheap.empty{\n\t\tauto top = heap.top;\n\t\theap.pop;\n\t\tint x = top.second, y = top.first;\n\t\tifstx continue;\n\t\tstx = 1;\n\t\t// 遍历该节点的每个临界结点，给每个选出最短距离 \n\t\tforint i = hx; i = 1; i = nei{\n\t\t\tint j = ei;\n\t\t\tifdisj  disx + wi{\n\t\t\t\tdisj = disx + wi;\n\t\t\t\theap.push{disj, j};\n\t\t\t}\n\t\t}\n\t}\n\tifdisa == 0x3f3f3f3f return 1;\n\treturn disa;\n}\n\nint main{\n\tmemseth, 1, sizeof h;\n\tcin  a  b;\n\twhileb{\n\t\tint x, y, z;\n\t\tcin  x  y  z;\n\t\taddx, y, z;\n\t\taddy, x, z;\n\t}\n\tcout << dj << endl;\n\n    return 0;\n}\n\n\n Floyd\n\n与迪杰斯特拉的区别：\n\n 迪杰斯特拉算法适用于非负权，用于查找1到n 的最短距离，数据范围大\n 弗洛伊德算法适用于含有负权，用于查找每个点之间的最短距离，数据范围较少\n\n AcWing 854. Floyd求最短路\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int PII;\n\nint n, m, k;\nint e201201;\n\nvoid floyd{\n\t//  fi, j, k表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么fi, j, k = minfi, j, k  1, fi, k, k  1 + fk, j, k  1。\n    // 因此在计算第k层的fi, j的时候必须先将第k  1层的所有状态计算出来，所以需要把k放在最外层。 \n\tforint k = 1; k <= n; k++{\n\t\tforint i = 1; i <= n; i++{\n\t\t\tforint j = 1; j <= n; j++{\n\t\t\t\teij = mineij, eik + ekj;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main{\n\tcin  n  m  k; \n\tforint i = 1; i <= n; i++{\n\t\tforint j = 1; j <= n; j++{\n\t\t\tifi == j eij = 0;\n\t\t\telse eij = INF;\n\t\t}\n\t}\n\tforint i = 0; i < m; i++{\n\t\tint x, y, z;\n\t\tcin  x  y  z;\n\t\texy = minexy, z;\n\t}\n\tfloyd;\n\twhilek{\n\t\tint x, y;\n\t\tcin  x  y;\n\t\t// 不能exy == INF，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可 \n\t\tifexy  INF / 2 cout << \"impossible\"<<endl;\n\t\telse cout << exy <<endl;\n\t}\n\treturn 0;\n}\n\n\n 数学知识\n\n 质数\n\n AcWing 867. 分解质因数\n\n主要需要开方来避免超时\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\n\nint main{\n\t\n\tint n, m;\n\tcin  n;\n\twhilen{\n\t\tcin  m;\n\t\tint mm = m, flag = 0;\n\t\tforint i = 2; i <= m / i; i++{\n\t\t\tint idx = 0;\n\t\t\twhilemm % i == 0{\n\t\t\t\tidx ++;\n\t\t\t\tmm /= i;\n\t\t\t}\n\t\t\tifidx = 0{\n\t\t\t    flag = 1;\n\t\t\t    cout << i << \" \" << idx << endl;\n\t\t\t} \n\t\t}\n\t\tifflag{\n\t        ifmm = 1 cout << mm << \" \" << 1 << endl;\n\t        cout << endl;\n\t\t}\n\t\telse {\n\t\t    cout << m << \" \" << 1 << endl;\n\t\t    cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n AcWing 868. 筛质数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10;\nint nN, stN, idx;\n\nvoid init{\n\tforint i = 2; i <= N; i++{\n\t\tifsti nidx++ = i;\n\t\tforint j = 0; nj <= N / i; j++{\n\t\t\tstnj  i = 1;\n\t\t\tifi % nj == 0 break;\n\t\t}\n\t}\n}\n\n\nint main{\n\tinit;\n\tint a, res = 0;\n\tcin  a;\n\tforint i = 2; i <= a; i++{\n\t\tifsti{\n\t\t\tres ++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n 约数\n\n图片描述http://www.lijunxi.site:4000/api/file/download/bd17a18c0c3c475c87f230830d333ee3.png\n\n AcWing 870. 约数个数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main{\n\tset<int s;\n\tmap<int, int mp;\n\tll a, b, res = 1;\n\tcin  a;\n\twhilea{\n\t\tcin  b;\n\t\tint xx = b;\n\t\tforint i = 2; i <= b / i; i++{\n\t\t\twhilexx % i == 0{\n\t\t\t\txx /= i; \n\t\t\t\tmpi ++;\n\t\t\t}\n\t\t}\n                // x的最大公约数可能大于sqrtx;\n\t\tifxx  1 mpxx ++;\n\t}\n\tforauto i: mp{\n\t\tres = res  i.second + 1 % M; \n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n\n AcWing 871. 约数之和\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main{\n\tmap<ll, ll mp;\n\tint a;\n\tll res = 1;\n\tcin  a;\n\twhilea{\n\t\tint m;\n\t\tcin  m;\n\t\tint c = m;\n\t\tforint i = 2; i <= m / i; i++{\n\t\t\tll cot = 0;\n\t\t\twhilec % i == 0{\n\t\t\t\tc /= i;\n\t\t\t\tmpi ++;\n\t\t\t}\n\t\t}\n\t\tifc  1 mpc ++;\t\n\t}\n\tforauto i: mp{\n\t\tll x = i.first, y = i.second, cot1 = 1, cot2 = 1;\n\t\twhiley{ \n\t\t\tcot2 = cot2  x % M;\n\t\t\tcot1 = cot1 + cot2 % M;\n\t\t}\n\t\tres = res  cot1 % M;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n\n AcWing 872. 最大公约数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n// 最大公约数\nll fun1int x, int y{\n\treturn y ? fun1y, x % y : x;\n}\n// 最小公倍数\nll fun2int x, int y{\n\treturn x  fun1x, y / y;\n}\n\nint main{\n\t\n\tint a;\n\tcin  a;\n\twhilea{\n\t\tint m, n;\n\t\tcin  m  n;\n\t\tcout << fun1m, n << endl;\n\t}\n\n\n\treturn 0;\n}\n\n\n 欧拉函数\n\n 1∼N 中与 N 互质的数的个数被称为欧拉函数，称为On  \n 若N = p1^a\\p2^b\\p3^c\\.....  \n 则ON = N \\ p11/p1 \\ p21/p2 \\ p31/p3 \\.....\n\n AcWing 873. 欧拉函数\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10, M = 1e9 + 7;\n\nint main{\n\t\n\tint a;\n\tcin  a;\n\twhilea{\n\t\tint m;\n\t\tcin  m;\n\t\tll res = m; \n\t\tmap<int, ll mp;\n\t\tforint i = 2; i <= m / i; i++{\n\t\t\twhilem % i == 0{\n\t\t\t\tm /= i;\n\t\t\t\tmpi ++;\n\t\t\t} \n\t\t}\n\t\tifm  1 mpm ++;\n\t\tforauto i: mp{\n\t\t\tint x = i.first;\n\t\t\tres = res  x  1 / x;\n\t\t} \n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}\n\n\n 组合数\n\n AcWing 885. 求组合数 I\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 10, M = 1e9 + 7;\n\nint e20102010;\n\nvoid init{\n    // 类似于DP\n    // eij就代表的是Cij\n\tforint i = 0; i < 2010; i++{\n\t\tforint j = 0; j <= i; j++{\n\t\t    // Ci0为1\n\t\t\tifj eij = 1;\n\t\t\telse eij = ei1j1 + ei1j % M;\n\t\t}\n\t}\n} \n\nint main{\n\t\n\tinit; \n\tint a;\n\tcin  a;\n\twhilea{\n\t\tint m, n;\n\t\tcin  m  n;\n\t\tcout << emn << endl;\n\t}\n\n\treturn 0;\n}\n\n\n 容斥原理\n\n AcWing 890. 能被整除的数\n\n若给出的待求的数组都是互质\n\nc++\ninclude<bits/stdc++.h\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint v20;\nint main{\n\n    int a, b, res = 0;\n    cin  a  b;\n    forint i = 0; i < b; i ++{\n        cin  vi;\n    }\n    forint i = 1; i < 1 << b; i ++{\n        int cot = 0, t = 1;\n        forint j = 0; j < b; j ++{\n            ifi  j & 1{\n                cot ++;\n                ifll t  vj  a{\n                    t = 1;\n                    break;\n                }\n                t = vj;\n            }\n        }\n        ift = 1{\n            ifcot % 2 == 0{\n                res = a / t;\n            } else {\n                res += a / t;\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n\n\n否则，修改乘积为求最小公倍数\n\n参考Leetcode：单面值组合的第 K 小金额https://leetcode.cn/problems/kthsmallestamountwithsingledenominationcombination/\n\nc++\nclass Solution {\npublic:\n    int len;\n    long long funlong long x, vector<int& v{\n        long long res = 0;\n        forint i = 1; i < 1 << len; i++{\n            long long cot = 0, t = 1;\n            forint j = 0; j < len; j++{\n                ifi  j & 1{\n                    long long ccc = t / gcdt, vj  vj; //《修改这里\n                    ifccc  x{\n                        t = 1;\n                        break;\n                    }\n                    cot ++;\n                    t = ccc;\n                }\n            }\n            ift = 1{\n                ifcot % 2 == 1 res += x / t;\n                else res = x / t;\n            }\n        }\n        return res;\n    }\n    long long findKthSmallestvector<int& coins, int k {\n        len = coins.size;\n        long long l = 1, r = 1e12;\n        whilel < r{\n            long long mid = l + r  1;\n            iffunmid, coins = k r = mid;\n            else l = mid + 1;\n        }\n\n        return l;\n\n    }\n};\n\n\n\n\n 动态规划\n\n 记忆化搜索\n\n AcWing 901. 滑雪\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint a, b;\nint n310310, cot310310;\nint ix4 = {1,0,1,0};\nint iy4 = {0,1,0,1};\n\nint dfsint x, int y{\n\tifcotxy = 1 return cotxy;\n\tcotxy = 1;\n\tforint i = 0; i < 4; i++{\n\t\tint xx = ixi + x, yy = iyi + y;\n\t\tifxx = 1 && xx <= a && yy = 1 && yy <= b && nxy  nxxyy{\n\t\t\tcotxy = maxcotxy, dfsxx, yy + 1;\n\t\t}\n\t}\n\treturn cotxy;\n}\n\n\nint main{\n    memsetcot, 1, sizeof cot;\n\tcin  a  b;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcin  nij;\n\t\t}\n\t}\n\tint ans = 0;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tans = maxans, dfsi, j;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n\n 线性DP\n\n AcWing 898. 数字三角形\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 510, M = 1e5 + 10;\t\nint nNN; \nint cotNN;\nint a;\n\nint dfsint x, int y{\n\tifx < 1  x  a  y < 1  y  a return 0;\n\tifcotxy = 1 return cotxy;\n\tint 1 = dfsx + 1, y, 2 = dfsx + 1, y + 1;\n\tcotxy = max1, 2 + nxy; \n\treturn cotxy; \n}\n\nint main{\n\tmemsetcot, 1, sizeof cot;\n\tcin  a;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= i; j++{\n\t\t\tcin  nij;\t\n\t\t}\n\t}\n\tcout << dfs1, 1 << endl;\n\t\n\treturn 0;\n}\n\n\n AcWing 896. 最长上升子序列\n\n\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\nint nN;\nint a;\nvector<int v; \n\nint main{\n\n\tint a;\n\tcin  a;\n\tforint i = 0; i < a; i++ cin  ni;\n\tforint i = 0; i < a; i++{\n\t\tifv.empty  ni  v.back{\n\t\t\tv.pushbackni;\n\t\t}\n\t\telse{\n\t\t\tlowerboundv.begin, v.end, ni = ni;\n\t\t}\n\t}\n\tcout << v.size << endl;\n\t\n\treturn 0;\n}\n\n\n AcWing 897. 最长公共子序列\n\nc++\ninclude<bits/stdc++.h \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int PII;\nconst int N = 1e5 + 10, M = 1e5 + 10;\n\nchar n1N, n2N;\n// nij记录前i个n1和前j个n2的公共子串的最大长度\nint n10101010;\n \nint main{\n\t\n\tint a, b;\n\tcin  a  b  n1 + 1  n2 + 1;\n\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tifn1i == n2j{\n\t\t\t\tnij = ni1j1 + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnij = maxni1j, nij1;\n\t\t\t}\n\t\t}\n\t}\n\t\tforint i = 1; i <= a; i++{\n\t\tforint j = 1; j <= b; j++{\n\t\t\tcout << nij << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << nab << endl;\n\t\n\treturn 0;\n}\n"}]