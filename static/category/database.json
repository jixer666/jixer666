[{"filename":"mysql","category":"database","md":{"topSummary":"\r\ntitle: MySQL知识点总结\r\ncategory: MySQL,数据库\r\ndate: 2024-05-23\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n近日看了小林 code 的关于 MySQL 的八股文，易忘，于是在此提取重点记下\r\n\r\n参考文章：[小林code-MySQL篇](https://xiaolincoding.com/mysql/index/index_interview.html)，[JavaGuide-MySQL篇](https://javaguide.cn/database/mysql/mysql-questions-01.html)以及部分知识库\r\n\r\n## 索引\r\n\r\n若把数据库库的表比作一本书，那么索引就是书的目录，通过索引我们可以快速定位想要寻找的位置\r\n\r\n### 索引分类\r\n\r\nMySQL的默认采用存储结构是 InnoDB ，使用最多的索引类型是 B+ 树\r\n\r\n这里我们将不同的索引类型进行分开讨论：\r\n\r\n- 按照数据结构进行划分：B+ 树索引、\tHash 索引、Full-Text 索引\r\n- 按照物理存储进行划分：主键索引、二级索引\r\n- 按照字段特性进行划分：主键索引、唯一索引、普通索引、前缀索引\r\n- 按照字段个数进行划分：单列索引、联合索引\r\n\r\n> 补充 => 按存储方式划分：\r\n>\r\n> - 聚簇索引：非叶子结点只存储 key，叶子结点存储 key 和实际存储\r\n> - 非聚簇索引：非叶子结点只存储 key，叶子结点存储聚簇索引\r\n\r\n### MySQL选取索引探讨\r\n\r\nMySQL所选用的索引第一个目的肯定是查询越快越好，这里我们就到了二分查找，但是二分查找的数组的插入性能低下，就需要用到二分查找树，二分查找树有个弊端：当插入的数据是递增的时候（特殊的数据例子），这时候的查找效率就变成了 O(n)，所以我们需要在插入的时候限制不能让他一直插入到一端结点，这时候就想到了平衡二叉树，平衡二叉树保证了每个节点的左子树和右子树的高度差不能超过 1，很符合当前二分查找树出现弊端的情况，但是新的问题又出现了，平衡二叉树只有两个子节点，当数据非常大的情况下，树的高度就会变得很高，就需要很多次查询，影响效率；于是 B 树就横空出世了，它解决了平衡二叉树结点只有两个导致树高的问题，它可以由很多个子结点，想到用 B 树，那么 B+ 树岂不是更好？，B+ 树的查询、插入和删除、范围查询效率更高，于是就采用了 B+ 树结构作为默认的索引\r\n\r\n### B+ 树索引执行过程\r\n\r\n若存在如下结构的 B+ 树\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/btree.drawio.png)\r\n\r\n当要查询 ID 为5的时候，首先会用二分查询在(1，10，20)之间进行查询，找到在(1，10)之间，接着在第二层进行查询(1，4，7)，找到是在(4，7)范围内，最后在叶子结点进行查找(4，5，6)，找到5，范围其数据即可\r\n\r\n上面是只有主键索引的情况，若出现既有主键索引，又有二级索引的情况，方式就会有变化：二级索引的叶子节点存放的(二级索引，主键索引)，而没有存在具体的数据，如果我们质询要查询主键值，就直接返回【这种在二级索引就能查询到的结果叫做**覆盖索引**】，若要查询其他的具体所以，我们需要通过二级索引查找得到主键值，再通过主键值【**回表**】查询数据，也就是需要查询两个 B+ 树才能查到数据\r\n\r\n### 最左匹配原则\r\n\r\n在使用联合索引的时候，存在最左匹配原则\r\n\r\n比如一个表的索引字段为（a，b，c），当我们查询以下条件的时候（查询的时候与 abc 顺序无关）\r\n\r\n```sql\r\nwhere a=1；\r\nwhere a=1 and b=2 and c=3；\r\nwhere a=1 and b=2；\r\n```\r\n\r\n就会匹配上联合索引，但是若是以下条件时候就不会，不满足最左匹配原则\r\n\r\n```sql\r\nwhere b=2；\r\nwhere c=3；\r\nwhere b=2 and c=3；\r\n```\r\n\r\n为什么呢？因为我们通过B+ 树索引执行过程可知，是先按照 a 进行排序的，当 a 想同，在按照 b 排序，当 b 相同，再按照 c 排序。\r\n\r\n所以 **b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。\t\r\n\r\n### 字段索引选用的情况\r\n\r\n事物都存在两面性，索引既然有好的一面，那么也有坏的一面，例如：\r\n\r\n1. 索引需要的占用物理空间\r\n2. 创建索引和维护索引需要耗费时间，所需时间随数据量增大而增加\r\n3. 降低增删改效率，因为每次增删改，都会动态维护 B+ 树的有序性\r\n\r\n**字段选用索引的情况：**\r\n\r\n1. 经常用 `where` 查询条件的字段\r\n2. 具有唯一性的字段\r\n3. 经常用 `group by` 和 `order by` 的字段【我们不需要再次排序，因为 B+ 树的记录是有序的】\r\n\r\n**字段不选用索引的情况：**\r\n\r\n1. 更新频繁的字段\r\n2. 表数据太少的时候\r\n3. `where`、`group by` 和 `order by` 的用不上的字段\r\n4. 字段中存在大量重复数据的时候\r\n\r\n### 索引失效\r\n\r\nMySQL中索引失效是一个常见的面试题，以下是索引失效的几种情况：\r\n\r\n1. 使用左或者左右模糊匹配的时候，如：`%x` 或 `%xx%` 【注意：`%x` 并不一定会导致索引失效，当表中的字段都是索引字段，没有遵循最左匹配原则也是走全扫描二级索引树】\r\n2. 条件查询中对索引使用函数、计算、类型转换\r\n3. 若是联合索引未遵守最左匹配原则\r\n4. 在 WHERE 子句中，OR 前的条件是索引列，而 OR 后的条件不是索引列\r\n5. 对联合索引进行排序的时候，asc 和 desc 混合使用或者排序的列不是来自同一个联合索引\r\n\r\n### 索引优化的方法\r\n\r\n1、**前缀索引优化**\r\n\r\n2、**覆盖索引优化**：\r\n\r\n添加冗余字段当作联合索引\r\n\r\n3、**主键索引最好自增**：\r\n\r\n若主键自增，每次插入的时候就不用移动数据，直接插到最后；若不是自增，插入位置是随机的，我们就不得不移动其他的数据，甚至是需要从一个页面移到另一个页面，这种现象就是**页分裂**【存在大量空间碎片，结构不紧凑影响查询效率】\r\n\r\n4、**索引最好设置为 NOT NULL**：\r\n\r\n- 为 null 的索引字段进行索引统计和值比较更为复杂，比如：进行索引统计，count 会省略值为 null 的行\r\n- null 会占用至少1字节的物理空间\r\n\r\n5、**防止索引失效**\r\n\r\n### 索引的代价\r\n\r\n**空间代价**\r\n\r\n每次建立一个索引，都会建立一个 B+ 树，一个 B+ 树节点就是一个 MySQL 数据页 16 KB\r\n\r\n**时间代价**\r\n\r\n1、当对数据进行增删改的时候，如果修改的列为索引列，那么也会要对这颗 B+ 树进行修改（设计也分裂，合并，回收）\r\n\r\n2、二级索引需要回表（若查询的数据列不属于索引范畴）\r\n\r\n3、查询的时候需要生成查询计划，以成本为指标，计算各个索引的成本，选取最低的成本索引进行查询\r\n\r\n### 索引查询相关概念\r\n\r\n例如 SQL 语句：`select * from test where id >= 10 and id <= 20`\r\n\r\n**扫描区间**\r\n\r\n需要扫描的记录，所在的区间，这里指的是：[133，982]\r\n\r\n**边界条件**\r\n\r\n形成扫描区间的搜索条件，这里指的是 `id >= 10 and id <= 20 `\r\n\r\n> 注意不是所有的搜索条件都能成为边界条件：\r\n> 如果查询语句变为 id >= 10 and id <= 20 and content = \"123\"，那么在 id 在 [10, 20] 的区间中，并不是按照 content 排序的，content 只作为普通的搜索条件，需要回表后才能判断【效率比全表扫描还低】\r\n\r\n### 执行计划\r\n\r\n一、**table**：无论查询多少张表，最终都会一步步变成单表\r\n\r\n二、**id**：每一个 select 关键字对应一个 id，无论查询多少张表，id 都是一样的。出现在前面的是驱动表，出现在后边的被驱动表\r\n\r\n三、**select_type**：一个大查询被分割成多个小查询，逐步完成\r\n\r\n- SIMPLE：不包含 union 和子查询的查询类型\r\n- PRIMARY：对包含 UNION、UNION ALL 或子查询的大查询来说，最左边的那个 SELECT 对应的 select_type 为 PRIMARY\r\n- UNION：对包含 UNION、UNION ALL 除了最左边的那个 SELECT 对应的小查询外，其余小查询的select_type为 UNION\r\n- UNION RESULT：MySQL 使用临时表来完成UNION的去重工作，这个临时表的 select_type 为  UNION RESULT ，id 为 NULL\r\n- SUBQUERY：如果包含子查询的 SQL 不能转为半连接形式，并且子查询不是相关子查询，且优化器决定采用物化子查询的方式来进行子查询时，这个子查询的第一个 SELECT 关键字对应的查询的  select_type 为 SUBQUERY\r\n- DEPENDENT SUBQUERY ：如果包含子查询的 SQL 不能转为半连接形式，并且子查询被优化器转换为相关子查询，这个子查询的第一个 SELECT 关键字对应的查询的 select_type 为 DEPENDENT  SUBQUERY\r\n\r\n四、**type**：每一条记录对应的表的访问方式\r\n\r\n有如下 SQL\r\n\r\n```sql\r\nCREATE TABLE test (\r\n  id INT NOT NULL AUTO_INCREMENT,\r\n  key1 VARCHAR ( 16 ),\r\n  key2 INT,\r\n  key3 VARCHAR ( 16 ),\r\n  part1 VARCHAR ( 16 ),\r\n  part2 VARCHAR ( 16 ),\r\n  part3 VARCHAR ( 16 ),\r\n  content VARCHAR ( 32 ),\r\n  PRIMARY KEY ( id ),\r\n  KEY idx_key1 ( key1 ),\r\n  UNIQUE uk_key2 ( key2 ),\r\n  KEY idx_key3 ( key3 ),\r\nKEY idx_key_part ( part1, part2, part3 ) \r\n) ENGINE = InnoDB CHARSET = utf8mb4;\r\n```\r\n\r\n效率排序：all < index < range < ref < ref_eq < const < system\r\n\r\n1、const : 通过主键或唯一二级索引定位一条数据，表示常数级别，代价忽略不计\r\n\r\n```sql\r\nEXPLAIN SELECT  * FROM test WHERE id = 1\r\n```\r\n\r\n2、ref：普通二级索引列与常数进行比较（或唯一二级索引列可以为NULL）\r\n只要左起连续的列都是等值匹配，就可以使用ref方式\r\n\r\n```sql\r\nSELECT * FROM test WHERE part1 = 'a'\r\n```\r\n\r\n3、ref_or_null : 通过二级索引进行等值匹配**以及列为NULL的值**\r\n\r\n```sql\r\nexplain SELECT  * FROM test WHERE key1 = '1' OR key1 IS NULL\r\n```\r\n\r\n4、range：使用索引进行查询，并且形成了多个单点扫描区间或范围扫描区间 （(-∞ ， +∞ )不算）\r\n\r\n```sql\r\nexplain SELECT * FROM test WHERE key2 >= 1 or key2 in (123, 312)\r\n```\r\n\r\n5、index：当可以使用索引覆盖，却需要扫描全部索引记录时候的访问方式\r\n\r\n```sql\r\nexplain SELECT part2 FROM test WHERE part3 = 'opq'\r\n```\r\n\r\n6、eq_ref：针对被驱动表，如果是以主键或不问NULL的唯一二级索引进行等值匹配的查询\r\n\r\n五、**possible_keys** ：可能用到的索引\r\n\r\n六、**key**：实际用到的索引\r\n\r\n七、**key_len**：简单的说，是用到的索引的列的长度\r\n\r\n八、**ref**：当访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 时，与索引等值匹配的是什么，一个常数或是一个列\r\n\r\n### 查询的成本\r\n\r\n1、根据搜索条件找出可能使用的索引\r\n\r\n2、计算出全表扫描的代价\r\n\r\n3、计算可能使用不同索引的执行查询的代价\r\n\r\n4、对比各种执行方案的代价，选用成本最低的那个方案\r\n\r\n成本计算 = I/O 成本 + CPU 成本\r\n\r\n- I/O 成本：数据页数  X 1.0 +1.1(微调值)\r\n- CPU 成本：数据记录数 X 0.2 +1.0(微调值)\r\n\r\n使用 SQL 命令：`show TABLE STATUS LIKE 'test'` 用来查看页数和记录数\r\n\r\n- 数据页数：`Data_length` / 16 / 1024\r\n- 数据记录数：`Rows`\r\n\r\n## 事务\r\n\r\nA 向 B 转账100元，首先 A 扣除了100元，但是当 B 接收100元的时候，服务器出现故障导致 B 没有收到转账，但是 A 已经扣除了100元，也就是100元就不见了。要想让操作全部执行成功或者全部执行失败，就需要用到**事务**\r\n\r\n### 事务特性\r\n\r\n事务有四个特性，如下：\r\n\r\n- **原子性**：要么全部成功，要么全部失败\r\n- **一致性**：A 给 B 100元，A 扣除了100元，不会出现B没有增加100元的情况\r\n- **隔离性**：多个事务使用相同的数据时，不会相互干扰\r\n- **持久性**：数据修改后是永久保存的，即使重启后也不会丢失\r\n\r\n### 并行事务引发的问题\r\n\r\n1、**脏读**：一个事务读取到另一个事务未提交的数据\r\n\r\n有一个数据为100，现在 A 将数据修改为200，这时候还未提交事务，这时候 B 获取数据200，拿到别处地方用，可是 A 出现某种状况导致回滚，A 的数据变回100\r\n\r\n2、**不可重复读**：在同一个事务中多次读取同一个数据，但这些读取中取得了不同的结果\r\n\r\n有一个数据为100，现在 A 读取了数据100，接着 B 将数据修改为200并提交了事务，当 A 再次读取的时候数据变成了200，与之前读取的数据不一致\r\n\r\n3、**幻读**：在同一事务中多次查询符合条件的记录数量，出现查询到的数量不一样\r\n\r\n有大于1的记录为100条，现在 B 对大于1的记录条数进行查询得到100，现在 A 插入了一条记录3并提交了事务，当 B 再次查询的时候发现条数为101条，前后两次查询到的记录数量不一样\r\n\r\n**严重性排序**：脏读 > 不可重复读 > 幻读\r\n\r\n### Read View\r\n\r\nRead View 结构如下：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/readview结构.drawio.png)\r\n\r\n### 事务隔离级别\r\n\r\nMySQL有四种事务隔离级别\r\n\r\n#### **读未提交**\r\n\r\n一个事务还未提交，它做的变更就能被其他事务看到\r\n\r\n可能造成：脏读、不可重复读、幻读\r\n\r\n实现：因为能读到未提交事务修改的数据，所以直接读取最新的数据就行\r\n\r\n#### **读提交**\r\n\r\n一个事务提交后才能被其他事务看到\r\n\r\n可能造成：不可重复读、幻读\r\n\r\n实现：**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**\r\n\r\n建议先看可重复读的实现部分，再来看此处的实现部分，进行对比\r\n\r\n比如：例子和可重复读一致\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100（创建了 Read View）\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100（创建了 Read View）\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 为 200（创建了 Read View）\r\n\r\n解释：\r\n\r\n1. 第一次读取事务 B 创建了 Read View\r\n\r\n```\r\ncreator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n事务的 min_trx_id 值51大于 trx_id 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n2. 事务 A 修改了 money 值，记录的字段创建了版本链\r\n\r\n```\r\nid:1, name: Jixer, money: 200, trx_id:51, roll_pointer:o--------->id:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o\r\n```\r\n\r\n3. 事务 B 再次读取，创建了Read View\r\n\r\n```\r\ncreator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n分析和可重复读那块一致\r\n\r\n4. 事务 A 提交了事务，事务 B 第三次读取的时候创建了 Read View\r\n\r\n```\r\nx creator_trx_id:52, mids:[52], min_trx_id: 52, max_trx_id: 53\r\n```\r\n\r\n发现此时的 min_trx_id 值52已经大于了 trx_id 值51，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n所以在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录并提交了事务\r\n\r\n#### **可重复读**\r\n\r\n**MySQL 默认的隔离级别**\r\n\r\n一个事务执行过程中看到的数据一直和事务启动前看到的数据是一致的\r\n\r\n可能造成：幻读【这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，解决方案见下个目录】\r\n\r\n实现：**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**\t\r\n\r\n比如：\r\n\r\n有一条字段如下，trx_id 和 roll_pointer 为**聚簇索引**（一般情况下就是主键索引，但是并不一定是主键索引）记录中的两个隐藏列\r\n\r\n```\r\nid:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o(undo日志)\r\n```\r\n\r\n现在有两个事务 A 和 B\r\n\r\n```\r\nA：creator_trx_id:51, mids:[51], min_trx_id: 51, max_trx_id: 52\r\nB：creator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 依然 100\r\n\r\n解释：\r\n\r\n1. 事务 B 读取的时候最小的 min_trx_id 值51大于 trx_id 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n2. 事务 A 修改了记录，此时 MySQL 会记录相应的 undo log，以链表的形式串联起来，形成**版本链**，如下所示\r\n\r\n```\r\nid:1, name: Jixer, money: 200, trx_id:51, roll_pointer:o--------->id:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o\r\n```\r\n\r\n3. 事务 B 再次读取的时候，此时的 trx_id值51在 Read View 的 min_trx_id 值51和 max_trx_id 值53之间，所以需判断 trx_id 是否在 m_ids 范围内，判断结果是在的，说明这条记录是还未提交的，因此 B 不会读取此时的记录，而是沿着 undo log向下找第一条小于 Read View 的 min_trx_id 值的旧版本记录，所以事务 B 找到 trx_id 为 50的记录，此时读取到 money 为100\r\n4. 事务 A 提交事务后，由于 Read View 还是用到最开始创建的，所以和步骤3一样任然查询出 money 为100\r\n\r\n> 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 **MVCC（多版本并发控制）**\r\n\r\n#### **串行化**\r\n\r\n会对记录加上读写锁，当多个事务对这个条记录进行读写操作的时候，若发生读写冲突，后访问的事务必须等前一个事务执行完才能继续执行\r\n\r\n实现：加读写锁来避免并行访问\r\n\r\n**隔离水平高低：**串行化 > 可重复读 > 读已提交 > 读未提交\r\n\r\n### 可重复读并没有完全解决幻读\r\n\r\n这种隔离级别很大程度上避免了幻读现象，**但并不是完全解决了**，目前采用的解决方案有两种\r\n\r\n- 针对快照读（普通 select 语句）：通过 **MVCC** 解决了幻读，事务执行过程中即使中途插入了一条数据，但是还是查询不出来这条数据，看到的数据一直和事务启动时看到的数据是一致的，所以避免幻读问题\r\n- 针对当前读（select ... for update 等语句）：通过 **next-key lock（记录锁+间隙锁）**方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就避免幻读问题\r\n\r\n举例了两个发生幻读场景的例子。\r\n\r\n第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n### 开启事务命令\r\n\r\n开始事务有两种命令，事务时机不同，如下：\r\n\r\n- begin/start transaction 命令：执行这条语句后事务并不会立刻启动，而是需要当执行了第一条 select 语句后才是真正的启动时机\r\n- start transaction with consistent snapshot 命令：执行命令后会立刻启动事务\r\n\r\n## 锁\r\n\r\n### 全局锁\r\n\r\n使用全局锁的命令：\r\n\r\n```mysql\r\nflush tables with read lock\r\n```\r\n\r\n执行过后，整个数据库就处于**只读状态**，此时对数据库的任何增删改操作都会被阻塞\r\n\r\n释放全局锁命令如下，断开会话也会自动释放全局锁\r\n\r\n```mysq\r\nunlock tables\r\n```\r\n\r\n**适用场景：**全局锁适用于**全库逻辑备份**，在备份数据库期间不会因为数据或表结构的更新，而出现导致备份文件的数据与预期的不一样\r\n\r\n**缺点：**全库逻辑备份的时候，没法更新新的数据，会导致业务停滞【但是这种缺点可以避免，如果数据库支持**可重复读的隔离级别**，那么会先创建 Read View ，整个事务都在用这个 Read View，而且由于 MVCC 的支持，备份期间数据依然可以进行更新操作】\r\n\r\n### 表级锁\r\n\r\n#### 表锁\r\n\r\n使用命令：\r\n\r\n```mysql\r\n//表级别的共享锁，也就是读锁；\r\nlock tables t_student read;\r\n//表级别的独占锁，也就是写锁；\r\nlock tables t_stuent write;\r\n```\r\n\r\n要释放表锁命令如下，断开会话也会自动释放表锁\r\n\r\n```sql\r\nunlock tables\r\n```\r\n\r\n若一个线程对表加了表锁，那么这个线程是对该表进行写操作会被阻塞，其他的线程也是会被阻塞\r\n\r\n#### 元数据锁（MDL）\r\n\r\n我们不需要显示的使用元数据锁，当我们对表进行操作会自动的帮我们加上元数据锁\r\n\r\n- 当对表数据进行 CRUD 的时候，加的是**元数据读锁**\r\n- 当对表结构进行修改的时候，加的是**元数据写锁**\r\n\r\n当有线程 A 使用 select 语句，此时对表加了元数据读锁，若线程 B 也用 select 语句，此时并不会阻塞线程 B，因为都是读锁；若线程 B 对表结构进行修改，则由于线程 A 读锁还在占用，所以线程 B 会进行阻塞，之后大量的线程若都是 select 语句，那么就都会被阻塞，数据库的线程很快就会爆满了\r\n\r\n这是因为申请元数据锁都会被放在一个队列中，队列中**写锁优先级大于读锁**，所以若写锁阻塞了，后面的读锁都会被阻塞。所以在数据库表结构更改前都要先看看那些长事务是否已经加了元数据读锁，可以考虑 kill 掉这个长事务，在对表结构进行修改\r\n\r\n#### 意向锁\r\n\r\n意向锁的目的：**是为了快速判断表里是否有记录被加锁**\r\n\r\n- 在加共享锁之前，会先加上意向共享锁\r\n- 在加独占锁之前，会先加上意向独占锁\r\n\r\n表锁和行锁是满足读读共享、读写互斥、写写互斥的\r\n\r\n#### AUTO-INC 锁\r\n\r\n当主键的值设置为自增的情况时，我们可以不用专门传入主键值进行保存，这主要是由于 **AUTO-INC 锁**实现的\r\n\r\nAUTO-INC 锁**不是在提交事务后释放，而是在在执行完插入语句后就释放**\r\n\r\n> 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增\r\n> 在插入的时候会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，接着就把所释放了，而不是在执行完插入语句后释放\r\n\r\n### 行级锁\r\n\r\n#### 记录锁（Record Lock）\r\n\r\n锁住的是一条记录，有两种不同的记录锁：S 锁和 X 锁\r\n\r\n- 记录加了 S 锁后任能加 S 锁，但不能加 X 锁\r\n- 记录加了 X 锁后不能加 S 锁，也不能加 X 锁\r\n\r\n执行语句如下：\r\n\r\n```mysql\r\nselect * from t_test where id = 1 for update;\r\n```\r\n\r\n#### 间隙锁（Gap Lock）\r\n\r\n锁的是一个范围，只存在于可重复读隔离级别，目的是**为了解决可重复读隔离级别下幻读的现象**\r\n\r\n例如：表中有一个 范围id 为（3, 5）间隙锁，那么 id 为4就不能插入\r\n\r\n#### 临键锁（Next-key Lock）\r\n\r\n临键锁 = Record Lock + Gap Lock\r\n\r\n锁定一个范围，并且锁定记录本身\r\n\r\n例如：表中有一个 范围id 为（3, 5] 间隙锁，那么 id 为4就不能插入并且 id  为5的记录也不能修改\r\n\r\n#### 插入意向锁\r\n\r\n一个事务在插入数据的时候需要判断该记录是否已经加了间隙锁，若加了间隙锁就会阻塞，直到释放间隙锁为止，在此期间会生成一个**插入意向锁**\r\n\r\n插入意向锁不是意向锁，是一种特殊的间隙锁，属于行级锁\r\n\r\n如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点\r\n\r\n一条记录在同一区间内不能既有插入意向锁，又有间隙锁\r\n\r\n## 日志\r\n\r\n\r\n\r\n## 执行一条 select 语句期间发生了什么\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/mysql查询流程.png)\r\n\r\n1. 连接器：客户端与连接器进行连接，校验用户身份\r\n2. 查询缓存：若是查询语句就需要查询缓存，命中就返回，否则就继续向下执行\r\n3. 解析 SQL：对 SQL 语句继续词法分析和语法分析，构建语法树\r\n4. 处理 SQL：\r\n   - 预处理阶段：检查表或字段是否存在，将 `select *` 中的 `*` 符号扩展为表上的所有列\r\n   - 优化阶段：选择查询成本最小的执行计划\r\n   - 执行阶段：根据执行计划执行 SQL 语句，从存储引擎读取记录，返回给客户端\r\n\r\n## 存储引擎\r\n\r\nMySQL 5.5.5 之前的版本，**MyISAM** 是 MySQL 的默认存储引擎，在5.5.5之后用 **InnoDB** 作为默认存储引擎\r\n\r\n### 存储引擎架构\r\n\r\nMySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎。我们可以为不同的数据库设置不同的存储引擎，存储引擎是**基于表的，而不是数据库**\r\n\r\n### MyISAM与InnoDB对比\r\n\r\n1、InnoDB 支持行级锁，而 MyISAM 只支持表级锁\r\n\r\n2、InnoDB 提供事务，而 MyISAM 不提供事务\r\n\r\n3、InnoDB 支持外键，而 MyISAM 不支持外键\r\n\r\n4、InnoDB 支持数据库崩溃后安全恢复（依赖于 `redo log` ），而 MyISAM 不支持\r\n\r\n5、都是采用 B+ 树索引，但是索引实现不一样\r\n\r\n6、InnoDB 性能比 MyISAM 好\r\n","title":" MySQL知识点总结\r\n","category":[" MySQL","数据库\r\n"],"date":" 2024-05-23\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n近日看了小林 code 的关于 MySQL 的八股文，易忘，于是在此提取重点记下\r\n\r\n参考文章：小林codeMySQL篇https://xiaolincoding.com/mysql/index/indexinterview.html，JavaGuideMySQL篇https://javaguide.cn/database/mysql/mysqlquestions01.html以及部分知识库\r\n\r\n 索引\r\n\r\n若把数据库库的表比作一本书，那么索引就是书的目录，通过索引我们可以快速定位想要寻找的位置\r\n\r\n 索引分类\r\n\r\nMySQL的默认采用存储结构是 InnoDB ，使用最多的索引类型是 B+ 树\r\n\r\n这里我们将不同的索引类型进行分开讨论：\r\n\r\n 按照数据结构进行划分：B+ 树索引、\tHash 索引、FullText 索引\r\n 按照物理存储进行划分：主键索引、二级索引\r\n 按照字段特性进行划分：主键索引、唯一索引、普通索引、前缀索引\r\n 按照字段个数进行划分：单列索引、联合索引\r\n\r\n 补充 = 按存储方式划分：\r\n\r\n  聚簇索引：非叶子结点只存储 key，叶子结点存储 key 和实际存储\r\n  非聚簇索引：非叶子结点只存储 key，叶子结点存储聚簇索引\r\n\r\n MySQL选取索引探讨\r\n\r\nMySQL所选用的索引第一个目的肯定是查询越快越好，这里我们就到了二分查找，但是二分查找的数组的插入性能低下，就需要用到二分查找树，二分查找树有个弊端：当插入的数据是递增的时候（特殊的数据例子），这时候的查找效率就变成了 On，所以我们需要在插入的时候限制不能让他一直插入到一端结点，这时候就想到了平衡二叉树，平衡二叉树保证了每个节点的左子树和右子树的高度差不能超过 1，很符合当前二分查找树出现弊端的情况，但是新的问题又出现了，平衡二叉树只有两个子节点，当数据非常大的情况下，树的高度就会变得很高，就需要很多次查询，影响效率；于是 B 树就横空出世了，它解决了平衡二叉树结点只有两个导致树高的问题，它可以由很多个子结点，想到用 B 树，那么 B+ 树岂不是更好？，B+ 树的查询、插入和删除、范围查询效率更高，于是就采用了 B+ 树结构作为默认的索引\r\n\r\n B+ 树索引执行过程\r\n\r\n若存在如下结构的 B+ 树\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/mysql/btree.drawio.png\r\n\r\n当要查询 ID 为5的时候，首先会用二分查询在1，10，20之间进行查询，找到在1，10之间，接着在第二层进行查询1，4，7，找到是在4，7范围内，最后在叶子结点进行查找4，5，6，找到5，范围其数据即可\r\n\r\n上面是只有主键索引的情况，若出现既有主键索引，又有二级索引的情况，方式就会有变化：二级索引的叶子节点存放的二级索引，主键索引，而没有存在具体的数据，如果我们质询要查询主键值，就直接返回【这种在二级索引就能查询到的结果叫做覆盖索引】，若要查询其他的具体所以，我们需要通过二级索引查找得到主键值，再通过主键值【回表】查询数据，也就是需要查询两个 B+ 树才能查到数据\r\n\r\n 最左匹配原则\r\n\r\n在使用联合索引的时候，存在最左匹配原则\r\n\r\n比如一个表的索引字段为（a，b，c），当我们查询以下条件的时候（查询的时候与 abc 顺序无关）\r\n\r\nsql\r\nwhere a=1；\r\nwhere a=1 and b=2 and c=3；\r\nwhere a=1 and b=2；\r\n\r\n\r\n就会匹配上联合索引，但是若是以下条件时候就不会，不满足最左匹配原则\r\n\r\nsql\r\nwhere b=2；\r\nwhere c=3；\r\nwhere b=2 and c=3；\r\n\r\n\r\n为什么呢？因为我们通过B+ 树索引执行过程可知，是先按照 a 进行排序的，当 a 想同，在按照 b 排序，当 b 相同，再按照 c 排序。\r\n\r\n所以 b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。\t\r\n\r\n 字段索引选用的情况\r\n\r\n事物都存在两面性，索引既然有好的一面，那么也有坏的一面，例如：\r\n\r\n1. 索引需要的占用物理空间\r\n2. 创建索引和维护索引需要耗费时间，所需时间随数据量增大而增加\r\n3. 降低增删改效率，因为每次增删改，都会动态维护 B+ 树的有序性\r\n\r\n字段选用索引的情况：\r\n\r\n1. 经常用 where 查询条件的字段\r\n2. 具有唯一性的字段\r\n3. 经常用 group by 和 order by 的字段【我们不需要再次排序，因为 B+ 树的记录是有序的】\r\n\r\n字段不选用索引的情况：\r\n\r\n1. 更新频繁的字段\r\n2. 表数据太少的时候\r\n3. where、group by 和 order by 的用不上的字段\r\n4. 字段中存在大量重复数据的时候\r\n\r\n 索引失效\r\n\r\nMySQL中索引失效是一个常见的面试题，以下是索引失效的几种情况：\r\n\r\n1. 使用左或者左右模糊匹配的时候，如：%x 或 %xx% 【注意：%x 并不一定会导致索引失效，当表中的字段都是索引字段，没有遵循最左匹配原则也是走全扫描二级索引树】\r\n2. 条件查询中对索引使用函数、计算、类型转换\r\n3. 若是联合索引未遵守最左匹配原则\r\n4. 在 WHERE 子句中，OR 前的条件是索引列，而 OR 后的条件不是索引列\r\n5. 对联合索引进行排序的时候，asc 和 desc 混合使用或者排序的列不是来自同一个联合索引\r\n\r\n 索引优化的方法\r\n\r\n1、前缀索引优化\r\n\r\n2、覆盖索引优化：\r\n\r\n添加冗余字段当作联合索引\r\n\r\n3、主键索引最好自增：\r\n\r\n若主键自增，每次插入的时候就不用移动数据，直接插到最后；若不是自增，插入位置是随机的，我们就不得不移动其他的数据，甚至是需要从一个页面移到另一个页面，这种现象就是页分裂【存在大量空间碎片，结构不紧凑影响查询效率】\r\n\r\n4、索引最好设置为 NOT NULL：\r\n\r\n 为 null 的索引字段进行索引统计和值比较更为复杂，比如：进行索引统计，count 会省略值为 null 的行\r\n null 会占用至少1字节的物理空间\r\n\r\n5、防止索引失效\r\n\r\n 索引的代价\r\n\r\n空间代价\r\n\r\n每次建立一个索引，都会建立一个 B+ 树，一个 B+ 树节点就是一个 MySQL 数据页 16 KB\r\n\r\n时间代价\r\n\r\n1、当对数据进行增删改的时候，如果修改的列为索引列，那么也会要对这颗 B+ 树进行修改（设计也分裂，合并，回收）\r\n\r\n2、二级索引需要回表（若查询的数据列不属于索引范畴）\r\n\r\n3、查询的时候需要生成查询计划，以成本为指标，计算各个索引的成本，选取最低的成本索引进行查询\r\n\r\n 索引查询相关概念\r\n\r\n例如 SQL 语句：select  from test where id = 10 and id <= 20\r\n\r\n扫描区间\r\n\r\n需要扫描的记录，所在的区间，这里指的是：133，982\r\n\r\n边界条件\r\n\r\n形成扫描区间的搜索条件，这里指的是 id = 10 and id <= 20 \r\n\r\n 注意不是所有的搜索条件都能成为边界条件：\r\n 如果查询语句变为 id = 10 and id <= 20 and content = \"123\"，那么在 id 在 10, 20 的区间中，并不是按照 content 排序的，content 只作为普通的搜索条件，需要回表后才能判断【效率比全表扫描还低】\r\n\r\n 执行计划\r\n\r\n一、table：无论查询多少张表，最终都会一步步变成单表\r\n\r\n二、id：每一个 select 关键字对应一个 id，无论查询多少张表，id 都是一样的。出现在前面的是驱动表，出现在后边的被驱动表\r\n\r\n三、selecttype：一个大查询被分割成多个小查询，逐步完成\r\n\r\n SIMPLE：不包含 union 和子查询的查询类型\r\n PRIMARY：对包含 UNION、UNION ALL 或子查询的大查询来说，最左边的那个 SELECT 对应的 selecttype 为 PRIMARY\r\n UNION：对包含 UNION、UNION ALL 除了最左边的那个 SELECT 对应的小查询外，其余小查询的selecttype为 UNION\r\n UNION RESULT：MySQL 使用临时表来完成UNION的去重工作，这个临时表的 selecttype 为  UNION RESULT ，id 为 NULL\r\n SUBQUERY：如果包含子查询的 SQL 不能转为半连接形式，并且子查询不是相关子查询，且优化器决定采用物化子查询的方式来进行子查询时，这个子查询的第一个 SELECT 关键字对应的查询的  selecttype 为 SUBQUERY\r\n DEPENDENT SUBQUERY ：如果包含子查询的 SQL 不能转为半连接形式，并且子查询被优化器转换为相关子查询，这个子查询的第一个 SELECT 关键字对应的查询的 selecttype 为 DEPENDENT  SUBQUERY\r\n\r\n四、type：每一条记录对应的表的访问方式\r\n\r\n有如下 SQL\r\n\r\nsql\r\nCREATE TABLE test \r\n  id INT NOT NULL AUTOINCREMENT,\r\n  key1 VARCHAR  16 ,\r\n  key2 INT,\r\n  key3 VARCHAR  16 ,\r\n  part1 VARCHAR  16 ,\r\n  part2 VARCHAR  16 ,\r\n  part3 VARCHAR  16 ,\r\n  content VARCHAR  32 ,\r\n  PRIMARY KEY  id ,\r\n  KEY idxkey1  key1 ,\r\n  UNIQUE ukkey2  key2 ,\r\n  KEY idxkey3  key3 ,\r\nKEY idxkeypart  part1, part2, part3  \r\n ENGINE = InnoDB CHARSET = utf8mb4;\r\n\r\n\r\n效率排序：all < index < range < ref < refeq < const < system\r\n\r\n1、const : 通过主键或唯一二级索引定位一条数据，表示常数级别，代价忽略不计\r\n\r\nsql\r\nEXPLAIN SELECT   FROM test WHERE id = 1\r\n\r\n\r\n2、ref：普通二级索引列与常数进行比较（或唯一二级索引列可以为NULL）\r\n只要左起连续的列都是等值匹配，就可以使用ref方式\r\n\r\nsql\r\nSELECT  FROM test WHERE part1 = 'a'\r\n\r\n\r\n3、refornull : 通过二级索引进行等值匹配以及列为NULL的值\r\n\r\nsql\r\nexplain SELECT   FROM test WHERE key1 = '1' OR key1 IS NULL\r\n\r\n\r\n4、range：使用索引进行查询，并且形成了多个单点扫描区间或范围扫描区间 （∞ ， +∞ 不算）\r\n\r\nsql\r\nexplain SELECT  FROM test WHERE key2 = 1 or key2 in 123, 312\r\n\r\n\r\n5、index：当可以使用索引覆盖，却需要扫描全部索引记录时候的访问方式\r\n\r\nsql\r\nexplain SELECT part2 FROM test WHERE part3 = 'opq'\r\n\r\n\r\n6、eqref：针对被驱动表，如果是以主键或不问NULL的唯一二级索引进行等值匹配的查询\r\n\r\n五、possiblekeys ：可能用到的索引\r\n\r\n六、key：实际用到的索引\r\n\r\n七、keylen：简单的说，是用到的索引的列的长度\r\n\r\n八、ref：当访问方法是 const、eqref、ref、refornull、uniquesubquery、indexsubquery 时，与索引等值匹配的是什么，一个常数或是一个列\r\n\r\n 查询的成本\r\n\r\n1、根据搜索条件找出可能使用的索引\r\n\r\n2、计算出全表扫描的代价\r\n\r\n3、计算可能使用不同索引的执行查询的代价\r\n\r\n4、对比各种执行方案的代价，选用成本最低的那个方案\r\n\r\n成本计算 = I/O 成本 + CPU 成本\r\n\r\n I/O 成本：数据页数  X 1.0 +1.1微调值\r\n CPU 成本：数据记录数 X 0.2 +1.0微调值\r\n\r\n使用 SQL 命令：show TABLE STATUS LIKE 'test' 用来查看页数和记录数\r\n\r\n 数据页数：Datalength / 16 / 1024\r\n 数据记录数：Rows\r\n\r\n 事务\r\n\r\nA 向 B 转账100元，首先 A 扣除了100元，但是当 B 接收100元的时候，服务器出现故障导致 B 没有收到转账，但是 A 已经扣除了100元，也就是100元就不见了。要想让操作全部执行成功或者全部执行失败，就需要用到事务\r\n\r\n 事务特性\r\n\r\n事务有四个特性，如下：\r\n\r\n 原子性：要么全部成功，要么全部失败\r\n 一致性：A 给 B 100元，A 扣除了100元，不会出现B没有增加100元的情况\r\n 隔离性：多个事务使用相同的数据时，不会相互干扰\r\n 持久性：数据修改后是永久保存的，即使重启后也不会丢失\r\n\r\n 并行事务引发的问题\r\n\r\n1、脏读：一个事务读取到另一个事务未提交的数据\r\n\r\n有一个数据为100，现在 A 将数据修改为200，这时候还未提交事务，这时候 B 获取数据200，拿到别处地方用，可是 A 出现某种状况导致回滚，A 的数据变回100\r\n\r\n2、不可重复读：在同一个事务中多次读取同一个数据，但这些读取中取得了不同的结果\r\n\r\n有一个数据为100，现在 A 读取了数据100，接着 B 将数据修改为200并提交了事务，当 A 再次读取的时候数据变成了200，与之前读取的数据不一致\r\n\r\n3、幻读：在同一事务中多次查询符合条件的记录数量，出现查询到的数量不一样\r\n\r\n有大于1的记录为100条，现在 B 对大于1的记录条数进行查询得到100，现在 A 插入了一条记录3并提交了事务，当 B 再次查询的时候发现条数为101条，前后两次查询到的记录数量不一样\r\n\r\n严重性排序：脏读  不可重复读  幻读\r\n\r\n Read View\r\n\r\nRead View 结构如下：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/mysql/readview结构.drawio.png\r\n\r\n 事务隔离级别\r\n\r\nMySQL有四种事务隔离级别\r\n\r\n 读未提交\r\n\r\n一个事务还未提交，它做的变更就能被其他事务看到\r\n\r\n可能造成：脏读、不可重复读、幻读\r\n\r\n实现：因为能读到未提交事务修改的数据，所以直接读取最新的数据就行\r\n\r\n 读提交\r\n\r\n一个事务提交后才能被其他事务看到\r\n\r\n可能造成：不可重复读、幻读\r\n\r\n实现：读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View\r\n\r\n建议先看可重复读的实现部分，再来看此处的实现部分，进行对比\r\n\r\n比如：例子和可重复读一致\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100（创建了 Read View）\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100（创建了 Read View）\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 为 200（创建了 Read View）\r\n\r\n解释：\r\n\r\n1. 第一次读取事务 B 创建了 Read View\r\n\r\n\r\ncreatortrxid:52, mids:51,52, mintrxid: 51, maxtrxid: 53\r\n\r\n\r\n事务的 mintrxid 值51大于 trxid 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n2. 事务 A 修改了 money 值，记录的字段创建了版本链\r\n\r\n\r\nid:1, name: Jixer, money: 200, trxid:51, rollpointer:oid:1, name: Jixer, money: 100, trxid:50, rollpointer:o\r\n\r\n\r\n3. 事务 B 再次读取，创建了Read View\r\n\r\n\r\ncreatortrxid:52, mids:51,52, mintrxid: 51, maxtrxid: 53\r\n\r\n\r\n分析和可重复读那块一致\r\n\r\n4. 事务 A 提交了事务，事务 B 第三次读取的时候创建了 Read View\r\n\r\n\r\nx creatortrxid:52, mids:52, mintrxid: 52, maxtrxid: 53\r\n\r\n\r\n发现此时的 mintrxid 值52已经大于了 trxid 值51，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n所以在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录并提交了事务\r\n\r\n 可重复读\r\n\r\nMySQL 默认的隔离级别\r\n\r\n一个事务执行过程中看到的数据一直和事务启动前看到的数据是一致的\r\n\r\n可能造成：幻读【这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，解决方案见下个目录】\r\n\r\n实现：可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View\t\r\n\r\n比如：\r\n\r\n有一条字段如下，trxid 和 rollpointer 为聚簇索引（一般情况下就是主键索引，但是并不一定是主键索引）记录中的两个隐藏列\r\n\r\n\r\nid:1, name: Jixer, money: 100, trxid:50, rollpointer:oundo日志\r\n\r\n\r\n现在有两个事务 A 和 B\r\n\r\n\r\nA：creatortrxid:51, mids:51, mintrxid: 51, maxtrxid: 52\r\nB：creatortrxid:52, mids:51,52, mintrxid: 51, maxtrxid: 53\r\n\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 依然 100\r\n\r\n解释：\r\n\r\n1. 事务 B 读取的时候最小的 mintrxid 值51大于 trxid 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n2. 事务 A 修改了记录，此时 MySQL 会记录相应的 undo log，以链表的形式串联起来，形成版本链，如下所示\r\n\r\n\r\nid:1, name: Jixer, money: 200, trxid:51, rollpointer:oid:1, name: Jixer, money: 100, trxid:50, rollpointer:o\r\n\r\n\r\n3. 事务 B 再次读取的时候，此时的 trxid值51在 Read View 的 mintrxid 值51和 maxtrxid 值53之间，所以需判断 trxid 是否在 mids 范围内，判断结果是在的，说明这条记录是还未提交的，因此 B 不会读取此时的记录，而是沿着 undo log向下找第一条小于 Read View 的 mintrxid 值的旧版本记录，所以事务 B 找到 trxid 为 50的记录，此时读取到 money 为100\r\n4. 事务 A 提交事务后，由于 Read View 还是用到最开始创建的，所以和步骤3一样任然查询出 money 为100\r\n\r\n 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）\r\n\r\n 串行化\r\n\r\n会对记录加上读写锁，当多个事务对这个条记录进行读写操作的时候，若发生读写冲突，后访问的事务必须等前一个事务执行完才能继续执行\r\n\r\n实现：加读写锁来避免并行访问\r\n\r\n隔离水平高低：串行化  可重复读  读已提交  读未提交\r\n\r\n 可重复读并没有完全解决幻读\r\n\r\n这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，目前采用的解决方案有两种\r\n\r\n 针对快照读（普通 select 语句）：通过 MVCC 解决了幻读，事务执行过程中即使中途插入了一条数据，但是还是查询不出来这条数据，看到的数据一直和事务启动时看到的数据是一致的，所以避免幻读问题\r\n 针对当前读（select ... for update 等语句）：通过 nextkey lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 nextkey lock，如果有其他事务在 nextkey lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就避免幻读问题\r\n\r\n举例了两个发生幻读场景的例子。\r\n\r\n第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n 开启事务命令\r\n\r\n开始事务有两种命令，事务时机不同，如下：\r\n\r\n begin/start transaction 命令：执行这条语句后事务并不会立刻启动，而是需要当执行了第一条 select 语句后才是真正的启动时机\r\n start transaction with consistent snapshot 命令：执行命令后会立刻启动事务\r\n\r\n 锁\r\n\r\n 全局锁\r\n\r\n使用全局锁的命令：\r\n\r\nmysql\r\nflush tables with read lock\r\n\r\n\r\n执行过后，整个数据库就处于只读状态，此时对数据库的任何增删改操作都会被阻塞\r\n\r\n释放全局锁命令如下，断开会话也会自动释放全局锁\r\n\r\nmysq\r\nunlock tables\r\n\r\n\r\n适用场景：全局锁适用于全库逻辑备份，在备份数据库期间不会因为数据或表结构的更新，而出现导致备份文件的数据与预期的不一样\r\n\r\n缺点：全库逻辑备份的时候，没法更新新的数据，会导致业务停滞【但是这种缺点可以避免，如果数据库支持可重复读的隔离级别，那么会先创建 Read View ，整个事务都在用这个 Read View，而且由于 MVCC 的支持，备份期间数据依然可以进行更新操作】\r\n\r\n 表级锁\r\n\r\n 表锁\r\n\r\n使用命令：\r\n\r\nmysql\r\n//表级别的共享锁，也就是读锁；\r\nlock tables tstudent read;\r\n//表级别的独占锁，也就是写锁；\r\nlock tables tstuent write;\r\n\r\n\r\n要释放表锁命令如下，断开会话也会自动释放表锁\r\n\r\nsql\r\nunlock tables\r\n\r\n\r\n若一个线程对表加了表锁，那么这个线程是对该表进行写操作会被阻塞，其他的线程也是会被阻塞\r\n\r\n 元数据锁（MDL）\r\n\r\n我们不需要显示的使用元数据锁，当我们对表进行操作会自动的帮我们加上元数据锁\r\n\r\n 当对表数据进行 CRUD 的时候，加的是元数据读锁\r\n 当对表结构进行修改的时候，加的是元数据写锁\r\n\r\n当有线程 A 使用 select 语句，此时对表加了元数据读锁，若线程 B 也用 select 语句，此时并不会阻塞线程 B，因为都是读锁；若线程 B 对表结构进行修改，则由于线程 A 读锁还在占用，所以线程 B 会进行阻塞，之后大量的线程若都是 select 语句，那么就都会被阻塞，数据库的线程很快就会爆满了\r\n\r\n这是因为申请元数据锁都会被放在一个队列中，队列中写锁优先级大于读锁，所以若写锁阻塞了，后面的读锁都会被阻塞。所以在数据库表结构更改前都要先看看那些长事务是否已经加了元数据读锁，可以考虑 kill 掉这个长事务，在对表结构进行修改\r\n\r\n 意向锁\r\n\r\n意向锁的目的：是为了快速判断表里是否有记录被加锁\r\n\r\n 在加共享锁之前，会先加上意向共享锁\r\n 在加独占锁之前，会先加上意向独占锁\r\n\r\n表锁和行锁是满足读读共享、读写互斥、写写互斥的\r\n\r\n AUTOINC 锁\r\n\r\n当主键的值设置为自增的情况时，我们可以不用专门传入主键值进行保存，这主要是由于 AUTOINC 锁实现的\r\n\r\nAUTOINC 锁不是在提交事务后释放，而是在在执行完插入语句后就释放\r\n\r\n 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增\r\n 在插入的时候会为被 AUTOINCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，接着就把所释放了，而不是在执行完插入语句后释放\r\n\r\n 行级锁\r\n\r\n 记录锁（Record Lock）\r\n\r\n锁住的是一条记录，有两种不同的记录锁：S 锁和 X 锁\r\n\r\n 记录加了 S 锁后任能加 S 锁，但不能加 X 锁\r\n 记录加了 X 锁后不能加 S 锁，也不能加 X 锁\r\n\r\n执行语句如下：\r\n\r\nmysql\r\nselect  from ttest where id = 1 for update;\r\n\r\n\r\n 间隙锁（Gap Lock）\r\n\r\n锁的是一个范围，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象\r\n\r\n例如：表中有一个 范围id 为（3, 5）间隙锁，那么 id 为4就不能插入\r\n\r\n 临键锁（Nextkey Lock）\r\n\r\n临键锁 = Record Lock + Gap Lock\r\n\r\n锁定一个范围，并且锁定记录本身\r\n\r\n例如：表中有一个 范围id 为（3, 5 间隙锁，那么 id 为4就不能插入并且 id  为5的记录也不能修改\r\n\r\n 插入意向锁\r\n\r\n一个事务在插入数据的时候需要判断该记录是否已经加了间隙锁，若加了间隙锁就会阻塞，直到释放间隙锁为止，在此期间会生成一个插入意向锁\r\n\r\n插入意向锁不是意向锁，是一种特殊的间隙锁，属于行级锁\r\n\r\n如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点\r\n\r\n一条记录在同一区间内不能既有插入意向锁，又有间隙锁\r\n\r\n 日志\r\n\r\n\r\n\r\n 执行一条 select 语句期间发生了什么\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/mysql/mysql查询流程.png\r\n\r\n1. 连接器：客户端与连接器进行连接，校验用户身份\r\n2. 查询缓存：若是查询语句就需要查询缓存，命中就返回，否则就继续向下执行\r\n3. 解析 SQL：对 SQL 语句继续词法分析和语法分析，构建语法树\r\n4. 处理 SQL：\r\n    预处理阶段：检查表或字段是否存在，将 select  中的  符号扩展为表上的所有列\r\n    优化阶段：选择查询成本最小的执行计划\r\n    执行阶段：根据执行计划执行 SQL 语句，从存储引擎读取记录，返回给客户端\r\n\r\n 存储引擎\r\n\r\nMySQL 5.5.5 之前的版本，MyISAM 是 MySQL 的默认存储引擎，在5.5.5之后用 InnoDB 作为默认存储引擎\r\n\r\n 存储引擎架构\r\n\r\nMySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎。我们可以为不同的数据库设置不同的存储引擎，存储引擎是基于表的，而不是数据库\r\n\r\n MyISAM与InnoDB对比\r\n\r\n1、InnoDB 支持行级锁，而 MyISAM 只支持表级锁\r\n\r\n2、InnoDB 提供事务，而 MyISAM 不提供事务\r\n\r\n3、InnoDB 支持外键，而 MyISAM 不支持外键\r\n\r\n4、InnoDB 支持数据库崩溃后安全恢复（依赖于 redo log ），而 MyISAM 不支持\r\n\r\n5、都是采用 B+ 树索引，但是索引实现不一样\r\n\r\n6、InnoDB 性能比 MyISAM 好\r\n"},{"filename":"redis","category":"database","md":{"topSummary":"\r\ntitle: Redis知识点总结\r\ncategory: Redis,数据库\r\ndate: 2024-03-23\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n对 Redis 面试知识点进行总结，参考文章：[JavaGuide-Redis篇](https://javaguide.cn/database/redis/redis-questions-01.html)\r\n\r\n## Redis基础\r\n\r\nRedis 是一个基于内存的数据库，速写速度快，采用 KV 键值对的形式对数据进行存储。此外 Redis 还支持多种优化后的数据结构、内置了 Lua 脚本、消息队列、延时队列等强大功能\r\n\r\n### Redis 为什么访问怎么快\r\n\r\n- Redis 基于内存，内存比磁盘的访问速度快\r\n- Redis 内置多种优化后的数据结构\r\n- Redis 是单线路事件循环和 IO 多路复用\r\n- Redis 通信协议实现简单且解析高效\r\n\r\n### 分布式缓存技术选型有哪些\r\n\r\n1、Redis，生态丰富，资料齐全\r\n\r\n2、Memcached ，一开始兴起比较常用\r\n\r\n3、腾讯的 Tendis，没维护了，使用的少\r\n\r\n### Reids和Memcached的异同\r\n\r\n共同点：\r\n\r\n- 都是基于内存数据库，当作缓存使用\r\n- 都有过期策略\r\n- 性能都很高\r\n\r\n不同点：\r\n\r\n- Reids 含有多种数据结构和多种特性，能够适应更多复杂的场景\r\n- Redis 能够数据持久化\r\n- Redis 原生支持集群模式\r\n- Redis 过期数据删除采用惰性删除和定期删除，Memcached 采用惰性删除\r\n- Redis 采用单线路的多路 IO 复用模型，Memcached 采用多线程的非阻塞 IO 复用的网络模型\r\n\r\n### 为什么采用Redis\r\n\r\n1. 访问速度高：基于内存，访问速度比磁盘快\r\n2. 高并发：能够承受的请求数量远远大于数据库\r\n3. 功能全面：内置分布式锁、消息队列等功能\r\n\r\n### 常见的缓存策略\r\n\r\n1、旁路缓存\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：更新数据库，删除缓存\r\n\r\n2、 读写穿透\r\n\r\n以缓存为主要数据存储\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：先查询缓存，缓存中不存在就直接更新数据库，缓存存在就更新缓存再更新数据库（**同步更新**）\r\n\r\n3、异步缓存写入\r\n\r\n与读写穿透类似，不同之处是更新的时候只更新缓存，采用**异步批量**的方式更新数据库\r\n\r\n### Redis Module\r\n\r\n我们可以通过 Redis Module 开发自己的 Module，比如自定义分布式锁等\r\n\r\n## Redis应用\r\n\r\n### Redis 除了做缓存，还能做什么\r\n\r\n很多，比如：分布式锁、限流、消息队列、延时队列等\r\n\r\n### 如何用Redis实现一个分布式锁\r\n\r\n使用 Lua 脚本配合 Redis 实现，可结合项目说明一下\r\n\r\n### 如何用Redis实现一个消息队列\r\n\r\nRedis 2.0之前用 List 实现，缺点是实现的功能太简单了，消息确认机制等功能需要我们自己实现，更重要的是它没有广播机制，消息也只能背消费一次\r\n\r\nRedis 2.0之后用发布定于实现，解决了 List 没有广播机制的问题\r\n\r\n### 如何用Redis实现一个延时队列\r\n\r\n两种方法：Redis 过期时间监听和 Redisson 内置的延时队列\r\n\r\n第一种方法缺点：时效性差、消息会被丢失、多服务实例下消息会被重复消费\r\n\r\n## Redis数据类型\r\n\r\n### 常用数据类型有哪些\r\n\r\n五种基础数据类型：String、hash、set（集合）、list、zset（有序集合）\r\n\r\n三种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial （地理位置）\r\n\r\n### 数据类型底层实现\r\n\r\n- String：SDS（简单动态字符串）\r\n- Hash：哈希表或压缩列表\r\n- List：双向链表或压缩列表\r\n- Set：哈希表或整数集合\r\n- ZSet：压缩列表或跳表\r\n\r\n### String应用场景\r\n\r\n存放 Token、序列化对象、页面访问计数用来限流等\r\n\r\n### String与Hash存储对象对比\r\n\r\n1、String 存储的是整合对象数据，Hash 是各个字段单独存储，也可以单独修改或添加。若是需要经常修改或查询单个字段用 Hash 比较好\r\n\r\n2、String 存储比 Hash 存储更节省内存\r\n\r\n绝大部分情况下，都建议用 String 存放对象数据\r\n\r\n例如：购物车信息需要频繁改动就选用 Hash 存储比较好\r\n\r\n### Set的应用场景\r\n\r\n1、需要随机获取元素的场景：抽奖\r\n\r\n- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。\r\n\r\n- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\r\n\r\n- `SRANDMEMBER key count` : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景\r\n\r\n2、存放数据不能重复：统计文章点赞\r\n\r\n3、多个数据的交集、并集和差集：共同关注\r\n\r\n## Redis持久化机制\r\n\r\n有三种持久化方式：\r\n\r\n- 快照（RDB）\r\n- 只追加文件（AOF）\r\n- RDB 和 AOF 的混合持久化\r\n\r\n## Redis线程模型","title":" Redis知识点总结\r\n","category":[" Redis","数据库\r\n"],"date":" 2024-03-23\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n对 Redis 面试知识点进行总结，参考文章：JavaGuideRedis篇https://javaguide.cn/database/redis/redisquestions01.html\r\n\r\n Redis基础\r\n\r\nRedis 是一个基于内存的数据库，速写速度快，采用 KV 键值对的形式对数据进行存储。此外 Redis 还支持多种优化后的数据结构、内置了 Lua 脚本、消息队列、延时队列等强大功能\r\n\r\n Redis 为什么访问怎么快\r\n\r\n Redis 基于内存，内存比磁盘的访问速度快\r\n Redis 内置多种优化后的数据结构\r\n Redis 是单线路事件循环和 IO 多路复用\r\n Redis 通信协议实现简单且解析高效\r\n\r\n 分布式缓存技术选型有哪些\r\n\r\n1、Redis，生态丰富，资料齐全\r\n\r\n2、Memcached ，一开始兴起比较常用\r\n\r\n3、腾讯的 Tendis，没维护了，使用的少\r\n\r\n Reids和Memcached的异同\r\n\r\n共同点：\r\n\r\n 都是基于内存数据库，当作缓存使用\r\n 都有过期策略\r\n 性能都很高\r\n\r\n不同点：\r\n\r\n Reids 含有多种数据结构和多种特性，能够适应更多复杂的场景\r\n Redis 能够数据持久化\r\n Redis 原生支持集群模式\r\n Redis 过期数据删除采用惰性删除和定期删除，Memcached 采用惰性删除\r\n Redis 采用单线路的多路 IO 复用模型，Memcached 采用多线程的非阻塞 IO 复用的网络模型\r\n\r\n 为什么采用Redis\r\n\r\n1. 访问速度高：基于内存，访问速度比磁盘快\r\n2. 高并发：能够承受的请求数量远远大于数据库\r\n3. 功能全面：内置分布式锁、消息队列等功能\r\n\r\n 常见的缓存策略\r\n\r\n1、旁路缓存\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：更新数据库，删除缓存\r\n\r\n2、 读写穿透\r\n\r\n以缓存为主要数据存储\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：先查询缓存，缓存中不存在就直接更新数据库，缓存存在就更新缓存再更新数据库（同步更新）\r\n\r\n3、异步缓存写入\r\n\r\n与读写穿透类似，不同之处是更新的时候只更新缓存，采用异步批量的方式更新数据库\r\n\r\n Redis Module\r\n\r\n我们可以通过 Redis Module 开发自己的 Module，比如自定义分布式锁等\r\n\r\n Redis应用\r\n\r\n Redis 除了做缓存，还能做什么\r\n\r\n很多，比如：分布式锁、限流、消息队列、延时队列等\r\n\r\n 如何用Redis实现一个分布式锁\r\n\r\n使用 Lua 脚本配合 Redis 实现，可结合项目说明一下\r\n\r\n 如何用Redis实现一个消息队列\r\n\r\nRedis 2.0之前用 List 实现，缺点是实现的功能太简单了，消息确认机制等功能需要我们自己实现，更重要的是它没有广播机制，消息也只能背消费一次\r\n\r\nRedis 2.0之后用发布定于实现，解决了 List 没有广播机制的问题\r\n\r\n 如何用Redis实现一个延时队列\r\n\r\n两种方法：Redis 过期时间监听和 Redisson 内置的延时队列\r\n\r\n第一种方法缺点：时效性差、消息会被丢失、多服务实例下消息会被重复消费\r\n\r\n Redis数据类型\r\n\r\n 常用数据类型有哪些\r\n\r\n五种基础数据类型：String、hash、set（集合）、list、zset（有序集合）\r\n\r\n三种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial （地理位置）\r\n\r\n 数据类型底层实现\r\n\r\n String：SDS（简单动态字符串）\r\n Hash：哈希表或压缩列表\r\n List：双向链表或压缩列表\r\n Set：哈希表或整数集合\r\n ZSet：压缩列表或跳表\r\n\r\n String应用场景\r\n\r\n存放 Token、序列化对象、页面访问计数用来限流等\r\n\r\n String与Hash存储对象对比\r\n\r\n1、String 存储的是整合对象数据，Hash 是各个字段单独存储，也可以单独修改或添加。若是需要经常修改或查询单个字段用 Hash 比较好\r\n\r\n2、String 存储比 Hash 存储更节省内存\r\n\r\n绝大部分情况下，都建议用 String 存放对象数据\r\n\r\n例如：购物车信息需要频繁改动就选用 Hash 存储比较好\r\n\r\n Set的应用场景\r\n\r\n1、需要随机获取元素的场景：抽奖\r\n\r\n SADD key member1 member2 ...：向指定集合添加一个或多个元素。\r\n\r\n SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\r\n\r\n SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景\r\n\r\n2、存放数据不能重复：统计文章点赞\r\n\r\n3、多个数据的交集、并集和差集：共同关注\r\n\r\n Redis持久化机制\r\n\r\n有三种持久化方式：\r\n\r\n 快照（RDB）\r\n 只追加文件（AOF）\r\n RDB 和 AOF 的混合持久化\r\n\r\n Redis线程模型"}]