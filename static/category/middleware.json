[{"filename":"rabbitmq","category":"middleware","md":{"topSummary":"\r\ntitle: RabbitMQ学习笔记\r\ncategory: RabbitMQ,中间件\r\ndate: 2024-06-27\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## 基本概念\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/sadsad.png)\r\n\r\n- virtual-host：虚拟主机（数据隔离）\r\n- publisher：生产者\r\n- consumer：消费者\r\n- queue：队列（存储消息）\r\n- exchange：交换机（路由消息）\r\n\r\n## 工作模式\r\n\r\n### 简单模式\r\n\r\n一个消费者绑定一个队列\r\n\r\n发送消息：\r\n\r\n```java\r\n@Autowired\r\nprivate RabbitTemplate rabbitTemplate;\r\n\r\n@Test\r\npublic void t1(){\r\n    rabbitTemplate.convertAndSend(\"simple.queue\", \"HelloWorld\");\r\n}\r\n```\r\n\r\n接收消息：\r\n\r\n```java\r\n@RabbitListener(queues = \"simple.queue\")\r\npublic void listenSimpleQueue(String msg){\r\n    log.info(\"收到消息：{}\", msg);\r\n}\r\n```\r\n\r\n### Work 模式\r\n\r\n多个消费者绑定一个队列，共同消费队列中的消息\r\n\r\n![](https://s11.ax1x.com/2024/01/30/pFKdfBt.png)\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t2() throws InterruptedException {\r\n    for(int i = 1; i <= 50; i++){\r\n        rabbitTemplate.convertAndSend(\"work.queue\", \"HelloWorld! Work_\" + i);\r\n        Thread.sleep(20);\r\n    }\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"work.queue\")\r\npublic void listenWorkQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n    Thread.sleep(20);\r\n}\r\n\r\n@RabbitListener(queues = \"work.queue\")\r\npublic void listenWorkQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n    Thread.sleep(200);\r\n}\r\n```\r\n\r\n这里我模拟了两个不同的处理能力消费者，消费者1的消费能力大于消费者2。若我们就直接用这个，控制台打印：\r\n\r\n```\r\n消费者1收到消息：HelloWorld! Work_1\r\n消费者2收到消息：....HelloWorld! Work_2\r\n消费者1收到消息：HelloWorld! Work_3\r\n消费者1收到消息：HelloWorld! Work_5\r\n消费者1收到消息：HelloWorld! Work_7\r\n消费者2收到消息：....HelloWorld! Work_4\r\n消费者1收到消息：HelloWorld! Work_9\r\n消费者1收到消息：HelloWorld! Work_11\r\n消费者1收到消息：HelloWorld! Work_13\r\n消费者2收到消息：....HelloWorld! Work_6\r\n消费者1收到消息：HelloWorld! Work_15\r\n消费者1收到消息：HelloWorld! Work_17\r\n消费者1收到消息：HelloWorld! Work_19\r\n消费者1收到消息：HelloWorld! Work_21\r\n消费者2收到消息：....HelloWorld! Work_8\r\n消费者1收到消息：HelloWorld! Work_23\r\n消费者1收到消息：HelloWorld! Work_25\r\n消费者1收到消息：HelloWorld! Work_27\r\n消费者2收到消息：....HelloWorld! Work_10\r\n消费者1收到消息：HelloWorld! Work_29\r\n消费者1收到消息：HelloWorld! Work_31\r\n消费者1收到消息：HelloWorld! Work_33\r\n消费者2收到消息：....HelloWorld! Work_12\r\n消费者1收到消息：HelloWorld! Work_35\r\n消费者1收到消息：HelloWorld! Work_37\r\n消费者1收到消息：HelloWorld! Work_39\r\n消费者2收到消息：....HelloWorld! Work_14\r\n消费者1收到消息：HelloWorld! Work_41\r\n消费者1收到消息：HelloWorld! Work_43\r\n消费者1收到消息：HelloWorld! Work_45\r\n消费者1收到消息：HelloWorld! Work_47\r\n消费者2收到消息：....HelloWorld! Work_16\r\n消费者1收到消息：HelloWorld! Work_49\r\n消费者2收到消息：....HelloWorld! Work_18\r\n消费者2收到消息：....HelloWorld! Work_20\r\n消费者2收到消息：....HelloWorld! Work_22\r\n消费者2收到消息：....HelloWorld! Work_24\r\n消费者2收到消息：....HelloWorld! Work_26\r\n消费者2收到消息：....HelloWorld! Work_28\r\n消费者2收到消息：....HelloWorld! Work_30\r\n消费者2收到消息：....HelloWorld! Work_32\r\n消费者2收到消息：....HelloWorld! Work_34\r\n消费者2收到消息：....HelloWorld! Work_36\r\n消费者2收到消息：....HelloWorld! Work_38\r\n消费者2收到消息：....HelloWorld! Work_40\r\n消费者2收到消息：....HelloWorld! Work_42\r\n消费者2收到消息：....HelloWorld! Work_44\r\n消费者2收到消息：....HelloWorld! Work_46\r\n消费者2收到消息：....HelloWorld! Work_48\r\n消费者2收到消息：....HelloWorld! Work_50\r\n```\r\n\r\n可以看到，消费者1和消费者2消费的数量是一样的。但是因为消费者1的消费速度大于2，所以消息很快就会被消费完，而消费者2的速度太慢，导致消息一直堆积\r\n\r\n修改代码，添加如下配置：\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n```\r\n\r\n让消费者只有在处理完当前1条消息后才能继续消费，这样执行一遍，控制台打印：\r\n\r\n```\r\n消费者1收到消息：HelloWorld! Work_1\r\n消费者2收到消息：....HelloWorld! Work_2\r\n消费者1收到消息：HelloWorld! Work_3\r\n消费者1收到消息：HelloWorld! Work_4\r\n消费者1收到消息：HelloWorld! Work_5\r\n消费者1收到消息：HelloWorld! Work_6\r\n消费者2收到消息：....HelloWorld! Work_8\r\n消费者1收到消息：HelloWorld! Work_7\r\n消费者1收到消息：HelloWorld! Work_9\r\n消费者1收到消息：HelloWorld! Work_10\r\n消费者1收到消息：HelloWorld! Work_11\r\n消费者1收到消息：HelloWorld! Work_12\r\n消费者1收到消息：HelloWorld! Work_13\r\n消费者1收到消息：HelloWorld! Work_14\r\n消费者2收到消息：....HelloWorld! Work_15\r\n消费者1收到消息：HelloWorld! Work_16\r\n消费者1收到消息：HelloWorld! Work_17\r\n消费者1收到消息：HelloWorld! Work_18\r\n消费者1收到消息：HelloWorld! Work_19\r\n消费者1收到消息：HelloWorld! Work_20\r\n消费者1收到消息：HelloWorld! Work_21\r\n消费者2收到消息：....HelloWorld! Work_23\r\n消费者1收到消息：HelloWorld! Work_22\r\n消费者1收到消息：HelloWorld! Work_24\r\n消费者1收到消息：HelloWorld! Work_25\r\n消费者1收到消息：HelloWorld! Work_26\r\n消费者1收到消息：HelloWorld! Work_27\r\n消费者1收到消息：HelloWorld! Work_28\r\n消费者1收到消息：HelloWorld! Work_29\r\n消费者1收到消息：HelloWorld! Work_30\r\n消费者2收到消息：....HelloWorld! Work_31\r\n消费者1收到消息：HelloWorld! Work_32\r\n消费者1收到消息：HelloWorld! Work_33\r\n消费者1收到消息：HelloWorld! Work_34\r\n消费者1收到消息：HelloWorld! Work_35\r\n消费者1收到消息：HelloWorld! Work_36\r\n消费者1收到消息：HelloWorld! Work_37\r\n消费者2收到消息：....HelloWorld! Work_38\r\n消费者1收到消息：HelloWorld! Work_39\r\n消费者1收到消息：HelloWorld! Work_40\r\n消费者1收到消息：HelloWorld! Work_41\r\n消费者1收到消息：HelloWorld! Work_42\r\n消费者1收到消息：HelloWorld! Work_43\r\n消费者1收到消息：HelloWorld! Work_44\r\n消费者1收到消息：HelloWorld! Work_45\r\n消费者2收到消息：....HelloWorld! Work_46\r\n消费者1收到消息：HelloWorld! Work_47\r\n消费者1收到消息：HelloWorld! Work_48\r\n消费者1收到消息：HelloWorld! Work_49\r\n消费者1收到消息：HelloWorld! Work_50\r\n```\r\n\r\n可以发现，消费者1的消费数量明显多于消费者2，达到了一种能者多劳的效果\r\n\r\n## 交换机\r\n\r\n生产环境中消息不会直接发送到队列，需要经过交换机来转发，有三种交换机类型:\r\n\r\n- Fanou：广播\r\n- Direct：定向\r\n- Topic：话题\r\n\r\n### Fanout 交换机\r\n\r\n创建一个类型为 `fanout` 交换机：`test.fanout`，绑定两个队列 `fanout.queue1` 和 `fanout.queue2`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t3(){\r\n    rabbitTemplate.convertAndSend(\"test.fanout\", null, \"HelloWorld! Fanout\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"fanout.queue1\")\r\npublic void listenFanoutQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"fanout.queue2\")\r\npublic void listenFanoutQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n控制台打印：\r\n\r\n```\r\n消费者2收到消息：....HelloWorld! Fanout\r\n消费者1收到消息：HelloWorld! Fanout\r\n```\r\n\r\n可以知道，消息通过 Fanout 交换机转发，会发送给绑定该交换机的所有队列，这就好理解广播的作用了\r\n\r\n### Direct 交换机\r\n\r\nDirect 交换机可以在 Fanout 交换机的基础上实现更复杂的业务，比如想要在广播的同时，让某些队列不接受消息\r\n\r\n创建一个交换机 `test.dirct`，绑定两个队列：`dirct.queue1` 包括 routing key：`blue `和 `red` 、`dirct.queue2` 包括 routing key：`red` 和 `yellow`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t4(){\r\n      rabbitTemplate.convertAndSend(\"test.direct\", \"red\", \"HelloWorld! Direct Red\");\r\n      rabbitTemplate.convertAndSend(\"test.direct\", \"blue\", \"HelloWorld! Direct Blue\");\r\n    rabbitTemplate.convertAndSend(\"test.direct\", \"yellow\", \"HelloWorld! Direct Yellow\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"direct.queue1\")\r\npublic void listenDirectQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"direct.queue2\")\r\npublic void listenDirectQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n有控制台打印可知：当发送消息 routing key 为 red 的时候，两者都会收到消息；当 routing key 为 blue 的时候，只有第一个消费者能够消费； routing key 为 yellow 的时候，只有第二个消费者能够消费\r\n\r\n### Topic 交换机\r\n\r\nTopic 交换机相对于 Direct 交换机，它能够在使用 routing key 的时候使用通配符表示，适用的场景更多\r\n\r\n有两种通配符，通配符通过 `.` 进行分割\r\n\r\n- #：代指0个或者多个单词\r\n- *：代指1个单词\r\n\r\n创建一个交换机 `test.queue`，绑定两个队列：`topic.queue1` 包括 routing key：`china.#`、`topic.queue2` 包括 routing key：`#.news`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t5(){\r\n      rabbitTemplate.convertAndSend(\"test.topic\", \"china.666\", \"HelloWorld! Topic china\");\r\n      rabbitTemplate.convertAndSend(\"test.topic\", \"japan.news\", \"HelloWorld! Topic 日本\");\r\n    rabbitTemplate.convertAndSend(\"test.topic\", \"china.news\", \"HelloWorld! Topic 都有\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"topic.queue1\")\r\npublic void listenTopicQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"topic.queue2\")\r\npublic void listenTopicQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n## 交换机和队列绑定\r\n\r\n有两种方式，一种是配置实现，一种是注解实现\r\n\r\n第一种当出现交换机和队列数量过多时，代码就要写很多，且绑定关系也会变得复杂，所以选择上最好选用第二种\r\n\r\n### 配置式\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/asdaklsASDjlk.png)\r\n\r\n创建一个 Fanout 交换机\r\n\r\n```java\r\n@Bean\r\npublic FanoutExchange fanoutExchange1(){\r\n    return new FanoutExchange(\"test.fanout2\");\r\n}\r\n```\r\n\r\n创建一个队列\r\n\r\n```java\r\n@Bean\r\npublic Queue fanoutQueue1(){\r\n    return new Queue(\"fanout.queue3\");\r\n}\r\n```\r\n\r\n绑定队列和交换机\r\n\r\n```java\r\n// 第一种绑定方式\r\n@Bean\r\npublic Binding binding(){\r\n    return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange1());\r\n}\r\n// 第二种绑定方式\r\n@Bean\r\npublic Binding binding(FanoutExchange fanoutExchange1, Queue fanoutQueue1){\r\n    return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange1);\r\n}\r\n\r\n// 若是有routing key\r\n@Bean\r\npublic Binding binding(DirectExchange DirectExchange1, Queue fanoutQueue1){\r\n    return BindingBuilder.bind(fanoutQueue1).to(DirectExchange1).with(\"red\");\r\n}\r\n```\r\n\r\n### 注解式\r\n\r\n参考格式\r\n\r\n```java\r\n@RabbitListener(bindings = @QueueBinding(\r\n        value = @Queue(name = \"direct.queue3\", durable = \"true\"),\r\n        exchange = @Exchange(name = \"test.direct2\", type = ExchangeTypes.DIRECT),\r\n        key = {\"red\", \"yellow\"}\r\n))\r\npublic void listenDirectQueue3(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n## 消息转化器\r\n\r\nSpring amqp 默认适用的消息转化器用的是 `SimpleMessageConverter`，当传入一个 Map 对象，因为 Map 实现了 Serializable 接口，所以会用 JDK 自带的 `(new ObjectOutputStream(stream)).writeObject(object)` 方法进行序列化，序列化的结果如下：\r\n\r\n```\r\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAAEVG9ueXQA\r\nAzEzM3QABE1pa2V0AAMyMTN4\r\n```\r\n\r\n所以需要对这个对象进行 jackson 序列化\r\n\r\n添加 yml 依赖\r\n\r\n```yaml\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n    <version>2.15.4</version>\r\n</dependency>\r\n```\r\n\r\n添加 Bean，返回 `Jackson2JsonMessageConverter`\r\n\r\n```java\r\n@Bean\r\npublic MessageConverter jackMessageConverter(){\r\n    return new Jackson2JsonMessageConverter();\r\n}\r\n```\r\n\r\n生产者\r\n\r\n```java\r\n@Test\r\npublic void t6(){\r\n    Map<String, String> res = new HashMap<>();\r\n    res.put(\"Tony\", \"133\");\r\n    res.put(\"Mike\", \"213\");\r\n    rabbitTemplate.convertAndSend(\"object.queue\", res);\r\n}\r\n```\r\n\r\n消费者\r\n\r\n```java\r\n@RabbitListener(queues = \"object.queue\")\r\npublic void listenObjectQueue(Map<String, String> msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n控制台输出\r\n\r\n```\r\n消费者收到消息：....{Tony=133, Mike=213}\r\n```\r\n\r\n可以看到，消息已经成功序列化\r\n\r\n## 消息的可靠性\r\n\r\n### 生产者可靠性\r\n\r\n#### 生产者重连\r\n\r\n由于网络波动，可能出现客户端连接 MQ 失败的情况，导致连接 MQ 失败\r\n\r\n解决：添加 yml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    # 以下配置是MQ连接超时的配置\r\n    connection-timeout: 1s # 超时连接时间\r\n    template:\r\n      retry:\r\n        enabled: true # 开启超时自动重连\r\n        initial-interval: 1000ms # 失败后的初始等待时间\r\n        multiplier: 1 # 失败后下次等待时常的倍数\r\n        max-attempts: 3 # 最大重连次数\r\n```\r\n\r\n当连接超时后，会等待1秒后再次进行重连，若3次重连后任然失败，就会抛出异常\r\n\r\n**注意**：超时重连是阻塞式的重试，也就是说重试不成功是不会执行消息发送后面的代码的\r\n\r\n#### 生产者确认\r\n\r\n有两种确认机制： Publisher Confirm 和 Publisher Return\r\n\r\n当消息发送到了 MQ，返回 ACK，否则都是 NACK\r\n\r\n添加 yml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n   \t...\r\n    # 以下是生产者消息确认\r\n    publisher-confirm-type: correlated # 开启消息确认机制，类型为异步\r\n    publisher-returns: true # 开启消息return机制，用于返回失败消息\r\n```\r\n\r\n有三种消息确认类型\r\n\r\n- none：关闭确认机制\r\n- simple：同步阻塞等待回调消息\r\n- correlated：异步回调执行回调消息\r\n\r\n添加 Confirm 配置类，需要实现 `ApplicationContextAware` 接口\r\n\r\n```java\r\n@Slf4j\r\n@Configuration\r\npublic class MqConfirmConfig implements ApplicationContextAware {\r\n    @Override\r\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\r\n        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);\r\n        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {\r\n            @Override\r\n            public void returnedMessage(ReturnedMessage message) {\r\n                log.error(\"收到消息return callback：message:{}, exchange:{}, code:{}, text:{}, routingKey:{}\",\r\n                        message.getMessage(), message.getExchange(), message.getReplyCode(),\r\n                        message.getReplyText(), message.getRoutingKey());\r\n            }\r\n        });\r\n    }\r\n}\t\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t7(){\r\n    CorrelationData cd = new CorrelationData(UUID.randomUUID().toString(true));\r\n    cd.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {\r\n        @Override\r\n        public void onFailure(Throwable ex) {\r\n            // Spring内部出现错误，与MQ无关，一般不会发生错误\r\n            log.error(\"消息回调失败：\", ex);\r\n        }\r\n\r\n        @Override\r\n        public void onSuccess(CorrelationData.Confirm result) {\r\n            if (result.isAck()){\r\n                log.info(\"消息发送成功，收到ACK\");\r\n            } else {\r\n                log.error(\"消息发送失败，收到NACK，原因：{}\", result.getReason());\r\n            }\r\n        }\r\n    });\r\n\r\n    rabbitTemplate.convertAndSend(\"test.direct\", \"yellow\", \"HelloWorld! Direct Yellow\", cd);\r\n}\r\n```\r\n\r\n此时交换机和 routing key 都是正确的，控制台打印：\r\n\r\n```\r\n消息发送成功，收到ACK\r\n```\r\n\r\n若 routing key 不正确，控制台打印：\r\n\r\n```\r\n消息发送成功，收到ACK\r\n收到消息return callback：message:(Body:'\"HelloWorld! Direct Yellow\"' MessageProperties [headers={spring_returned_message_correlation=f6a38c92958643c299b834c543a56f38, __TypeId__=java.lang.String}, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0]), exchange:test.direct, code:312, text:NO_ROUTE, routingKey:yel1low\r\n```\r\n\r\n若交换机不存在，控制台打印：\r\n\r\n```\r\n消息发送失败，收到NACK，原因：channel error; protocol method: #method<channel.close>(reply-code=404, reply-text=NOT_FOUND - no exchange 'test.direct1' in vhost '/jixer', class-id=60, method-id=40)\r\n```\r\n\r\n**注意**：在实际开发中，尽量不使用生产者确认机制（影响效率）。若一定要使用，无需开启 Publisher Return 机制，因为一般路由失败都是自己业务的问题，比如：交换机名字写出。对于 NACK 消息可以有限次数重试机，依然失败则记录异常消息\r\n\r\n### MQ 可靠性\r\n\r\n#### 数据持久化\r\n\r\n数据持久化有三个方面：\r\n\r\n- 交换机持久化\r\n- 队列持久化\r\n- 消息持久化\r\n\r\n当我们使用 SpringBoot 创建交换机、队列、消息的时候会默认使用持久化\r\n\r\n若我们不用持久化，重启一遍 RabbitMQ，这些数据就会丢失\r\n\r\n下面演示发送消息非持久化带来的问题：\r\n\r\n生产者\r\n\r\n```java\r\n@Test\r\npublic void t8(){\r\n    Message msg = MessageBuilder.withBody(\"123123\".getBytes(StandardCharsets.UTF_8))\r\n            .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)\r\n            .build();\r\n    for(int i = 0; i < 1000000; i++){\r\n        rabbitTemplate.convertAndSend(\"simple.queue\", msg);\r\n    }\r\n}\r\n```\r\n\r\n无消费者，此时观察管理页面\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/124GHDhj.png)\r\n\r\n可以看到，当消息增多，出现堆积，会造成 Page Out，MQ 会陷入短暂的阻塞，接收速度变为0，无法处理消息\r\n\r\n这是因为非持久的消息保存在内存中，MQ 会每隔一段时间当把消息存入内存，这段时间内会阻塞出现 Page Out\r\n\r\n若我们发送持久化就不会出现 Page Out 的问题\r\n\r\n#### Lazy Queue\r\n\r\nLazy Queue的特点：\r\n\r\n- 接收的消息直接存入磁盘，也就是页面显示直接在 Page Out\r\n- 消费者消费需要从磁盘读取并加载到内存中\r\n- 支持百万条消息存储\r\n\r\n**创建 Lazy Queue**\r\n\r\n配置类方式\r\n\r\n```java\r\n@Bean\r\npublic Queue lazyQueue(){\r\n    return QueueBuilder.durable(\"lazy.queue\").lazy().build();\r\n}\r\n```\r\n\r\n注解方式\r\n\r\n```java\r\n@RabbitListener(queuesToDeclare = @Queue(\r\n        name = \"lazy.queue\",\r\n        durable = \"true\",\r\n        arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")\r\n))\r\npublic void listenLazyQueue(String msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n发送100万条消息，管理页面显示：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/dHDlkjae.png)\r\n\r\n可以看到消息一直处于 Page Out，并且速率大部分时间都处于峰值\r\n\r\n### 消费者的可靠性\r\n\r\n#### 消费者确认\r\n\r\n当消费者处理完消息后，可以告知 RabbitMQ 自己消息的处理状态，有三种状态：\r\n\r\n- ACK：成功，MQ 删除消息\r\n- NACK：失败，MQ 需要再次投递消息\r\n- REJECT：失败并拒绝，MQ 删除消息（一般是出现消息格式错误）\r\n\r\n添加 yaml 依赖\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledge-mode: auto # 消费者消息确认类型\r\n```\r\n\r\n消费者确认类型有三种：\r\n\r\n- none：不做处理\r\n- manual：手动模式\r\n- auto：自动模式（默认）\r\n  - 业务异常返回 NACK\r\n  - 消息处理异常或校验异常返回 REJECT\r\n\r\n向 `simple.queue` 队列发送一条消息\r\n\r\n消费者\r\n\r\n```java\r\n@RabbitListener(queues = \"simple.queue\")\r\npublic void listenSimpleQueue(String msg) throws Exception {\r\n    log.info(\"收到消息：{}\", msg);\r\n    throw new Exception(\"故意的\");\r\n}\r\n```\r\n\r\n若选择用 none 类型：走到异常，但这段代码还没走完，消息已经消费了，消息丢失\r\n\r\n若选用 auto 类型：走到异常后，业务返回 NACK，RabbitMQ 自动重新投递，直到消费成功为止；若将传参 String 类型换成其他类型（消息格式错误），业务代码返回 REJECT，MQ 会消费并删除消息\r\n\r\n#### 消费者失败重试\r\n\r\n上面消费者确认有个问题：经过消费者确认后一直失败一直在重试，一直在消耗系统资源\r\n\r\n解决办法：添加消费者失败重试\r\n\r\n当重试次数达一定次数后就自定义重试策略\r\n\r\n有三种重试策略：\r\n\r\n- RepublishMessageRecoverer：将失败消息投递到指定的交换机处理\r\n- RejectAndDontRequeueRecoverer：直接 REJECT，丢弃消息（默认）\r\n- ImmediateRequeueMessageRecoverer：返回 NACK，消息重回入队\r\n\r\n这里选用 RepublishMessageRecoverer 策略\r\n\r\n添加 yaml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n  \t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledge-mode: auto # 消费者消息确认类型\r\n    # 以下是开启消费者失败重试机制\r\n        retry:\r\n          enabled: true\r\n          initial-interval: 1000ms # 初始失败的时长等待\r\n          multiplier: 1 # 失败后下次等待时常的倍数\r\n          max-attempts: 3 # 最大重连次数\r\n          stateless: true # true无状态，false有状态。如果业务包含事务，改为false\r\n```\r\n\r\n新建一个 ErrorConfig 配置类，用于绑定失败处理交换机和队列，并设置失败处理策略\r\n\r\n通过 `@ConditionalOnProperty` 来限制只有当 yml 配置文件中 `retry.enabled` 为 `true` 的时候才创建 Bean\r\n\r\n```java\r\n@Configuration\r\n@ConditionalOnProperty(prefix = \"spring.rabbitmq.listener.simple\", name = \"retry.enabled\", havingValue = \"true\") // 只有当前配置文件为true才创建bean\r\npublic class ErrorConfig {\r\n    @Bean\r\n    public DirectExchange errorExchange(){\r\n        return new DirectExchange(\"test.error\");\r\n    }\t\r\n    @Bean\r\n    public Queue errorQueue(){\r\n        return new Queue(\"error.queue\");\r\n    }\r\n    @Bean\r\n    public Binding binding(){\r\n        return BindingBuilder.bind(errorQueue()).to(errorExchange()).with(\"error\");\r\n    }\r\n    @Bean\r\n    public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){\r\n        return new RepublishMessageRecoverer(rabbitTemplate, \"test.error\", \"error\");\r\n    }\r\n}\r\n```\r\n\r\n在消费者代码处抛出异常，会看到当重试三次后，会将失败消息发送错误处理交换机，再由交换机转发到队列，后面由人工进行处理\r\n\r\n错误消息如下：可以看清楚的看到那块地方出错了\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/d12HSyrash.png)\r\n\r\n#### 消费者的幂等性\r\n\r\n通过上述消费者的确认和消费者的失败重试，可以保证消费者至少能够把消息消费一次，但是可能出现多次消费的情况，多次消费可能导致数据错误\r\n\r\n幂等：执行一次和执行多次对业务的结果是一样的\r\n\r\n**方案一：唯一消息 ID**\r\n\r\n给每个消息设置一个唯一的 ID，每次消费者进行消费的时候将 ID 保存入数据库，下次消费前先判断数据库是否已经存在 ID，存在就代表已经消费，否则就可以消费\r\n\r\n修改消息转化器，设置自动创建消息 ID\r\n\r\n```java\r\n@Bean\r\npublic MessageConverter jackMessageConverter(){\r\n    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();\r\n    jackson2JsonMessageConverter.setCreateMessageIds(true);\r\n    return jackson2JsonMessageConverter;\r\n}\r\n```\r\n\r\n创建后的消息如图所示：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/sadJ1.png)\r\n\r\n**方案二：业务判断**\r\n\r\n根据业务的需求来判断，比如：支付服务完成后发送消息给订单服务，订单服务需要将订单状态由未支付变为已支付，所以这里只需要对未支付的订单进行消费即可，已支付的订单不需要再次处理\r\n\r\n具体的 SQL 语句变为：\r\n\r\n```sql\r\nupdate tb_order set status = 1 where id = xxx and status = 2\r\n```\r\n\r\n只需要对数据库操作一次就满足了要求，而方案一需要对数据库进行多次操作（查询，更新）\r\n\r\n## 延迟消息\r\n\r\n### 死信交换机\r\n\r\n创建队列与交换，关系如图所示：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/asdUI1g.png)\r\n\r\n`simple.direct` 交换机绑定 `simple.queue` 队列， `simple.queue` 绑定 `dlx.direct` 死信交换机\r\n\r\n创建 `simple.queue` 的时候绑定死信交换机方法如下：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/rabbitmq/dKLHJh.png)\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t10(){\r\n    rabbitTemplate.convertAndSend(\"simple.direct\", \"simple\", \"你好\", new MessagePostProcessor() {\r\n        @Override\r\n        public Message postProcessMessage(Message message) throws AmqpException {\r\n            message.getMessageProperties().setExpiration(\"10000\"); // 设置过期时间\r\n            return message;\r\n        }\r\n    });\r\n    log.info(\"发送消息\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"dlx.queue\")\r\npublic void listenDlxQueue(String msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n生产者发送过期时间为10s消息，消费者监听的是死信队列，并不是监听的是 `simple.queue` 这个队列\r\n\r\n因为 `simple.queue` 队列的消息没有被消费，所以当10s后消息会被发送到死信交换机，死信交换机转发到死信队列\r\n\r\n### 消息延迟插件\r\n\r\n消息延迟与死信交换机不同，它是将消息发送到交换机，在交换机中暂存一段时间后再投递到队列中\r\n\r\n插件下载地址：[rabbitmq/rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases)\r\n\r\n进入 RabbitMQ 插件目录执行以下命令开启插件\r\n\r\n```\r\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t11(){\r\n    rabbitTemplate.convertAndSend(\"delay.direct\", \"hi\", \"你好\", new MessagePostProcessor() {\r\n        @Override\r\n        public Message postProcessMessage(Message message) throws AmqpException {\r\n            message.getMessageProperties().setDelay(10000); // 设置延迟时间\r\n            return message;\r\n        }\r\n    });\r\n    log.info(\"发送消息\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(bindings = @QueueBinding(\r\n        value = @Queue(name = \"delay.queue\", durable = \"true\"),\r\n        exchange = @Exchange(name = \"delay.direct\", delayed = \"true\"),\r\n        key = {\"hi\", \"hello\"}\r\n))\r\npublic void listenDelayQueue(String msg) throws InterruptedException {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\nRabbitMQ 的延迟消息是有一定的功能损耗的，所以适用于延迟时间不太长的场景\r\n\r\n在一般的超时订单场景中，若设置的超时时间为30分钟，会存在两个问题：\r\n\r\n- 若并发高，30分钟可能堆积消息过多，MQ 压力大\r\n- 大多数订单在下单后1分钟内就会支付，但是 MQ 却需要等待30分钟，浪费资源\r\n\r\n解决方法：设置消息过期时间梯度数组，将30分钟拆分为多个小部分，每个部分个根据可能支付的概率选用合适的等大时间\r\n","title":" RabbitMQ学习笔记\r\n","category":[" RabbitMQ","中间件\r\n"],"date":" 2024-06-27\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"},"simpleMd":"\r\n\r\n 基本概念\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/sadsad.png\r\n\r\n virtualhost：虚拟主机（数据隔离）\r\n publisher：生产者\r\n consumer：消费者\r\n queue：队列（存储消息）\r\n exchange：交换机（路由消息）\r\n\r\n 工作模式\r\n\r\n 简单模式\r\n\r\n一个消费者绑定一个队列\r\n\r\n发送消息：\r\n\r\njava\r\n@Autowired\r\nprivate RabbitTemplate rabbitTemplate;\r\n\r\n@Test\r\npublic void t1{\r\n    rabbitTemplate.convertAndSend\"simple.queue\", \"HelloWorld\";\r\n}\r\n\r\n\r\n接收消息：\r\n\r\njava\r\n@RabbitListenerqueues = \"simple.queue\"\r\npublic void listenSimpleQueueString msg{\r\n    log.info\"收到消息：{}\", msg;\r\n}\r\n\r\n\r\n Work 模式\r\n\r\n多个消费者绑定一个队列，共同消费队列中的消息\r\n\r\nhttps://s11.ax1x.com/2024/01/30/pFKdfBt.png\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t2 throws InterruptedException {\r\n    forint i = 1; i <= 50; i++{\r\n        rabbitTemplate.convertAndSend\"work.queue\", \"HelloWorld Work\" + i;\r\n        Thread.sleep20;\r\n    }\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"work.queue\"\r\npublic void listenWorkQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n    Thread.sleep20;\r\n}\r\n\r\n@RabbitListenerqueues = \"work.queue\"\r\npublic void listenWorkQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n    Thread.sleep200;\r\n}\r\n\r\n\r\n这里我模拟了两个不同的处理能力消费者，消费者1的消费能力大于消费者2。若我们就直接用这个，控制台打印：\r\n\r\n\r\n消费者1收到消息：HelloWorld Work1\r\n消费者2收到消息：....HelloWorld Work2\r\n消费者1收到消息：HelloWorld Work3\r\n消费者1收到消息：HelloWorld Work5\r\n消费者1收到消息：HelloWorld Work7\r\n消费者2收到消息：....HelloWorld Work4\r\n消费者1收到消息：HelloWorld Work9\r\n消费者1收到消息：HelloWorld Work11\r\n消费者1收到消息：HelloWorld Work13\r\n消费者2收到消息：....HelloWorld Work6\r\n消费者1收到消息：HelloWorld Work15\r\n消费者1收到消息：HelloWorld Work17\r\n消费者1收到消息：HelloWorld Work19\r\n消费者1收到消息：HelloWorld Work21\r\n消费者2收到消息：....HelloWorld Work8\r\n消费者1收到消息：HelloWorld Work23\r\n消费者1收到消息：HelloWorld Work25\r\n消费者1收到消息：HelloWorld Work27\r\n消费者2收到消息：....HelloWorld Work10\r\n消费者1收到消息：HelloWorld Work29\r\n消费者1收到消息：HelloWorld Work31\r\n消费者1收到消息：HelloWorld Work33\r\n消费者2收到消息：....HelloWorld Work12\r\n消费者1收到消息：HelloWorld Work35\r\n消费者1收到消息：HelloWorld Work37\r\n消费者1收到消息：HelloWorld Work39\r\n消费者2收到消息：....HelloWorld Work14\r\n消费者1收到消息：HelloWorld Work41\r\n消费者1收到消息：HelloWorld Work43\r\n消费者1收到消息：HelloWorld Work45\r\n消费者1收到消息：HelloWorld Work47\r\n消费者2收到消息：....HelloWorld Work16\r\n消费者1收到消息：HelloWorld Work49\r\n消费者2收到消息：....HelloWorld Work18\r\n消费者2收到消息：....HelloWorld Work20\r\n消费者2收到消息：....HelloWorld Work22\r\n消费者2收到消息：....HelloWorld Work24\r\n消费者2收到消息：....HelloWorld Work26\r\n消费者2收到消息：....HelloWorld Work28\r\n消费者2收到消息：....HelloWorld Work30\r\n消费者2收到消息：....HelloWorld Work32\r\n消费者2收到消息：....HelloWorld Work34\r\n消费者2收到消息：....HelloWorld Work36\r\n消费者2收到消息：....HelloWorld Work38\r\n消费者2收到消息：....HelloWorld Work40\r\n消费者2收到消息：....HelloWorld Work42\r\n消费者2收到消息：....HelloWorld Work44\r\n消费者2收到消息：....HelloWorld Work46\r\n消费者2收到消息：....HelloWorld Work48\r\n消费者2收到消息：....HelloWorld Work50\r\n\r\n\r\n可以看到，消费者1和消费者2消费的数量是一样的。但是因为消费者1的消费速度大于2，所以消息很快就会被消费完，而消费者2的速度太慢，导致消息一直堆积\r\n\r\n修改代码，添加如下配置：\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n    listener:\r\n      simple:\r\n        prefetch: 1  每次只能领取一条消息，处理完才能获取一下条消息\r\n\r\n\r\n让消费者只有在处理完当前1条消息后才能继续消费，这样执行一遍，控制台打印：\r\n\r\n\r\n消费者1收到消息：HelloWorld Work1\r\n消费者2收到消息：....HelloWorld Work2\r\n消费者1收到消息：HelloWorld Work3\r\n消费者1收到消息：HelloWorld Work4\r\n消费者1收到消息：HelloWorld Work5\r\n消费者1收到消息：HelloWorld Work6\r\n消费者2收到消息：....HelloWorld Work8\r\n消费者1收到消息：HelloWorld Work7\r\n消费者1收到消息：HelloWorld Work9\r\n消费者1收到消息：HelloWorld Work10\r\n消费者1收到消息：HelloWorld Work11\r\n消费者1收到消息：HelloWorld Work12\r\n消费者1收到消息：HelloWorld Work13\r\n消费者1收到消息：HelloWorld Work14\r\n消费者2收到消息：....HelloWorld Work15\r\n消费者1收到消息：HelloWorld Work16\r\n消费者1收到消息：HelloWorld Work17\r\n消费者1收到消息：HelloWorld Work18\r\n消费者1收到消息：HelloWorld Work19\r\n消费者1收到消息：HelloWorld Work20\r\n消费者1收到消息：HelloWorld Work21\r\n消费者2收到消息：....HelloWorld Work23\r\n消费者1收到消息：HelloWorld Work22\r\n消费者1收到消息：HelloWorld Work24\r\n消费者1收到消息：HelloWorld Work25\r\n消费者1收到消息：HelloWorld Work26\r\n消费者1收到消息：HelloWorld Work27\r\n消费者1收到消息：HelloWorld Work28\r\n消费者1收到消息：HelloWorld Work29\r\n消费者1收到消息：HelloWorld Work30\r\n消费者2收到消息：....HelloWorld Work31\r\n消费者1收到消息：HelloWorld Work32\r\n消费者1收到消息：HelloWorld Work33\r\n消费者1收到消息：HelloWorld Work34\r\n消费者1收到消息：HelloWorld Work35\r\n消费者1收到消息：HelloWorld Work36\r\n消费者1收到消息：HelloWorld Work37\r\n消费者2收到消息：....HelloWorld Work38\r\n消费者1收到消息：HelloWorld Work39\r\n消费者1收到消息：HelloWorld Work40\r\n消费者1收到消息：HelloWorld Work41\r\n消费者1收到消息：HelloWorld Work42\r\n消费者1收到消息：HelloWorld Work43\r\n消费者1收到消息：HelloWorld Work44\r\n消费者1收到消息：HelloWorld Work45\r\n消费者2收到消息：....HelloWorld Work46\r\n消费者1收到消息：HelloWorld Work47\r\n消费者1收到消息：HelloWorld Work48\r\n消费者1收到消息：HelloWorld Work49\r\n消费者1收到消息：HelloWorld Work50\r\n\r\n\r\n可以发现，消费者1的消费数量明显多于消费者2，达到了一种能者多劳的效果\r\n\r\n 交换机\r\n\r\n生产环境中消息不会直接发送到队列，需要经过交换机来转发，有三种交换机类型:\r\n\r\n Fanou：广播\r\n Direct：定向\r\n Topic：话题\r\n\r\n Fanout 交换机\r\n\r\n创建一个类型为 fanout 交换机：test.fanout，绑定两个队列 fanout.queue1 和 fanout.queue2\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t3{\r\n    rabbitTemplate.convertAndSend\"test.fanout\", null, \"HelloWorld Fanout\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"fanout.queue1\"\r\npublic void listenFanoutQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n}\r\n\r\n@RabbitListenerqueues = \"fanout.queue2\"\r\npublic void listenFanoutQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n控制台打印：\r\n\r\n\r\n消费者2收到消息：....HelloWorld Fanout\r\n消费者1收到消息：HelloWorld Fanout\r\n\r\n\r\n可以知道，消息通过 Fanout 交换机转发，会发送给绑定该交换机的所有队列，这就好理解广播的作用了\r\n\r\n Direct 交换机\r\n\r\nDirect 交换机可以在 Fanout 交换机的基础上实现更复杂的业务，比如想要在广播的同时，让某些队列不接受消息\r\n\r\n创建一个交换机 test.dirct，绑定两个队列：dirct.queue1 包括 routing key：blue 和 red 、dirct.queue2 包括 routing key：red 和 yellow\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t4{\r\n      rabbitTemplate.convertAndSend\"test.direct\", \"red\", \"HelloWorld Direct Red\";\r\n      rabbitTemplate.convertAndSend\"test.direct\", \"blue\", \"HelloWorld Direct Blue\";\r\n    rabbitTemplate.convertAndSend\"test.direct\", \"yellow\", \"HelloWorld Direct Yellow\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"direct.queue1\"\r\npublic void listenDirectQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n}\r\n\r\n@RabbitListenerqueues = \"direct.queue2\"\r\npublic void listenDirectQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n有控制台打印可知：当发送消息 routing key 为 red 的时候，两者都会收到消息；当 routing key 为 blue 的时候，只有第一个消费者能够消费； routing key 为 yellow 的时候，只有第二个消费者能够消费\r\n\r\n Topic 交换机\r\n\r\nTopic 交换机相对于 Direct 交换机，它能够在使用 routing key 的时候使用通配符表示，适用的场景更多\r\n\r\n有两种通配符，通配符通过 . 进行分割\r\n\r\n ：代指0个或者多个单词\r\n ：代指1个单词\r\n\r\n创建一个交换机 test.queue，绑定两个队列：topic.queue1 包括 routing key：china.、topic.queue2 包括 routing key：.news\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t5{\r\n      rabbitTemplate.convertAndSend\"test.topic\", \"china.666\", \"HelloWorld Topic china\";\r\n      rabbitTemplate.convertAndSend\"test.topic\", \"japan.news\", \"HelloWorld Topic 日本\";\r\n    rabbitTemplate.convertAndSend\"test.topic\", \"china.news\", \"HelloWorld Topic 都有\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"topic.queue1\"\r\npublic void listenTopicQueue1String msg throws InterruptedException {\r\n    log.info\"消费者1收到消息：{}\", msg;\r\n}\r\n\r\n@RabbitListenerqueues = \"topic.queue2\"\r\npublic void listenTopicQueue2String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n 交换机和队列绑定\r\n\r\n有两种方式，一种是配置实现，一种是注解实现\r\n\r\n第一种当出现交换机和队列数量过多时，代码就要写很多，且绑定关系也会变得复杂，所以选择上最好选用第二种\r\n\r\n 配置式\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/asdaklsASDjlk.png\r\n\r\n创建一个 Fanout 交换机\r\n\r\njava\r\n@Bean\r\npublic FanoutExchange fanoutExchange1{\r\n    return new FanoutExchange\"test.fanout2\";\r\n}\r\n\r\n\r\n创建一个队列\r\n\r\njava\r\n@Bean\r\npublic Queue fanoutQueue1{\r\n    return new Queue\"fanout.queue3\";\r\n}\r\n\r\n\r\n绑定队列和交换机\r\n\r\njava\r\n// 第一种绑定方式\r\n@Bean\r\npublic Binding binding{\r\n    return BindingBuilder.bindfanoutQueue1.tofanoutExchange1;\r\n}\r\n// 第二种绑定方式\r\n@Bean\r\npublic Binding bindingFanoutExchange fanoutExchange1, Queue fanoutQueue1{\r\n    return BindingBuilder.bindfanoutQueue1.tofanoutExchange1;\r\n}\r\n\r\n// 若是有routing key\r\n@Bean\r\npublic Binding bindingDirectExchange DirectExchange1, Queue fanoutQueue1{\r\n    return BindingBuilder.bindfanoutQueue1.toDirectExchange1.with\"red\";\r\n}\r\n\r\n\r\n 注解式\r\n\r\n参考格式\r\n\r\njava\r\n@RabbitListenerbindings = @QueueBinding\r\n        value = @Queuename = \"direct.queue3\", durable = \"true\",\r\n        exchange = @Exchangename = \"test.direct2\", type = ExchangeTypes.DIRECT,\r\n        key = {\"red\", \"yellow\"}\r\n\r\npublic void listenDirectQueue3String msg throws InterruptedException {\r\n    log.info\"消费者2收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n 消息转化器\r\n\r\nSpring amqp 默认适用的消息转化器用的是 SimpleMessageConverter，当传入一个 Map 对象，因为 Map 实现了 Serializable 接口，所以会用 JDK 自带的 new ObjectOutputStreamstream.writeObjectobject 方法进行序列化，序列化的结果如下：\r\n\r\n\r\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAAEVG9ueXQA\r\nAzEzM3QABE1pa2V0AAMyMTN4\r\n\r\n\r\n所以需要对这个对象进行 jackson 序列化\r\n\r\n添加 yml 依赖\r\n\r\nyaml\r\n<dependency\r\n    <groupIdcom.fasterxml.jackson.core</groupId\r\n    <artifactIdjacksondatabind</artifactId\r\n    <version2.15.4</version\r\n</dependency\r\n\r\n\r\n添加 Bean，返回 Jackson2JsonMessageConverter\r\n\r\njava\r\n@Bean\r\npublic MessageConverter jackMessageConverter{\r\n    return new Jackson2JsonMessageConverter;\r\n}\r\n\r\n\r\n生产者\r\n\r\njava\r\n@Test\r\npublic void t6{\r\n    Map<String, String res = new HashMap<;\r\n    res.put\"Tony\", \"133\";\r\n    res.put\"Mike\", \"213\";\r\n    rabbitTemplate.convertAndSend\"object.queue\", res;\r\n}\r\n\r\n\r\n消费者\r\n\r\njava\r\n@RabbitListenerqueues = \"object.queue\"\r\npublic void listenObjectQueueMap<String, String msg {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n控制台输出\r\n\r\n\r\n消费者收到消息：....{Tony=133, Mike=213}\r\n\r\n\r\n可以看到，消息已经成功序列化\r\n\r\n 消息的可靠性\r\n\r\n 生产者可靠性\r\n\r\n 生产者重连\r\n\r\n由于网络波动，可能出现客户端连接 MQ 失败的情况，导致连接 MQ 失败\r\n\r\n解决：添加 yml 配置\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n     以下配置是MQ连接超时的配置\r\n    connectiontimeout: 1s  超时连接时间\r\n    template:\r\n      retry:\r\n        enabled: true  开启超时自动重连\r\n        initialinterval: 1000ms  失败后的初始等待时间\r\n        multiplier: 1  失败后下次等待时常的倍数\r\n        maxattempts: 3  最大重连次数\r\n\r\n\r\n当连接超时后，会等待1秒后再次进行重连，若3次重连后任然失败，就会抛出异常\r\n\r\n注意：超时重连是阻塞式的重试，也就是说重试不成功是不会执行消息发送后面的代码的\r\n\r\n 生产者确认\r\n\r\n有两种确认机制： Publisher Confirm 和 Publisher Return\r\n\r\n当消息发送到了 MQ，返回 ACK，否则都是 NACK\r\n\r\n添加 yml 配置\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n   \t...\r\n     以下是生产者消息确认\r\n    publisherconfirmtype: correlated  开启消息确认机制，类型为异步\r\n    publisherreturns: true  开启消息return机制，用于返回失败消息\r\n\r\n\r\n有三种消息确认类型\r\n\r\n none：关闭确认机制\r\n simple：同步阻塞等待回调消息\r\n correlated：异步回调执行回调消息\r\n\r\n添加 Confirm 配置类，需要实现 ApplicationContextAware 接口\r\n\r\njava\r\n@Slf4j\r\n@Configuration\r\npublic class MqConfirmConfig implements ApplicationContextAware {\r\n    @Override\r\n    public void setApplicationContextApplicationContext applicationContext throws BeansException {\r\n        RabbitTemplate rabbitTemplate = applicationContext.getBeanRabbitTemplate.class;\r\n        rabbitTemplate.setReturnsCallbacknew RabbitTemplate.ReturnsCallback {\r\n            @Override\r\n            public void returnedMessageReturnedMessage message {\r\n                log.error\"收到消息return callback：message:{}, exchange:{}, code:{}, text:{}, routingKey:{}\",\r\n                        message.getMessage, message.getExchange, message.getReplyCode,\r\n                        message.getReplyText, message.getRoutingKey;\r\n            }\r\n        };\r\n    }\r\n}\t\r\n\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t7{\r\n    CorrelationData cd = new CorrelationDataUUID.randomUUID.toStringtrue;\r\n    cd.getFuture.addCallbacknew ListenableFutureCallback<CorrelationData.Confirm {\r\n        @Override\r\n        public void onFailureThrowable ex {\r\n            // Spring内部出现错误，与MQ无关，一般不会发生错误\r\n            log.error\"消息回调失败：\", ex;\r\n        }\r\n\r\n        @Override\r\n        public void onSuccessCorrelationData.Confirm result {\r\n            if result.isAck{\r\n                log.info\"消息发送成功，收到ACK\";\r\n            } else {\r\n                log.error\"消息发送失败，收到NACK，原因：{}\", result.getReason;\r\n            }\r\n        }\r\n    };\r\n\r\n    rabbitTemplate.convertAndSend\"test.direct\", \"yellow\", \"HelloWorld Direct Yellow\", cd;\r\n}\r\n\r\n\r\n此时交换机和 routing key 都是正确的，控制台打印：\r\n\r\n\r\n消息发送成功，收到ACK\r\n\r\n\r\n若 routing key 不正确，控制台打印：\r\n\r\n\r\n消息发送成功，收到ACK\r\n收到消息return callback：message:Body:'\"HelloWorld Direct Yellow\"' MessageProperties headers={springreturnedmessagecorrelation=f6a38c92958643c299b834c543a56f38, TypeId=java.lang.String}, contentType=application/json, contentEncoding=UTF8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0, exchange:test.direct, code:312, text:NOROUTE, routingKey:yel1low\r\n\r\n\r\n若交换机不存在，控制台打印：\r\n\r\n\r\n消息发送失败，收到NACK，原因：channel error; protocol method: method<channel.closereplycode=404, replytext=NOTFOUND  no exchange 'test.direct1' in vhost '/jixer', classid=60, methodid=40\r\n\r\n\r\n注意：在实际开发中，尽量不使用生产者确认机制（影响效率）。若一定要使用，无需开启 Publisher Return 机制，因为一般路由失败都是自己业务的问题，比如：交换机名字写出。对于 NACK 消息可以有限次数重试机，依然失败则记录异常消息\r\n\r\n MQ 可靠性\r\n\r\n 数据持久化\r\n\r\n数据持久化有三个方面：\r\n\r\n 交换机持久化\r\n 队列持久化\r\n 消息持久化\r\n\r\n当我们使用 SpringBoot 创建交换机、队列、消息的时候会默认使用持久化\r\n\r\n若我们不用持久化，重启一遍 RabbitMQ，这些数据就会丢失\r\n\r\n下面演示发送消息非持久化带来的问题：\r\n\r\n生产者\r\n\r\njava\r\n@Test\r\npublic void t8{\r\n    Message msg = MessageBuilder.withBody\"123123\".getBytesStandardCharsets.UTF8\r\n            .setDeliveryModeMessageDeliveryMode.NONPERSISTENT\r\n            .build;\r\n    forint i = 0; i < 1000000; i++{\r\n        rabbitTemplate.convertAndSend\"simple.queue\", msg;\r\n    }\r\n}\r\n\r\n\r\n无消费者，此时观察管理页面\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/124GHDhj.png\r\n\r\n可以看到，当消息增多，出现堆积，会造成 Page Out，MQ 会陷入短暂的阻塞，接收速度变为0，无法处理消息\r\n\r\n这是因为非持久的消息保存在内存中，MQ 会每隔一段时间当把消息存入内存，这段时间内会阻塞出现 Page Out\r\n\r\n若我们发送持久化就不会出现 Page Out 的问题\r\n\r\n Lazy Queue\r\n\r\nLazy Queue的特点：\r\n\r\n 接收的消息直接存入磁盘，也就是页面显示直接在 Page Out\r\n 消费者消费需要从磁盘读取并加载到内存中\r\n 支持百万条消息存储\r\n\r\n创建 Lazy Queue\r\n\r\n配置类方式\r\n\r\njava\r\n@Bean\r\npublic Queue lazyQueue{\r\n    return QueueBuilder.durable\"lazy.queue\".lazy.build;\r\n}\r\n\r\n\r\n注解方式\r\n\r\njava\r\n@RabbitListenerqueuesToDeclare = @Queue\r\n        name = \"lazy.queue\",\r\n        durable = \"true\",\r\n        arguments = @Argumentname = \"xqueuemode\", value = \"lazy\"\r\n\r\npublic void listenLazyQueueString msg {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n发送100万条消息，管理页面显示：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/dHDlkjae.png\r\n\r\n可以看到消息一直处于 Page Out，并且速率大部分时间都处于峰值\r\n\r\n 消费者的可靠性\r\n\r\n 消费者确认\r\n\r\n当消费者处理完消息后，可以告知 RabbitMQ 自己消息的处理状态，有三种状态：\r\n\r\n ACK：成功，MQ 删除消息\r\n NACK：失败，MQ 需要再次投递消息\r\n REJECT：失败并拒绝，MQ 删除消息（一般是出现消息格式错误）\r\n\r\n添加 yaml 依赖\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1  每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledgemode: auto  消费者消息确认类型\r\n\r\n\r\n消费者确认类型有三种：\r\n\r\n none：不做处理\r\n manual：手动模式\r\n auto：自动模式（默认）\r\n   业务异常返回 NACK\r\n   消息处理异常或校验异常返回 REJECT\r\n\r\n向 simple.queue 队列发送一条消息\r\n\r\n消费者\r\n\r\njava\r\n@RabbitListenerqueues = \"simple.queue\"\r\npublic void listenSimpleQueueString msg throws Exception {\r\n    log.info\"收到消息：{}\", msg;\r\n    throw new Exception\"故意的\";\r\n}\r\n\r\n\r\n若选择用 none 类型：走到异常，但这段代码还没走完，消息已经消费了，消息丢失\r\n\r\n若选用 auto 类型：走到异常后，业务返回 NACK，RabbitMQ 自动重新投递，直到消费成功为止；若将传参 String 类型换成其他类型（消息格式错误），业务代码返回 REJECT，MQ 会消费并删除消息\r\n\r\n 消费者失败重试\r\n\r\n上面消费者确认有个问题：经过消费者确认后一直失败一直在重试，一直在消耗系统资源\r\n\r\n解决办法：添加消费者失败重试\r\n\r\n当重试次数达一定次数后就自定义重试策略\r\n\r\n有三种重试策略：\r\n\r\n RepublishMessageRecoverer：将失败消息投递到指定的交换机处理\r\n RejectAndDontRequeueRecoverer：直接 REJECT，丢弃消息（默认）\r\n ImmediateRequeueMessageRecoverer：返回 NACK，消息重回入队\r\n\r\n这里选用 RepublishMessageRecoverer 策略\r\n\r\n添加 yaml 配置\r\n\r\nyaml\r\nspring:\r\n  rabbitmq:\r\n  \t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1  每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledgemode: auto  消费者消息确认类型\r\n     以下是开启消费者失败重试机制\r\n        retry:\r\n          enabled: true\r\n          initialinterval: 1000ms  初始失败的时长等待\r\n          multiplier: 1  失败后下次等待时常的倍数\r\n          maxattempts: 3  最大重连次数\r\n          stateless: true  true无状态，false有状态。如果业务包含事务，改为false\r\n\r\n\r\n新建一个 ErrorConfig 配置类，用于绑定失败处理交换机和队列，并设置失败处理策略\r\n\r\n通过 @ConditionalOnProperty 来限制只有当 yml 配置文件中 retry.enabled 为 true 的时候才创建 Bean\r\n\r\njava\r\n@Configuration\r\n@ConditionalOnPropertyprefix = \"spring.rabbitmq.listener.simple\", name = \"retry.enabled\", havingValue = \"true\" // 只有当前配置文件为true才创建bean\r\npublic class ErrorConfig {\r\n    @Bean\r\n    public DirectExchange errorExchange{\r\n        return new DirectExchange\"test.error\";\r\n    }\t\r\n    @Bean\r\n    public Queue errorQueue{\r\n        return new Queue\"error.queue\";\r\n    }\r\n    @Bean\r\n    public Binding binding{\r\n        return BindingBuilder.binderrorQueue.toerrorExchange.with\"error\";\r\n    }\r\n    @Bean\r\n    public MessageRecoverer messageRecovererRabbitTemplate rabbitTemplate{\r\n        return new RepublishMessageRecovererrabbitTemplate, \"test.error\", \"error\";\r\n    }\r\n}\r\n\r\n\r\n在消费者代码处抛出异常，会看到当重试三次后，会将失败消息发送错误处理交换机，再由交换机转发到队列，后面由人工进行处理\r\n\r\n错误消息如下：可以看清楚的看到那块地方出错了\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/d12HSyrash.png\r\n\r\n 消费者的幂等性\r\n\r\n通过上述消费者的确认和消费者的失败重试，可以保证消费者至少能够把消息消费一次，但是可能出现多次消费的情况，多次消费可能导致数据错误\r\n\r\n幂等：执行一次和执行多次对业务的结果是一样的\r\n\r\n方案一：唯一消息 ID\r\n\r\n给每个消息设置一个唯一的 ID，每次消费者进行消费的时候将 ID 保存入数据库，下次消费前先判断数据库是否已经存在 ID，存在就代表已经消费，否则就可以消费\r\n\r\n修改消息转化器，设置自动创建消息 ID\r\n\r\njava\r\n@Bean\r\npublic MessageConverter jackMessageConverter{\r\n    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter;\r\n    jackson2JsonMessageConverter.setCreateMessageIdstrue;\r\n    return jackson2JsonMessageConverter;\r\n}\r\n\r\n\r\n创建后的消息如图所示：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/sadJ1.png\r\n\r\n方案二：业务判断\r\n\r\n根据业务的需求来判断，比如：支付服务完成后发送消息给订单服务，订单服务需要将订单状态由未支付变为已支付，所以这里只需要对未支付的订单进行消费即可，已支付的订单不需要再次处理\r\n\r\n具体的 SQL 语句变为：\r\n\r\nsql\r\nupdate tborder set status = 1 where id = xxx and status = 2\r\n\r\n\r\n只需要对数据库操作一次就满足了要求，而方案一需要对数据库进行多次操作（查询，更新）\r\n\r\n 延迟消息\r\n\r\n 死信交换机\r\n\r\n创建队列与交换，关系如图所示：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/asdUI1g.png\r\n\r\nsimple.direct 交换机绑定 simple.queue 队列， simple.queue 绑定 dlx.direct 死信交换机\r\n\r\n创建 simple.queue 的时候绑定死信交换机方法如下：\r\n\r\nhttps://gitee.com/lijunxi666/picturebed/raw/master/rabbitmq/dKLHJh.png\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t10{\r\n    rabbitTemplate.convertAndSend\"simple.direct\", \"simple\", \"你好\", new MessagePostProcessor {\r\n        @Override\r\n        public Message postProcessMessageMessage message throws AmqpException {\r\n            message.getMessageProperties.setExpiration\"10000\"; // 设置过期时间\r\n            return message;\r\n        }\r\n    };\r\n    log.info\"发送消息\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerqueues = \"dlx.queue\"\r\npublic void listenDlxQueueString msg {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\n生产者发送过期时间为10s消息，消费者监听的是死信队列，并不是监听的是 simple.queue 这个队列\r\n\r\n因为 simple.queue 队列的消息没有被消费，所以当10s后消息会被发送到死信交换机，死信交换机转发到死信队列\r\n\r\n 消息延迟插件\r\n\r\n消息延迟与死信交换机不同，它是将消息发送到交换机，在交换机中暂存一段时间后再投递到队列中\r\n\r\n插件下载地址：rabbitmq/rabbitmqdelayedmessageexchangehttps://github.com/rabbitmq/rabbitmqdelayedmessageexchange/releases\r\n\r\n进入 RabbitMQ 插件目录执行以下命令开启插件\r\n\r\n\r\nrabbitmqplugins enable rabbitmqdelayedmessageexchange\r\n\r\n\r\n生产者：\r\n\r\njava\r\n@Test\r\npublic void t11{\r\n    rabbitTemplate.convertAndSend\"delay.direct\", \"hi\", \"你好\", new MessagePostProcessor {\r\n        @Override\r\n        public Message postProcessMessageMessage message throws AmqpException {\r\n            message.getMessageProperties.setDelay10000; // 设置延迟时间\r\n            return message;\r\n        }\r\n    };\r\n    log.info\"发送消息\";\r\n}\r\n\r\n\r\n消费者：\r\n\r\njava\r\n@RabbitListenerbindings = @QueueBinding\r\n        value = @Queuename = \"delay.queue\", durable = \"true\",\r\n        exchange = @Exchangename = \"delay.direct\", delayed = \"true\",\r\n        key = {\"hi\", \"hello\"}\r\n\r\npublic void listenDelayQueueString msg throws InterruptedException {\r\n    log.info\"消费者收到消息：....{}\", msg;\r\n}\r\n\r\n\r\nRabbitMQ 的延迟消息是有一定的功能损耗的，所以适用于延迟时间不太长的场景\r\n\r\n在一般的超时订单场景中，若设置的超时时间为30分钟，会存在两个问题：\r\n\r\n 若并发高，30分钟可能堆积消息过多，MQ 压力大\r\n 大多数订单在下单后1分钟内就会支付，但是 MQ 却需要等待30分钟，浪费资源\r\n\r\n解决方法：设置消息过期时间梯度数组，将30分钟拆分为多个小部分，每个部分个根据可能支付的概率选用合适的等大时间\r\n"},{"filename":"zhi-fu-bao","category":"middleware","md":{"topSummary":"\ntitle: SpringBoot整合支付宝支付\ncategory: SpringBoot,中间件\ndate: 2024-01-27\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 依赖\n\n```xml\n<alipay-easysdk.version>2.2.0</alipay-easysdk.version>\n\n<dependency>\n    <groupId>com.alipay.sdk</groupId>\n    <artifactId>alipay-easysdk</artifactId>\n    <version>${alipay-easysdk.version}</version>\n</dependency>\n```\n\n## 配置\n\n**yml配置文件**\n\n```yaml\nalipay:\n  appId: # AppID\n  appPrivateKey: # 密钥\n  alipayPublicKey: # 公钥\n  notifyUrl: # 回调地址【需要用到内网穿透】\n  gateway: openapi-sandbox.dl.alipaydev.com\n  returnUrl: http://localhost:8080  # 支付成功后返回的地址【我这里设置的是返回前端首页】\n```\n\n**配置类**\n\n```java\n@Data\n@Slf4j\n@Component\n@ConfigurationProperties(prefix = \"alipay\")\npublic class AliPayConfig {\n   private String appId;\n   private String appPrivateKey;\n   private String alipayPublicKey;\n   private String notifyUrl;\n   private String gateway;\n   private String returnUrl;\n\n   @PostConstruct\n   public void init() {\n      // 设置参数（全局只需设置一次）\n      Config config = new Config();\n      config.protocol = \"https\";\n      config.gatewayHost = this.gateway;\n      config.signType = \"RSA2\";\n      config.appId = this.appId;\n      config.merchantPrivateKey = this.appPrivateKey;\n      config.alipayPublicKey = this.alipayPublicKey;\n      config.notifyUrl = this.notifyUrl;\n      Factory.setOptions(config);\n      log.info(\"支付宝SDK初始化成功\");\n   }\n\n}\n```\n\n## 接口\n\n这里需要两个接口，一个是创建支付表单的接口，一个是支付结果异步回调的接口【必须是POST请求，而且返回值必须是success或者是failure字符串类型】\n\n>  说明一下：第一个接口的主要作用是返回具有html代码的支付宝支付表单页面，就这个功能；第二个接口的作用是对支付接口进行验签，看是否支付成功\n\n```java\n@Api(tags = \"支付接口\")\n@RestController\n@RequestMapping(\"/pay\")\npublic class PayController {\n\n    @Autowired\n    private PayService payService;\n\n    @ApiOperation(\"付款\")\n    @GetMapping(\"/payment/{orderId}\")\n    public Result<String> pay(@PathVariable(\"orderId\") Long orderId) {\n        String form = payService.pay(orderId);\n\n        return Result.success(form, \"付款成功\");\n    }\n\n    @ApiOperation(\"异步回调结果\")\n    @PostMapping(\"/callback\")\n    public String callback(HttpServletRequest request){\n        return payService.callback(request);\n    }\n\n}\n```\n\n## 方法\n\n第一个接口的实现方法\n\n```java\n@Override\npublic String pay(Long orderId) {\n    // 获取订单信息\n    CourseOrderEntity courseOrderEntity = courseOrderService.getById(orderId);\n    if (courseOrderEntity.getPaymentStatus() == 3){\n        throw new KunKeException(\"订单已经失效\");\n    } else if (courseOrderEntity.getPaymentStatus() == 2){\n        throw new KunKeException(\"订单已付款\");\n    }\n\n    // 支付标题\n    String subject = courseOrderEntity.getCourseTitle();\n    // 支付订单编号\n    String tradeNo = generateTradeNo();\n    // 价格\n    String price = courseOrderEntity.getResPrice().toString();\n    // 创建网页支付\n    AlipayTradePagePayResponse response;\n    String res = null;\n    try {\n        // 发起API调用（以创建当面付收款二维码为例）\n        // \"http://localhost:8080\"是返回前端的地址，为了方便我就直接写死了\n        response = Factory.Payment.Page()\n                .pay(subject, tradeNo, price, \"http://localhost:8080\");\n        if (ResponseChecker.success(response)) {\n            // 更新订单编号\n            courseOrderService.update(new LambdaUpdateWrapper<CourseOrderEntity>()\n                            .set(CourseOrderEntity::getPaymentId, tradeNo)\n                            .eq(CourseOrderEntity::getId, orderId));\n            res = response.getBody();\n        }\n    } catch (Exception e) {\n        log.error(\"支付出错：{}\", e.toString());\n        throw new KunKeException(\"支付出错\");\n    }\n    return res;\n}\n\n/**\n* 通过时间生成外部订单号 out_trade_no\n* @return\n*/\nprivate String generateTradeNo() {\n   DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmssSSS\");\n   String tradeNo = LocalDateTime.now(ZoneOffset.of(\"+8\")).format(formatter);\n   return tradeNo;\n}\n```\n\n第二个接口的实现方法\n\n```java\n@Override\npublic String callback(HttpServletRequest request) {\n    // 获取支付宝的请求信息\n    // 将Map<String, String[]>转为Map<String, String>\n    Map<String, String> params = new HashMap<>();\n    Map<String, String[]> requestParams = request.getParameterMap();\n    for (String name : requestParams.keySet()) {\n        params.put(name, request.getParameter(name));\n    }\n\n    try {\n        // 验签\n        boolean signVerified = Factory.Payment.Common().verifyNotify(params);\n        if (signVerified) {\n            // 验签通过\n            // 更新付款状态为已支付\n            Long paymentId = Long.valueOf(params.get(\"out_trade_no\"));\n            CourseOrderEntity one = courseOrderService.getOne(new LambdaQueryWrapper<CourseOrderEntity>().eq(CourseOrderEntity::getPaymentId, paymentId));\n            one.setPaymentStatus(2);\n            one.setPaymentTime(LocalDateTime.now());\n            courseOrderService.updateById(one);\n            // 存入redis\n            stringRedisTemplate.opsForValue().set(COURSE_USER_BUY + one.getUsername() + \":\" + one.getCourseId(), \"1\");\n            return \"success\";\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    // 验签失败\n    return \"failure\";\n}\n```\n\n## 使用\n\n前端调用`/pay/payment/${id}`就能够看到一个支付宝表单页面【如果配置没出错的情况下】，支付成功后会异步调用回调的接口进行验签\n","title":" SpringBoot整合支付宝支付\n","category":[" SpringBoot","中间件\n"],"date":" 2024-01-27\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 依赖\n\nxml\n<alipayeasysdk.version2.2.0</alipayeasysdk.version\n\n<dependency\n    <groupIdcom.alipay.sdk</groupId\n    <artifactIdalipayeasysdk</artifactId\n    <version${alipayeasysdk.version}</version\n</dependency\n\n\n 配置\n\nyml配置文件\n\nyaml\nalipay:\n  appId:  AppID\n  appPrivateKey:  密钥\n  alipayPublicKey:  公钥\n  notifyUrl:  回调地址【需要用到内网穿透】\n  gateway: openapisandbox.dl.alipaydev.com\n  returnUrl: http://localhost:8080   支付成功后返回的地址【我这里设置的是返回前端首页】\n\n\n配置类\n\njava\n@Data\n@Slf4j\n@Component\n@ConfigurationPropertiesprefix = \"alipay\"\npublic class AliPayConfig {\n   private String appId;\n   private String appPrivateKey;\n   private String alipayPublicKey;\n   private String notifyUrl;\n   private String gateway;\n   private String returnUrl;\n\n   @PostConstruct\n   public void init {\n      // 设置参数（全局只需设置一次）\n      Config config = new Config;\n      config.protocol = \"https\";\n      config.gatewayHost = this.gateway;\n      config.signType = \"RSA2\";\n      config.appId = this.appId;\n      config.merchantPrivateKey = this.appPrivateKey;\n      config.alipayPublicKey = this.alipayPublicKey;\n      config.notifyUrl = this.notifyUrl;\n      Factory.setOptionsconfig;\n      log.info\"支付宝SDK初始化成功\";\n   }\n\n}\n\n\n 接口\n\n这里需要两个接口，一个是创建支付表单的接口，一个是支付结果异步回调的接口【必须是POST请求，而且返回值必须是success或者是failure字符串类型】\n\n  说明一下：第一个接口的主要作用是返回具有html代码的支付宝支付表单页面，就这个功能；第二个接口的作用是对支付接口进行验签，看是否支付成功\n\njava\n@Apitags = \"支付接口\"\n@RestController\n@RequestMapping\"/pay\"\npublic class PayController {\n\n    @Autowired\n    private PayService payService;\n\n    @ApiOperation\"付款\"\n    @GetMapping\"/payment/{orderId}\"\n    public Result<String pay@PathVariable\"orderId\" Long orderId {\n        String form = payService.payorderId;\n\n        return Result.successform, \"付款成功\";\n    }\n\n    @ApiOperation\"异步回调结果\"\n    @PostMapping\"/callback\"\n    public String callbackHttpServletRequest request{\n        return payService.callbackrequest;\n    }\n\n}\n\n\n 方法\n\n第一个接口的实现方法\n\njava\n@Override\npublic String payLong orderId {\n    // 获取订单信息\n    CourseOrderEntity courseOrderEntity = courseOrderService.getByIdorderId;\n    if courseOrderEntity.getPaymentStatus == 3{\n        throw new KunKeException\"订单已经失效\";\n    } else if courseOrderEntity.getPaymentStatus == 2{\n        throw new KunKeException\"订单已付款\";\n    }\n\n    // 支付标题\n    String subject = courseOrderEntity.getCourseTitle;\n    // 支付订单编号\n    String tradeNo = generateTradeNo;\n    // 价格\n    String price = courseOrderEntity.getResPrice.toString;\n    // 创建网页支付\n    AlipayTradePagePayResponse response;\n    String res = null;\n    try {\n        // 发起API调用（以创建当面付收款二维码为例）\n        // \"http://localhost:8080\"是返回前端的地址，为了方便我就直接写死了\n        response = Factory.Payment.Page\n                .paysubject, tradeNo, price, \"http://localhost:8080\";\n        if ResponseChecker.successresponse {\n            // 更新订单编号\n            courseOrderService.updatenew LambdaUpdateWrapper<CourseOrderEntity\n                            .setCourseOrderEntity::getPaymentId, tradeNo\n                            .eqCourseOrderEntity::getId, orderId;\n            res = response.getBody;\n        }\n    } catch Exception e {\n        log.error\"支付出错：{}\", e.toString;\n        throw new KunKeException\"支付出错\";\n    }\n    return res;\n}\n\n/\n 通过时间生成外部订单号 outtradeno\n @return\n/\nprivate String generateTradeNo {\n   DateTimeFormatter formatter = DateTimeFormatter.ofPattern\"yyyyMMddHHmmssSSS\";\n   String tradeNo = LocalDateTime.nowZoneOffset.of\"+8\".formatformatter;\n   return tradeNo;\n}\n\n\n第二个接口的实现方法\n\njava\n@Override\npublic String callbackHttpServletRequest request {\n    // 获取支付宝的请求信息\n    // 将Map<String, String转为Map<String, String\n    Map<String, String params = new HashMap<;\n    Map<String, String requestParams = request.getParameterMap;\n    for String name : requestParams.keySet {\n        params.putname, request.getParametername;\n    }\n\n    try {\n        // 验签\n        boolean signVerified = Factory.Payment.Common.verifyNotifyparams;\n        if signVerified {\n            // 验签通过\n            // 更新付款状态为已支付\n            Long paymentId = Long.valueOfparams.get\"outtradeno\";\n            CourseOrderEntity one = courseOrderService.getOnenew LambdaQueryWrapper<CourseOrderEntity.eqCourseOrderEntity::getPaymentId, paymentId;\n            one.setPaymentStatus2;\n            one.setPaymentTimeLocalDateTime.now;\n            courseOrderService.updateByIdone;\n            // 存入redis\n            stringRedisTemplate.opsForValue.setCOURSEUSERBUY + one.getUsername + \":\" + one.getCourseId, \"1\";\n            return \"success\";\n        }\n    } catch Exception e {\n        e.printStackTrace;\n    }\n\n    // 验签失败\n    return \"failure\";\n}\n\n\n 使用\n\n前端调用/pay/payment/${id}就能够看到一个支付宝表单页面【如果配置没出错的情况下】，支付成功后会异步调用回调的接口进行验签\n"},{"filename":"minio","category":"middleware","md":{"topSummary":"\ntitle: SpringBoot整合Minio\ncategory: Minio,中间件\ndate: 2024-01-26\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 简介\n\n**MinIO** 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。\n\n## 安装\n\n采用docker拉取\n\n```bash\ndocker pull minio/minio\n```\n\n运行\n\n> 终端的端口在9001，java代码调用接口端口在9092\n\n```bash\ndocker run -d -p 9001:9000 -p 9092:9090 --name minio -e \"MINIO_ACCESS_KEY=minioadmin\" -e \"MINIO_SECRET_KEY=minioadmin\" -v /usr/bin/lijunxi/minio/data:/data -v /usr/bin/lijunxi/minio/config:/root/.minio minio/minio server /data --console-address \":9000\" -address \":9090\"\n```\n\n## 整合\n\n**引入jar包**\n\n```xml\n<minio-version>8.0.3</minio-version>\n<okhttp.version>4.8.1</okhttp.version>\n\n<dependency>\n    <groupId>io.minio</groupId>\n    <artifactId>minio</artifactId>\n    <version>${minio-version}</version>\n</dependency>\n<dependency>\n    <groupId>com.squareup.okhttp3</groupId>\n    <artifactId>okhttp</artifactId>\n    <version>${okhttp.version}</version>\n</dependency>\n```\n\n**yml配置文件**\n\n```yml\nminio:\n  endpoint: http://192.168.101.130:9092/  # minio的链接【需要用的Java连接端口】\n  accessKey: minioadmin # 默认账号\n  secretKey: minioadmin # 默认密码\n  bucket: xxxx\n```\n\n**minio配置类**\n\n用于进行minio配置，设置桶的链接对象\n\n```java\n@Configuration\npublic class MinioConfig {\n\n    @Value(\"${minio.endpoint}\")\n    private String endpoint;\n    @Value(\"${minio.accessKey}\")\n    private String accessKey;\n    @Value(\"${minio.secretKey}\")\n    private String secretKey;\n\n    @Bean\n    public MinioClient minioClient() {\n\n        MinioClient minioClient =\n                MinioClient.builder()\n                        .endpoint(endpoint)\n                        .credentials(accessKey, secretKey)\n                        .build();\n        return minioClient;\n    }\n}\n```\n\n### **上传文件**\n\n> localFilePath：本地文件路径\n> mimeType：文件的mineType\n> bucket：桶\n> objectName：需要上传到minio的文件名【可以自定义路径】\n\n```java\n@Autowired\nMinioClient minioClient;\n\n@Override\npublic boolean addFilesToMinIO(String localFilePath, String mimeType, String bucket, String objectName) {\n    try {\n        UploadObjectArgs testbucket = UploadObjectArgs.builder()\n                .bucket(bucket)\n                .object(objectName)\n                .filename(localFilePath)\n                .contentType(mimeType)\n                .build();\n        minioClient.uploadObject(testbucket);\n        log.debug(\"上传文件到minio成功,bucket:{},objectName:{}\", bucket, objectName);\n        return true;\n    } catch (Exception e) {\n        e.printStackTrace();\n        log.error(\"上传文件到minio出错,bucket:{},objectName:{},错误原因:{}\", bucket, objectName, e.getMessage(), e);\n        throw new KunKeException(\"上传文件到文件系统失败\");\n    }\n}\n```\n\n根据文件后缀获取mimeType\n\n```java\nprivate String getMimeType(String extension) {\n    if (extension == null)\n        extension = \"\";\n    // 根据扩展名取出mimeType\n    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(extension);\n    / /通用mimeType，字节流\n    String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;\n    if (extensionMatch != null) {\n        mimeType = extensionMatch.getMimeType();\n    }\n    return mimeType;\n}\n```\n\n### **下载文件**\n\n```java\n@Override\npublic File downloadFileFromMinIO(String bucket, String objectName) {\n    //临时文件\n    File minioFile = null;\n    FileOutputStream outputStream = null;\n    try {\n        InputStream stream = minioClient.getObject(GetObjectArgs.builder()\n                .bucket(bucket)\n                .object(objectName)\n                .build());\n        //创建临时文件\n        minioFile = File.createTempFile(\"minio\", \".merge\");\n        outputStream = new FileOutputStream(minioFile);\n        IOUtils.copy(stream, outputStream);\n        return minioFile;\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (outputStream != null) {\n            try {\n                outputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n```\n\n### **删除文件**\n\n删除单个文件：`RemoveObjectArgs`\n\n```java\n@Test\npublic void test_delete() throws Exception {\n    // RemoveObjectArgs\n    RemoveObjectArgs removeObjectArgs = RemoveObjectArgs.builder().bucket(\"testbucket\").object(\"qq.jpg\").build();\t \n    // 删除文件\n    minioClient.removeObject(removeObjectArgs);\n}\n```\n\n批量删除文件：`RemoveObjectsArgs`\n\n```java\nprivate void clearChunkFiles(String chunkFileFolderPath, int chunkTotal) {\n\n    try {\n        List<DeleteObject> deleteObjects = Stream.iterate(0, i -> ++i)\n                .limit(chunkTotal)\n                .map(i -> new DeleteObject(chunkFileFolderPath.concat(Integer.toString(i))))\n                .collect(Collectors.toList());\n\n        RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder().bucket(bucket).objects(deleteObjects).build();\n        Iterable<Result<DeleteError>> results = minioClient.removeObjects(removeObjectsArgs);\n        results.forEach(r -> {\n            DeleteError deleteError = null;\n            try {\n                deleteError = r.get();\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                log.error(\"清楚分块文件失败,objectname:{}\", deleteError.objectName(), e);\n            }\n        });\n    } catch (Exception e) {\n        e.printStackTrace();\n        log.error(\"清楚分块文件失败,chunkFileFolderPath:{}\", chunkFileFolderPath, e);\n    }\n}\n```\n\n### 访问\n\nMinio文件的访问都是通过yml配置中的 `endpoint + bucket + 自定义的objectName` 来进行访问\n\n例如我的一个图片访问路径：`http://192.168.101.130:9092/kunke/2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png`\n\n- `http://192.168.101.130:9092`：endpoint\n\n- `kunke`：bucket\n\n- `2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png`：自定义的文件路径【包含文件名】\n","title":" SpringBoot整合Minio\n","category":[" Minio","中间件\n"],"date":" 2024-01-26\n","author":" Jixer\n","source":" 原创\n\n"},"simpleMd":"\n\n 简介\n\nMinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。\n\n 安装\n\n采用docker拉取\n\nbash\ndocker pull minio/minio\n\n\n运行\n\n 终端的端口在9001，java代码调用接口端口在9092\n\nbash\ndocker run d p 9001:9000 p 9092:9090 name minio e \"MINIOACCESSKEY=minioadmin\" e \"MINIOSECRETKEY=minioadmin\" v /usr/bin/lijunxi/minio/data:/data v /usr/bin/lijunxi/minio/config:/root/.minio minio/minio server /data consoleaddress \":9000\" address \":9090\"\n\n\n 整合\n\n引入jar包\n\nxml\n<minioversion8.0.3</minioversion\n<okhttp.version4.8.1</okhttp.version\n\n<dependency\n    <groupIdio.minio</groupId\n    <artifactIdminio</artifactId\n    <version${minioversion}</version\n</dependency\n<dependency\n    <groupIdcom.squareup.okhttp3</groupId\n    <artifactIdokhttp</artifactId\n    <version${okhttp.version}</version\n</dependency\n\n\nyml配置文件\n\nyml\nminio:\n  endpoint: http://192.168.101.130:9092/   minio的链接【需要用的Java连接端口】\n  accessKey: minioadmin  默认账号\n  secretKey: minioadmin  默认密码\n  bucket: xxxx\n\n\nminio配置类\n\n用于进行minio配置，设置桶的链接对象\n\njava\n@Configuration\npublic class MinioConfig {\n\n    @Value\"${minio.endpoint}\"\n    private String endpoint;\n    @Value\"${minio.accessKey}\"\n    private String accessKey;\n    @Value\"${minio.secretKey}\"\n    private String secretKey;\n\n    @Bean\n    public MinioClient minioClient {\n\n        MinioClient minioClient =\n                MinioClient.builder\n                        .endpointendpoint\n                        .credentialsaccessKey, secretKey\n                        .build;\n        return minioClient;\n    }\n}\n\n\n 上传文件\n\n localFilePath：本地文件路径\n mimeType：文件的mineType\n bucket：桶\n objectName：需要上传到minio的文件名【可以自定义路径】\n\njava\n@Autowired\nMinioClient minioClient;\n\n@Override\npublic boolean addFilesToMinIOString localFilePath, String mimeType, String bucket, String objectName {\n    try {\n        UploadObjectArgs testbucket = UploadObjectArgs.builder\n                .bucketbucket\n                .objectobjectName\n                .filenamelocalFilePath\n                .contentTypemimeType\n                .build;\n        minioClient.uploadObjecttestbucket;\n        log.debug\"上传文件到minio成功,bucket:{},objectName:{}\", bucket, objectName;\n        return true;\n    } catch Exception e {\n        e.printStackTrace;\n        log.error\"上传文件到minio出错,bucket:{},objectName:{},错误原因:{}\", bucket, objectName, e.getMessage, e;\n        throw new KunKeException\"上传文件到文件系统失败\";\n    }\n}\n\n\n根据文件后缀获取mimeType\n\njava\nprivate String getMimeTypeString extension {\n    if extension == null\n        extension = \"\";\n    // 根据扩展名取出mimeType\n    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatchextension;\n    / /通用mimeType，字节流\n    String mimeType = MediaType.APPLICATIONOCTETSTREAMVALUE;\n    if extensionMatch = null {\n        mimeType = extensionMatch.getMimeType;\n    }\n    return mimeType;\n}\n\n\n 下载文件\n\njava\n@Override\npublic File downloadFileFromMinIOString bucket, String objectName {\n    //临时文件\n    File minioFile = null;\n    FileOutputStream outputStream = null;\n    try {\n        InputStream stream = minioClient.getObjectGetObjectArgs.builder\n                .bucketbucket\n                .objectobjectName\n                .build;\n        //创建临时文件\n        minioFile = File.createTempFile\"minio\", \".merge\";\n        outputStream = new FileOutputStreamminioFile;\n        IOUtils.copystream, outputStream;\n        return minioFile;\n    } catch Exception e {\n        e.printStackTrace;\n    } finally {\n        if outputStream = null {\n            try {\n                outputStream.close;\n            } catch IOException e {\n                e.printStackTrace;\n            }\n        }\n    }\n    return null;\n}\n\n\n 删除文件\n\n删除单个文件：RemoveObjectArgs\n\njava\n@Test\npublic void testdelete throws Exception {\n    // RemoveObjectArgs\n    RemoveObjectArgs removeObjectArgs = RemoveObjectArgs.builder.bucket\"testbucket\".object\"qq.jpg\".build;\t \n    // 删除文件\n    minioClient.removeObjectremoveObjectArgs;\n}\n\n\n批量删除文件：RemoveObjectsArgs\n\njava\nprivate void clearChunkFilesString chunkFileFolderPath, int chunkTotal {\n\n    try {\n        List<DeleteObject deleteObjects = Stream.iterate0, i  ++i\n                .limitchunkTotal\n                .mapi  new DeleteObjectchunkFileFolderPath.concatInteger.toStringi\n                .collectCollectors.toList;\n\n        RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder.bucketbucket.objectsdeleteObjects.build;\n        Iterable<Result<DeleteError results = minioClient.removeObjectsremoveObjectsArgs;\n        results.forEachr  {\n            DeleteError deleteError = null;\n            try {\n                deleteError = r.get;\n\n            } catch Exception e {\n                e.printStackTrace;\n                log.error\"清楚分块文件失败,objectname:{}\", deleteError.objectName, e;\n            }\n        };\n    } catch Exception e {\n        e.printStackTrace;\n        log.error\"清楚分块文件失败,chunkFileFolderPath:{}\", chunkFileFolderPath, e;\n    }\n}\n\n\n 访问\n\nMinio文件的访问都是通过yml配置中的 endpoint + bucket + 自定义的objectName 来进行访问\n\n例如我的一个图片访问路径：http://192.168.101.130:9092/kunke/2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png\n\n http://192.168.101.130:9092：endpoint\n\n kunke：bucket\n\n 2024/01/25/36d7c1e3144c2feb8a10db7f561fbab6.png：自定义的文件路径【包含文件名】\n"}]