{"filename":"zhi-fu-bao","category":"middleware","md":{"topSummary":"\ntitle: SpringBoot整合支付宝支付\ncategory: SpringBoot,中间件\ndate: 2024-01-27\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 依赖\n\n```xml\n<alipay-easysdk.version>2.2.0</alipay-easysdk.version>\n\n<dependency>\n    <groupId>com.alipay.sdk</groupId>\n    <artifactId>alipay-easysdk</artifactId>\n    <version>${alipay-easysdk.version}</version>\n</dependency>\n```\n\n## 配置\n\n**yml配置文件**\n\n```yaml\nalipay:\n  appId: # AppID\n  appPrivateKey: # 密钥\n  alipayPublicKey: # 公钥\n  notifyUrl: # 回调地址【需要用到内网穿透】\n  gateway: openapi-sandbox.dl.alipaydev.com\n  returnUrl: http://localhost:8080  # 支付成功后返回的地址【我这里设置的是返回前端首页】\n```\n\n**配置类**\n\n```java\n@Data\n@Slf4j\n@Component\n@ConfigurationProperties(prefix = \"alipay\")\npublic class AliPayConfig {\n   private String appId;\n   private String appPrivateKey;\n   private String alipayPublicKey;\n   private String notifyUrl;\n   private String gateway;\n   private String returnUrl;\n\n   @PostConstruct\n   public void init() {\n      // 设置参数（全局只需设置一次）\n      Config config = new Config();\n      config.protocol = \"https\";\n      config.gatewayHost = this.gateway;\n      config.signType = \"RSA2\";\n      config.appId = this.appId;\n      config.merchantPrivateKey = this.appPrivateKey;\n      config.alipayPublicKey = this.alipayPublicKey;\n      config.notifyUrl = this.notifyUrl;\n      Factory.setOptions(config);\n      log.info(\"支付宝SDK初始化成功\");\n   }\n\n}\n```\n\n## 接口\n\n这里需要两个接口，一个是创建支付表单的接口，一个是支付结果异步回调的接口【必须是POST请求，而且返回值必须是success或者是failure字符串类型】\n\n>  说明一下：第一个接口的主要作用是返回具有html代码的支付宝支付表单页面，就这个功能；第二个接口的作用是对支付接口进行验签，看是否支付成功\n\n```java\n@Api(tags = \"支付接口\")\n@RestController\n@RequestMapping(\"/pay\")\npublic class PayController {\n\n    @Autowired\n    private PayService payService;\n\n    @ApiOperation(\"付款\")\n    @GetMapping(\"/payment/{orderId}\")\n    public Result<String> pay(@PathVariable(\"orderId\") Long orderId) {\n        String form = payService.pay(orderId);\n\n        return Result.success(form, \"付款成功\");\n    }\n\n    @ApiOperation(\"异步回调结果\")\n    @PostMapping(\"/callback\")\n    public String callback(HttpServletRequest request){\n        return payService.callback(request);\n    }\n\n}\n```\n\n## 方法\n\n第一个接口的实现方法\n\n```java\n@Override\npublic String pay(Long orderId) {\n    // 获取订单信息\n    CourseOrderEntity courseOrderEntity = courseOrderService.getById(orderId);\n    if (courseOrderEntity.getPaymentStatus() == 3){\n        throw new KunKeException(\"订单已经失效\");\n    } else if (courseOrderEntity.getPaymentStatus() == 2){\n        throw new KunKeException(\"订单已付款\");\n    }\n\n    // 支付标题\n    String subject = courseOrderEntity.getCourseTitle();\n    // 支付订单编号\n    String tradeNo = generateTradeNo();\n    // 价格\n    String price = courseOrderEntity.getResPrice().toString();\n    // 创建网页支付\n    AlipayTradePagePayResponse response;\n    String res = null;\n    try {\n        // 发起API调用（以创建当面付收款二维码为例）\n        // \"http://localhost:8080\"是返回前端的地址，为了方便我就直接写死了\n        response = Factory.Payment.Page()\n                .pay(subject, tradeNo, price, \"http://localhost:8080\");\n        if (ResponseChecker.success(response)) {\n            // 更新订单编号\n            courseOrderService.update(new LambdaUpdateWrapper<CourseOrderEntity>()\n                            .set(CourseOrderEntity::getPaymentId, tradeNo)\n                            .eq(CourseOrderEntity::getId, orderId));\n            res = response.getBody();\n        }\n    } catch (Exception e) {\n        log.error(\"支付出错：{}\", e.toString());\n        throw new KunKeException(\"支付出错\");\n    }\n    return res;\n}\n\n/**\n* 通过时间生成外部订单号 out_trade_no\n* @return\n*/\nprivate String generateTradeNo() {\n   DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmssSSS\");\n   String tradeNo = LocalDateTime.now(ZoneOffset.of(\"+8\")).format(formatter);\n   return tradeNo;\n}\n```\n\n第二个接口的实现方法\n\n```java\n@Override\npublic String callback(HttpServletRequest request) {\n    // 获取支付宝的请求信息\n    // 将Map<String, String[]>转为Map<String, String>\n    Map<String, String> params = new HashMap<>();\n    Map<String, String[]> requestParams = request.getParameterMap();\n    for (String name : requestParams.keySet()) {\n        params.put(name, request.getParameter(name));\n    }\n\n    try {\n        // 验签\n        boolean signVerified = Factory.Payment.Common().verifyNotify(params);\n        if (signVerified) {\n            // 验签通过\n            // 更新付款状态为已支付\n            Long paymentId = Long.valueOf(params.get(\"out_trade_no\"));\n            CourseOrderEntity one = courseOrderService.getOne(new LambdaQueryWrapper<CourseOrderEntity>().eq(CourseOrderEntity::getPaymentId, paymentId));\n            one.setPaymentStatus(2);\n            one.setPaymentTime(LocalDateTime.now());\n            courseOrderService.updateById(one);\n            // 存入redis\n            stringRedisTemplate.opsForValue().set(COURSE_USER_BUY + one.getUsername() + \":\" + one.getCourseId(), \"1\");\n            return \"success\";\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    // 验签失败\n    return \"failure\";\n}\n```\n\n## 使用\n\n前端调用`/pay/payment/${id}`就能够看到一个支付宝表单页面【如果配置没出错的情况下】，支付成功后会异步调用回调的接口进行验签\n","title":" SpringBoot整合支付宝支付\n","category":[" SpringBoot","中间件\n"],"date":" 2024-01-27\n","author":" Jixer\n","source":" 原创\n\n"}}