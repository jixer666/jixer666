{"filename":"springsecurity-learn","category":"java","md":{"topSummary":"\ntitle: SpringSecurity学习笔记\ncategory: Java,SpringSecurity\ndate: 2024-01-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n两个核心功能：**认证**和**授权**\n\n## 基本原理\n\n### 拦截器链\n\nSpringSecurity本质是一个过滤器链，在 SpringBoot 2.3.4.RELEASE中，共有15种拦截器，如图所示：\n\n![](../../.vuepress/public/assets/article/springsecurity-filter/dkhd21HR825.png)\n\n```\norg.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter org.springframework.security.web.context.SecurityContextPersistenceFilter  org.springframework.security.web.header.HeaderWriterFilter org.springframework.security.web.csrf.CsrfFilter org.springframework.security.web.authentication.logout.LogoutFilter  org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter  org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter  org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter org.springframework.security.web.savedrequest.RequestCacheAwareFilter org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter org.springframework.security.web.authentication.AnonymousAuthenticationFilter  org.springframework.security.web.session.SessionManagementFilter  org.springframework.security.web.access.ExceptionTranslationFilter  org.springframework.security.web.access.intercept.FilterSecurityIntercepto\n```\n\n重点三个：\n\n`FilterSecurityInterceptor`：是一个方法级的权限过滤器, 基本位于过滤链的最底部。\n\n`ExceptionTranslationFilter`：是个异常过滤器，用来处理在认证授权过程中抛出的异常\n\n`UsernamePasswordAuthenticationFilter` ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码\n\n### 主要拦截器介绍\n\n#### SecurityContextPersistenceFilter\n\n包路径：org.springframework.security.web.context\n\n负责将安全上下文存储在 HttpSession 中，以便在后续请求中访问\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    // 判断是否是第一次请求\n    if (request.getAttribute(\"__spring_security_scpf_applied\") != null) {\n        chain.doFilter(request, response);\n    } else {\n        boolean debug = this.logger.isDebugEnabled();\n        // 设置值\n        request.setAttribute(\"__spring_security_scpf_applied\", Boolean.TRUE);\n        if (this.forceEagerSessionCreation) {\n            HttpSession session = request.getSession();\n            if (debug && session.isNew()) {\n                this.logger.debug(\"Eagerly created session: \" + session.getId());\n            }\n        }\n\n        HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request, response);\n        SecurityContext contextBeforeChainExecution = this.repo.loadContext(holder);\n        boolean var13 = false;\n\n        try {\n            var13 = true;\n            // 将SecurityContext安全信息设置到SecurityContextHolder线程上下文中\n            SecurityContextHolder.setContext(contextBSecurityContextHolder中eforeChainExecution);\n            chain.doFilter(holder.getR\tequest(), holder.getResponse());\n            var13 = false;\n        } finally {\n            if (var13) {\n                SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\n                SecurityContextHolder.clearContext();\n                // 将上下文信息保存在session中\n                this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());\n                request.removeAttribute(\"__spring_security_scpf_applied\");\n                if (debug) {\n                    this.logger.debug(\"SecurityContextHolder now cleared, as request processing completed\");\n                }\n\n            }\n        }\n\n        SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();\n        SecurityContextHolder.clearContext();\n        this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());\n            request.removeAttribute(\"__spring_security_scpf_applied\");\n        if (debug) {\n            this.logger.debug(\"SecurityContextHolder now cleared, as request processing completed\");\n        }\n\n    }\n}\n```\n\n#### LogoutFilter\n\n包路径：org.springframework.security.web.authentication.logout.LogoutFilter\n\n匹配URL为 /logout 的请求，实现用户退出，清除认证信息\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    if (this.requiresLogout(request, response)) { // 匹配URL\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Logging out user '\" + auth + \"' and transferring to logout destination\");\n        }\n\n        this.handler.logout(request, response, auth); // 清除认证信息\n        this.logoutSuccessHandler.onLogoutSuccess(request, response, auth); // 处理自定义退出成功逻辑\n    } else {\n        chain.doFilter(request, response);\n    }\n}\n```\n\n对于 `logoutSuccessHandler.onLogoutSuccess` 这个方法，我们可以对他进行重写，实现自己的退出成功逻辑\n\n#### UsernamePasswordAuthenticationFilter\n\n包路径：org.springframework.security.web.authentication\n\n匹配请求为 POST，且路径为` /login` 的请求，通过表单的用户名和密码进行认证，认证成功会将用户信息放到上下文中\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest)req;\n    HttpServletResponse response = (HttpServletResponse)res;\n    if (!this.requiresAuthentication(request, response)) {\n        chain.doFilter(request, response);\n    } else {\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Request is to process authentication\");\n        }\n\n        Authentication authResult;\n        try {\n            // 调用子类的attemptAuthentication方法\n            authResult = this.attemptAuthentication(request, response);\n            // 子类未完成认证\n            if (authResult == null) {\n                return;\n            }\n\n            this.sessionStrategy.onAuthentication(authResult, request, response);\n        } catch (InternalAuthenticationServiceException var8) {\n            this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8);\n            // 认证失败\n            this.unsuccessfulAuthentication(request, response, var8);\n            return;\n        } catch (AuthenticationException var9) {\n            // 认证失败\n            this.unsuccessfulAuthentication(request, response, var9);\n            return;\n        }\n\n        if (this.continueChainBeforeSuccessfulAuthentication) {\n            chain.doFilter(request, response);\n        }\n\t\t// 认证成功\n        this.successfulAuthentication(request, response, chain, authResult);\n    }\n}\n\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n    if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n        throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n    } else {\n        String username = this.obtainUsername(request);\n        String password = this.obtainPassword(request);\n        if (username == null) {\n            username = \"\";\n        }\n\n        if (password == null) {\n            password = \"\";\n        }\n\n        username = username.trim();\n        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n        this.setDetails(request, authRequest);\n        // 核心部分，交给内部的AuthenticationManager去认证，并返回认证后的 Authentication\n        return this.getAuthenticationManager().authenticate(authRequest);\n    }\n}\n```\n\n#### DefaultLoginPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n若未自定义认证界面，过滤器会生成一个默认的认证界面\n\n```java\nprivate void init(UsernamePasswordAuthenticationFilter authFilter, AbstractAuthenticationProcessingFilter openIDFilter) {\n    this.loginPageUrl = \"/login\";\n    this.logoutSuccessUrl = \"/login?logout\";\n    this.failureUrl = \"/login?error\";\n    if (authFilter != null) { // 若自定义了，authFilter就为null\n        this.formLoginEnabled = true;\n        this.usernameParameter = authFilter.getUsernameParameter();\n        this.passwordParameter = authFilter.getPasswordParameter();\n        if (authFilter.getRememberMeServices() instanceof AbstractRememberMeServices) {\n            this.rememberMeParameter = ((AbstractRememberMeServices)authFilter.getRememberMeServices()).getParameter();\n        }\n    }\n\n    if (openIDFilter != null) {\n        this.openIdEnabled = true;\n        this.openIDusernameParameter = \"openid_identifier\";\n        if (openIDFilter.getRememberMeServices() instanceof AbstractRememberMeServices) {\n            this.openIDrememberMeParameter = ((AbstractRememberMeServices)openIDFilter.getRememberMeServices()).getParameter();\n        }\n    }\n\n}\n```\n\n#### DefaultLogoutPageGeneratingFilter\n\n包路径：org.springframework.security.web.authentication.ui\n\n和 DefaultLogoutPageGeneratingFilter 类似，此过滤器可以生产一个默认的退出登录页面\n\n```java\nprivate void renderLogout(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String page = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"utf-8\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1, shrink-to-fit=no\\\">\\n    <meta name=\\\"description\\\" content=\\\"\\\">\\n    <meta name=\\\"author\\\" content=\\\"\\\">\\n    <title>Confirm Log Out?</title>\\n    <link href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\\\" rel=\\\"stylesheet\\\" integrity=\\\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\\\" crossorigin=\\\"anonymous\\\">\\n    <link href=\\\"https://getbootstrap.com/docs/4.0/examples/signin/signin.css\\\" rel=\\\"stylesheet\\\" crossorigin=\\\"anonymous\\\"/>\\n  </head>\\n  <body>\\n     <div class=\\\"container\\\">\\n      <form class=\\\"form-signin\\\" method=\\\"post\\\" action=\\\"\" + request.getContextPath() + \"/logout\\\">\\n        <h2 class=\\\"form-signin-heading\\\">Are you sure you want to log out?</h2>\\n\" + this.renderHiddenInputs(request) + \"        <button class=\\\"btn btn-lg btn-primary btn-block\\\" type=\\\"submit\\\">Log Out</button>\\n      </form>\\n    </div>\\n  </body>\\n</html>\";\n    response.setContentType(\"text/html;charset=UTF-8\");\n    response.getWriter().write(page);\n}\n```\n\n#### AnonymousAuthenticationFilter\n\n当用户没有授权认证，那么就会给他一个匿名身份\n\n\n\n#### ExceptionTranslationFilter\n\n包路径：org.springframework.security.web.access\n\n捕获并处理认证和授权过程中发生的异常\n\n\n\n#### FilterSecurityInterceptor\n\n包路径：org.springframework.security.web.access.intercept\n\n获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来决定其是否有权限\n\n\n\n## 过滤器加载流程\n\n### DelegatingFilterProxy类\n\n首先执行`doFilter`方法\n\n```java\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        Filter delegateToUse = this.delegate;\n        if (delegateToUse == null) {\n            synchronized(this.delegateMonitor) {\n                delegateToUse = this.delegate;\n                if (delegateToUse == null) {\n                    WebApplicationContext wac = this.findWebApplicationContext();\n                    if (wac == null) {\n                        throw new IllegalStateException(\"No WebApplicationContext found: no ContextLoaderListener or DispatcherServlet registered?\");\n                    }\n\n                    delegateToUse = this.initDelegate(wac);\n                }\n\n                this.delegate = delegateToUse;\n            }\n        }\n```\n\n接着执行`initDelegate`\n\n```java\n protected Filter initDelegate(WebApplicationContext wac) throws ServletException {\n        String targetBeanName = this.getTargetBeanName();\n        Assert.state(targetBeanName != null, \"No target bean name set\");\n        Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);\n        if (this.isTargetFilterLifecycle()) {\n            delegate.init(this.getFilterConfig());\n        }\n\n        return delegate;\n    }\n```\n\n`targetBeanName`在`SpringSecurity`中有一个固定的名字：`FilterChainProxy`\n\n### FilterChainProxy类\n\n首先执行`doFilter`方法\n\n```java\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        boolean clearContext = request.getAttribute(FILTER_APPLIED) == null;\n        if (clearContext) {\n            try {\n                request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n                this.doFilterInternal(request, response, chain);\n            } finally {\n                SecurityContextHolder.clearContext();\n                request.removeAttribute(FILTER_APPLIED);\n            }\n        } else {\n            this.doFilterInternal(request, response, chain);\n        }\n\n    }\n```\n\n执行`doFilterInternal`方法\n\n```java\nprivate void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        FirewalledRequest fwRequest = this.firewall.getFirewalledRequest((HttpServletRequest)request);\n        HttpServletResponse fwResponse = this.firewall.getFirewalledResponse((HttpServletResponse)response);\n        List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);\n        if (filters != null && filters.size() != 0) {\n            FilterChainProxy.VirtualFilterChain vfc = new FilterChainProxy.VirtualFilterChain(fwRequest, chain, filters);\n            vfc.doFilter(fwRequest, fwResponse);\n        } else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(UrlUtils.buildRequestUrl(fwRequest) + (filters == null ? \" has no matching filters\" : \" has an empty filter list\"));\n            }\n\n            fwRequest.reset();\n            chain.doFilter(fwRequest, fwResponse);\n        }\n    }\n```\n\n`  List<Filter> filters = this.getFilters((HttpServletRequest)fwRequest);`会执行`getFilters`方法，它会把过滤器一个一个加载到过滤链中\n\n```java\nprivate List<Filter> getFilters(HttpServletRequest request) {\n      Iterator var2 = this.filterChains.iterator();\n\n      SecurityFilterChain chain;\n      do {\n          if (!var2.hasNext()) {\n              return null;\n          }\n\n          chain = (SecurityFilterChain)var2.next();\n      } while(!chain.matches(request));\n\n      return chain.getFilters();\n}\n```\n\n## 重要接口\n\n### UserDetailsService\n\n```java\npublic interface UserDetailsService {\n    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;\n}\n```\n\n> 当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 `UserDetailsService `接口即可。\n\n作用：查询数据库用户名和密码过程\n\n- 创建类继承`UsernamePasswordAuthenticationFilter`，重写三个方法\n- 创建类实现`UserDetailService`，返回`UserDetails`对象（框架提供的对象）\n\n`UserDetails`类\n\n```java\npublic interface UserDetails extends Serializable {\n  \t// 表示获取登录用户所有权限\n    Collection<? extends GrantedAuthority> getAuthorities();\n    // 表示获取密码\n    String getPassword();\n    // 表示获取用户名\n    String getUsername();\n    // 表示判断账户是否过期\n    boolean isAccountNonExpired();\n    // 表示判断账户是否被锁定\n    boolean isAccountNonLocked();\n    // 表示凭证{密码}是否过期\n    boolean isCredentialsNonExpired();\n    // 表示当前用户是否可用\n    boolean isEnabled();\n}\n```\n\n### PasswordEncoder\n\n```java\npublic interface PasswordEncoder {\n    // 表示把参数按照特定的解析规则进行解析\n    String encode(CharSequence var1);\n\t// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。\n    boolean matches(CharSequence var1, String var2);\n\t// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncoding(String encodedPassword) {\n        return false;\n    }\n}\n```\n\n接口实现\n\n`BCryptPasswordEncoder` 是 Spring Security 官方推荐的密码解析器，是对`PasswordEncoder`类的实现\n\n加密\n\n```java\npublic String encode(CharSequence rawPassword) {\n        if (rawPassword == null) {\n            throw new IllegalArgumentException(\"rawPassword cannot be null\");\n        } else {\n            String salt;\n            if (this.random != null) {\n                salt = BCrypt.gensalt(this.version.getVersion(), this.strength, this.random);\n            } else {\n                salt = BCrypt.gensalt(this.version.getVersion(), this.strength);\n            }\n\n            return BCrypt.hashpw(rawPassword.toString(), salt);\n        }\n    }\n```\n\n匹配\n\n```java\npublic boolean matches(CharSequence rawPassword, String encodedPassword) {\n        if (rawPassword == null) {\n            throw new IllegalArgumentException(\"rawPassword cannot be null\");\n        } else if (encodedPassword != null && encodedPassword.length() != 0) {\n            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {\n                this.logger.warn(\"Encoded password does not look like BCrypt\");\n                return false;\n            } else {\n                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);\n            }\n        } else {\n            this.logger.warn(\"Empty encoded password\");\n            return false;\n        }\n    }\n```\n\n## SpringSecurity Web 权限方案\n\n授权和认证两种\n\n### 设置用户名和密码\n\n方式一：配置文件实现\n\n```properties\nspring.security.user.name=ljx\nspring.security.user.password=ljx\n```\n\n方式二：配置类实现\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        BCryptPasswordEncoder cryptPasswordEncoder = new BCryptPasswordEncoder();\n        auth.inMemoryAuthentication().withUser(\"ljx\").password(cryptPasswordEncoder.encode(\"ljx\")).roles(\"user\");\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n}\n```\n\n方式三：自定义实现类\n\n创建配置类\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    /**\n     * 自定义类实现登录\n     * @param auth\n     * @throws Exception\n     */\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());\n\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n编写`userDetailService`实现类，返回`User`对象`\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<GrantedAuthority> list = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(\"ljx\", new BCryptPasswordEncoder().encode(\"ljx\"), list);\n    }\n}\n```\n\n### 整合数据库实现登录\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        User user = userMapper.queryUserByUsername(s);\n        if(s == null){\n            throw new UsernameNotFoundException(\"用户不存在\");\n        }\n        List<GrantedAuthority> list = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(user.getUsername(), new BCryptPasswordEncoder().encode(user.getPassword()), list);\n    }\n}\n```\n\n### 路径拦截路径拦截\n\n实现`configure`的另一个方法（与上面的不一样）\n\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n           http.and()\n                .authorizeRequests()\n                .antMatchers(\"/api/main/t\").permitAll() // 不需要认证\n                .anyRequest().authenticated()\n                .and().csrf().disable();  // 关闭csrf\n    }\n```\n\n## 角色权限访问控制\n\n### hasAuthority\n\n如果当前的主体具有指定的权限，则返回 true,否则返回 false\n\n```java\n.antMatchers(\"/test1\").hasAuthority(\"admin\")\n```\n\n### hasAnyAuthority\n\n如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串表）的话，返回 true\n\n```java\n.antMatchers(\"/test2\").hasAnyAuthority(\"admin, role\")\n```\n\n### hasRole\n\n如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。\n\n```java\n.antMatchers(\"/test3\").hasRole(\"sale\")\n```\n\n这个方法于之前两个不同的是底层原码是默认加了`ROLE_`前缀，所以在添加用户权限的时候需注意在角色前面加`ROLE_`\n\n```java\nprivate static String hasRole(String role) {\n        Assert.notNull(role, \"role cannot be null\");\n        if (role.startsWith(\"ROLE_\")) {\n            throw new IllegalArgumentException(\"role should not start with 'ROLE_' since it is automatically inserted. Got '\" + role + \"'\");\n        } else {\n            return \"hasRole('ROLE_\" + role + \"')\";\n        }\n    }\n```\n\n### hasAnyRole\n\n表示用户具备任何一个条件都可以访问\n\n```java\n.antMatchers(\"/test3\").hasAnyRole(\"sale\")\n```\n\n要求于`hasRole`一样\n\n### 自定义403页面\n\n```java\nhttp.exceptionHandling().accessDeniedPage(\"/unauth\");\n```\n\n```java\n@GetMapping(\"/unauth\")\n@ResponseBody\npublic String t4(){\n    return \"unauth\";\n}\n```\n\n### 注解使用\n\n#### @Secured\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(securedEnabled = true)\n```\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“\n\n在方法上加上这个注解\n\n```java\n@Secured({\"ROLE_sole\", \"ROLE_aaa\"})\n```\n\n#### @PreAuthorize\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n```\n\n注解适合进入方法前的权限验证\n\n```java\n@PreAuthorize(\"hasAnyAuthority('menu:system')\")\n// 此处hasAnyAuthority可以换成hasAnyRole，hasRole，hasAnyAuthority其中一个\n```\n\n#### @PostAuthorize\n\n**使用注解先要开启注解功能**\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true\n```\n\n在方法执行后再进行权限验证（接口里面方法任会被执行，只是最后会权限验证），适合验证带有返回值的权限\n\n```java\n@PostAuthorize(\"hasAnyAuthority('menu:system')\")\n```\n\n#### @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是` admin1`的数据，表达式中的 `filterObject`引用的是方法返回值 List 中的某一个元素\n\n```java\n@RequestMapping(\"getAll\")\n@PreAuthorize(\"hasRole('ROLE_role')\")\n@PostFilter(\"filterObject.username == 'admin1'\")\n@ResponseBody\npublic List<UserInfo> getAllUser(){\n ArrayList<UserInfo> list = new ArrayList<>();\n list.add(new UserInfo(1l,\"admin1\",\"6666\"));\n list.add(new UserInfo(2l,\"admin2\",\"888\"));\nreturn list;\n}\n```\n\n最终返回页面的数据\n\n```json\n[\n    {\n        \"id\": 1,\n        \"username\": \"admin1\",\n        \"num\": \"6666\"\n    }\n]\n```\n\n#### @PreFilter\n\n进入控制器之前对数据进行过滤\n\n```java\n@RequestMapping(\"getTestPreFilter\")\n@PreAuthorize(\"hasRole('ROLE_role')\")\n@PreFilter(value = \"filterObject.id % 2 == 0\")\n@ResponseBody\npublic List<UserInfo> getTestPreFilter(@RequestBody List<UserInfo> \nlist){\n list.forEach(t-> {\n System.out.println(t.getId()+\"\\t\"+t.getUsername());\n });\nreturn list;\n}\n```\n\n最终接收到的参数只有id为偶数才能被接收\n\n### 退出登录\n\n```java\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/index\").permitAll\n```\n\n## CSRF\n\n跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click  attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任\n\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。\n\n关闭csrf\n\n```java\nhttp.csrf().disable()\n```\n\n## 微服务\n\n### 数据库\n\n![image-20230726154749582](https://s1.ax1x.com/2023/07/26/pCjwOSS.png)\n\n### 搭建项目\n\n![image-20230726154749582](https://s1.ax1x.com/2023/07/26/pCjax1g.png)\n\n### 前置知识\n\n#### Nacos\n\n阿里巴巴的注册中心，网关服务（9001端口）通过注册中心转发到权限管理服务（8081端口）\n\n启动：Windows点击`startup.cmd`，Linux运行`startup.sh`\n\n访问地址：http://localhost:8848/nacos，默认用户名和密码都是nacos\n\n## 认证流程\n\n[![pCvJddf.png](https://s1.ax1x.com/2023/07/27/pCvJddf.png)](https://imgse.com/i/pCvJddf)\n\n`UsernamePasswordAuthenticationFilter`\n\n继承`AbstractAuthenticationProcessingFilter`父类\n\n查看父类的`doFilter`方法\n\n```java\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        // 判断是否是post提交\n        if (!this.requiresAuthentication(request, response)) {\n            chain.doFilter(request, response);\n        } else {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Request is to process authentication\");\n            }\n\t\t\t// 进行身份认证，认证成功将信息封装到Authentication中\n            Authentication authResult;\n            try {\n                authResult = this.attemptAuthentication(request, response);\n                if (authResult == null) {\n                    return;\n                }\t\n\t\t\t\t// session策略处理\n                this.sessionStrategy.onAuthentication(authResult, request, response);\n            } catch (InternalAuthenticationServiceException var8) {\n                // 认证失败\n                this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8);\n                this.unsuccessfulAuthentication(request, response, var8);\n                return;\n            } catch (AuthenticationException var9) {\n                this.unsuccessfulAuthentication(request, response, var9);\n                return;\n            }\n\t\t\t// 认证成功\n            // continueChainBeforeSuccessfulAuthentication默认为false\n            if (this.continueChainBeforeSuccessfulAuthentication) {\n                chain.doFilter(request, response);\n            }\n\n            this.successfulAuthentication(request, response, chain, authResult);\n        }\n    }\n```\n\n查看`UsernamePasswordAuthenticationFilter`子类中的`attemptAuthentication`方法（上述代码中的`attemptAuthentication`方法）\n\n```java\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        // 判断是否是post请求\n        if (this.postOnly && !request.getMethod().equals(\"POST\")) {\n            throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod());\n        } else {\n            // 检查参数书否为空\n            String username = this.obtainUsername(request);\n            String password = this.obtainPassword(request);\n            if (username == null) {\n                username = \"\";\n            }\n\n            if (password == null) {\n                password = \"\";\n            }\n\t\t\t// 去掉空格\n            username = username.trim();\n            // 使用获取数据构造对象，标记未认证\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);\n            // 将请求的信息设置到Authentication对象中\n            this.setDetails(request, authRequest);\n            // 进行身份验证（调用userDetailsService）\n            return this.getAuthenticationManager().authenticate(authRequest);\n        }\n    }\n```\n\n查看`ProviderManager`实现`AuthenticationManager`接口（该接口包含上述代码最后一行的的`authenticate`方法）\n\n```java\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        // 获取Authentication的类型，即UsernamePasswordAuthenticationToken.class\n        Class<? extends Authentication> toTest = authentication.getClass();\n        AuthenticationException lastException = null;\n        AuthenticationException parentException = null;\n        Authentication result = null;\n        Authentication parentResult = null;\n        boolean debug = logger.isDebugEnabled();\n        // 获取认证方式列表List<AuthenticationProvider>迭代器\n        Iterator var8 = this.getProviders().iterator();\n\n        while(var8.hasNext()) {\n            AuthenticationProvider provider = (AuthenticationProvider)var8.next();\n            // 判断当前AuthenticationProvider是否适用UsernamePasswordAuthenticationToken.class类型的Authentication\n            if (provider.supports(toTest)) {\n                if (debug) {\n                    logger.debug(\"Authentication attempt using \" + provider.getClass().getName());\n                }\n\n                try {\n                    // 认证成功会返回标记已认证的Authentication对象\n                    result = provider.authenticate(authentication);\n                    if (result != null) {\n                        // 信息拷贝到result中\n                        this.copyDetails(authentication, result);\n                        break;\n                    }\n                } catch (InternalAuthenticationServiceException | AccountStatusException var13) {\n                    this.prepareException(var13, authentication);\n                    throw var13;\n                } catch (AuthenticationException var14) {\n                    lastException = var14;\n                }\n            }\n        }\n\n        if (result == null && this.parent != null) {\n            try {\n                // 认证失败，使其父类型AuthenticationManager进行验证\n                result = parentResult = this.parent.authenticate(authentication);\n            } catch (ProviderNotFoundException var11) {\n            } catch (AuthenticationException var12) {\n                parentException = var12;\n                lastException = var12;\n            }\n        }\n\n        if (result != null) {\n            // 认证成功，去掉result铭感信息\n            if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {\n                // 去除的过程就是调用CredentialsContainer的eraseCredentials方法\n                ((CredentialsContainer)result).eraseCredentials();\n            }\n\t\t\t// 发布成功认证的事件\n            if (parentResult == null) {\n                this.eventPublisher.publishAuthenticationSuccess(result);\n            }\n\n            return result;\n        } else {\n            // 认证失败抛出异常\n            if (lastException == null) {\n                lastException = new ProviderNotFoundException(this.messages.getMessage(\"ProviderManager.providerNotFound\", new Object[]{toTest.getName()}, \"No AuthenticationProvider found for {0}\"));\n            }\n\n            if (parentException == null) {\n                this.prepareException((AuthenticationException)lastException, authentication);\n            }\n\n            throw lastException;\n        }\n    }\n```\n\n上述代码的去掉敏感信息方法\n\n```java\npublic abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer {\n    // 实现CredentialsContainer接口\n    public void eraseCredentials() {\n        // 前端传入的密码设为null\n        this.eraseSecret(this.getCredentials());\n        this.eraseSecret(this.getPrincipal());\n        this.eraseSecret(this.details);\n    }\n}\n```\n\n认证成功`successfulAuthentication`方法\n\n```java\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult);\n        }\n\t\t// 将认证成功的用户信息Authentication封装到SecurtyContext对象，并存入SecurityContextHolader\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n        // 处理RememberMe\n        this.rememberMeServices.loginSuccess(request, response, authResult);\n        if (this.eventPublisher != null) {\n            // 发布认证成功的属性\t\n            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n        }\n\t\t// 调用成功认证处理器\n        this.successHandler.onAuthenticationSuccess(request, response, authResult);\n    }\n```\n\n认证失败`unsuccessfulAuthentication`方法\n\n```java\nprotected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {\n    //清楚线程在SecurityContextHolder中的SecurtyContext对象\n    SecurityContextHolder.clearContext();\n    if (this.logger.isDebugEnabled()) {\n        this.logger.debug(\"Authentication request failed: \" + failed.toString(), failed);\n        this.logger.debug(\"Updated SecurityContextHolder to contain null Authentication\");\n        this.logger.debug(\"Delegating to authentication failure handler \" + this.failureHandler);\n    }\n\t // 处理RememberMe\n    this.rememberMeServices.loginFail(request, response);\n    // 调用认证失败处理器\n    this.failureHandler.onAuthenticationFailure(request, response, failed);\n}\n```\n\n[![pCvJGzd.png](https://s1.ax1x.com/2023/07/27/pCvJGzd.png)](https://imgse.com/i/pCvJGzd)\n","title":" SpringSecurity学习笔记\n","category":[" Java","SpringSecurity\n"],"date":" 2024-01-16\n","author":" Jixer\n","source":" 原创\n\n"}}