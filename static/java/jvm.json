{"filename":"jvm","category":"java","md":{"topSummary":"\ntitle: JVM知识点总结\ncategory: Java\ndate: 2024-05-16\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n参考文章：[JavaGuide](https://javaguide.cn/java/jvm/memory-area.html) 和 黑马程序员笔记\n\n## 运行时数据区域\n\n**JDK1.7**\n\n1、线程共享：堆（包括字符串常量池），方法区（包括运行时常量池，使用的是永久代空间）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：直接内存\n\n**JDK1.8**\n\n1、线程共享：堆（包括字符串常量池）\n2、线程私有：程序计数器、Java虚拟机栈、本地方法栈\n3、本地内存：元空间（包括运行时常量池）、直接内存\n\n### 程序计数器\n\n一小块固定的内存空间，每个线程的程序计数器不会相互影响，独立存储。随着线程的创建而创建，随着线程的结束而死亡，所以程序计数器**不会出现内存溢出的情况**\n\n有两个作用：\n\n- 控制程序指令的进行，实现代码的流程控制\n- 在多线程下，程序计数器记录了当前线程执行的位置，以便于在线程执行完后切换回来能够返回到当前位置\n\n### Java虚拟机栈\n\nJava虚拟机栈中存放了一个个栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法返回地址。随着线程的创建而创建，随着线程的结束而死亡。\n\n每个方法调用都会有一个对应的栈帧压入栈中，调用结束后，都会有一个栈帧被弹出。\n\n可能出现的两种错误：\n\n- 当在循环条件下进行调用的话会导致栈中被压入太多栈帧而占用空间，当超过Java虚拟机最大深度的时候会报出`StackOverFlowError`的错误。\n- 当栈内存可以动态拓展的时候，如果虚拟机无法申请到足够的内存空间会报出`OutOfMemoryError`错误\n\n#### 局部变量表\n\n存放编译时可知的基本数据类型、对象类型。\n\n#### 操作数栈\n\n存放方法执行过程中产生的中间计算结果，也存放临时变量。\n\n#### 动态链接\n\n主要用在当一个方法调用另一个方法的时候，需要将 Class 文件常量池中的符号引用转为内存地址的直接引用。\n\n### 本地方法栈\n\n与Java虚拟栈不同的是：Java虚拟机栈存放的是Java方法栈帧，而本地方法栈存放的是Native方法栈帧。\n\n### 堆\n\n最大的一块内存区域，主要存放的是**对象实例以及数组**（局部变量表中存放的是堆上对象的引用）。\n\n**几乎所有的对象都在堆上分配内存**，但是随着技术升级，如果某些方法中的对象没有被外部使用或者没有被返回，那么对象可以直接在Java虚拟机栈上分配内存。\n\n### 方法区\n\n方法区存放类的元信息（类的基本信息、字段信息、变量信息等），还包括运行时常量池、字符串常量池(JDK7之前)\n\nJDK1.8之前方法区实现是永久代空间，存放在堆区域中\n\nJDK1.8之后方法区实现是元空间，存放在直接内存区域中\n\n> 方法区与永久代和元空间的关系就像是接口和实现类的关系，方法区是接口，永久代和元空间是实现类\n\n### 运行时常量池\n\n方法区的一部分，存放编译期生成的各种字面量和符号引用\n\n### 字符串常量池\n\n方法区的一部分，存放常量字符串内容\n\n主要目的是为了避免字符串的重复创建\n\n#### 与运行时常量池的关系\n\nJDK7之前：运行时常量池包括字符串常量池，方法区实现为永久代\n\nJDK7：字符串常量池从方法区拿到堆中，运行时常量池剩下的还在方法区的永久代中\n\nJDK8之后：方法区用元空间替换了永久代空间，字符串常量池还在堆中\n\n### 直接内存\n\n一种特殊的内存缓冲区\n\n## 垃圾回收\n\nJava的自动内存管理主要针对对象内存回收和对象内存分配，最核心的功能是堆内存中对象的回收和分配\n\nJava堆是垃圾收集器管理的主要区域，因此也被称作**GC堆**\n\n### 堆空间基本结构\n\nJava堆分为不同的 区域，根据各个区域的特点选择合适的垃圾收集算法\n\n**JDK1.7：**\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、永久代：PerGen\n\n**JDK1.8：**\n\n1、新生代：Eden、S0、S1\n\n2、老生代：Tenured\n\n3、元空间：MetaSpace\n\n### 垃圾回收流程\n\n大部分情况，对象首先在Eden区域分配内存，若在一次新生代垃圾回收后，该对象还存活，就将它放到S0或S1并将年龄加1。当再一次一次新生代垃圾回收后，若对象任然存在，那么就回将当前存活的对象放到另一个地方（若当前是 S0，就放到 S1；若是 S1，就放到 S0）并将年龄加1，当年龄增加到默认值阈值（15）的时候，会将对象晋升至老年代中。若老年代空间不足，会触发 Full GC 对整个堆进行垃圾回收。若 Full GC 无法回收老年代的对象，那么当对象继续放入老年代时，就会抛出 `Out Of Memory` 异常。\n\n> 年龄是0-15的原因：年龄记录区域大小通常是4位，最大的二进制表示是1111，也就是15。\n\n### 对象判断死亡的方法\n\n当一个对象可以被回收，不一定代表一定会被回收！对象回收至少需要经过两次标记的过程，可达分析法是第一次筛选，筛选的条件是对象是否有必要执行`finalize`方法（若对象没有覆盖`finalize`方法或 `finalize` 方法已经被虚拟机调用过，就说明没有执行的必要），将需要执行的对象放在一个队列中进行第二次筛选，当这个对象与引用链上任意一个对象相关联，就不会回收，否则就会回收。\n\n#### 引用计数法\n\n给对象添加一个引用计数器，当对象被引用的时候就，计数器就加1，当引用消失的时候，引用就减1。当引用为0的时候就说明对象可以被回收\n\n优点：实现简单\n\n缺点：1、每次对象引用和取消都需要维护一下，影响系统的性能。2、当出现A引用B，同时B引用A的情况，也就是循环引用时会出现无法回收的问题\n\n#### 可达性分析算法\n\n用一个GC ROOT座作为根节点，与每个有引用的对象相连接，若对象到GC ROOT没有连接就说明对象可以被回收。\n\n**常见的GC ROOT：**\n\n- 虚拟机栈(栈帧中的局部变量表)中引用的对象\n- 本地方法栈(Native 方法)中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 所有被同步锁持有的对象\n- JNI（Java Native Interface）引用的对象\n\n### 引用类型\n\n#### 强引用\n\n大部分使用的引用都是强引用，垃圾回收器绝不会回收此类引用\n\n#### 软引用\n\n软引用通过`SoftReference`类实现，若系统内存不足，就会回收它，若内存足够，就不管。\n\n软引用可以用来实现内存敏感的高速缓存\n\n软引用可以和一个引用对象联合使用，若软引用的对象被垃圾回收，就会放到与之关联的引用队列中，通过遍历引用队列，将`SoftReference`的强引用删除\n\n#### 弱引用\n\n只具有弱引用的对象拥有更短暂的生命周期\n\n不管系统内存是否足够，只要发现是弱引用，就可能被垃圾回收。但是垃圾回收器是一个优先级很低的线程，不一定发现得了弱引用\n\n与软引用类似，弱引用可以和一个引用对象联合使用，若弱引用的对象被垃圾回收，就会放到与之关联的引用队列中\n\n#### 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n### 垃圾回收算法\n\n#### 标记-清除法\n\n标记出不需要回收的对象，在标记完后统一回收没有标记的对象\n\n优点：实现简单\n\n缺点：1、碎片化问题，没有标志的内存不连续，标记清除后会产生大量不连续的内存碎片。2、标记和清除两个过程效率都不高\n\n**实现过程：**\n\n1、对象被创建的时候，标记为0\n\n2、在标记阶段，将所有可达的对象标记为1\n\n3、扫描阶段，清除所有标记为0的对象\n\n#### 复制算法\n\n将内存分为相同的两块，每次使用其中的一块，当进行了垃圾回收后，将存活的对象移到另一块未使用的内存，然后将使用的内存一次性清除掉，这样每次回收都是内存的一半\n\n优点：解决了碎片化问题\n\n缺点：1、可用内存减小为原来的一般。2、存活对象数量多的化复制性能就变得很差\n\n#### 标记-整理算法\n\n过程与标记-清除算法类似，但是它标记后并不会回收对象，而是让存活的对象移动到另一端，清除掉段边界以外的内存\n\n#### 分代收集算法\n\n当前虚拟机都采用的这种算法，可以根据年代的特点进行使用不同的回收算法\n\n例如在新生代中，每次收集都会有大量对象死去，所以就采用标记-复制算法（只需要少部分复制成本就能完成对象收集），老年代中的对象存活率较高，所以就采用标记-整理或者标记-清除算法\n\n### 垃圾收集器\n\n如果说垃圾回收算法是内存回收的方法论，那么垃圾收集器就是内存回收后的实现\n\n#### Serial收集器\n\n单线程收集器，在进行垃圾收集的时候会停止掉所有的工作线程，直到它收集结束\n\n优点就是简单高效，没有线程交互的开销\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### ParNew收集器\n\nParNew收集器是Serial收集器的多线程版本\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### Parallel Scavenge收集器\n\nParallel Scavenge收集器看上去和ParNew收集器都一样，不同点是Parallel Scavenge收集器关注点是吞吐量（高效率的的利用CPU），而CMS等收集器关注点是用户线程的停顿时间（提高用户体验）\n\nParallel Scavenge收集器提供很多参数供用户找到最合适的停顿时间或最大吞吐量\n\n采用的算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**\n\n#### Serial Old收集器\n\nSerial收集器的老年代版本，主要有两大用途：\n\n1、JDK1.5版本之前与Parallel Scavenge收集器配合使用\n\n2、作为CMS收集器的后备方案\n\n#### Parallel Old收集器\n\nParallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法\n\n> 在关注吞吐量和CPU资源的场景下，可以优先考虑Parallel Scavenge收集器和Parallel Old收集器\n\n#### CMS收集器\n\n一款老年代收集器，可以分配新生代的 Serial 和 ParNew 收集器一起使用\n\n**一种以获取最短回收时间为目的的收集器，注重用户体验，能够实现GC和用户线程（基本上）同时进行**\n\n执行过程：\n\n1、初始标记：暂停所有其他的线程，快速记录与root相连接的对象\n\n2、并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象（但是这个闭包结构并不能将所有的可达对象都记录，因为用户线程在不断的更新引用域，GC线程无法保证可达分析的及时性）\n\n3、重新标记：修正并发标记的阶段因为用户线程继续运行而导致标记产生变动的那一部分对象标记记录\n\n4、清除标记：开启用户线程，同时GC线程对未标记的区域作清扫（垃圾回收）\n\n优点：并发收集，低停顿\n\n缺点：1、对CPU资源敏感。2、无法处理浮动垃圾。3、会产生大量空间碎片\n\n采用的算法：**标记-清除算法**\n\n**CMS 垃圾回收器在 Java 9 中已经被标记为过时，并在 Java 14 中被移除**\n\n#### G1收集器\n\n收集范围是新生代和老年代收，不需要结合其他收集器使用\n\n一款面向服务器的垃圾收集器，满足 GC 停顿时间要求的同时，还具备高吞吐量的特性\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region\n\n执行过程：1、初始标记。2、并发标记。3、最终标记。4、筛选回收。\n\n优点：1、并发与并行。2、分代收集。3、空间整理（整体上看是标记-整理算法，局部来看是标记-复制算法）4、可预测的停顿。\n\n**从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器**\n\n#### ZGC收集器\n\n与ParNew和G1类似，ZGC也采用标记-复制算法，但是ZGC做了重大改进：可以将暂停时间控制在几毫秒内，且暂停时间不受堆内存大小的影响\n\n## 类文件结构\n\n### 魔数\n\n每个Class文件的头4个字节称为魔数，通过这4个字节来确定一个文件的类型\n\nJava文件为kj0xcadebabe\n\n### Class文件版本号\n\n接着魔数的第5个和第6个此节表示的是**次版本号**，第7和第8个字节是**主版本号**\n\n通过这个版本号能够计算出JDK版本\n\nJDK1.2之后的版本计算方法：主版本号 - 44\n\n### 常量池\n\n接着主次版本号之后就是常量池，常量池存放：**字面量**和**符号引用**\n\n### 访问标志\n\n接常量池之后，紧挨着的两个字节代表访问标志\n\n访问标志用于识别一些类或接口的信息：这个Class是类还是接口，是 `public `还是 `private` 等\n\n### 当前类、父类、接口索引集合\n\nJava 类的继承关系由类索引、父类索引和接口索引集合三项确定\n\n### 字段表集合\n\n字段表用于描述接口或类中声明的变量，但不包括方法内的局部变量\n\n字段表结构：访问标志、名称索引、描述符索引、属性表集合\n\n### 方法集合\n\n字段表用于描述接口或类中声明的方法\n\n与字段表结构类似，但是与字段表不同的是少了 `volatile` 修饰符和 `transient` 修饰符这两个不可以修饰方法的访问标志，增加了`synchronized`、`native`、`abstract`等关键字修饰方法\n\n### 属性表集合\n\n字段表、方法表中都存在自己的属性表集合，以用于描述某些场景专有的信息\n\n## 类的加载过程\n\n### 类的生命周期\n\n加载->连接（验证->准备->解析）->初始化->使用->卸载\n\n### 加载\n\n这一阶段由**类加载器**完成，主要是完成下面三件事：\n\n1、通过全类名获取二进制流\n\n2、在方法去保存一个InstanceKClass对象，保存类的所有信息\n\n3、同时还会在堆上生成与方法区类似的java.lang.Class对象，作为方法区这些数据的访问入口\n\n加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了\n\n### 连接\n\n#### 验证\n\n检验字节码文件是否遵守了《Java虚拟机规范》的约束要求\n\n检查的部分：\n\n1、文件格式验证（Class文件格式）\n\n2、元数据验证（字节码语义）\n\n3、字节码验证（程序语义）\n\n4、符号引用验证（类的正确性）\n\n#### 准备\n\n正式的为类变量分配内存并设置类变量初始值\n\n#### 解析\n\n将常量池内的符号引用替换为直接引用\n\n### 初始化\n\n执行初始化方法（cinit）\n\n以下几种情况会进行类初始化\n\n1、当遇到 `new`、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条字节码指令时\n\n2、使用 `java.lang.reflect` 包的方法对类进行反射调用时\n\n3、初始化一个类，如果其父类还未初始化，则先触发该父类的初始化\n\n4、执行Main方法的当前类\n\n....\n\n以下几种情况不会进行类初始化\n\n1、无静态代码块且无静态变量赋值语句\n\n2、有静态变量的声明，但是没有赋值语句，如：`private static int a;`\n\n3、静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化，如：`private final static int a = 10;`\n\n### 卸载\n\n类的Class对象被GC\n\n## 类加载器\n\n### 介绍\n\n 类加载器的主要作用就是加载Java类的字节码（.Class文件）到JVM中（在内存中生成一个代表类的Class对象）\n\nJVM内置的三个重要类加载器：\n\n- **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载器，由C++实现，通常为null（因为C++实现的类加载器在Java无与之对应的类），无父类，用来加载JDK内部的核心类库\n- **`ExtensionClassLoader`(扩展类加载器)**：加载/jre/lib/ext下的类文件\n- **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类\n\n执行流程图：\n![](https://img2.imgtp.com/2024/05/20/fYIF5GzX.png)\n\n### 双亲委派模型\n\n类加载器有很多种，当我们需要加载一个类的时候需要哪一个类加载器呢？这时候就需要用到双亲委派模型了\n\n#### 执行流程\n\n执行流程集中在ClassLoader的loadClass方法中\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        //首先，检查该类是否已经加载过\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            //如果 c 为 null，则说明该类没有被加载过\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                    //当父类的加载器不为空，则通过父类的loadClass来加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                    //当父类的加载器为空，则调用启动类加载器来加载该类\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                //非空父类的类加载器无法找到相应的类，则抛出异常\n            }\n\n            if (c == null) {\n                //当父类加载器无法加载时，则调用findClass方法来加载该类\n                //用户可通过覆写该方法，来自定义类加载器\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                //用于统计类加载器相关的信息\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            //对类进行link操作\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n**总结：首先类加载器先判断自己是否已经加载过这个类了，若已经加载就直接返回，否则自己先不会加载，而是让父类加载器进行加载，只有当前父类加载器也没法加载的时候，自己才加载**\n\n由此可知，判断两个类是否相同，不但要看类的全名是否一致，还要看类加载器是否一致\n\n#### 打破双亲委派模型\n\n**1、自定义类加载器**\n\n自定义类加载器需要继承`ClassLoader`类，若不想打破双亲委派机制就重写`ClassLoder`类的`findClass`方法，若想打破，就重写`loadClass`方法（因为类加载器进行类加载的时候，会先调用父类加载器的`loadClass`方法，改变了传统双亲委派模型的执行流程）\n\n**2、线程上下文类加载器**\n\n有些时候，高层的类加载器需要加载底层的类加载才能加载的类\n\n例如：JDBC就是由启动类加载器委派应用类加载器去加载类的方式\n\n- 启动类加载器加载DriverManager\n- 在初始化DriverManager时，通过SPI机制加载jar中的msql驱动\n- SPI利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象\n\n获取线程线程上下文类加载器的代码：\n\n```java\nClassLoader cl = Thread.currentThread().getContextClassLoader();\n```\n\n**3、Osgi框架的类加载器**\n","title":" JVM知识点总结\n","category":[" Java\n"],"date":" 2024-05-16\n","author":" Jixer\n","source":" 原创\n\n"}}