{"filename":"hmdp","category":"project","md":{"topSummary":"\ntitle: 黑马点评项目笔记\ncategory: SpringBoot,Redis,实战项目\ndate: 2024-01-26\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## Session共享问题\n\n多台Tomcat并不共享session存储空间，当切换到不同的tomcat服务时导致数据丢失的问题\n\n## 缓存更新策略\n\n- 内存淘汰：reids自带的内存淘汰机制\n- 过期淘汰：利用exprie命令给数据设置过期时间\n- 主动更新：主动完成数据库与reids的同时更新\n\n### 策略选择\n\n- 低一致性需求：内存淘汰或过期淘汰\n- 高一致性需求：主动更新为主，过期淘汰为辅\n\n### 关于主动更新策略的思考\n\n1、**问题：是更新缓存还是删除缓存？**\n\n更新缓存：会产生无效更新，因为有可能你更新了，系统一直没用上。并且存在较大的线程安全问题\n\n删除缓存：本质是延迟更新，没有无效更新，线程安全问题相对较低\n\n经过思考得出的最佳策略：**删除缓存**\n\n2、**问题：先操作数据库还是缓存？**\n\n**方案一：先删除缓存，再更新数据库**\n\n正常情况：线程一先执行删除缓存，再更新数据库；线程二查询缓存有发现没有缓存，就查询数据库。\n\n异常情况：线程一先执行删除缓存，这时候线程二到了，查询缓存后发现无缓存，就去查询数据库，这时候数据库的数据是没更新的数据，就出现了异常，最后线程一才执行更新数据库。\n\n**方案二：先更新数据库，再删除缓存**\n\n正常情况：线程一先更新数据库，再删除缓存，线程二查询缓存发现没有缓存，就查询数据库。\n\n异常情况：线程二线查询缓存，发现有缓存，这时候线程一才到达，线程一就更新数据库，删除缓存，线程二就出现了异常，用的是没更新的数据。\n\n经过思考得出的最佳策略：**方案二**\n\n3、**如何确保数据库与缓存操作的原子性？**\n\n单体系统：利用事务机制\n\n分布式系统：利用分布式事务机制\n\n## 缓存穿透\n\n缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n**解决方案**\n\n- 缓存空对象：请求到了后缓存一个值为null的数据到redis中\n  - 优点：简单，容易维护\n  - 缺点：1、额外的内存消耗。2、可能造成短期的不一致\n- 布隆过滤：在客户端和redis之间加个过滤器，用二进制数组判断是否存在。注意这个方法并不是百分百准确\n  - 优先：内存占用少\n  - 缺点：1、实现复杂。2、存在误判可能\n\n## 缓存雪崩\n\n缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n\n**解决方案**\n\n- 给不同的key设置不同的的过期时间\n- 添加Redis集群提高服务可用性\n- 给缓存添加降级限流策略\n- 给业务添加多级缓存\n\n## 缓存击穿\n\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n**解决方案**\n\n- 给热点接口添加互斥锁\n- 逻辑过期【在redis中额外添加一个时间字段】\n\n## Redis全局唯一ID\n\n![](https://s11.ax1x.com/2024/01/17/pFkCTn1.png)\n\n- 符号位：1bit，永远为0\n- 时间戳：31bit，以秒为单位，可以用69年\n- 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同的ID\n\n## 优惠券秒杀\n\n### 超卖\n\n**解决办法**\n\n- 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取同步锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁\n  - 优点：简单粗暴\n  - 缺点：性能一般\n- 乐观锁：认为线程安全问题不一定会发生，因此不加锁，**只是在更新数据时去判断有没有其它线程对数据做了修改**。\n  - 如果没有修改则认为是安全的，自己才更新数据。\n  - 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。\n  - 优点：性能好\n  - 缺点：存在成功率低的问题（需要做处理）\n\n#### 悲观锁方法\n\n使用`synchronized`过于简单，采用乐观锁方法\n\n#### 乐观锁方法\n\n> 对于**乐观锁**的关键是判断之前查询得到的数据受否被修改过，常见的方法有两种：\n\n1、**版本号法**\n\n![](https://s11.ax1x.com/2024/01/17/pFkM5m8.png)\n\n2、**CAS法**\n\nCAS法和版本号法的区别在于CAS法是直接将库存和原来库做比较，而版本号法是比较的版本\n\n![](https://s11.ax1x.com/2024/01/17/pFkMOlq.png)\n\n**弊端**：出错率大大增加，100个库春，结果只有几十个成功卖出。为什么呢？\n\n解答：假设有100个线程同时请求，只有一个线程成功，其他99线程都在最后一步扣减库存的时候需要判断是否和之前的库存一致出错了，所以就大大提高了错误率。\n\n**怎么解决这个弊端？**\n\n解答：将最后判断是否和之前库存一致改为**只要库存大于0**就行了\n\n### 一人一单\n\n**解决办法**：使用乐观锁方法，添加同步代码`synchronized`，限制只有一个线程进入\n\n**存在的问题**：在单机模式下没问题，但在集群模式下就会出现问题，不同的SpringBoot服务中JVM使用的常量池、锁监视器是不一样，这导致了同一个用户两次请求都会进入到锁里，就出现了安全问题\n\n![](https://s11.ax1x.com/2024/01/18/pFkqadJ.png)\n\n**解决办法**：分布式锁，下面讲解分布式锁\n\n### 分布式锁\n\n**概念**：满足分布式系统或集群模式下多进程可见并且互斥的锁\n\n**满足的基本特性**：多进程可见、高可用、互斥、好性能、安全性\n\n**核心**：实现多进程之间的互斥，下面是常见的三种\n\n![](https://s11.ax1x.com/2024/01/18/pFkL2cV.png)\n\n**需要实现的两个基本方法**\n\n- 获取锁【通过`set lock name NX EX 10`来实现互斥锁并加上过期时间，NX是互斥，EX是设置超时时间】\n  - 互斥：确保只能有一个线程获取锁\n  - 非阻塞：尝试一次，成功返回true，失败返回false\n- 释放锁【`Del key`】\n  - 手动释放\n  - 超时释放\n\n**分布式锁误删问题**：因为线程一的某种原因导致阻塞，时间超过了Redis锁的过期时间，锁自动释放，线程二获取了线程一的锁，若此时线程一的业务执行完毕，就会手动调用释放锁，就把线程二的锁给释放了，出现了误删的情况\n\n![](https://s11.ax1x.com/2024/01/18/pFkjB7D.png)\n\n**误删情况解决办法**：获取锁的时候将value值设置为UUID+线程ID，每次释放锁的时候就拿redis中存放的值与这个值判断一下，相同才释放，否则不释放\n\n**采用上诉方法还是存在问题**\n\n释放锁的过程，是先判断reids中的值是否一致，再释放锁。可能出现在判断过后到是否锁之间出现阻塞的情况，因为在JVM中有个东西叫垃圾回收，它会阻塞代码。于是需要保证判断和释放这两部操作是原子操作，不可分割\n\n![](https://s11.ax1x.com/2024/01/18/pFAPylQ.png)\n\n**解决办法**：采用Lua脚本解决，编写Lua脚本，用Java调用\n\n#### 总结\n\n**实现Reids分布式锁的思路**\n\n- 利用`set nx ex`获取锁，并设置过期时间，保存现场标识\n- 释放锁先判断线程标识是否与自己一致，一致就删除锁【使用Lua脚本保证原子性】\n\n## Redisson\n\n**Redis的分布式锁是基于setnx实现的，存在一下问题**\n\n- 不可重入：同一个线程无法多次获取同一把锁\n- 不可重试：获取锁只尝试一次就返回false，没有重试机制\n- 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患\n- 主从一致性：如果Redis提供了主从集群,主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现\n\n**Redisson提供一系列分布式的Java常用对象和许多分布式服务**\n\n![](https://s11.ax1x.com/2024/01/18/pFAEp5t.png)\n\n### 可重入锁原理\n\n通过redis的hash结构进行锁的存储，同一个线程进入，会将value值加一，并设置有效期，每次释放锁就value值减一。若减后的值不为0，就重置有效期，否则就直接删除。实现代码通过Lua脚本进行。\n\n![](https://s11.ax1x.com/2024/01/18/pFAVqne.png)\n\n**流程图**\n\n![](https://s11.ax1x.com/2024/01/18/pFAZp1f.png)\n\n### 可重试锁原理\n\n利用信号量和PubSub功能实现等待、唤醒、获取锁失效的重试机制\n\n![](https://s11.ax1x.com/2024/01/18/pFAeYZQ.png)\n\n### 超时续约原理\n\n利用wathDog，每隔一段时间，重置超时时间\n\n### 主从一致性原理\n\n多个独立的Redis结点，必须所有的结点都获取重入锁，才算获取锁成功\n\n## 秒杀优化\n\n### 思路\n\n- 利用Reids Lua脚本完成库存余量、一人一单判断，完成抢单业务\n- 再将下单业务放入阻塞队列中，利用独立线程异步下单\n\n### 使用阻塞队列存在的问题\n\n- 内存限制问题：当队列的元素超过容量的时候会出现内存溢出\n- 数据安全问题：当队列的任务服务出现宕机，任务就会丢失\n\n## Reids消息队列\n\n### 基于List结构模拟消息队列\n\nReids中的List数据结构是一个双向链表，利用LPUSH结合RPOP，或者RPUSH结合LPOP来实现\n\n不过需要注意的是，当消息队列没有消息时RPOP和LPOP操作会返回NULL，并不像JVM阻塞队列那样会阻塞并等待消息。\n\n因此应该使用BRPOP或者BLPOP来实现阻塞效果\n\n#### 优点\n\n- 利用Reids存储，不受限于JVM内存上限\n- 基于Reidis的持久化机制，数据安全性有保证\n- 可以满足消息有序性\n\n#### 缺点\n\n- 无法避免消息丢失\n- 只支持单消费者\n\n### 基于PubSub的消息队列\n\n生产者向对应的cahnnel发送消息后，所有订阅者都能收到消息【一对多】\n\n- SUBSCRIBE channel [channel]：订阅一个或多个频道\n- PUSLISH channel msg：向一个频道发送消息\n- PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道\n\n#### 优点\n\n- 采用发布订阅模型，支持多生产、多消费\n\n#### 缺点\n\n- 不支持数据持久化\n- 无法避免消息丢失\n- 消息堆积有上限，超出时数据丢失\n\n### 基于Stream类型消息队列\n\nstream是一种数据类型，专门为消息队列设计的，相较于前面两种方式能够更加完美实现一个消息队列\n\n**生产消息**：用于向指定的Stream流中添加一个消息\n\n```\nXADD key *|ID value [value ...]\n\n# 创建名为 users 的队列，并向其中发送一个消息，内容是：{name=jack,age=21}，并且使用Redis自动生成ID\n127.0.0.1:6379> XADD users * name jack age 21\n\"1644805700523-0\n```\n\nkey就是消息队列，key不存(*)在会自动创建（默认），ID是消息表示，value是消息的内容\n\n**消费消息**：\n\n```\nXREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID ID\n\n# 读取XREAD中的第一条消息\nXREAD COUNT 1 STREAMS users 0\n# 阻塞1秒钟后从XREAD中读取的最新消息\nXREAD COUNT 1 BLOCK 1000 STREAMS users $\n```\n\n注意：当我们指定起始ID为`$`时代表读取最后一条消息（读取最新的消息）ID为`0`时代表读最开始的一条消息（读取最旧的消息），如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题\n\n#### 特点\n\n- 消息可回溯\n- 一个消息可以被多个消费者读取\n- 可以阻塞堆区\n- 有消息漏读风险\n\n#### 消费者组\n\n上面我们介绍的消费方式都是**单消费方式**，容易发生消息堆积导致消息丢失，所以我们需要改用消费者组的模式\n\n**消费者组**：将多个消费者划分到一个组，监听同一队列\n\n- **消息分流**：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度\n- **消息标识**：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费\n- **消息确认**：消费者获取消息后，消息处于`pending`（待处理）状态，并存入一个`pending-list`。当处理完成后需要通过`XACK`来确认消息，标记消息为已处理，才会从pending-list移除。\n\n```\n# 创建消费者组\nXGROUP CREATE key groupName ID\n# 删除指定的消费者组\nXGROUP DESTORY key groupName\n# 给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupName consumerName\n# 删除消费者组中指定消费者\nXGROUP DELCONSUMER key groupName consumerName\n# 从消费者组中读取消息\nXREADGROUP GROUP\n```\n\n![](https://img-blog.csdnimg.cn/img_convert/27039c5d7c9c137c15bab614293a63fe.png)\n\n![](https://img-blog.csdnimg.cn/img_convert/c1ffb0ac9d815f997953b1dfeae6768f.png)\n\n`stream`类型消息队列的`XREADGROUP`命令特点：\n\n- 消息可回溯\n- 可以多消费者争抢消息，加快消费速度\n- 可以阻塞读取\n- 没有消息漏读的风险\n- 有消息确认机制，保证消息至少被消费一次\n\n### 比较\n\n![](https://s21.ax1x.com/2024/03/11/pF6P3RK.png)\n\n## Feed流\n\n关注推送也叫投喂，为用户持续提供沉浸式体验，通过无限下拉刷新获取新的信息\n\n### 与传统模式的区别\n\n- 传统模式：用户寻找内容\n\n- Feed模式：内容匹配用户\n\n### Feed流常见的模式\n\n- TimeLine：不做内容筛选，简单的按照内容发布时间排序，常用于好友或者关注\n- 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容\n\n### Feed流实现方案\n\n![](https://s11.ax1x.com/2024/01/19/pFAoHxO.png)\n\n## HyperLogLog用法\n\n首先搞懂两个概念\n\n- UV：独立访客量，1天内一个用户多次访问该网站，只记录一次\n- PV：页面访问量：用户多次打开页面，记录多次PV\n\nUV统计\n\n- 优点：内存占用极小\n- 缺点：存在0.81%的误差【不过可以完全忽略】\n\n## 总结\n\n### 2024-1-16\n\n1、写了发短信验证码和登录接口，随机生成token，将用户信息存入redis中\n\n2、写了两个拦截器，一个拦截所有请求的token刷新拦截器【没有token直接放行，token中找不到数据直接放行，全部通过就存入UserHolder中】，一个是只拦截需要验证的登录拦截器【只需要检验UserHolder中是否有数据，有就通过，否则拦截】。\n\n3、对查询商品接口做了缓存，并且对**缓存击穿【互斥锁】**和**缓存穿透【缓存空对象】**做了处理，用jmeter进行检验\n\n### 2024-1-17\n\n1、 用逻辑过期时间解决缓存击穿【在shop中使用expire字段】，**使用这个方法需要将热点key提前预热**。通过比较当前时间和逻辑时间，而从决定是否需要重建数据。通过互斥锁来保证只有一个线程能够进入，通过独立线程来重构数据来减少响应时间\n\n2、创建了redis全局唯一ID生成器，通过符号位(1位)+时间错(31位)+序列号(32位)来形成一个唯一ID，但这样这个ID最大值并不满足总量的所需的范围要求，因此需要通过**不同的key来生成序列号**【通过加上`年:月:日`前缀】来保证每天的都有会不同的ID，这个最大值并不会超过一天所需的范围要求。\n\n3、写了优惠券秒杀功能，正常写法会出现超卖的情况，使用**乐观锁**优化后加上库存限制解决超卖问题【这里也可以用悲观锁解决，通过互斥锁或者同步代码】；使用**悲观锁**`synchronized`解决一人一单的问题，并用**代理事务【AopContext.currentProxy()】**解决事务\t\n\n### 2024-1-18\n\n1、一人一单集群模式下使用分布式锁解决，分布式锁带来了一系列问题，比如：两个服务的`synchronized (userId.toString().intern())`获取的对象不一致【**通过互斥锁解决**】，误删【**通过每次释放前判断存入锁的值是否一致解决**】，原子性问题【**释放锁的操作分为判断是否一致和释放锁，需要用Java调用写好的Lua脚本来确保原子性**】\n\n2、整合Redisson，了解其可重入的原理，可重试锁原理、超时续约原理、主从一致性原理\n\n3、新增查询笔记、点赞笔记\n\n### 2024-1-19\n\n1、点赞排行榜【采用redis的zSet存储，按照时间戳排序】、关注、共同关注【set集合取两个集合的并集】\n\n2、使用Feed流，在博文发布的时候推送给关注自己的人\n\n3、签到：使用二进制位`stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);`存储签到，签到了就是1，没签到就是0\n\n4、统计连续签到，通过`stringRedisTemplate.opsForValue().bitField`来获取 本月截至今天为止所有的签到记录\n\n### 2024-3-10\n\n1、优化优惠券秒杀逻辑，将原本对数据库的查询等判断条件全部放到Lua脚本中，改为从Reids中判断，极大的优化了查询的时间\n\n2、使用阻塞队列 + 线程池实现异步秒杀\n\n### 2024-3-11\n\n1、优化秒杀，使用Stream消息队列替换阻塞队列，能够弥补阻塞队列带来的问题，例如：内存上限，数据丢失等\n","title":" 黑马点评项目笔记\n","category":[" SpringBoot","Redis","实战项目\n"],"date":" 2024-01-26\n","author":" Jixer\n","source":" 原创\n\n"}}