{"filename":"java-more","category":"java","md":{"topSummary":"\r\ntitle: Java的深入理解\r\ncategory: Java\r\ndate: 2024-07-05\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## ArryList 扩容机制\r\n\r\n下面是 ArryList 的 `add` 方法\r\n\r\n```java\r\n/**\r\n* 将指定的元素追加到此列表的末尾。\r\n*/\r\npublic boolean add(E e) {\r\n    // 加元素之前，先调用ensureCapacityInternal方法\r\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n    elementData[size++] = e;\r\n    return true;\r\n}\r\n```\r\n\r\n`ensureCapacityInternal` 方法代码如下：\r\n\r\n```java\r\n// 根据给定的最小容量和当前数组元素来计算所需容量。\r\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\r\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\r\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\r\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\r\n    }\r\n    // 否则直接返回最小容量\r\n    return minCapacity;\r\n}\r\n\r\n// 确保内部容量达到指定的最小容量。\r\nprivate void ensureCapacityInternal(int minCapacity) {\r\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\r\n}\r\n```\r\n\r\n`ensureExplicitCapacity` 代码如下：\r\n\r\n```java\r\n//判断是否需要扩容\r\nprivate void ensureExplicitCapacity(int minCapacity) {\r\n    modCount++;\r\n    //判断当前数组容量是否足以存储minCapacity个元素\r\n    if (minCapacity - elementData.length > 0)\r\n        //调用grow方法进行扩容\r\n        grow(minCapacity);\r\n}\r\n```\r\n\r\n`gorw` 扩容代码如下：\r\n\r\n```java\r\n/**\r\n * 要分配的最大数组大小\r\n */\r\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\r\n\r\n/**\r\n * ArrayList扩容的核心方法。\r\n */\r\nprivate void grow(int minCapacity) {\r\n    // oldCapacity为旧容量，newCapacity为新容量\r\n    int oldCapacity = elementData.length;\r\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n\r\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n\r\n    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\r\n    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\r\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n        newCapacity = hugeCapacity(minCapacity);\r\n\r\n    // minCapacity is usually close to size, so this is a win:\r\n    elementData = Arrays.copyOf(elementData, newCapacity);\r\n}\r\n```\r\n\r\n分析：\r\n\r\n1、当传入第1个元素的时候\r\n\r\n- 因为当前数组为空，所以 `if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)` 条件成立，返回默认值10\r\n- 此时的 `elementData.length` 长度为0，所以 ` if (minCapacity - elementData.length > 0)` 条件成立，会执行扩容\r\n- `newCapacity` 大小为0，`minCapacity` 大小为10，所以 `if (newCapacity - minCapacity < 0)` 条件成立，最后执行 `Arrays.copyOf` 对数组进行增加容量\r\n\r\n2、当传入到第11个元素的时候\r\n\r\n- `calculateCapacity` 返回的是 size + 1，也就是 10 + 1 = 11\r\n- 此时的 `elementData.length` 长度为10，所以 ` if (minCapacity - elementData.length > 0)` 条件成立，会执行扩容\r\n- `newCapacity` 大小为15，`minCapacity` 大小为10，所以方法的两个 if 语句都不会执行，最后执行 `Arrays.copyOf` 对数组进行增加容量\r\n\r\n扩容方法会对长度为0或者长度超 `int` 类型范围的时候进行特判，其他的长度都是扩大1.5倍\r\n\r\n ## HashMap\r\n\r\n### 扩容机制\r\n\r\n1、若没有自定义容量大小，会默认初始化大小为16。每次扩容都会变为原来的2倍\r\n\r\n2、若自定义了容量大小，会用给定的容量作为初始化大小。每次扩容都会变为原来的2的幂次方【为什么？**因为获取元素下标的方法是应该是`hash % length`，为了让 `hash % length == hash & (length - 1)` 的前提是 length 是 2 的 n 次方**】\r\n\r\n### 数据结构\r\n\r\n1、在 JDK 1.8之前，底层数据结构选用的是**数组 + 链表**。当加入键值对的时候，会先对键进行扰动函数处理得到 hash 值，然后通过 `(n - 1) & hash` 获取得到当前需要存放的位置，若元素以及存在，就覆盖，否则就拉链法解决冲突\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是**数组 + 链表/红黑树**。当加入键值对的时候，为了解决哈希冲突，当链表的长度8的时候，会将链表转为红黑树（在转红黑树之前，先会对数组长度进行判断，若长度小于64，会先将数组进行扩容）\r\n\r\n## ConcurrentHashMap\r\n\r\n### 容量\r\n\r\n1、在 JDK 1.7之前，若没指定大小，默认为16，且一旦确定就不可变\r\n\r\n2、在 JDK 1.18之后，若没指定大小，默认为16，可以进行扩容\r\n\r\n### 数据结构\r\n\r\n1、在JDK1.7之前，底层数据结构选用的是**分段数组 + 链表**，分段数组每段里都有一把锁（分段锁），每一把锁只锁当前的一段数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争\r\n\r\n2、在 JDK 1.8之后，底层数据结构选用的是**node 数组 + 链表/红黑树**，并发控制通过 `synchronized` 和 CAS 来操作，`synchronized` 只锁定当前链表或红黑二叉树的首节点，锁粒度更细","title":" Java的深入理解\r\n","category":[" Java\r\n"],"date":" 2024-07-05\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"}}