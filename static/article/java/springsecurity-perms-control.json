{"filename":"springsecurity-perms-control","category":"java","md":{"topSummary":"\ntitle: SpringSecurity权限控制\ncategory: Java,SpringCloud\ndate: 2024-06-18\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 前置说明\n\n必备知识：SpringSecurity 的使用\n\n提前准备：5个基本表（权限表、角色表、菜单表、角色权限表、角色菜单表），为了方便这里是展示必须的操作，数据库的操作返回的数据是直接模拟的\n\n## 步骤\n\n### 自定义登录逻辑\n\n加入 jar 包我们什么都不做，启动项目，访问任何接口会默认跳转到一个登录页面。我们现在需要做的就是不让他显示这个页面并且通过我们自己定义的登录接口实现认证\n\n定义 `SecurityConfig` 配置类，用来管理整个安全配置\n\n首先修改一下 `configure(HttpSecurity http)` 方法\n\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http\n            // CSRF禁用，因为不使用session\n            .csrf().disable()\n            // 禁用HTTP响应标头\n            .headers().cacheControl().disable().and()\n            // 基于token，所以不需要session\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n            // 过滤请求\n            .authorizeRequests()\n            // 对于登录login 注册register 验证码captchaImage 允许匿名访问\n            .antMatchers(\"/auth/login\", \"/auth/register\").permitAll()\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest().authenticated()\n            .and()\n            .headers().frameOptions().disable();\n}\n```\n\n开放 `/auth/login` 登录接口，自定义 AuthenticationManager 的建造器，并确定加密算法为 `BCryptPasswordEncoder` ，这个加密算法可以替换为 MD5 加密\n\n```java\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\n    auth.userDetailsService(customUserDetailService).passwordEncoder(new BCryptPasswordEncoder());\n}\n```\n\n注入 AuthenticationManager Bean，目的是为了让我们在自己的接口调用 `authenticationManager.authenticate()` 方法进行验证\n\n```java\n@Bean\n@Override\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n```\n\n下面写自己的登录接口，在登陆方法中调用 `authenticationManager.authenticate` 来实现验证，而调用这个方法会调用我们自定义实现的 `CustomUserDetailService` 类的 `loadUserByUsername` 方法\n\n```java\n@Autowired\nprivate AuthenticationManager authenticationManager;\n\n@Override\npublic String login(LoginForm loginForm) {\n    // 若有其他检验项也需要检查\n    Authentication authentication = null;\n    try {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginForm.getUsername(), loginForm.getPassword());\n        UserHolder.setContext(authenticationToken);\n        // 这里会调用 UserDetailService 接口的 loadUserByUsername 方法\n        authentication = authenticationManager.authenticate(authenticationToken);\n    } catch (Exception e){\n        e.printStackTrace();\n    } finally {\n        UserHolder.clearContext();\n    }\n    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n\n    return JwtUtil.createToken(loginUser.getUsername());\n}\n```\n\n自定义 `CustomUserDetailService` 类，实现 `UserDetailsService` 接口，为了让登录验证走我们自己的验证逻辑，判断账号密码，从而生成 Token\n\n注：这里的查询用户拥有的权限是模拟的，真实项目需要联表查询数据库\n\n```java\n@Service\npublic class CustomUserDetailService implements UserDetailsService{\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // 检验账号状态\n        // 查询数据库检验账户密码的正确性\n        // ...\n\n        Authentication context = UserHolder.getContext();\n        return new LoginUser(new User(context.getName(), new BCryptPasswordEncoder().encode(context.getCredentials().toString())),\n                getPermsList());\n    }\n\n    /**\n     * 模拟用户拥有的权限\n     * @return\n     */\n    private Set<String> getPermsList() {\n        Set<String> res = new HashSet<>();\n        res.add(\"user:t1\");\n        res.add(\"user:t2\");\n\n        return res;\n    }\n}\n```\n\n### 自定义认证失败处理\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n\n// 认证失败处理类\nhttp.exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint).and() \n```\n\n`CustomAuthenticationEntryPoint` 类就是我们自定义的认证失败的逻辑处理类，我们可以通过 response 返回失败的 Json 数据\n\n```java\n@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setStatus(HttpStatus.UNAUTHORIZED.value());\n        response.setContentType(\"application/json\");\n        response.setCharacterEncoding(\"utf-8\");\n\n        Map<String, String> res = new HashMap<>();\n        res.put(\"code\", \"401\");\n        res.put(\"msg\", \"认证失败，无法访问系统资源\");\n\n        response.getWriter().print(JSON.toJSON(res));\n    }\n}\n```\n\n### 自定义退出登录处理\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomLogoutSuccessHandler customLogoutSuccessHandler;\n\n// 自定义退出登录\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessHandler(customLogoutSuccessHandler);\n```\n\n这段代码的代码的意思当我们调用接口 `/logout` 会走 `CustomLogoutSuccessHandler` 处理逻辑，我们可以在里面清除用户相关的数据等操作，并返回相关的 Json 数据\n\n```java\n@Component\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        // 清除Redis缓存的用户数据\n        // 写入用户操作日志\n        // ...\n\n        response.setStatus(HttpStatus.OK.value());\n        response.setContentType(\"application/json\");\n        response.setCharacterEncoding(\"utf-8\");\n\n        Map<String, String> res = new HashMap<>();\n        res.put(\"code\", \"200\");\n        res.put(\"msg\", \"退出成功\");\n\n        response.getWriter().print(JSON.toJSON(res));\n    }\n}\n```\n\n### 自定义Token拦截器\n\n在 `SecurityConfig` 配置类中修改，添加一句话\n\n```java\n@Autowired\nprivate CustomJwtAuthenticationTokenFilter customJwtAuthenticationTokenFilter;\n\n// 自定义Token拦截器\nhttp.addFilterBefore(customJwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n这段代码的意思就是在 执行 `UsernamePasswordAuthenticationFilter` 之前执行我们定义的 `CustomJwtAuthenticationTokenFilter` Token 拦截器\n\n```java\n@Component\npublic class CustomJwtAuthenticationTokenFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        LoginUser loginUser = JwtUtil.getLoginUser(request);\n        if (Objects.nonNull(loginUser)){\n            // 检验成功，看是否需要刷新token\n             JwtUtil.verifyRefreshToken(loginUser);\n            // 将用户信息设置在SecurityContextHolder中\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());\n            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n            SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        }\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n这里需要将用户信息保存到 `SecurityContextHolder` 中，不保存的化它任然会走认证失败的逻辑\n\n### 自定义跨域配置\n\n实现跨域配置需要实现一个 CorsFilte 的 Bean\n\n```java\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsFilter corsFilter() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        // 设置访问源地址\n        config.addAllowedOriginPattern(\"*\");\n        // 设置访问源请求头\n        config.addAllowedHeader(\"*\");\n        // 设置访问源请求方法\n        config.addAllowedMethod(\"*\");\n        // 有效期 1800秒\n        config.setMaxAge(1800L);\n        // 添加映射路径，拦截一切请求\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        // 返回新的CorsFilter\n        return new CorsFilter(source);\n    }\n}\n```\n\n然后将这个 Bean 写入到安全配置中\n\n```java\n// 添加CORS filter\nhttp.addFilterBefore(corsFilter, CustomJwtAuthenticationTokenFilter.class);\nhttp.addFilterBefore(corsFilter, LogoutFilter.class);\n```\n\n\n\n### 自定义认证白名单\n\n对于接口的匿名认证有两种方式，一种是在代码中写入\n\n```java\nhttp.antMatchers(\"/auth/login\", \"/auth/register\").permitAll()\n```\n\n另一种是通过 yml 配置文件来读取写入，这里我就用后一种方法来演示\n\n新建一个白名单配置类，使用 `@ConfigurationProperties` 注解来表明配置文件的位置\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"security.ignored\")\npublic class IgnorePathConfig {\n\n    private List<String> paths = new ArrayList<>();\n\n    public List<String> getPaths() {\n        return paths;\n    }\n}\n```\n\n在 yml 配置文件中写入\n\n```yml\nsecurity: # 白名单路径\n  ignored:\n    paths:\n      - /auth/test\n```\n\n好了现在就差个将这个白名单配置写入安全配置中，通过遍历白名单，将路径设置为匿名访问\n\n```java\n@Autowired\nprivate IgnorePathConfig ignorePathConfig;\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    // 配置不需要保护的资源路径允许访问\n    ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry registry = http.authorizeRequests();\n    ignorePathConfig.getPaths().forEach(url -> registry.antMatchers(url).permitAll());\n\t// ...\n    // ...\n}\n```\n\n### 自定义动态权限控制\n\n这个动态权限控制说白了还是拦截器，将用户拥有的权限与路径所需要的权限作比较，若用户没有这个权限就走认证逻辑\n\n新建一个拦截器，继承 `AbstractSecurityInterceptor` 类，实现 `Filter` 接口\n\n```java\n@Component\npublic class CustomAbstractSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {\n\n    @Autowired\n    private IgnorePathConfig ignorePathConfig;\n\n    @Autowired\n    private CustomFilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;\n\n    @Autowired\n    public void setMyAccessDecisionManager(CustomAccessDecisionManager myAccessDecisionManager) {\n        super.setAccessDecisionManager(myAccessDecisionManager);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);\n        // OPTIONS请求直接放行\n        if(request.getMethod().equals(HttpMethod.OPTIONS.toString())){\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n            return;\n        }\n        // 白名单请求直接放行\n        PathMatcher pathMatcher = new AntPathMatcher();\n        for (String path : ignorePathConfig.getPaths()) {\n            if(pathMatcher.match(path,request.getRequestURI())){\n                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n                return;\n            }\n        }\n        // 此处会调用AccessDecisionManager中的decide方法进行鉴权操作\n        InterceptorStatusToken token = super.beforeInvocation(fi);\n        try {\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        } finally {\n            super.afterInvocation(token, null);\n        }\n    }\n\n    @Override\n    public Class<?> getSecureObjectClass() {\n        return FilterInvocation.class;\n    }\n\n    @Override\n    public SecurityMetadataSource obtainSecurityMetadataSource() {\n        return filterInvocationSecurityMetadataSource;\n    }\n}\n```\n\n这里将 OPTIONS 和白名单的请求直接放，然后就调用 `AccessDecisionManager` 中的decide方法进行鉴权操作，所以还需要自定以这个鉴权操作\n\n```java\n@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager {\n\n    @Override\n    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {\n        // 当接口未被配置资源时直接放行\n        // configAttributes存在当前路径所需要的权限\n        if (CollUtil.isEmpty(configAttributes)) {\n            return;\n        }\n        Iterator<ConfigAttribute> iterator = configAttributes.iterator();\n        while (iterator.hasNext()) {\n            ConfigAttribute configAttribute = iterator.next();\n            // 将访问所需权限或用户拥有权限进行比对\n            // 用户的权限在登录的时候就会查询保存在Redis中，用户一访问就会根据token查询到权限，所以需要重写getAuthorities方法\n            String needAuthority = configAttribute.getAttribute();\n            System.out.println(\"需要的资源:\" + needAuthority);\n            System.out.println(\"拥有的资源:\" + authentication.getAuthorities());\n            for (GrantedAuthority grantedAuthority : authentication.getAuthorities()) {\n                if (needAuthority.trim().equals(grantedAuthority.getAuthority())) {\n                    return;\n                }\n            }\n        }\n        throw new AccessDeniedException(\"抱歉，您没有访问权限\");\n    }\n\n    @Override\n    public boolean supports(ConfigAttribute configAttribute) {\n        return true;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n}\n```\n\n这个鉴权是核心部分，就是判断用户是否拥有这个请求的权限\n\n那么问题来了：我们是如何知道路径的请求和它的请求权限的呢？\n\n注意在 `CustomAbstractSecurityInterceptor` 类中有个 `obtainSecurityMetadataSource` 方法\n\n```java\n@Override\npublic SecurityMetadataSource obtainSecurityMetadataSource() {\n    return filterInvocationSecurityMetadataSource;\n}\n```\n\n该对象用于读取数据库，获取请求对应的权限信息\n\n```java\n@Component\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {\n\n    private static Map<String, ConfigAttribute> configAttributeMap = null;\n\n    @Autowired\n    private CustomDynamicSecurityService myDynamicSecurityService;\n\n    @PostConstruct\n    public void loadDataSource() {\n        configAttributeMap = myDynamicSecurityService.loadDataSource();\n    }\n\n    public void clearDataSource() {\n        configAttributeMap.clear();\n        configAttributeMap = null;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {\n        // 若不存在就先加载（一般都是存在的，因为启动项目的时候已经加载好了）\n        if (configAttributeMap == null) {\n            this.loadDataSource();\n        }\n        List<ConfigAttribute> configAttributes = new ArrayList<>();\n        // 获取当前访问的路径\n        String url = ((FilterInvocation) o).getRequestUrl();\n        String path = URLUtil.getPath(url);\n        PathMatcher pathMatcher = new AntPathMatcher();\n        Iterator<String> iterator = configAttributeMap.keySet().iterator();\n        // 匹配当前路径所需的权限，若当前路径需要某个权限就加入configAttributes中\n        while (iterator.hasNext()) {\n            String pattern = iterator.next();\n            if (pathMatcher.match(pattern, path)) {\n                configAttributes.add(configAttributeMap.get(pattern));\n            }\n        }\n        // 未设置操作请求权限，返回空集合\n        return configAttributes;\n    }\n\n    @Override\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return true;\n    }\n}\n```\n\nconfigAttributeMap 是个 Map，键存放的路径，值存放的是权限\n\n这里需要返回 `Collection<ConfigAttribute>` 集合，就获取当前的路径，遍历从数据查询的所有路径的权限，依次匹配，看当前的路径是否需要权限，若需要有就加入 `configAttributes`\n\n`CustomDynamicSecurityService` 是个接口，具体实现需要在用户层实现，因为需要用到 mapper 方法的调用\n\n```java\npublic interface CustomDynamicSecurityService {\n    /**\n     * 加载资源ANT通配符和资源对应MAP\n     * 这里Bean注入需要用到用户模块的权限信息，所以在用户模块注入\n     * 只要与启动项目就回会运行\n     */\n    Map<String, ConfigAttribute>  ();\n}\n```\n\n在用户层中定义一个Bean，实现 `loadDataSource` 方法，同样的，这里的查询权限的数据也是模拟的，真实项目中需要查询数据库\n\n权限说明：访问 `/auth/t1` 接口需要 `user:t1` 权限，其他的同理\n\n```java\n@Bean\npublic CustomDynamicSecurityService dynamicSecurityService() {\n    return new CustomDynamicSecurityService() {\n        @Override\n        public Map<String, ConfigAttribute> loadDataSource() {\n            Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();\n            // 查询所有权限列表\n            // 这里模拟数据\n            map.put(\"/auth/t1\", new org.springframework.security.access.SecurityConfig(\"user:t1\"));\n            map.put(\"/auth/t2\", new org.springframework.security.access.SecurityConfig(\"user:t2\"));\n            map.put(\"/auth/t3\", new org.springframework.security.access.SecurityConfig(\"user:t3\"));\n\n            return map;\n        }\n    };\n}\n```\n\n好了，到这里就结束了，通过重写方法一系列的方法，拦截请求的路径，根据数据库查询的所有的权限，匹配到这个请求路径所需要的权限，再根据用户的权限来匹配，若用户有该权限就放行，否则就拦截\n\n## 代码\n\nGitee：[https://gitee.com/lijunxi666/further-use-of-spring-security](https://gitee.com/lijunxi666/further-use-of-spring-security)","title":" SpringSecurity权限控制\n","category":[" Java","SpringCloud\n"],"date":" 2024-06-18\n","author":" Jixer\n","source":" 原创\n\n"}}