{"filename":"javaweb","category":"java","md":{"topSummary":"\ntitle: JavaWeb学习笔记\ncategory: Java,Servlet\ndate: 2024-01-17\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## JDBC\n\n介绍：java用来连接和操作数据库\n\n**注意：最后千万别忘掉关闭资源**\n\n### 快速上手\n\n前提需要导入mysql jar包\n\n```\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo {\n    public static void main(String[] args) throws Exception{\n//        注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n//        获取链接\n//        useServerPrepStmts=true开启预编译功能\n        String url = \"jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"123456\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n//        执行语句\n        String sql = \"update jdbc_test set password = 12121 where username = 1\";\n//        获取执行对象\n        Statement statement = conn.createStatement();\n//        返回影响行数\n        int count = statement.executeUpdate(sql);\n        System.out.println(count);\n//        释放资源\n        conn.close();\n        statement.close();\n    }\n}\n```\n\n### API\n\n#### DriverManager\n\n通过`DriverManager.getConnection(url, username, password)`来得到一个Connection对象，代表与数据库连接成功\n\n#### Connection\n\n获取执行sql对象\n\n- 通过调用`createStatemen()`方法获取一个Statement对象\n- 通过调用`prepareStatement()`方法获取一个PrepareStatement对象\n\n事务管理\n\n- 通过调用`setAutoCommit(false)`方法来来关闭自动提交事务\n- 通过调用`sqlSession.commit()`方法来回滚事务\n- 通过调用`rollback()`方法来回滚事务\n\n事务管理就是关闭自动提交事务过后，执行的语句中若出现错误就会立刻回滚事务，一个都不执行；若语句执行完后没有提交事务，他也会回滚事务；\n\n#### Statement\n\n代表执行对象\n\n- 通过调用`executeUpdate(sql)`来对数据进行增删改，返回受影响的行数（int）\n- 通过调用`executeQuery(sql)`来对数据进行查询,返回一个ResultSet对象\n\n#### PreparedStatement\n\n代表执行对象，可以防止sql注入\n\n需要在sql语句中传参的位置用?占位符代替，调用setInt/setString(出现的位置, 需要代替的字符或者数字)来替换?，这样做的原理是使敏感字符用\\\\带转义，让它变为一个字符，不参与sql作用。\n\n例如：\n\n```\nString name = \"1\";\nString pas = \"'or '1' ='1\"; // sql注入代码\n String sql = \"select * from jdbc_test where username = '\"+name+\"' and password = '\"+pas+\"'\";\nStatement statement = connection.createStatement();\nResultSet resultSet = statement.executeQuery(sql);\n```\n\n这样写的sql语句为`select * from jdbc_test where username = '1' and passwor`d = ''or '1' ='1'，这样的sql语句一定为真，导致sql注入\n\n改进过后代码\n\n```\nString sql = \"select * from jdbc_test where username = ? and password = ?\";\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\npreparedStatement.setString(1, name);\npreparedStatement.setString(2, pas);\n```\n\n这样的sql为`select * from jdbc_test where username = '1' and password = '\\'or \\'1\\' =\\'1\\'`就不会出现sql注入问题\n\n#### ResultSet\n\n主要有两个重要的方法\n\n- 调用`next()`来判断是否下一行数据是否存在\n- 调用`getString(\"1\")/getInt(\"id\")`来输出改行数据的第1列或者列名为id的数据\n\n## Druid\n\ndruid使阿里巴巴开源的数据库连接池，可以进行多个用户连接，一开始就开了几个Connetion连接，用完并不会关闭而是返回连接池等待下一个用户；而不是用一个开一次连接，用完就关闭，导致浪费时间。\n\n需要引入druid和mysql jar包\n\n与jdbc不同的是这里需要一个Properties配置文件来配置数据库连接池信息\n\n```\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=123456\n# 初始化连接数量\ninitialSize=5\n# 最大连接数\nmaxActive=10\n# 最大等待时间\nmaxWait=3000\n```\n\n```\n// 加载配置文件\nProperties prop = new Properties();\n// System.out.println(System.getProperty(\"user.dir\"));  获取当前目录是src\nprop.load(new FileInputStream(\"jdbc_demo/src/druid.properties\"));\n```\n\n调用`DruidDataSourceFactory.createDataSource(prop)`返回一个DataSource对象，这个DataSource可以调用`getConnection()`来获取数据库连接返回一个Connection对象，拿到这个对象后的操作方法与上面一样\n\n## Mybaits\n\nMybats是JDBC框架，免除了几乎所有JDBC代码以及设置参数和获取结果集的工作\n\n**注意：别忘记关闭SqlSession开启的资源**\n\n### 目录\n\n![](../../.vuepress/public/assets/article/javaweb/QQ图片20230106061547.png)\n\njava下单UserMapper为接口文件，resource下的UserMapper为Mapper的xml文件（存放sql数据）。\n\n### **mybatis-config的配置**\n\n放在resources目录下\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n<!-- default为默认选取的数据库，这样写可以切换不同的数据库，对应environment的id-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n<!-- 事务管理方式，采用JDBC-->\n            <transactionManager type=\"JDBC\"/>\n<!-- 数据库连接池-->\n            <dataSource type=\"POOLED\">\n<!-- 数据库的连接信息-->\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql:///test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n<!-- 加载sql映射文件-->\n<!-- <mapper resource=\"com/ljx/mapper/UserMapper.xml\"/>-->\n\n<!-- mapper代理方式，扫包，若还有多个如BrandMapper,....不需要一个一个添加sql映射文件，-->\n        <package name=\"com.ljx.mapper\"/>\n    </mappers>\n</configuration>\n```\n\n加载配置文件，获取sqlSessionFactory对象\n\n```\nString resource = \"mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\n获取SqlSession对象，继承了Conntection的事务管理\n\n```\nSqlSession sqlSession = sqlSessionFactory.openSession();\n```\n\n获得UserMapper接口代理对象\n\n```\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n```\n\n接着就可以调用UserMapper的接口了（例如）\n\n```\nList<User> users = userMapper.selectAll();\n```\n\n**注意：除了查询，其他的增删改均需要事务提交**`sqlSession.commit();`\n\n### **XXXMapper的配置**\n\n放在resources/com/ljx/mapper目录下，与java里面的目录相对应\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace命名空间：为mapper的全限名，为java目录下mapper接口的地址，用来对应mapper-->\n<!--resultType返回类型，com.ljx.pojo.User是User类的文件地址-->\n<mapper namespace=\"com.ljx.mapper.UserMapper\"></mapper>\n```\n\n#### select标签\n\n普通查找\n\n```\n<select id=\"selectAll\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user;\n</select>\n```\n\n含有敏感字符查找\n\n```\n <!-- #{}占位符，会将其替换为?，为了防止sql注入，${}占位符，拼接sql，会存在sql注入问题-->\n<!-- 如遇到特殊字符如：<，则会报错，因为xml小于是一种开始的格式，需要处理\n        1.转移字符：&lt;\n        2.CDATA区：<![CDATA[ < ]]>，其中<![CDATA[内容]]>里可以写多个字符\n-->\n    <select id=\"selectId\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user\n        where id <![CDATA[ < ]]> #{id};\n    </select>\n```\n\n多条件查询\n\n```\n<select id=\"selectMore\" resultType=\"com.ljx.pojo.User\">\n        select *\n        from tb_user\n        where id = #{id}\n           and gender = #{gender};\n</select>\n```\n\n动态查询\n\n```\n<!--动态条件查询sql-->\n<!-- 并不是所有的参数都需要传入-->\n<!-- if标签，存在问题：第一个if若不存在就会出错。-->\n<!-- 解决：1、添加 1=1  2、用where标签替换where语句，若条件存在就会自动去掉and-->\n<select id=\"selectNiu\" resultType=\"com.ljx.pojo.User\">\n    select * from tb_user\n    <where>\n        <if test=\"username != null and username != ''\">and username = #{username}</if>\n        <if test=\"id != null\">and id = #{id}</if>\n    </where>\n</select>\n```\n\n单条件查询\n\n```\n<!--单条件动态查询-->\n<!-- choose标签相当于switch，when标签相当于case，test里放的是条件-->\n<!-- otherwise相当于default，若没有满足的条件就执行这个语句，否则不执行-->\n<select id=\"selectDan\" resultType=\"com.ljx.pojo.User\">\n    select * from tb_user\n    where\n    <choose>\n        <when test=\"username != null and username != ''\">username = #{username}</when>\n        <when test=\"id != null\">id = #{id}</when>\n        <otherwise>1 = 1</otherwise>\n        </choose>\n</select>\n```\n\n#### insert标签\n\n```\n<!-- useGeneratedKeys=\"true\" keyProperty=\"id\" 返回添加数据id-->\n<insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into tb_user (username, password, gender, addr)\n    values (#{username}, #{password}, #{gender}, #{addr})\n</insert>\n```\n\n#### updated标签\n\n普通修改\n\n```\n<update id=\"updated\">\n    update tb_user\n    set username = #{username},\n        password = #{password},\n        gender = #{gender},\n        addr = #{addr}\n    where id = #{id}\n</update>\n```\n\n动态修改\n\n```\n<update id=\"updatedDong\">\n    update tb_user\n    <set>\n        <if test=\"username != null and username != ''\">username = #{username},</if>\n        <if test=\"password != null and password != ''\">password = #{password},</if>\n        <if test=\"gender != null and gender != ''\">gender = #{gender},</if>\n        <if test=\"addr != null and addr != ''\">addr = #{addr}</if>\n    </set>\n    where id = #{id}\n</update>\n```\n\n#### delete标签\n\n普通删除\n\n```\n<delete id=\"delete\">\n    delete from tb_user where id = #{id}\n</delete>\n```\n\n批量删除\n\n```\n<!-- 用foreach循环遍历，因为一开始并不知道数组有多少长度-->\n<!-- mybatis默认将collection参数为array，只能为这个，若想改变产生名字，则必须在传参的时候用@Params注解改变默认名字-->\n<!-- 例如：void deleteFor(@Param(\"ids\") int[] ids);-->\n<delete id=\"deleteFor\">\n    delete from tb_user where id in\n    <foreach collection=\"array\" item=\"id\" separator=\",\" open=\"(\" close=\")\">\n        #{id}\n    </foreach>\n</delete>\n```\n\n### 注解方式\n\n用注解方式就不用写xml文件，极大的方便了开发，所以简单的sql语句用注解，复杂的sql语句用xml文件\n\n```\n@Select(\"select * from tb_user\")\nList<User> userAll();\n```\n\n## Servlet\n\nServlet是Java web的核心\n\n### 快速入门\n\n需要重写Servlet api中的5个方法\n\n```\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n\n@WebServlet(\"/demo1\")\npublic class servletDemo1 implements Servlet {\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"123\");\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(21);\n    }\n}\n```\n\n### Api\n\n#### init\n\n- 调用时机：默认情况下Servlet第一访问的时候创建Servlet对象，实例化后被调用\n- 调用次数：1次\n\n#### service\n\n- 调用时机：Servlet每一次被访问的时候\n- 调用次数：多次\n\n#### destroy\n\n- 调用时机：内存释放或者服务器关闭时，Servlet对象会销毁\n- 调用次数：1次\n\n### WebServlet注解配置规则\n\n`@WebServlet(urlPatterns = \"/demo2\", loadOnStartup = 1)`\n\nurlPatterns = xx， xx为路由地址，参数只有urlPatterns时可以省略只写`@WebServlet(\"xxx\")`\n\n- 1、数组，可以放多个接口\n- 2、精确匹配：`/api/demo`\n- 3、目录匹配：`/api/demo/*`\n- 4、拓展名匹配：`.do`\n- 5、任意匹配：`/` 或者 `/*`\n\nloadOnStartup为-1表示第一次访问的时候初始化，为正整数或者为0表示Servlet对象创建的时候就调用\n\n### HttpServlet\n\nHttpServlet是对Http协议进行封装的Servlet实现类\n\n需要重写doGet和doPost方法\n\n```\npublic class ServletDemo_HttpServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doGet(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n```\n\n封装的原理就是通过`ServletRequest`强制转为子类`HttpServletRequest`，在调用`getMethod()`方法获取调用方法，若是get方法就调用`doGet()`，post方法就调用`doPost()`\n\n### HttpServletRequest\n\n#### 请求行\n\n- 请求方法：post/get => `req.getMethod()`\n- 访问访问路径：/api => `req.getContextPath()`\n- 统一资源定位符：http://localhost:8080/api/demo5 => `req.getRequestURL()`\n- 统一资源标识符：/api/demo5 => `req.getRequestURI()`\n\n#### 请求参数\n\n`req.getQueryString()`\n\n#### 请求头\n\n`req.getHeader(\"xxx\")`\n\n#### 通用获取参数方法\n\n```\n// 若参数// 请求获得参数的通用方法, 键值对方法，底层用了getQueryString方法\nMap<String, String[]> map = req.getParameterMap();\nfor(String s: map.keySet()){\n    System.out.print(s + \":\");\n    for(String j: map.get(s)){\n        System.out.print(j + \"\");\n    }\n    System.out.println(\"\");\n}\n// 若参数有多个，根据key获取参数值，数组\nString[] sz = req.getParameterValues(\"username\");\n// 若参数只有一个，根据key获取值\nString sd = req.getParameter(\"password\");\n```\n\n#### 乱码问题\n\nget乱码问题：tomcat进行url解码的默认字符集为ISO-8859-1\n\n解决：1、对乱码进行解码，转为字节数组。2、解码\n\n```\nbyte ss[] = reqUsername.getBytes(StandardCharsets.ISO_8859_1);\nString endUsername = new String(ss, \"utf-8\");\n```\n\npost乱码问题解决：`req.setCharacterEncoding(\"UTF-8\");`\n\n#### 资源转发\n\n特点：1、浏览地址栏不变化；2、只能转发当前服务器内部资源；3、一次请求，转发资源间数据共享\n\n```\nreq.setAttribute(\"msg\", \"hello\");\nreq.getAttribute(\"msg\");\nreq.removeAttribute(\"msg\");\n```\n\n请求转发：`req.getRequestDispatcher(\"/demo\").forward(req, resp);`\n\n### HttpServletResponse\n\n#### **重定向**\n\n特点：1、路由器地址栏发送变化；2、可以重定向任意位置（服务器内部或者外部都可以）；3、两次请求，不能在多个资源中使用request共享数据\n\n```\n// 方法一\n// 设置状态码\nresponse.setStatus(302);\n//  设置响应头\nresponse.setHeader(\"Location\", \"/servlet_demo/demo1\");\n\n// 方法二\n// 重定向简化写法\n// request.getContextPath()：获取虚拟目录\nresponse.sendRedirect(request.getContextPath() + \"/demo1\");\n```\n\n#### response响应数据\n\n##### 字符输入流\n\n```\n// 设置请求头编码为utf-8并且支持html格式\nresponse.setHeader(\"content-type\", \"text/html;charset=utf-8\");\n//  获得字符输入流\nPrintWriter printWriter = response.getWriter();\nprintWriter.write(\"<h1>你好</h1>\");\n```\n\n##### 字节输入流\n\n```\nFileInputStream file = new FileInputStream(\"C:\\\\Users\\\\lenovo\\\\Pictures\\\\Saved Pictures\\\\qq.jpg\");\nServletOutputStream servletOutputStream = response.getOutputStream();\nbyte[] b = new byte[1024];\nint len = 0;\nwhile((len = file.read(b)) != -1){\n    servletOutputStream.write(b, 0, len);\n}\nfile.close(); // 这里需要关闭资源\n```\n\n##### JSON格式\n\n需要导入fastjson包\n\n```\n<dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.2.62</version>\n</dependency>\n```\n\n例子\n\n```\nint n[] = {1,2,3,6,4,5};\nString j = JSON.toJSONString(n);\nresponse.setContentType(\"text/html;charset=utf-8\");\nresponse.getWriter().write(j);\n```\n","title":" JavaWeb学习笔记\n","category":[" Java","Servlet\n"],"date":" 2024-01-17\n","author":" Jixer\n","source":" 原创\n\n"}}