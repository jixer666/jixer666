{"filename":"rabbitmq","category":"middleware","md":{"topSummary":"\r\ntitle: RabbitMQ学习笔记\r\ncategory: RabbitMQ,中间件\r\ndate: 2024-06-27\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n## 基本概念\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\sadsad.png)\r\n\r\n- virtual-host：虚拟主机（数据隔离）\r\n- publisher：生产者\r\n- consumer：消费者\r\n- queue：队列（存储消息）\r\n- exchange：交换机（路由消息）\r\n\r\n## 工作模式\r\n\r\n### 简单模式\r\n\r\n一个消费者绑定一个队列\r\n\r\n发送消息：\r\n\r\n```java\r\n@Autowired\r\nprivate RabbitTemplate rabbitTemplate;\r\n\r\n@Test\r\npublic void t1(){\r\n    rabbitTemplate.convertAndSend(\"simple.queue\", \"HelloWorld\");\r\n}\r\n```\r\n\r\n接收消息：\r\n\r\n```java\r\n@RabbitListener(queues = \"simple.queue\")\r\npublic void listenSimpleQueue(String msg){\r\n    log.info(\"收到消息：{}\", msg);\r\n}\r\n```\r\n\r\n### Work 模式\r\n\r\n多个消费者绑定一个队列，共同消费队列中的消息\r\n\r\n![](https://s11.ax1x.com/2024/01/30/pFKdfBt.png)\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t2() throws InterruptedException {\r\n    for(int i = 1; i <= 50; i++){\r\n        rabbitTemplate.convertAndSend(\"work.queue\", \"HelloWorld! Work_\" + i);\r\n        Thread.sleep(20);\r\n    }\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"work.queue\")\r\npublic void listenWorkQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n    Thread.sleep(20);\r\n}\r\n\r\n@RabbitListener(queues = \"work.queue\")\r\npublic void listenWorkQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n    Thread.sleep(200);\r\n}\r\n```\r\n\r\n这里我模拟了两个不同的处理能力消费者，消费者1的消费能力大于消费者2。若我们就直接用这个，控制台打印：\r\n\r\n```\r\n消费者1收到消息：HelloWorld! Work_1\r\n消费者2收到消息：....HelloWorld! Work_2\r\n消费者1收到消息：HelloWorld! Work_3\r\n消费者1收到消息：HelloWorld! Work_5\r\n消费者1收到消息：HelloWorld! Work_7\r\n消费者2收到消息：....HelloWorld! Work_4\r\n消费者1收到消息：HelloWorld! Work_9\r\n消费者1收到消息：HelloWorld! Work_11\r\n消费者1收到消息：HelloWorld! Work_13\r\n消费者2收到消息：....HelloWorld! Work_6\r\n消费者1收到消息：HelloWorld! Work_15\r\n消费者1收到消息：HelloWorld! Work_17\r\n消费者1收到消息：HelloWorld! Work_19\r\n消费者1收到消息：HelloWorld! Work_21\r\n消费者2收到消息：....HelloWorld! Work_8\r\n消费者1收到消息：HelloWorld! Work_23\r\n消费者1收到消息：HelloWorld! Work_25\r\n消费者1收到消息：HelloWorld! Work_27\r\n消费者2收到消息：....HelloWorld! Work_10\r\n消费者1收到消息：HelloWorld! Work_29\r\n消费者1收到消息：HelloWorld! Work_31\r\n消费者1收到消息：HelloWorld! Work_33\r\n消费者2收到消息：....HelloWorld! Work_12\r\n消费者1收到消息：HelloWorld! Work_35\r\n消费者1收到消息：HelloWorld! Work_37\r\n消费者1收到消息：HelloWorld! Work_39\r\n消费者2收到消息：....HelloWorld! Work_14\r\n消费者1收到消息：HelloWorld! Work_41\r\n消费者1收到消息：HelloWorld! Work_43\r\n消费者1收到消息：HelloWorld! Work_45\r\n消费者1收到消息：HelloWorld! Work_47\r\n消费者2收到消息：....HelloWorld! Work_16\r\n消费者1收到消息：HelloWorld! Work_49\r\n消费者2收到消息：....HelloWorld! Work_18\r\n消费者2收到消息：....HelloWorld! Work_20\r\n消费者2收到消息：....HelloWorld! Work_22\r\n消费者2收到消息：....HelloWorld! Work_24\r\n消费者2收到消息：....HelloWorld! Work_26\r\n消费者2收到消息：....HelloWorld! Work_28\r\n消费者2收到消息：....HelloWorld! Work_30\r\n消费者2收到消息：....HelloWorld! Work_32\r\n消费者2收到消息：....HelloWorld! Work_34\r\n消费者2收到消息：....HelloWorld! Work_36\r\n消费者2收到消息：....HelloWorld! Work_38\r\n消费者2收到消息：....HelloWorld! Work_40\r\n消费者2收到消息：....HelloWorld! Work_42\r\n消费者2收到消息：....HelloWorld! Work_44\r\n消费者2收到消息：....HelloWorld! Work_46\r\n消费者2收到消息：....HelloWorld! Work_48\r\n消费者2收到消息：....HelloWorld! Work_50\r\n```\r\n\r\n可以看到，消费者1和消费者2消费的数量是一样的。但是因为消费者1的消费速度大于2，所以消息很快就会被消费完，而消费者2的速度太慢，导致消息一直堆积\r\n\r\n修改代码，添加如下配置：\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n```\r\n\r\n让消费者只有在处理完当前1条消息后才能继续消费，这样执行一遍，控制台打印：\r\n\r\n```\r\n消费者1收到消息：HelloWorld! Work_1\r\n消费者2收到消息：....HelloWorld! Work_2\r\n消费者1收到消息：HelloWorld! Work_3\r\n消费者1收到消息：HelloWorld! Work_4\r\n消费者1收到消息：HelloWorld! Work_5\r\n消费者1收到消息：HelloWorld! Work_6\r\n消费者2收到消息：....HelloWorld! Work_8\r\n消费者1收到消息：HelloWorld! Work_7\r\n消费者1收到消息：HelloWorld! Work_9\r\n消费者1收到消息：HelloWorld! Work_10\r\n消费者1收到消息：HelloWorld! Work_11\r\n消费者1收到消息：HelloWorld! Work_12\r\n消费者1收到消息：HelloWorld! Work_13\r\n消费者1收到消息：HelloWorld! Work_14\r\n消费者2收到消息：....HelloWorld! Work_15\r\n消费者1收到消息：HelloWorld! Work_16\r\n消费者1收到消息：HelloWorld! Work_17\r\n消费者1收到消息：HelloWorld! Work_18\r\n消费者1收到消息：HelloWorld! Work_19\r\n消费者1收到消息：HelloWorld! Work_20\r\n消费者1收到消息：HelloWorld! Work_21\r\n消费者2收到消息：....HelloWorld! Work_23\r\n消费者1收到消息：HelloWorld! Work_22\r\n消费者1收到消息：HelloWorld! Work_24\r\n消费者1收到消息：HelloWorld! Work_25\r\n消费者1收到消息：HelloWorld! Work_26\r\n消费者1收到消息：HelloWorld! Work_27\r\n消费者1收到消息：HelloWorld! Work_28\r\n消费者1收到消息：HelloWorld! Work_29\r\n消费者1收到消息：HelloWorld! Work_30\r\n消费者2收到消息：....HelloWorld! Work_31\r\n消费者1收到消息：HelloWorld! Work_32\r\n消费者1收到消息：HelloWorld! Work_33\r\n消费者1收到消息：HelloWorld! Work_34\r\n消费者1收到消息：HelloWorld! Work_35\r\n消费者1收到消息：HelloWorld! Work_36\r\n消费者1收到消息：HelloWorld! Work_37\r\n消费者2收到消息：....HelloWorld! Work_38\r\n消费者1收到消息：HelloWorld! Work_39\r\n消费者1收到消息：HelloWorld! Work_40\r\n消费者1收到消息：HelloWorld! Work_41\r\n消费者1收到消息：HelloWorld! Work_42\r\n消费者1收到消息：HelloWorld! Work_43\r\n消费者1收到消息：HelloWorld! Work_44\r\n消费者1收到消息：HelloWorld! Work_45\r\n消费者2收到消息：....HelloWorld! Work_46\r\n消费者1收到消息：HelloWorld! Work_47\r\n消费者1收到消息：HelloWorld! Work_48\r\n消费者1收到消息：HelloWorld! Work_49\r\n消费者1收到消息：HelloWorld! Work_50\r\n```\r\n\r\n可以发现，消费者1的消费数量明显多于消费者2，达到了一种能者多劳的效果\r\n\r\n## 交换机\r\n\r\n生产环境中消息不会直接发送到队列，需要经过交换机来转发，有三种交换机类型:\r\n\r\n- Fanou：广播\r\n- Direct：定向\r\n- Topic：话题\r\n\r\n### Fanout 交换机\r\n\r\n创建一个类型为 `fanout` 交换机：`test.fanout`，绑定两个队列 `fanout.queue1` 和 `fanout.queue2`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t3(){\r\n    rabbitTemplate.convertAndSend(\"test.fanout\", null, \"HelloWorld! Fanout\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"fanout.queue1\")\r\npublic void listenFanoutQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"fanout.queue2\")\r\npublic void listenFanoutQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n控制台打印：\r\n\r\n```\r\n消费者2收到消息：....HelloWorld! Fanout\r\n消费者1收到消息：HelloWorld! Fanout\r\n```\r\n\r\n可以知道，消息通过 Fanout 交换机转发，会发送给绑定该交换机的所有队列，这就好理解广播的作用了\r\n\r\n### Direct 交换机\r\n\r\nDirect 交换机可以在 Fanout 交换机的基础上实现更复杂的业务，比如想要在广播的同时，让某些队列不接受消息\r\n\r\n创建一个交换机 `test.dirct`，绑定两个队列：`dirct.queue1` 包括 routing key：`blue `和 `red` 、`dirct.queue2` 包括 routing key：`red` 和 `yellow`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t4(){\r\n      rabbitTemplate.convertAndSend(\"test.direct\", \"red\", \"HelloWorld! Direct Red\");\r\n      rabbitTemplate.convertAndSend(\"test.direct\", \"blue\", \"HelloWorld! Direct Blue\");\r\n    rabbitTemplate.convertAndSend(\"test.direct\", \"yellow\", \"HelloWorld! Direct Yellow\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"direct.queue1\")\r\npublic void listenDirectQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"direct.queue2\")\r\npublic void listenDirectQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n有控制台打印可知：当发送消息 routing key 为 red 的时候，两者都会收到消息；当 routing key 为 blue 的时候，只有第一个消费者能够消费； routing key 为 yellow 的时候，只有第二个消费者能够消费\r\n\r\n### Topic 交换机\r\n\r\nTopic 交换机相对于 Direct 交换机，它能够在使用 routing key 的时候使用通配符表示，适用的场景更多\r\n\r\n有两种通配符，通配符通过 `.` 进行分割\r\n\r\n- #：代指0个或者多个单词\r\n- *：代指1个单词\r\n\r\n创建一个交换机 `test.queue`，绑定两个队列：`topic.queue1` 包括 routing key：`china.#`、`topic.queue2` 包括 routing key：`#.news`\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t5(){\r\n      rabbitTemplate.convertAndSend(\"test.topic\", \"china.666\", \"HelloWorld! Topic china\");\r\n      rabbitTemplate.convertAndSend(\"test.topic\", \"japan.news\", \"HelloWorld! Topic 日本\");\r\n    rabbitTemplate.convertAndSend(\"test.topic\", \"china.news\", \"HelloWorld! Topic 都有\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"topic.queue1\")\r\npublic void listenTopicQueue1(String msg) throws InterruptedException {\r\n    log.info(\"消费者1收到消息：{}\", msg);\r\n}\r\n\r\n@RabbitListener(queues = \"topic.queue2\")\r\npublic void listenTopicQueue2(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n## 交换机和队列绑定\r\n\r\n有两种方式，一种是配置实现，一种是注解实现\r\n\r\n第一种当出现交换机和队列数量过多时，代码就要写很多，且绑定关系也会变得复杂，所以选择上最好选用第二种\r\n\r\n### 配置式\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\asdaklsASDjlk.png)\r\n\r\n创建一个 Fanout 交换机\r\n\r\n```java\r\n@Bean\r\npublic FanoutExchange fanoutExchange1(){\r\n    return new FanoutExchange(\"test.fanout2\");\r\n}\r\n```\r\n\r\n创建一个队列\r\n\r\n```java\r\n@Bean\r\npublic Queue fanoutQueue1(){\r\n    return new Queue(\"fanout.queue3\");\r\n}\r\n```\r\n\r\n绑定队列和交换机\r\n\r\n```java\r\n// 第一种绑定方式\r\n@Bean\r\npublic Binding binding(){\r\n    return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange1());\r\n}\r\n// 第二种绑定方式\r\n@Bean\r\npublic Binding binding(FanoutExchange fanoutExchange1, Queue fanoutQueue1){\r\n    return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange1);\r\n}\r\n\r\n// 若是有routing key\r\n@Bean\r\npublic Binding binding(DirectExchange DirectExchange1, Queue fanoutQueue1){\r\n    return BindingBuilder.bind(fanoutQueue1).to(DirectExchange1).with(\"red\");\r\n}\r\n```\r\n\r\n### 注解式\r\n\r\n参考格式\r\n\r\n```java\r\n@RabbitListener(bindings = @QueueBinding(\r\n        value = @Queue(name = \"direct.queue3\", durable = \"true\"),\r\n        exchange = @Exchange(name = \"test.direct2\", type = ExchangeTypes.DIRECT),\r\n        key = {\"red\", \"yellow\"}\r\n))\r\npublic void listenDirectQueue3(String msg) throws InterruptedException {\r\n    log.info(\"消费者2收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n## 消息转化器\r\n\r\nSpring amqp 默认适用的消息转化器用的是 `SimpleMessageConverter`，当传入一个 Map 对象，因为 Map 实现了 Serializable 接口，所以会用 JDK 自带的 `(new ObjectOutputStream(stream)).writeObject(object)` 方法进行序列化，序列化的结果如下：\r\n\r\n```\r\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAAEVG9ueXQA\r\nAzEzM3QABE1pa2V0AAMyMTN4\r\n```\r\n\r\n所以需要对这个对象进行 jackson 序列化\r\n\r\n添加 yml 依赖\r\n\r\n```yaml\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n    <version>2.15.4</version>\r\n</dependency>\r\n```\r\n\r\n添加 Bean，返回 `Jackson2JsonMessageConverter`\r\n\r\n```java\r\n@Bean\r\npublic MessageConverter jackMessageConverter(){\r\n    return new Jackson2JsonMessageConverter();\r\n}\r\n```\r\n\r\n生产者\r\n\r\n```java\r\n@Test\r\npublic void t6(){\r\n    Map<String, String> res = new HashMap<>();\r\n    res.put(\"Tony\", \"133\");\r\n    res.put(\"Mike\", \"213\");\r\n    rabbitTemplate.convertAndSend(\"object.queue\", res);\r\n}\r\n```\r\n\r\n消费者\r\n\r\n```java\r\n@RabbitListener(queues = \"object.queue\")\r\npublic void listenObjectQueue(Map<String, String> msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n控制台输出\r\n\r\n```\r\n消费者收到消息：....{Tony=133, Mike=213}\r\n```\r\n\r\n可以看到，消息已经成功序列化\r\n\r\n## 消息的可靠性\r\n\r\n### 生产者可靠性\r\n\r\n#### 生产者重连\r\n\r\n由于网络波动，可能出现客户端连接 MQ 失败的情况，导致连接 MQ 失败\r\n\r\n解决：添加 yml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    # 以下配置是MQ连接超时的配置\r\n    connection-timeout: 1s # 超时连接时间\r\n    template:\r\n      retry:\r\n        enabled: true # 开启超时自动重连\r\n        initial-interval: 1000ms # 失败后的初始等待时间\r\n        multiplier: 1 # 失败后下次等待时常的倍数\r\n        max-attempts: 3 # 最大重连次数\r\n```\r\n\r\n当连接超时后，会等待1秒后再次进行重连，若3次重连后任然失败，就会抛出异常\r\n\r\n**注意**：超时重连是阻塞式的重试，也就是说重试不成功是不会执行消息发送后面的代码的\r\n\r\n#### 生产者确认\r\n\r\n有两种确认机制： Publisher Confirm 和 Publisher Return\r\n\r\n当消息发送到了 MQ，返回 ACK，否则都是 NACK\r\n\r\n添加 yml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n   \t...\r\n    # 以下是生产者消息确认\r\n    publisher-confirm-type: correlated # 开启消息确认机制，类型为异步\r\n    publisher-returns: true # 开启消息return机制，用于返回失败消息\r\n```\r\n\r\n有三种消息确认类型\r\n\r\n- none：关闭确认机制\r\n- simple：同步阻塞等待回调消息\r\n- correlated：异步回调执行回调消息\r\n\r\n添加 Confirm 配置类，需要实现 `ApplicationContextAware` 接口\r\n\r\n```java\r\n@Slf4j\r\n@Configuration\r\npublic class MqConfirmConfig implements ApplicationContextAware {\r\n    @Override\r\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\r\n        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);\r\n        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {\r\n            @Override\r\n            public void returnedMessage(ReturnedMessage message) {\r\n                log.error(\"收到消息return callback：message:{}, exchange:{}, code:{}, text:{}, routingKey:{}\",\r\n                        message.getMessage(), message.getExchange(), message.getReplyCode(),\r\n                        message.getReplyText(), message.getRoutingKey());\r\n            }\r\n        });\r\n    }\r\n}\t\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t7(){\r\n    CorrelationData cd = new CorrelationData(UUID.randomUUID().toString(true));\r\n    cd.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {\r\n        @Override\r\n        public void onFailure(Throwable ex) {\r\n            // Spring内部出现错误，与MQ无关，一般不会发生错误\r\n            log.error(\"消息回调失败：\", ex);\r\n        }\r\n\r\n        @Override\r\n        public void onSuccess(CorrelationData.Confirm result) {\r\n            if (result.isAck()){\r\n                log.info(\"消息发送成功，收到ACK\");\r\n            } else {\r\n                log.error(\"消息发送失败，收到NACK，原因：{}\", result.getReason());\r\n            }\r\n        }\r\n    });\r\n\r\n    rabbitTemplate.convertAndSend(\"test.direct\", \"yellow\", \"HelloWorld! Direct Yellow\", cd);\r\n}\r\n```\r\n\r\n此时交换机和 routing key 都是正确的，控制台打印：\r\n\r\n```\r\n消息发送成功，收到ACK\r\n```\r\n\r\n若 routing key 不正确，控制台打印：\r\n\r\n```\r\n消息发送成功，收到ACK\r\n收到消息return callback：message:(Body:'\"HelloWorld! Direct Yellow\"' MessageProperties [headers={spring_returned_message_correlation=f6a38c92958643c299b834c543a56f38, __TypeId__=java.lang.String}, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0]), exchange:test.direct, code:312, text:NO_ROUTE, routingKey:yel1low\r\n```\r\n\r\n若交换机不存在，控制台打印：\r\n\r\n```\r\n消息发送失败，收到NACK，原因：channel error; protocol method: #method<channel.close>(reply-code=404, reply-text=NOT_FOUND - no exchange 'test.direct1' in vhost '/jixer', class-id=60, method-id=40)\r\n```\r\n\r\n**注意**：在实际开发中，尽量不使用生产者确认机制（影响效率）。若一定要使用，无需开启 Publisher Return 机制，因为一般路由失败都是自己业务的问题，比如：交换机名字写出。对于 NACK 消息可以有限次数重试机，依然失败则记录异常消息\r\n\r\n### MQ 可靠性\r\n\r\n#### 数据持久化\r\n\r\n数据持久化有三个方面：\r\n\r\n- 交换机持久化\r\n- 队列持久化\r\n- 消息持久化\r\n\r\n当我们使用 SpringBoot 创建交换机、队列、消息的时候会默认使用持久化\r\n\r\n若我们不用持久化，重启一遍 RabbitMQ，这些数据就会丢失\r\n\r\n下面演示发送消息非持久化带来的问题：\r\n\r\n生产者\r\n\r\n```java\r\n@Test\r\npublic void t8(){\r\n    Message msg = MessageBuilder.withBody(\"123123\".getBytes(StandardCharsets.UTF_8))\r\n            .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)\r\n            .build();\r\n    for(int i = 0; i < 1000000; i++){\r\n        rabbitTemplate.convertAndSend(\"simple.queue\", msg);\r\n    }\r\n}\r\n```\r\n\r\n无消费者，此时观察管理页面\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\124GHDhj.png)\r\n\r\n可以看到，当消息增多，出现堆积，会造成 Page Out，MQ 会陷入短暂的阻塞，接收速度变为0，无法处理消息\r\n\r\n这是因为非持久的消息保存在内存中，MQ 会每隔一段时间当把消息存入内存，这段时间内会阻塞出现 Page Out\r\n\r\n若我们发送持久化就不会出现 Page Out 的问题\r\n\r\n#### Lazy Queue\r\n\r\nLazy Queue的特点：\r\n\r\n- 接收的消息直接存入磁盘，也就是页面显示直接在 Page Out\r\n- 消费者消费需要从磁盘读取并加载到内存中\r\n- 支持百万条消息存储\r\n\r\n**创建 Lazy Queue**\r\n\r\n配置类方式\r\n\r\n```java\r\n@Bean\r\npublic Queue lazyQueue(){\r\n    return QueueBuilder.durable(\"lazy.queue\").lazy().build();\r\n}\r\n```\r\n\r\n注解方式\r\n\r\n```java\r\n@RabbitListener(queuesToDeclare = @Queue(\r\n        name = \"lazy.queue\",\r\n        durable = \"true\",\r\n        arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")\r\n))\r\npublic void listenLazyQueue(String msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n发送100万条消息，管理页面显示：\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\dHDlkjae.png)\r\n\r\n可以看到消息一直处于 Page Out，并且速率大部分时间都处于峰值\r\n\r\n### 消费者的可靠性\r\n\r\n#### 消费者确认\r\n\r\n当消费者处理完消息后，可以告知 RabbitMQ 自己消息的处理状态，有三种状态：\r\n\r\n- ACK：成功，MQ 删除消息\r\n- NACK：失败，MQ 需要再次投递消息\r\n- REJECT：失败并拒绝，MQ 删除消息（一般是出现消息格式错误）\r\n\r\n添加 yaml 依赖\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n\t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledge-mode: auto # 消费者消息确认类型\r\n```\r\n\r\n消费者确认类型有三种：\r\n\r\n- none：不做处理\r\n- manual：手动模式\r\n- auto：自动模式（默认）\r\n  - 业务异常返回 NACK\r\n  - 消息处理异常或校验异常返回 REJECT\r\n\r\n向 `simple.queue` 队列发送一条消息\r\n\r\n消费者\r\n\r\n```java\r\n@RabbitListener(queues = \"simple.queue\")\r\npublic void listenSimpleQueue(String msg) throws Exception {\r\n    log.info(\"收到消息：{}\", msg);\r\n    throw new Exception(\"故意的\");\r\n}\r\n```\r\n\r\n若选择用 none 类型：走到异常，但这段代码还没走完，消息已经消费了，消息丢失\r\n\r\n若选用 auto 类型：走到异常后，业务返回 NACK，RabbitMQ 自动重新投递，直到消费成功为止；若将传参 String 类型换成其他类型（消息格式错误），业务代码返回 REJECT，MQ 会消费并删除消息\r\n\r\n#### 消费者失败重试\r\n\r\n上面消费者确认有个问题：经过消费者确认后一直失败一直在重试，一直在消耗系统资源\r\n\r\n解决办法：添加消费者失败重试\r\n\r\n当重试次数达一定次数后就自定义重试策略\r\n\r\n有三种重试策略：\r\n\r\n- RepublishMessageRecoverer：将失败消息投递到指定的交换机处理\r\n- RejectAndDontRequeueRecoverer：直接 REJECT，丢弃消息（默认）\r\n- ImmediateRequeueMessageRecoverer：返回 NACK，消息重回入队\r\n\r\n这里选用 RepublishMessageRecoverer 策略\r\n\r\n添加 yaml 配置\r\n\r\n```yaml\r\nspring:\r\n  rabbitmq:\r\n  \t...\r\n    listener:\r\n      simple:\r\n        prefetch: 1 # 每次只能领取一条消息，处理完才能获取一下条消息\r\n        acknowledge-mode: auto # 消费者消息确认类型\r\n    # 以下是开启消费者失败重试机制\r\n        retry:\r\n          enabled: true\r\n          initial-interval: 1000ms # 初始失败的时长等待\r\n          multiplier: 1 # 失败后下次等待时常的倍数\r\n          max-attempts: 3 # 最大重连次数\r\n          stateless: true # true无状态，false有状态。如果业务包含事务，改为false\r\n```\r\n\r\n新建一个 ErrorConfig 配置类，用于绑定失败处理交换机和队列，并设置失败处理策略\r\n\r\n通过 `@ConditionalOnProperty` 来限制只有当 yml 配置文件中 `retry.enabled` 为 `true` 的时候才创建 Bean\r\n\r\n```java\r\n@Configuration\r\n@ConditionalOnProperty(prefix = \"spring.rabbitmq.listener.simple\", name = \"retry.enabled\", havingValue = \"true\") // 只有当前配置文件为true才创建bean\r\npublic class ErrorConfig {\r\n    @Bean\r\n    public DirectExchange errorExchange(){\r\n        return new DirectExchange(\"test.error\");\r\n    }\t\r\n    @Bean\r\n    public Queue errorQueue(){\r\n        return new Queue(\"error.queue\");\r\n    }\r\n    @Bean\r\n    public Binding binding(){\r\n        return BindingBuilder.bind(errorQueue()).to(errorExchange()).with(\"error\");\r\n    }\r\n    @Bean\r\n    public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){\r\n        return new RepublishMessageRecoverer(rabbitTemplate, \"test.error\", \"error\");\r\n    }\r\n}\r\n```\r\n\r\n在消费者代码处抛出异常，会看到当重试三次后，会将失败消息发送错误处理交换机，再由交换机转发到队列，后面由人工进行处理\r\n\r\n错误消息如下：可以看清楚的看到那块地方出错了\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\d12HSyrash.png)\r\n\r\n#### 消费者的幂等性\r\n\r\n通过上述消费者的确认和消费者的失败重试，可以保证消费者至少能够把消息消费一次，但是可能出现多次消费的情况，多次消费可能导致数据错误\r\n\r\n幂等：执行一次和执行多次对业务的结果是一样的\r\n\r\n**方案一：唯一消息 ID**\r\n\r\n给每个消息设置一个唯一的 ID，每次消费者进行消费的时候将 ID 保存入数据库，下次消费前先判断数据库是否已经存在 ID，存在就代表已经消费，否则就可以消费\r\n\r\n修改消息转化器，设置自动创建消息 ID\r\n\r\n```java\r\n@Bean\r\npublic MessageConverter jackMessageConverter(){\r\n    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();\r\n    jackson2JsonMessageConverter.setCreateMessageIds(true);\r\n    return jackson2JsonMessageConverter;\r\n}\r\n```\r\n\r\n创建后的消息如图所示：\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\sadJ1.png)\r\n\r\n**方案二：业务判断**\r\n\r\n根据业务的需求来判断，比如：支付服务完成后发送消息给订单服务，订单服务需要将订单状态由未支付变为已支付，所以这里只需要对未支付的订单进行消费即可，已支付的订单不需要再次处理\r\n\r\n具体的 SQL 语句变为：\r\n\r\n```sql\r\nupdate tb_order set status = 1 where id = xxx and status = 2\r\n```\r\n\r\n只需要对数据库操作一次就满足了要求，而方案一需要对数据库进行多次操作（查询，更新）\r\n\r\n## 延迟消息\r\n\r\n### 死信交换机\r\n\r\n创建队列与交换，关系如图所示：\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\asdUI1g.png)\r\n\r\n`simple.direct` 交换机绑定 `simple.queue` 队列， `simple.queue` 绑定 `dlx.direct` 死信交换机\r\n\r\n创建 `simple.queue` 的时候绑定死信交换机方法如下：\r\n\r\n![](../../.vuepress\\public\\assets\\article\\rabbitmq\\dKLHJh.png)\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t10(){\r\n    rabbitTemplate.convertAndSend(\"simple.direct\", \"simple\", \"你好\", new MessagePostProcessor() {\r\n        @Override\r\n        public Message postProcessMessage(Message message) throws AmqpException {\r\n            message.getMessageProperties().setExpiration(\"10000\"); // 设置过期时间\r\n            return message;\r\n        }\r\n    });\r\n    log.info(\"发送消息\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(queues = \"dlx.queue\")\r\npublic void listenDlxQueue(String msg) {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\n生产者发送过期时间为10s消息，消费者监听的是死信队列，并不是监听的是 `simple.queue` 这个队列\r\n\r\n因为 `simple.queue` 队列的消息没有被消费，所以当10s后消息会被发送到死信交换机，死信交换机转发到死信队列\r\n\r\n### 消息延迟插件\r\n\r\n消息延迟与死信交换机不同，它是将消息发送到交换机，在交换机中暂存一段时间后再投递到队列中\r\n\r\n插件下载地址：[rabbitmq/rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases)\r\n\r\n进入 RabbitMQ 插件目录执行以下命令开启插件\r\n\r\n```\r\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\r\n```\r\n\r\n生产者：\r\n\r\n```java\r\n@Test\r\npublic void t11(){\r\n    rabbitTemplate.convertAndSend(\"delay.direct\", \"hi\", \"你好\", new MessagePostProcessor() {\r\n        @Override\r\n        public Message postProcessMessage(Message message) throws AmqpException {\r\n            message.getMessageProperties().setDelay(10000); // 设置延迟时间\r\n            return message;\r\n        }\r\n    });\r\n    log.info(\"发送消息\");\r\n}\r\n```\r\n\r\n消费者：\r\n\r\n```java\r\n@RabbitListener(bindings = @QueueBinding(\r\n        value = @Queue(name = \"delay.queue\", durable = \"true\"),\r\n        exchange = @Exchange(name = \"delay.direct\", delayed = \"true\"),\r\n        key = {\"hi\", \"hello\"}\r\n))\r\npublic void listenDelayQueue(String msg) throws InterruptedException {\r\n    log.info(\"消费者收到消息：....{}\", msg);\r\n}\r\n```\r\n\r\nRabbitMQ 的延迟消息是有一定的功能损耗的，所以适用于延迟时间不太长的场景\r\n\r\n在一般的超时订单场景中，若设置的超时时间为30分钟，会存在两个问题：\r\n\r\n- 若并发高，30分钟可能堆积消息过多，MQ 压力大\r\n- 大多数订单在下单后1分钟内就会支付，但是 MQ 却需要等待30分钟，浪费资源\r\n\r\n解决方法：设置消息过期时间梯度数组，将30分钟拆分为多个小部分，每个部分个根据可能支付的概率选用合适的等大时间\r\n","title":" RabbitMQ学习笔记\r\n","category":[" RabbitMQ","中间件\r\n"],"date":" 2024-06-27\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"}}