{"filename":"mysql","category":"database","md":{"topSummary":"\r\ntitle: MySQL知识点总结\r\ncategory: MySQL,数据库\r\ndate: 2024-05-23\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n近日看了小林 code 的关于 MySQL 的八股文，易忘，于是在此提取重点记下\r\n\r\n参考文章：[小林code-MySQL篇](https://xiaolincoding.com/mysql/index/index_interview.html) 和  [JavaGuide-MySQL篇](https://javaguide.cn/database/mysql/mysql-questions-01.html) \r\n\r\n## 索引\r\n\r\n若把数据库库的表比作一本书，那么索引就是书的目录，通过索引我们可以快速定位想要寻找的位置\r\n\r\n### 索引分类\r\n\r\nMySQL的默认采用存储结构是 InnoDB ，使用最多的索引类型是 B+ 树\r\n\r\n这里我们将不同的索引类型进行分开讨论：\r\n\r\n- 按照数据结构进行划分：B+ 树索引、Hash 索引、Full-Text 索引\r\n\r\n- 按照物理存储进行划分：主键索引、二级索引\r\n\r\n- 按照字段特性进行划分：主键索引、唯一索引、普通索引、前缀索引\r\n\r\n- 按照字段个数进行划分：单列索引、联合索引\r\n\r\n### MySQL选取索引探讨\r\n\r\nMySQL所选用的索引第一个目的肯定是查询越快越好，这里我们就到了二分查找，但是二分查找的数组的插入性能低下，就需要用到二分查找树，二分查找树有个弊端：当插入的数据是递增的时候，这时候的查找效率就变成了 O(n)，所以我们需要在插入的时候限制不能让他一直插入到一端结点，这时候就想到了平衡二叉树，平衡二叉树保证了每个节点的左子树和右子树的高度差不能超过 1，很符合当前二分查找树出现弊端的情况，但是新的问题又出现了，平衡二叉树只有两个子节点，当数据非常大的情况下，树的高度就会变得很高，就需要很多次查询，影响效率；于是 B 树就横空出世了，它解决了平衡二叉树结点只有两个导致树高的问题，它可以由很多个子结点，想到用 B 树，那么 B+ 树岂不是更好？，B+ 树的查询、插入和删除、范围查询效率更高，于是就采用了 B+ 树结构作为默认的索引\r\n\r\n### B+ 树索引执行过程\r\n\r\n若存在如下结构的 B+ 树\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/btree.drawio.png)\r\n\r\n当要查询 ID 为5的时候，首先会用二分查询在(1，10，20)之间进行查询，找到在(1，10)之间，接着在第二层进行查询(1，4，7)，找到是在(4，7)范围内，最后在叶子结点进行查找(4，5，6)，找到5，范围其数据即可\r\n\r\n上面是只有主键索引的情况，若出现既有主键索引，又有二级索引的情况，方式就会有变化：二级索引的叶子节点存放的(二级索引，主键索引)，而没有存在具体的数据，如果我们质询要查询主键值，就直接返回【这种在二级索引就能查询到的结果叫做**覆盖索引**】，若要查询其他的具体所以，我们需要通过二级索引查找得到主键值，再通过主键值【**回表**】查询数据，也就是需要查询两个 B+ 树才能查到数据\r\n\r\n### 最左匹配原则\r\n\r\n在使用联合索引的时候，存在最左匹配原则\r\n\r\n比如一个表的索引字段为（a，b，c），当我们查询以下条件的时候（查询的时候与 abc 顺序无关）\r\n\r\n```sql\r\nwhere a=1；\r\nwhere a=1 and b=2 and c=3；\r\nwhere a=1 and b=2；\r\n```\r\n\r\n就会匹配上联合索引，但是若是以下条件时候就不会，不满足最左匹配原则\r\n\r\n```sql\r\nwhere b=2；\r\nwhere c=3；\r\nwhere b=2 and c=3；\r\n```\r\n\r\n为什么呢？因为我们通过B+ 树索引执行过程可知，是先按照 a 进行排序的，当 a 想同，在按照 b 排序，当 b 相同，再按照 c 排序。\r\n\r\n所以 **b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。\t\r\n\r\n### 字段索引选用的情况\r\n\r\n事物都存在两面性，索引既然有好的一面，那么也有坏的一面，例如：\r\n\r\n1. 索引需要的占用物理空间\r\n2. 创建索引和维护索引需要耗费时间，所需时间随数据量增大而增加\r\n3. 降低增删改效率，因为每次增删改，都会动态维护 B+ 树的有序性\r\n\r\n**字段选用索引的情况：**\r\n\r\n1. 经常用 `where` 查询条件的字段\r\n2. 具有唯一性的字段\r\n3. 经常用 `group by` 和 `order by` 的字段【我们不需要再次排序，因为 B+ 树的记录是有序的】\r\n\r\n**字段不选用索引的情况：**\r\n\r\n1. 更新频繁的字段\r\n2. 表数据太少的时候\r\n3. `where`、`group by` 和 `order by` 的用不上的字段\r\n4. 字段中存在大量重复数据的时候\r\n\r\n### 索引失效\r\n\r\nMySQL中索引失效是一个常见的面试题，以下是索引失效的几种情况：\r\n\r\n1. 使用左或者左右模糊匹配的时候，如：`%x` 或 `%xx%` 【注意：`%x` 并不一定会导致索引失效，当表中的字段都是索引字段，没有遵循最左匹配原则也是走全扫描二级索引树】\r\n2. 条件查询中对索引使用函数、计算、类型转换\r\n3. 若是联合索引未遵守最左匹配原则\r\n4. 在 WHERE 子句中，OR 前的条件是索引列，而 OR 后的条件不是索引列\r\n\r\n### 索引优化的方法\r\n\r\n1、**前缀索引优化**\r\n\r\n2、**覆盖索引优化**：\r\n\r\n添加冗余字段当作联合索引\r\n\r\n3、**主键索引最好自增**：\r\n\r\n若主键自增，每次插入的时候就不用移动数据，直接插到最后；若不是自增，插入位置是随机的，我们就不得不移动其他的数据，甚至是需要从一个页面移到另一个页面，这种现象就是**页分裂**【存在大量空间碎片，结构不紧凑影响查询效率】\r\n\r\n4、**索引最好设置为 NOT NULL**：\r\n\r\n- 为 null 的索引字段进行索引统计和值比较更为复杂，比如：进行索引统计，count 会省略值为 null 的行\r\n- null 会占用至少1字节的物理空间\r\n\r\n5、**防止索引失效**\r\n\r\n## 事务\r\n\r\nA 向 B 转账100元，首先 A 扣除了100元，但是当 B 接收100元的时候，服务器出现故障导致 B 没有收到转账，但是 A 已经扣除了100元，也就是100元就不见了。要想让操作全部执行成功或者全部执行失败，就需要用到**事务**\r\n\r\n### 事务特性\r\n\r\n事务有四个特性，如下：\r\n\r\n- **原子性**：要么全部成功，要么全部失败\r\n- **一致性**：A 给 B 100元，A 扣除了100元，不会出现B没有增加100元的情况\r\n- **隔离性**：多个事务使用相同的数据时，不会相互干扰\r\n- **持久性**：数据修改后是永久保存的，即使重启后也不会丢失\r\n\r\n### 并行事务引发的问题\r\n\r\n1、**脏读**：一个事务读取到另一个事务未提交的数据\r\n\r\n有一个数据为100，现在 A 将数据修改为200，这时候还未提交事务，这时候 B 获取数据200，拿到别处地方用，可是 A 出现某种状况导致回滚，A 的数据变回100\r\n\r\n2、**不可重复读**：在同一个事务中多次读取同一个数据，但这些读取中取得了不同的结果\r\n\r\n有一个数据为100，现在 A 读取了数据100，接着 B 将数据修改为200并提交了事务，当 A 再次读取的时候数据变成了200，与之前读取的数据不一致\r\n\r\n3、**幻读**：在同一事务中多次查询符合条件的记录数量，出现查询到的数量不一样\r\n\r\n有大于1的记录为100条，现在 B 对大于1的记录条数进行查询得到100，现在 A 插入了一条记录3并提交了事务，当 B 再次查询的时候发现条数为101条，前后两次查询到的记录数量不一样\r\n\r\n**严重性排序**：脏读 > 不可重复读 > 幻读\r\n\r\n### Read View\r\n\r\nRead View 结构如下：\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/readview结构.drawio.png)\r\n\r\n### 事务隔离级别\r\n\r\nMySQL有四种事务隔离级别\r\n\r\n#### **读未提交**\r\n\r\n一个事务还未提交，它做的变更就能被其他事务看到\r\n\r\n可能造成：脏读、不可重复读、幻读\r\n\r\n实现：因为能读到未提交事务修改的数据，所以直接读取最新的数据就行\r\n\r\n#### **读提交**\r\n\r\n一个事务提交后才能被其他事务看到\r\n\r\n可能造成：不可重复读、幻读\r\n\r\n实现：**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**\r\n\r\n建议先看可重复读的实现部分，再来看此处的实现部分，进行对比\r\n\r\n比如：例子和可重复读一致\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100（创建了 Read View）\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100（创建了 Read View）\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 为 200（创建了 Read View）\r\n\r\n解释：\r\n\r\n1. 第一次读取事务 B 创建了 Read View\r\n\r\n```\r\ncreator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n事务的 min_trx_id 值51大于 trx_id 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n2. 事务 A 修改了 money 值，记录的字段创建了版本链\r\n\r\n```\r\nid:1, name: Jixer, money: 200, trx_id:51, roll_pointer:o--------->id:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o\r\n```\r\n\r\n3. 事务 B 再次读取，创建了Read View\r\n\r\n```\r\ncreator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n分析和可重复读那块一致\r\n\r\n4. 事务 A 提交了事务，事务 B 第三次读取的时候创建了 Read View\r\n\r\n```\r\nx creator_trx_id:52, mids:[52], min_trx_id: 52, max_trx_id: 53\r\n```\r\n\r\n发现此时的 min_trx_id 值52已经大于了 trx_id 值51，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n\r\n所以在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录并提交了事务\r\n\r\n#### **可重复读**\r\n\r\n**MySQL 默认的隔离级别**\r\n\r\n一个事务执行过程中看到的数据一直和事务启动前看到的数据是一致的\r\n\r\n可能造成：幻读【这种隔离级别很大程度上避免了幻读现象，但并不是完全解决了，解决方案见下个目录】\r\n\r\n实现：**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**\t\r\n\r\n比如：\r\n\r\n有一条字段如下，trx_id 和 roll_pointer 为**聚簇索引**（一般情况下就是主键索引，但是并不一定是主键索引）记录中的两个隐藏列\r\n\r\n```\r\nid:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o(undo日志)\r\n```\r\n\r\n现在有两个事务 A 和 B\r\n\r\n```\r\nA：creator_trx_id:51, mids:[51], min_trx_id: 51, max_trx_id: 52\r\nB：creator_trx_id:52, mids:[51,52], min_trx_id: 51, max_trx_id: 53\r\n```\r\n\r\n执行了以下操作：\r\n\r\n1. 事务 B 读取了 money 为 100\r\n2. 事务 A 修改了 money 为 200，没有提交事务\r\n3. 事务 B 再次读取 money 还是 100\r\n4. 事务 A 提交了事务\r\n5. 事务 B 再次读取 money 依然 100\r\n\r\n解释：\r\n\r\n1. 事务 B 读取的时候最小的 min_trx_id 值51大于 trx_id 值50，所以当前的记录对事务 B 是可见的，于是就直接读取了记录\r\n2. 事务 A 修改了记录，此时 MySQL 会记录相应的 undo log，以链表的形式串联起来，形成**版本链**，如下所示\r\n\r\n```\r\nid:1, name: Jixer, money: 200, trx_id:51, roll_pointer:o--------->id:1, name: Jixer, money: 100, trx_id:50, roll_pointer:o\r\n```\r\n\r\n3. 事务 B 再次读取的时候，此时的 trx_id值51在 Read View 的 min_trx_id 值51和 max_trx_id 值53之间，所以需判断 trx_id 是否在 m_ids 范围内，判断结果是在的，说明这条记录是还未提交的，因此 B 不会读取此时的记录，而是沿着 undo log向下找第一条小于 Read View 的 min_trx_id 值的旧版本记录，所以事务 B 找到 trx_id 为 50的记录，此时读取到 money 为100\r\n4. 事务 A 提交事务后，由于 Read View 还是用到最开始创建的，所以和步骤3一样任然查询出 money 为100\r\n\r\n> 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 **MVCC（多版本并发控制）**\r\n\r\n#### **串行化**\r\n\r\n会对记录加上读写锁，当多个事务对这个条记录进行读写操作的时候，若发生读写冲突，后访问的事务必须等前一个事务执行完才能继续执行\r\n\r\n实现：加读写锁来避免并行访问\r\n\r\n**隔离水平高低：**串行化 > 可重复读 > 读已提交 > 读未提交\r\n\r\n### 可重复读并没有完全解决幻读\r\n\r\n这种隔离级别很大程度上避免了幻读现象，**但并不是完全解决了**，目前采用的解决方案有两种\r\n\r\n- 针对快照读（普通 select 语句）：通过 **MVCC** 解决了幻读，事务执行过程中即使中途插入了一条数据，但是还是查询不出来这条数据，看到的数据一直和事务启动时看到的数据是一致的，所以避免幻读问题\r\n- 针对当前读（select ... for update 等语句）：通过 **next-key lock（记录锁+间隙锁）**方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就避免幻读问题\r\n\r\n举例了两个发生幻读场景的例子。\r\n\r\n第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。\r\n\r\n### 开启事务命令\r\n\r\n开始事务有两种命令，事务时机不同，如下：\r\n\r\n- begin/start transaction 命令：执行这条语句后事务并不会立刻启动，而是需要当执行了第一条 select 语句后才是真正的启动时机\r\n- start transaction with consistent snapshot 命令：执行命令后会立刻启动事务\r\n\r\n## 锁\r\n\r\n### 全局锁\r\n\r\n使用全局锁的命令：\r\n\r\n```mysql\r\nflush tables with read lock\r\n```\r\n\r\n执行过后，整个数据库就处于**只读状态**，此时对数据库的任何增删改操作都会被阻塞\r\n\r\n释放全局锁命令如下，断开会话也会自动释放全局锁\r\n\r\n```mysq\r\nunlock tables\r\n```\r\n\r\n**适用场景：**全局锁适用于**全库逻辑备份**，在备份数据库期间不会因为数据或表结构的更新，而出现导致备份文件的数据与预期的不一样\r\n\r\n**缺点：**全库逻辑备份的时候，没法更新新的数据，会导致业务停滞【但是这种缺点可以避免，如果数据库支持**可重复读的隔离级别**，那么会先创建 Read View ，整个事务都在用这个 Read View，而且由于 MVCC 的支持，备份期间数据依然可以进行更新操作】\r\n\r\n### 表级锁\r\n\r\n#### 表锁\r\n\r\n使用命令：\r\n\r\n```mysql\r\n//表级别的共享锁，也就是读锁；\r\nlock tables t_student read;\r\n//表级别的独占锁，也就是写锁；\r\nlock tables t_stuent write;\r\n```\r\n\r\n要释放表锁命令如下，断开会话也会自动释放表锁\r\n\r\n```sql\r\nunlock tables\r\n```\r\n\r\n若一个线程对表加了表锁，那么这个线程是对该表进行写操作会被阻塞，其他的线程也是会被阻塞\r\n\r\n#### 元数据锁（MDL）\r\n\r\n我们不需要显示的使用元数据锁，当我们对表进行操作会自动的帮我们加上元数据锁\r\n\r\n- 当对表数据进行 CRUD 的时候，加的是**元数据读锁**\r\n- 当对表结构进行修改的时候，加的是**元数据写锁**\r\n\r\n当有线程 A 使用 select 语句，此时对表加了元数据读锁，若线程 B 也用 select 语句，此时并不会阻塞线程 B，因为都是读锁；若线程 B 对表结构进行修改，则由于线程 A 读锁还在占用，所以线程 B 会进行阻塞，之后大量的线程若都是 select 语句，那么就都会被阻塞，数据库的线程很快就会爆满了\r\n\r\n这是因为申请元数据锁都会被放在一个队列中，队列中**写锁优先级大于读锁**，所以若写锁阻塞了，后面的读锁都会被阻塞。所以在数据库表结构更改前都要先看看那些长事务是否已经加了元数据读锁，可以考虑 kill 掉这个长事务，在对表结构进行修改\r\n\r\n#### 意向锁\r\n\r\n意向锁的目的：**是为了快速判断表里是否有记录被加锁**\r\n\r\n- 在加共享锁之前，会先加上意向共享锁\r\n- 在加独占锁之前，会先加上意向独占锁\r\n\r\n表锁和行锁是满足读读共享、读写互斥、写写互斥的\r\n\r\n#### AUTO-INC 锁\r\n\r\n当主键的值设置为自增的情况时，我们可以不用专门传入主键值进行保存，这主要是由于 **AUTO-INC 锁**实现的\r\n\r\nAUTO-INC 锁**不是在提交事务后释放，而是在在执行完插入语句后就释放**\r\n\r\n> 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增\r\n> 在插入的时候会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，接着就把所释放了，而不是在执行完插入语句后释放\r\n\r\n### 行级锁\r\n\r\n#### 记录锁（Record Lock）\r\n\r\n锁住的是一条记录，有两种不同的记录锁：S 锁和 X 锁\r\n\r\n- 记录加了 S 锁后任能加 S 锁，但不能加 X 锁\r\n- 记录加了 X 锁后不能加 S 锁，也不能加 X 锁\r\n\r\n执行语句如下：\r\n\r\n```mysql\r\nselect * from t_test where id = 1 for update;\r\n```\r\n\r\n#### 间隙锁（Gap Lock）\r\n\r\n锁的是一个范围，只存在于可重复读隔离级别，目的是**为了解决可重复读隔离级别下幻读的现象**\r\n\r\n例如：表中有一个 范围id 为（3, 5）间隙锁，那么 id 为4就不能插入\r\n\r\n#### 临键锁（Next-key Lock）\r\n\r\n临键锁 = Record Lock + Gap Lock\r\n\r\n锁定一个范围，并且锁定记录本身\r\n\r\n例如：表中有一个 范围id 为（3, 5] 间隙锁，那么 id 为4就不能插入并且 id  为5的记录也不能修改\r\n\r\n#### 插入意向锁\r\n\r\n一个事务在插入数据的时候需要判断该记录是否已经加了间隙锁，若加了间隙锁就会阻塞，直到释放间隙锁为止，在此期间会生成一个**插入意向锁**\r\n\r\n插入意向锁不是意向锁，是一种特殊的间隙锁，属于行级锁\r\n\r\n如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点\r\n\r\n一条记录在同一区间内不能既有插入意向锁，又有间隙锁\r\n\r\n## 日志\r\n\r\n\r\n\r\n## 执行一条 select 语句期间发生了什么\r\n\r\n![](https://gitee.com/lijunxi666/picture-bed/raw/master/mysql/mysql查询流程.png)\r\n\r\n1. 连接器：客户端与连接器进行连接，校验用户身份\r\n2. 查询缓存：若是查询语句就需要查询缓存，命中就返回，否则就继续向下执行\r\n3. 解析 SQL：对 SQL 语句继续词法分析和语法分析，构建语法树\r\n4. 处理 SQL：\r\n   - 预处理阶段：检查表或字段是否存在，将 `select *` 中的 `*` 符号扩展为表上的所有列\r\n   - 优化阶段：选择查询成本最小的执行计划\r\n   - 执行阶段：根据执行计划执行 SQL 语句，从存储引擎读取记录，返回给客户端\r\n\r\n## 存储引擎\r\n\r\nMySQL 5.5.5 之前的版本，**MyISAM** 是 MySQL 的默认存储引擎，在5.5.5之后用 **InnoDB** 作为默认存储引擎\r\n\r\n### 存储引擎架构\r\n\r\nMySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎。我们可以为不同的数据库设置不同的存储引擎，存储引擎是**基于表的，而不是数据库**\r\n\r\n### MyISAM与InnoDB对比\r\n\r\n1、InnoDB 支持行级锁，而 MyISAM 只支持表级锁\r\n\r\n2、InnoDB 提供事务，而 MyISAM 不提供事务\r\n\r\n3、InnoDB 支持外键，而 MyISAM 不支持外键\r\n\r\n4、InnoDB 支持数据库崩溃后安全恢复（依赖于 `redo log` ），而 MyISAM 不支持\r\n\r\n5、都是采用 B+ 树索引，但是索引实现不一样\r\n\r\n6、InnoDB 性能比 MyISAM 好\r\n","title":" MySQL知识点总结\r\n","category":[" MySQL","数据库\r\n"],"date":" 2024-05-23\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"}}