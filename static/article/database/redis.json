{"filename":"redis","category":"database","md":{"topSummary":"\r\ntitle: Redis知识点总结\r\ncategory: Redis,数据库\r\ndate: 2024-03-23\r\nauthor: Jixer\r\nsource: 原创\r\n\r\n","mainContent":"\r\n\r\n对 Redis 面试知识点进行总结，参考文章：[JavaGuide-Redis篇](https://javaguide.cn/database/redis/redis-questions-01.html)\r\n\r\n## Redis基础\r\n\r\nRedis 是一个基于内存的数据库，速写速度快，采用 KV 键值对的形式对数据进行存储。此外 Redis 还支持多种优化后的数据结构、内置了 Lua 脚本、消息队列、延时队列等强大功能\r\n\r\n### Redis 为什么访问怎么快\r\n\r\n- Redis 基于内存，内存比磁盘的访问速度快\r\n- Redis 内置多种优化后的数据结构\r\n- Redis 是单线路事件循环和 IO 多路复用\r\n- Redis 通信协议实现简单且解析高效\r\n\r\n### 分布式缓存技术选型有哪些\r\n\r\n1、Redis，生态丰富，资料齐全\r\n\r\n2、Memcached ，一开始兴起比较常用\r\n\r\n3、腾讯的 Tendis，没维护了，使用的少\r\n\r\n### Reids和Memcached的异同\r\n\r\n共同点：\r\n\r\n- 都是基于内存数据库，当作缓存使用\r\n- 都有过期策略\r\n- 性能都很高\r\n\r\n不同点：\r\n\r\n- Reids 含有多种数据结构和多种特性，能够适应更多复杂的场景\r\n- Redis 能够数据持久化\r\n- Redis 原生支持集群模式\r\n- Redis 过期数据删除采用惰性删除和定期删除，Memcached 采用惰性删除\r\n- Redis 采用单线路的多路 IO 复用模型，Memcached 采用多线程的非阻塞 IO 复用的网络模型\r\n\r\n### 为什么采用Redis\r\n\r\n1. 访问速度高：基于内存，访问速度比磁盘快\r\n2. 高并发：能够承受的请求数量远远大于数据库\r\n3. 功能全面：内置分布式锁、消息队列等功能\r\n\r\n### 常见的缓存策略\r\n\r\n1、旁路缓存\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：更新数据库，删除缓存\r\n\r\n2、 读写穿透\r\n\r\n以缓存为主要数据存储\r\n\r\n读：先查询缓存，缓存不存在再查询数据库，将查到的数据写入缓存再返回\r\n\r\n写：先查询缓存，缓存中不存在就直接更新数据库，缓存存在就更新缓存再更新数据库（**同步更新**）\r\n\r\n3、异步缓存写入\r\n\r\n与读写穿透类似，不同之处是更新的时候只更新缓存，采用**异步批量**的方式更新数据库\r\n\r\n### Redis Module\r\n\r\n我们可以通过 Redis Module 开发自己的 Module，比如自定义分布式锁等\r\n\r\n## Redis应用\r\n\r\n### Redis 除了做缓存，还能做什么\r\n\r\n很多，比如：分布式锁、限流、消息队列、延时队列等\r\n\r\n### 如何用Redis实现一个分布式锁\r\n\r\n使用 Lua 脚本配合 Redis 实现，可结合项目说明一下\r\n\r\n### 如何用Redis实现一个消息队列\r\n\r\nRedis 2.0之前用 List 实现，缺点是实现的功能太简单了，消息确认机制等功能需要我们自己实现，更重要的是它没有广播机制，消息也只能背消费一次\r\n\r\nRedis 2.0之后用发布定于实现，解决了 List 没有广播机制的问题\r\n\r\n### 如何用Redis实现一个延时队列\r\n\r\n两种方法：Redis 过期时间监听和 Redisson 内置的延时队列\r\n\r\n第一种方法缺点：时效性差、消息会被丢失、多服务实例下消息会被重复消费\r\n\r\n## Redis数据类型\r\n\r\n### 常用数据类型有哪些\r\n\r\n五种基础数据类型：String、hash、set（集合）、list、zset（有序集合）\r\n\r\n三种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial （地理位置）\r\n\r\n### 数据类型底层实现\r\n\r\n- String：SDS（简单动态字符串）\r\n- Hash：哈希表或压缩列表\r\n- List：双向链表或压缩列表\r\n- Set：哈希表或整数集合\r\n- ZSet：压缩列表或跳表\r\n\r\n### String应用场景\r\n\r\n存放 Token、序列化对象、页面访问计数用来限流等\r\n\r\n### String与Hash存储对象对比\r\n\r\n1、String 存储的是整合对象数据，Hash 是各个字段单独存储，也可以单独修改或添加。若是需要经常修改或查询单个字段用 Hash 比较好\r\n\r\n2、String 存储比 Hash 存储更节省内存\r\n\r\n绝大部分情况下，都建议用 String 存放对象数据\r\n\r\n例如：购物车信息需要频繁改动就选用 Hash 存储比较好\r\n\r\n### Set的应用场景\r\n\r\n1、需要随机获取元素的场景：抽奖\r\n\r\n- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。\r\n\r\n- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\r\n\r\n- `SRANDMEMBER key count` : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景\r\n\r\n2、存放数据不能重复：统计文章点赞\r\n\r\n3、多个数据的交集、并集和差集：共同关注\r\n\r\n## Redis持久化机制\r\n\r\n有三种持久化方式：\r\n\r\n- 快照（RDB）\r\n- 只追加文件（AOF）\r\n- RDB 和 AOF 的混合持久化\r\n\r\n## Redis线程模型","title":" Redis知识点总结\r\n","category":[" Redis","数据库\r\n"],"date":" 2024-03-23\r\n","author":" Jixer\r\n","source":" 原创\r\n\r\n"}}