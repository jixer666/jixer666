{"filename":"leetcode-week-396","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第396场周赛\ncategory: 算法\ndate: 2024-05-05\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n本次比赛WA嘛了，最后3分钟把第三题解了，一直错本来都打算放弃了，突然就给我对了。\n\n字符串这方面还是太弱了，本场基本都是字符串的题目.....\n\n## 有效单词\n\n签到题，如果数组元素较多的的化建议用循环做\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string word) {\n        int len = word.size();\n        if(len < 3){\n            return false;\n        }\n        int f1 = 0, f2 = 0;\n        for(int i = 0; i < len; i++){\n            char c = word[i];\n            if(c == 'a' || c == 'e' || c == 'i' || c =='o' || c == 'u' ||\n              c == 'A' || c == 'E' || c == 'I' || c =='O' || c == 'U' ){\n                f1 = 1;\n            } else {\n                if(c >= 'a' && c <= 'z' || c >= '0' && c <= '9' || c >= 'A' && c <= 'Z'){\n                    if(c >= 'a' && c <= 'z' ||  c >= 'A' && c <= 'Z'){\n                         f2 = 1;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        if(f1 && f2) return true;\n        else return false;\n    }\n};\n```\n\n## K 周期字符串需要的最少操作次数\n\n一开始没读懂题目，后面发现不必要考虑两个字符串相隔的位置\n\n```c++\nclass Solution {\npublic:\n    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int len = word.size(), maxlen = 0, cot = 0, idx = 0;\n        string mstr = \"\";\n        unordered_map<string, int> ump;\n        for(int i = 0;  i < len; i++){\n            string ss = word.substr(i, k);\n            ump[ss] ++;\n            if(ump[ss] > maxlen){\n                maxlen = ump[ss];\n                mstr = ss;\n            }\n            i += k - 1;\n        }\n        idx = 0;\n        for(int i = 0;  i < len; i++){\n            string ss = word.substr(i, k);\n            if(ss == mstr){\n                cot ++;\n            }\n            i += k - 1;\n        }\n        return (len - cot * k) / k;\n    }\n};\n```\n\n## 同位字符串连接的最小长度\n\n通过求出每个元素的个数，然后求出所有个数的最大公约数来判断可以分为多少组，从而求出每组的个数\n\n个人感觉这题的数据量不是很多，我这个思路遇多多少少是有点问题的\n\n```c++\nclass Solution {\npublic:\n    int fun(int x, int y){\n        return y == 0? x : fun(y, x % y);\n    }\n    int minAnagramLength(string s) {\n        set<char> ss;\n        int len = s.size();\n        unordered_map<char, int> ump;\n        int cot = INT_MAX, f = 0, cot2 = 0, bf = 0;\n        for(int i = 0; i < len; i++){\n            ump[s[i]] ++;\n        }\n        for(auto item : ump){\n            if(bf == 0){\n                bf = item.second;\n            } else {\n                cot = min(cot, fun(bf, item.second));\n                bf = item.second;\n            }\n        }\n\n        return cot != INT_MAX ? len / cot: len / bf;\n    }\n};\n```\n\n## 使数组中所有元素相等的最小开销\n\n待补充\n","title":" Leetcode第396场周赛\n","category":[" 算法\n"],"date":" 2024-05-05\n","author":" Jixer\n","source":" 原创\n\n"}}