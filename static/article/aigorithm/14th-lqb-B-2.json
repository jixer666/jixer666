{"filename":"14th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十四届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-03-12\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 日期统计\n\n> 此题蓝桥杯官网没说清除，子序列按道理来说应该是连续的，而这个题却不是\n>\n> 思路：暴力法遍历8个数，找出符合条件的即可\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\nint a, b;\nint n[101];\n\nint v[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nset<int> s;\nint main(){\n\tint res = 0;\n\tfor(int i = 0; i < 100; i++) cin >> n[i];\n\tfor(int i = 0; i < 100; i++){\n\t\tif(n[i] == 2){\n\t\t\tfor(int i2 = i + 1; i2 < 100; i2++){\n\t\t\t\tif(n[i2] == 0){\n\t\t\t\t\tfor(int i3 = i2 + 1; i3 < 100; i3++){\n\t\t\t\t\t\tif(n[i3] == 2){\n\t\t\t\t\t\t\tfor(int i4 = i3 + 1; i4 < 100; i4++){\n\t\t\t\t\t\t\t\tif(n[i4] == 3){\n\t\t\t\t\t\t\t\t\tfor(int i5 = i4 + 1; i5 < 100; i5++){\n\t\t\t\t\t\t\t\t\t\tfor(int i6 = i5 + 1; i6 < 100; i6++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int i7 = i6 + 1; i7 < 100; i7++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int i8 = i7 + 1; i8 < 100; i8++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tint moth = n[i5] * 10 + n[i6], day = n[i7] * 10 + n[i8];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(moth >= 1 && moth <= 12 && day >= 1 && day <= v[moth]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(s.find(moth * 100 + day) == s.end()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts.insert(moth * 100 + day);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s.size() << endl;\n\t \n\n\treturn 0;\n}\n```\n\n### 01串的熵\n\n暴力枚举\n\n```c++\n#include<bits/stdc++.h>\n#include<math.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tint cot = 23333333;\n\tfor(int i = 1; i < cot; i++){\n\t\tint j = cot - i;\n\t\tdouble a = 1.0 * i / cot;\n\t\tdouble b = 1.0 * j / cot;\n\t\tdouble res = -a * log2(a) * i - b * log2(b) * j;  \t \n\t\tif(fabs(res - 11625907.5798) < 0.0001){\n\t\t\tcout << min(i, cot - i) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 冶炼金属\n\n> 唯一会做的简单题。。。\n>\n> 思路：每次循环都求出最大和最小的边界，注意考虑最大最小边界【根据题意笔画一下】\n\n```c++\n#include<bits/stdc++.h> \nusing namespace std;\n\nint main(){\n\t\n\tint a, _max = 1e9, _min = 0;\n\tcin >> a;\n\twhile(a--){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t_max = min(_max, x / y);\n\t\t_min = max(_min, x / (y + 1) + 1); \n\t}\n\tcout << _min << \" \" << _max << endl;\n\t\n\treturn 0;\n}\n```\n\n### 飞机降落\n\n> 原先第一看就使用贪心，后看题解需使用 DFS + 剪枝（原因是因为数据范围只有10）\n>\n> 思路：从下标0开始搜索，每次搜索都遍历一次数组，从第一个没遍历到的下标下手，继续搜索，这里需要用额外的数组标识是否已经遍历过了。当搜索的下标到最后时，也就是下标等于数组时，就说明能完成降落，因为如果无法完成降落，就不会进行下一次的搜索\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a, b;\nbool res = false;\nint flag[11];\n\nstruct p{\n\tint x, y, z;\n} n[11];\n\nvoid dfs(int x, int s){\n\tif(res){\n\t\treturn;\n\t}\n\tif(x == b){\n\t\tres = true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < b; i++){\n\t\tif(!flag[i] && s <= n[i].x + n[i].y){\n\t\t\tflag[i] = 1;\n            // 此处用了一点点贪心，尽可能保证本次的开始是满足条件的\n            // 也就是必须都要满足时间是从上一次结束和这一次开始，取个最大值就行\n\t\t\tdfs(x + 1, max(s, n[i].x) + n[i].z);\n\t\t\tflag[i] = 0;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n   \tcin >> a;\n   \twhile(a--){\n   \t\tres = false;\n\t\tcin >> b;\n\t\tfor(int i = 0; i < b; i++) cin >> n[i].x >> n[i].y >> n[i].z;\n\t\tdfs(0, 0);\n\t\tif(res) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n```\n\n### 接龙数列\n\n> 最少删除数 = 总长度- 最长接龙数总长度  \n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b; \nint dp[10];\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tint res = 0;\n\tfor(int i = 0; i < a; i++){\n\t\tstring num;\n\t\tcin >> num;\n\t\tint x = num[0] - '0', y = num[num.size() - 1] - '0';\n\t\tdp[y] = max(dp[x] + 1, dp[y]);\n\t\tres = max(res, dp[y]);\n\t}\n\tcout << a - res << endl;\n\n\n\treturn 0;\n}\n```\n\n### 子串简写\n\n此题唯一需要注意的是数据范围需要用 long long\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[9] = {1,-1,0,0}, iy[9] = {0,0,1,-1};\nint a, b;\nint n[5001][5001];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tstring str;\n\tchar x, y;\n\tcin >> str >> x >> y;\n\tll len = str.size(), cot = 0, res = 0;\n\tqueue<int> pq;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] == x) pq.push(i);\n\t\telse if(str[i] == y){\n\t\t\tres += cot;\n\t\t\twhile(pq.size() && i - pq.front() + 1 >= a){\n\t\t\t\tcot ++;\n\t\t\t\tpq.pop();\n\t\t\t\tres ++;\n\t\t\t}\n\t\t\t\n\t\t} \n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 个人感受\n\n重温一下去年蓝桥杯省赛，依稀记得去年只做了一个C题，一些题用暴力骗分，填空题全军覆没\n\n现在任感觉难度颇高，技术有待提高\n","title":" 第十四届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-03-12\n","author":" Jixer\n","source":" 原创\n\n"}}