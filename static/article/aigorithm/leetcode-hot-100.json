{"filename":"leetcode-hot-100","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode热题100\ncategory: 算法\ndate: 2024-02-25\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 哈希\n\n### 两数之和\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\n        for(int i = 0; i < nums.size(); i++){\n            if(mp.find(target - nums[i]) != mp.end()){\n                int cc = mp[target - nums[i]];\n                if(cc == i) continue;\n                return {i, mp[target - nums[i]]};\n            }   \n        }\n        return {};\n    }\n};\n```\n\n### 字母异位词分组\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> res;\n        unordered_map<string, vector<string>> ump; \n        for(int i = 0; i < strs.size(); i ++){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            ump[str].push_back(strs[i]);\n        }\n        for (auto it = ump.begin(); it != ump.end(); it ++) {\n            res.push_back(it->second);\n        }\n        return res;\n    }\n};\n```\n\n### 最长连续序列\n\n> 思路：先存入set，再判断是否连续\n>\n> 知识点：set.count()用于判断set中是否存在某个值\n\n```java\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> s;\n        int res = 0, cot = 1;\n        for(int i: nums) s.insert(i);\n        for(int i: s){\n           if(s.count(i - 1)){\n               cot ++;\n           } else {\n               cot = 1;\n           }\n            res = max(res, cot);\n        }\n        return res;\n    }\n};\n```\n\n## 双指针\n\n### 移动零\n\n> 思路：一个指针指向0的下标，一个指向非0下标，不断向后移，遇到非0就交换标记的0的那个数\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int len = nums.size(), l = 0, r = 0;\n        while(r < len){\n            if(nums[r]){\n                swap(nums[l], nums[r]);\n                l ++;\n            }\n            r ++;\n        }\n    }\n};\n```\n\n### 盛最多水的容器\n\n> 思路：一个指针指向左端点，一个指针指向右端点，不断向中间靠拢，每次靠拢都计算一下左右圈起来的面积；若左端点长度小， 就+1，否则右端点就减一\n\n```c++\nclass Solution {\npublic:\n    int maxArea(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1, res = 0;\n        for(int i: nums){\n            int num = 0;\n            if(nums[l] < nums[r]){\n                num = (r - l) * nums[l];\n                l ++;\n            } else {\n                num = (r - l) * nums[r];\n                r --; \n            }\n            res = max(num, res);\n        }\n        return res;\n    }\n};\n```\n\n### 三数之和\n\n> 思路：先需要排序，再来两重循环，要使a+b+c=0，a,b已经确定了，就差c，让c从往前遍历，因为是不断递增的所以a<b<c ，第二次循环b1时，b1>b，所以c1必须小于c才能使得总和为0。满足这个特性，我们就可以用双指针解决。虽然第二重循环中有个for循环，但其实它的循环是对第二重循环遍历r生效的，所以并不影响总的时间复杂度为0(N^2)。\n\n```java\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> res;\n        int len = nums.size();\n        sort(nums.begin(), nums.end());\n        for(int i = 0; i < len; i++){\n            // 需要和上次不同\n            if(i > 0 && nums[i] == nums[i -1]){\n                continue;\n            }\n            int r = len - 1;\n            for(int j = i + 1; j < len; j ++){\n                // 需要和上次不同\n                if(j > i + 1 && nums[j] == nums[j - 1]){\n                    continue;\n                } \n                // 不断相减，找到满足和接近0的r下标\n                while(j < r && nums[i] + nums[j] + nums[r] > 0){\n                    r --;\n                }\n                // j和r下标重合了，说明后续的循环是无效的无需遍历了\n                if(r == j){\n                    break;\n                }\n                if(nums[i] + nums[j] + nums[r] == 0){\n                    res.push_back({nums[r], nums[i], nums[j]});\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 接雨水\n\n> 思路：先从左边考虑，从左往右不断遍历，维护一个左端最大值，若小于这个最大值，就用差算出需要接的雨水。但如果一直这样维护到右半端会出问题【因为可能不知道右端是否存在边，若右边根本就没有边就无需遍历了】，右半端需要维护右端的最大值。所以就左右一起维护往中间靠拢，期间不断维护左右端点的最大值。\n\n```java\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int l = 0, r = height.size() - 1, rmax = 0, lmax = 0, res = 0;\n        while(l < r){\n            lmax = max(lmax, height[l]);\n            rmax = max(rmax, height[r]);\n            if(height[l] < height[r]){\n                res += lmax - height[l];\n                l ++;\n            } else {\n                res += rmax - height[r];\n                r --;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 滑动窗口\n\n### 无重复字符的最长子串\n\n> 思路：依次向右遍历，遇到没出现过的字符写入map中，若出现过就不断弹出队列，直到弹出的字符与当前遍历到的字符一致未知，并且不断维护队列的最大值。最后也别忘了维护最大值，防止出现都是不一致的字符的情况\n\n```java\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        queue<char> q;\n        map<char, int> mp;\n        int res = 0;\n        for(int i = 0; i < s.size(); i++){\n            if(!mp[s[i]]){\n                mp[s[i]] = 1;\n                q.push(s[i]);\n            } else{\n                int len = q.size();\n                res = max(res, len);\n                while(q.size() && q.front() != s[i]){\n                    mp[q.front()] = 0;\n                    q.pop();\n                }\n                q.pop();\n                q.push(s[i]);\n            }\n        }\n        int len = q.size();\n        res = max(res, len);\n        return res;\n    }\n};\n```\n\n### 找到字符串中所有字母异位词\n\n> 思路：用vector来维护字符串中每个字符的个数，若确认两个字符串是一致，则vector也是一样的，用滑动窗口不断右遍历来维护vector\n>\n> 知识点：vector之间可以相等来判断是否一致；想用vector下标法之前必须指定vector个数【前提是该下标要存在】\n\n```java\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int len1 = s.size(), len2 = p.size();\n        if(len1 < len2){\n            return vector<int>();\n        }\n        vector<int> v1(26);\n        vector<int> v2(26);\n        vector<int> res;\n        for(int i = 0; i < len2; i++){\n            v1[s[i] - 'a'] ++;\n            v2[p[i] - 'a'] ++;\n        }\n        if(v1 == v2){\n            res.push_back(0);\n        }\n        for(int i = 0; i < len1 - len2; i++){\n            v1[s[i] - 'a'] --;\n            v1[s[i + len2] - 'a'] ++;\n            if(v1 == v2){\n                res.push_back(i + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 字串\n\n### 和为 K 的子数组\n\n> 思路：用map存放前缀和的各个值，循环遍历一次每次就判断当前的前缀和的值-k是否在map中存在，存在就加一\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int, int> ump;\n        ump[0] = 1;\n        int res = 0, cot = 0;\n        for(int i: nums){\n            cot += i;\n            if(ump.find(cot - k) != ump.end()){\n                res += ump[cot - k];\n            }\n            ump[cot] ++;\n        }\n        return res;\n    }\n};\n```\n\n### 滑动窗口最大值\n\n> 思路：用双端队列维护一个单调队列，每次都会判断队列的尾部是否比当前的nums[i]小，小的话就需要弹出，因为只要有这个元素在，前面的元素永远也不是最大的一个。\n>\n> 知识点：单调队列\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        // 存放下标\n        deque<int> q;\n        vector<int> v;\n        for(int i = 0; i < nums.size(); i++){\n            // 当队列最后一个值小于当前nums[i]时，需要弹出末尾的元素\n            // 因为只要有这个元素在，前面的元素永远也不是最大的一个\n            while(q.size() && nums[q.back()] < nums[i]) q.pop_back();\n            q.push_back(i);\n            // 当超过队列的元素的时候需要弹出队列头\n            if(i - q.front() >= k) q.pop_front();\n            // 当下标超过规定的k的时候就代表可以进行计算\n            if(i >= k - 1) v.push_back(nums[q.front()]);   \n        }\n        return v;\n    }\n};\n```\n\n## 普通数组\n\n### 最大子数组和\n\n> 思路：每次遍历都需要前缀和的值加上当前的值和当前的值进行比较，选出最大的值赋值给前缀和值\n>\n> 知识点：前缀和\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int res = nums[0], cot = nums[0];\n        for(int i = 1; i < nums.size(); i++){\n            cot = max(nums[i], cot + nums[i]);\n            res = max(res, cot);\n        }\n        return res;\n    }\n};\n```\n\n### 合并区间\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<vector<int>> res;\n        sort(intervals.begin(), intervals.end());\n        int len = intervals.size(), minL = intervals[0][0], minR = intervals[0][1];\n        for(int i = 1; i < len; i++){\n            int l = intervals[i][0], r = intervals[i][1];\n            if(l > minR){\n                res.push_back({minL, minR});\n                minL = l;\n            }\n            minR = max(minR, r);\n        }\n        res.push_back({minL, minR});\n        return res;\n    }\n};\n```\n\n### 轮转数组\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int len = nums.size();\n        unordered_map<int, int> mp;\n        for(int i = 0; i < len; i++){\n            mp[i] = nums[i];\n        }\n        for(int i = 0; i < len; i++){\n            nums[(i + k) % len] = mp[i];\n        }\n    }\n};\n```\n\n### 除自身以外数组的乘积\n\n```c++\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int all = nums[0], is = 0, len = nums.size();\n        vector<int> res;\n        if(all == 0){\n            is ++;\n            all = 1;\n        }\n        for(int i = 1; i < len; i++){\n            if(nums[i] == 0) {\n                is ++;\n                continue;\n            }\n            all *= nums[i];\n        }\n        for(int i: nums){\n            if(i == 0){\n                if(is > 1) res.push_back(0);\n                else res.push_back(all);\n            } else {\n                if(is == 1) res.push_back(0);\n                else if(is > 1) res.push_back(0);\n                else res.push_back(all / i);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 缺失的第一个正数\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int res = -100000000, minNum = 0;\n        unordered_map<int, int> ump;\n        priority_queue<int, vector<int>, greater<int>> pq;\n        set<int> s;\n        for(int i: nums) {\n           if(i > 0) s.insert(i);\n        }\n        for(int i: s) {\n            pq.push(i);\n        }\n        int idx = 1;\n        if(pq.size() && pq.top() == 1){\n            while(pq.size()){\n                pq.pop();\n                if(pq.top() != ++idx){\n                    break;\n                } \n            }\n        }\n        return idx;\n\n    }\n};\n```\n\n## 图论\n\n### 岛屿的数量\n\n> 思路：采用DFS遍历，将每个遍历到的为1的点设置标记，下次遍历的时候只遍历没标记的点；把标记的区域数量相加就是结果\n>\n> 知识点：DFS\n\n```c++\nclass Solution {\npublic:\n    vector<vector<char>> num;\n    int lenx, leny;\n    int flag[301][301];\n    int ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    void dfs(int x, int y){\n        if(num[x][y] == '0'){\n            return;\n        }\n        for(int i = 0; i < 4; i++){\n            int _x = ix[i] + x, _y = iy[i] + y;\n            if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && !flag[_x][_y]){\n                flag[_x][_y] = 1;\n                dfs(_x, _y);\n            }\n        }\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int cot = 0;\n        num = grid;\n        lenx = num.size(), leny = grid[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(!flag[i][j] && grid[i][j] == '1'){\n                    dfs(i, j);\n                    cot ++;\n                }\n            }\n        }\n        return cot;\n    }\n};\n```\n\n### 腐烂的橘子\n\n> 思路：先将每个腐烂的橘子加入到队列中，再进行BFS遍历；这里遍历有个关键点就是只遍历没有腐烂的句子，已腐烂的句子无需遍历，因为已经腐烂的句子也会进行传播，而且他的传播用时比现在的短\n>\n> 知识点：多源BFS\n\n```c++\nclass Solution {\npublic:\n    int lenx = 0, leny = 0, cot = 0;\n    int flag[11][11], ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    queue<pair<int, int>> q;\n    int bfs(vector<vector<int>>& grid){\n        int res = 0;\n        while(q.size()){\n            auto top = q.front();\n            q.pop();\n            int xx = top.first, yy = top.second;\n            for(int i = 0; i < 4; i++){\n                int _x = ix[i] + xx, _y = iy[i] + yy;\n                if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && grid[_x][_y] == 1 && !flag[_x][_y]){\n                    flag[_x][_y] = flag[xx][yy] + 1;\n                    q.push({_x, _y});\n                    if(grid[_x][_y] == 1){\n                        cot --;\n                        res = flag[_x][_y];\n                        if(!cot){\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return cot == 0 ? res : -1;\n    }\n    int orangesRotting(vector<vector<int>>& grid) {\n        lenx = grid.size(), leny = grid[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(grid[i][j] == 2){\n                    q.push({i, j});\n                    flag[i][j] = 0;\n                } else if(grid[i][j] == 1){\n                    cot ++;\n                }\n            }\n        }\n        return bfs(grid);\n    }\n};\n```\n\n### 课程表\n\n> 思路：用n来标志状态（0表示未选，1表示正在选，2表示已选），见注释\n>\n> 知识点：DFS\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> num;\n    vector<int> n;\n    bool flag = true;\n    void dfs(int x) {\n        // 标记正在选\n        n[x] = 1;\n        // 假设当前x已经正在选，遍历需要依赖它的课程编号\n        for(int i: num[x]){\n            // 未选就遍历\n            if(!n[i]){\n                dfs(i);\n                if(!flag){\n                    return;\n                }\n             // 正在选说明出现重复依赖，就直接return\n            } else if(n[i] == 1){\n                flag = false;\n                return;\n            }\n        }\n        // 标记已选\n        n[x] = 2;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int len = prerequisites.size();\n        num.resize(numCourses);\n        n.resize(numCourses);\n        for (int i = 0; i < len; i++) {\n            int _1 = prerequisites[i][0], _2 = prerequisites[i][1];\n            num[_2].push_back(_1);\n        }\n        for (int i = 0; i < numCourses; i++) {\n           \t// 只遍历未选的\n            if(!n[i]){\n                dfs(i);\n            }\n        }\n        return flag;\n    }\n};\n```\n\n## 回溯\n\n### 全排列\n\n> 知识点：回溯\n\n```c++\nclass Solution {\npublic:\n    vector<int> num;\n    vector<vector<int>> res;\n    int len = 0;\n    int n[7];\n    void dfs(int x, vector<int> v){\n        if(v.size() == len){\n            res.push_back(v);\n            return;\n        }\n        for(int i = 0; i < len; i++){\n            if(!n[i]){\n                n[i] = 1;\n                v.push_back(num[i]);\n                dfs(i, v);\n                n[i] = 0;\n                v.pop_back();\n            }\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        num = nums;\n        len = nums.size();\n        dfs(0, {});\n        return res;\n    }\n};\n```\n\n### 子集\n\n```c++\nclass Solution {\npublic:\n    vector<int> num;\n    int len = 0;\n    vector<vector<int>> res;\n    void dfs(int x, vector<int> v){\n        if(x == len){\n            res.push_back(v);\n            return;\n        }\n        dfs(x + 1, v);\n        v.push_back(num[x]);\n        dfs(x + 1, v);\n        v.pop_back();\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        num = nums;\n        len = nums.size();\n        dfs(0, {});\n        return res;\n    }\n};\n```\n\n### 电话号码的字母组合\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, vector<char>> ump;\n    vector<string> res;\n    int len = 0;\n    void init(){\n        ump['2'] = {'a','b','c'};\n        ump['3'] = {'d','e','f'};\n        ump['4'] = {'g','h','i'};\n        ump['5'] = {'j','k','l'};\n        ump['6'] = {'m','n','o'};\n        ump['7'] = {'p','q','r','s'};\n        ump['8'] = {'t','u','v'};\n        ump['9'] = {'w','x','y','z'};\n    }\n    void dfs(int x, string str, string digit){\n        if(x == len){\n            res.push_back(str);\n            return;\n        }\n        char c = digit[x];\n        for(int i = 0; i < ump[c].size(); i++){\n            dfs(x + 1, str + ump[c][i], digit);\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        len = digits.size();\n        if(len == 0){\n            return {};\n        }\n        init();\n        dfs(0, \"\", digits);\n\n        return res;\n    }\n};\n```\n\n### 组合总和\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> num;\n    int len = 0;\n    void dfs(int x, int n, vector<int> v, int total){\n        if(n > total){\n            return;\n        }\n        if(n == total){\n            res.push_back(v);\n            return;\n        }\n        v.push_back(num[x]);\n        dfs(x, n + num[x], v, total);\n        v.pop_back();\n        if(x + 1 < len){\n            dfs(x + 1, n, v, total);\n        }\n       \n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        len = candidates.size();\n        num = candidates;\n        dfs(0, 0, {}, target);\n        return res;\n    }\n};\n```\n\n### 括号生成\n\n```c++\nclass Solution {\npublic:\n    vector<string> res;\n    void dfs(int x, int y, string str, int n){\n        if(x > n || y > n){\n            return;\n        }\n        if(x == n){\n            res.push_back(str);\n            return;\n        }\n        dfs(x, y + 1, str + \"(\", n);\n        if(x < y){\n            dfs(x + 1, y, str + \")\", n);\n        }\n\n    }\n    vector<string> generateParenthesis(int n) {\n        dfs(0, 0, \"\", n);\n        return res;\n    }\n};\n```\n\n### 单词搜索\n\n```c++\nclass Solution {\npublic:\n    vector<vector<char>> num;\n    int lenx = 0, leny = 0;\n    bool flag = false;\n    int f[7][7];\n    int ix[4] = {0,0,1,-1}, iy[4] = {1,-1,0,0};\n    bool find(string s, string w){\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] != w[i]) return false;\n        }\n        return true;\n    }\n    void dfs(int x, int y, string s, string w, int f[][7]){\n        if(s == w){\n            flag = true;\n            return;\n        }\n        for(int i = 0; i < 4; i++){\n            int _x = ix[i] + x, _y = iy[i] + y;\n            if(_x >= 0 && _x < lenx && _y >= 0 && _y < leny && !f[_x][_y] && find(s + num[_x][_y], w)){\n                f[_x][_y] = 1;\n                dfs(_x, _y, s + num[_x][_y], w, f);\n                f[_x][_y] = 0;\n            }\n        }\n        \n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        num = board;\n        lenx = board.size(), leny = board[0].size();\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                if(board[i][j] == word[0]){\n                    memset(f, 0, sizeof f);\n                    string ss = \"\";\n                    ss.append(1, word[0]);\n                    f[i][j] = 1;\n                    dfs(i, j, ss, word, f);\n                    if(flag){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n### 分割回文串\n\n> 思路：用二维数组n来标记i，j是否是回文串，先将n全部赋值为1，找出不是回文串的区间。最后用BFS找出回文串\n>\n> 知识点：BFS，动态规划\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> res;\n    int n[17][17];\n    int len = 0;\n    void dfs(string s, int x, vector<string> v){\n        if(x > len) return;\n        if(x == len){\n            res.push_back(v);\n            return;\n        }\n        for(int i = x; i < len; i++){\n            if(n[x][i]){\n                v.push_back(s.substr(x, i - x + 1));\n                dfs(s, i + 1, v);\n                v.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> partition(string s) {\n        len = s.size();\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++){\n                n[i][j] = 1;\n            }\n        }\n        for(int i = 0; i < len; i++){\n            for(int j = i - 1; j >= 0; j--){\n                n[j][i] = s[i] == s[j] && n[j + 1][i - 1];\n            }\n        }\n        dfs(s, 0, {});\n        return res;\n    }\n};\n```\n\n### N 皇后\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> res;\n    vector<char> v;\n    // 分别表示45°，-45°，y轴标志数组，看是否已经存在\n    int fx[100], fy[100], line[100];\n    void dfs(int x, int n, vector<string> strv){\n        if(x == n){\n            res.push_back(strv);\n            return;\n        }\n        for(int i = 0; i < n; i++){\n            if(!line[i] && !fx[i - x + n] && !fy[i + x]){\n                fy[i + x] = 1;\n                fx[i - x + n] = 1;\n                line[i] = 1;\n                strv[x][i] = 'Q';\n                dfs(x + 1, n, strv);\n                fy[i + x] = 0;\n                fx[i - x + n] = 0;\n                line[i] = 0;\n                strv[x][i] = '.';\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<string> strv;\n        for(int i = 0; i < n; i++){\n            string str = \"\";\n            for(int j = 0; j < n; j++){\n                str += '.';\n            }\n            strv.push_back(str);\n        }\n        dfs(0, n, strv);\n        return res;\n    }\n};\n```\n\n### 零钱兑换\n\n> 知识点：BFS + 记忆化搜索 + 剪枝\n\n```c++\nclass Solution {\npublic:\n    int bfs(vector<int>& coins, int amount){\n        int len = coins.size(), res = INT_MAX;\n        queue<pair<long long, int>> q;\n        unordered_set<long long> s;\n        q.push({0, 0});\n        while(q.size()){\n            auto top = q.front();\n            q.pop();\n            long long x = top.first;\n            int y = top.second;\n            if(x > amount){\n                // 剪枝\n                continue;\n            } else if(x == amount){\n                res = min(res, y);\n                continue;\n            }\n            for(int i = 0; i < len; i++){\n                long long cc = x + coins[i];\n                // 记忆化搜索，已经搜索过了的不再重复记录\n                if(s.find(cc) == s.end()){\n                    s.insert(cc);\n                    q.push({cc, y + 1});\n                }\n            }\n        }\n        return res == INT_MAX ? -1 : res;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        return bfs(coins, amount);\n    }\n};\n```\n\n## 二分\n\n**二分模板**\n\n```c++\n// 左边距\nint get_l(int x){\n    int l = 0, r = a - 1;\n    while(l < r){\n        int mid = (l + r ) / 2;\n        if(n[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 右边距\nint get_r(int x){\n   int l = 0, r = a - 1;\n   while(l < r){\n   \tint mid = (l + r + 1) / 2;\n       if(n[mid] <= x) l = mid;\n       else r = mid - 1;\n   }\n   return r;\n}\n```\n\n### 搜索插入位置\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size();\n        while(l < r){\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n### 在排序数组中查找元素的第一个和最后一个位置\n\n> 左右边距模板题\n\n```c++\nclass Solution {\npublic:\n    int len = 0;\n    int left(vector<int>& nums, int target){\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l >= 0 && l < len && nums[l] == target ? l : -1;\n    }\n    int right(vector<int>& nums, int target){\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = l + r + 1 >> 1;\n            if(nums[mid] <= target) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return r >= 0 && r < len && nums[r] == target ? r : -1;\n    }\n    vector<int> searchRange(vector<int>& nums, int target) {\n        len = nums.size();\n        return {left(nums, target), right(nums, target)};\n    }\n};\n```\n\n### 搜索二维矩阵\n\n> 思路：将二维转为一维，再用二分查找\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int lenx = matrix.size(), leny = matrix[0].size();\n        vector<int> v;\n        for(int i = 0; i < lenx; i++){\n            for(int j = 0; j < leny; j++){\n                v.push_back(matrix[i][j]);\n            }\n        }\n        int l = 0, r = v.size() - 1;\n        while(l < r){\n            int mid = l + r >> 1;\n            if(v[mid] >= target){\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return (l >= 0 && l < v.size() && v[l] == target) ? true : false;\n    }\n};\n```\n\n### 搜索旋转排序数组\n\n> 思路：中间值与第一个值比较便能知道在左区间还是在右区间，分别在区间内进行讨论即可\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1;\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] >= nums[0]){\n                if(nums[mid] > target && nums[0] <= target){\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else{\n                if(nums[mid] < target && nums[0] > target){\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```\n\n### 寻找旋转排序数组中的最小值\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int len = nums.size();\n        int l = 0, r = len - 1;\n        while(l < r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] >= nums[0]){\n                if(nums[mid] > nums[len - 1]) l = mid + 1;\n                else r = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n\n## 栈\n\n### 有效的括号\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> ss;\n        bool flag = false;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '(' || s[i] == '[' || s[i] == '{') ss.push(s[i]);\n            else {\n                if(ss.size() && ss.top() == '(' && s[i] == ')') ss.pop();\n                else if(ss.size() && ss.top() == '{' && s[i] == '}') ss.pop();\n                else if(ss.size() && ss.top() == '[' && s[i] == ']') ss.pop();\n                else return false;\n            }\n        }\n        return ss.size() == 0 ? true: false;\n    }\n};\n```\n\n### 字符串解码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> ss;\n        stack<int> cc;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] >= '0' && s[i] <= '9') {\n               int q = i, num = 0;\n               while(s[q] >= '0' && s[q] <= '9'){\n                    num = num * 10 + s[q] - '0';\n                    q ++;\n               }\n               cc.push(num);\n               i = q - 1;\n            }\n            else {\n                if(s[i] == ']'){\n                    string str = \"\", rstr = \"\";\n                    while(ss.size()){\n                        if(ss.top() == \"[\") {\n                            ss.pop();\n                            break;\n                        }\n                        str = ss.top() + str;\n                        ss.pop();\n                    }\n                    int cot = cc.top();\n                    cc.pop();\n                    for(int j = 0; j < cot; j++) rstr += str;\n                    ss.push(rstr);\n\n                }\n                else{\n                    string cstr = \"\";\n                    cstr.append(1, s[i]);\n                    ss.push(cstr);\n                }\n            }\n        }\n        string res = \"\";\n        while(ss.size()){\n            res = ss.top() + res;\n            ss.pop();\n        }\n        return res;\n    }\n};\n```\n\n### 每日温度\n\n> 思路：维护一个递减的单调栈\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int len = temperatures.size();\n        stack<int> s;\n        vector<int> res(len, 0);\n        for(int i = 0; i < len; i++){\n            while(s.size() && temperatures[s.top()] < temperatures[i]){\n                res[s.top()] = i - s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n        return res;\n        \n    }\n};\n```\n\n## 堆\n\n### 数组中的第K个最大元素\n\n> 知识点：优先队列\n\n```c++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int idx = 0, res = 1;\n        priority_queue<int, vector<int>, less<int>> pq;\n        for(int i = 0; i < nums.size(); i++){\n            pq.push(nums[i]);\n        }\n        while(pq.size()){\n            int top = pq.top();\n            idx ++;\n            pq.pop();\n            if(idx == k){\n                res = top;\n                break;\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 前 K 个高频元素\n\n> 知识点：并查集\n\n```c++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n[100010];\n    unordered_map<int, int> mp;\n    static bool cmp(p a1, p b1){\n        return a1.y > b1.y;\n    }\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        int len = nums.size();\n        vector<int> res;\n        for(int i = 0; i < len; i++){\n            int index = i;\n            if(mp.find(nums[i]) != mp.end()){\n                index = mp[nums[i]];\n            }\n            n[index].x = nums[index];\n            n[index].y ++;\n            mp[nums[i]] = index;\n        }\n        sort(n, n + len, cmp);\n        for(int i = 0; i < k; i++){\n            res.push_back(n[i].x);\n        }\n        return res;\n    }\n};\n```\n\n## 贪心\n\n### 买卖股票的最佳时机\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size(), maxx = 0, res = 0;\n        vector<int> v(len);\n        for(int i = len - 1; i >= 0; i--){\n            maxx = max(prices[i], maxx);\n            v[i] = maxx;\n        }\n        for(int i = 0; i < len; i++){\n            res = max(res, v[i] - prices[i]);\n        }\n        return res;\n    }\n};\n```\n\n### 跳跃游戏\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int len = nums.size(), maxx = 0;\n        vector<bool> v(len, false);\n        for(int i = 0; i < len; i++){\n            if(i > maxx){\n                return false;\n            }\n            maxx = max(maxx, i + nums[i]);\n            v[i] = true;\n        }\n        return v[len - 1];\n    }a\n};\n```\n\n### <u>* 跳跃游戏 II</u>\n\n```c++\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int len = nums.size(), maxx= 0, end = 0, res = 0;\n        // * 循环遍历到 len - 1\n        for(int i = 0; i < len - 1; i++){ \n            maxx = max(maxx, nums[i] + i);\n            if(end == i){\n                end = maxx;\n                res ++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 划分字母区间\n\n```c++\nclass Solution {\npublic:\n    struct p{\n        int x, y;\n    } n[27];\n    vector<int> partitionLabels(string s) {\n        vector<int> res;\n        int len = s.size();\n        for(int i = 0; i < len; i++){\n            n[s[i] - 'a'].x = min(n[s[i] - 'a'].x, i);\n            n[s[i] - 'a'].y = max(n[s[i] - 'a'].y, i);\n        }\n        int minL = 0, maxL = 0;\n        for(int i = 0; i < len; i++){\n            maxL = max(n[s[i] - 'a'].y, maxL);\n            if(maxL == i){\n                res.push_back(maxL - minL + 1);\n                minL = i + 1;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 动态规划\n\n### 爬楼梯\n\n> 思路：斐波拉且数列\n\n```c++\nclass Solution {\npublic:\n    int nums[46];\n    int climbStairs(int n) {\n        nums[0] = 1;\n        nums[1] = 1;\n        for(int i = 2; i <= n; i++){\n            nums[i] = nums[i - 1] + nums[i - 2]; \n        }\n        return nums[n];\n    }\n};\n```\n\n### 杨辉三角\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> res(numRows);\n        res[0] = {1};\n        for(int i = 1; i < numRows; i++){\n            vector<int> v(i + 1, 1);\n            for(int j = 1; j <= i - 1; j++){\n                v[j] = res[i - 1][j] + res[i - 1][j - 1]; \n            }\n            res[i] = v;\n        }\n        return res;\n    }\n};\n```\n\n### 打家劫舍\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size(), res = 0;\n        vector<int> v(len + 1);\n        for(int i = 1; i <= len; i++){\n            v[i] = nums[i - 1];\n            res = max(v[i], res);\n        }\n        for(int i = 3; i <= len; i++){    \n            v[i] = v[i] + max(v[i - 2], v[i - 3]);\n            res = max(res, v[i]);\n        }\n        return res;\n\n    }\n};\n```\n\n### 完全平方数\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> v(n + 1);\n        v[1] = 1;\n        for(int i = 2; i <= n; i++){\n            int num = INT_MAX;\n            for(int j = 1; j * j <= i; j++){\n                // 此处为关键点，从完全平方数开始找，找出想要最小凑出完全平凡数的数的结果\n                num = min(num, v[i - j * j]);\n            }\n            // 最后加上完全平凡数的结果1\n            v[i] = num + 1;\n        }\n        return v[n];\n    }\n};\n```\n\n\n\n\n\n## 常用算法总结\n\n- 二分\n\n- 哈希\n\n- 双指针\n\n- 思维\n\n- 模拟\n\n- 贪心\n\n- 前缀和(一维、二维)，后缀和\n\n- 队列\n  - 滑动窗口[双端队列]\n  - 优先队列\n  \n- 栈\n  - 单调栈\n\n- 搜索\n  - DFS\n  - BFS\n  - 多源BFS\n\n- 动态规划\n\n- 数学知识\n\n  - 哈夫顿距离：d(i,j)=|xi-xj|+|yi-yj|\n\n    - 哈夫顿距离转为切比雪夫距离：|xi-xj| + |yi-yj| =  max(|x1'-x2'|, |y1'-y2'|)\n\n      原坐标(x, y)与(x', y')的关系：(x', y') = (x + y, y - x)\n\n  - 欧氏距离：d(i,j)=(xi-xj) ^ 2 + (yi - yj) ^ 2\n\n  - 直线公式：y = (y2-y1)/(x2-x1) * x - (x2 * y1 - x1 * y2)/(x2-x1)\n  \n  - 质数\n  \n  - 因数\n  \n  - 容斥原理\n  \n- 图论\n\n  - 迪杰斯特拉\n\n","title":" Leetcode热题100\n","category":[" 算法\n"],"date":" 2024-02-25\n","author":" Jixer\n","source":" 原创\n\n"}}