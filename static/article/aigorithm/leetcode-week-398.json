{"filename":"leetcode-week-398","category":"aigorithm","md":{"topSummary":"\ntitle: Leetcode第398场周赛\ncategory: 算法\ndate: 2024-05-20\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n## 3151. 特殊数组 I\n\n简单模拟\n\n```c++\nclass Solution {\npublic:\n    bool isArraySpecial(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1){\n            return true;\n        }\n        for(int i = 1; i < len; i++){\n            if(nums[i] % 2 == nums[i - 1] % 2){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n## 特殊数组 II\n\n前缀和处理相邻特殊元素总数\n\n```c++\nclass Solution {\npublic:\n    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int len = nums.size();\n        vector<bool> res;\n        if(len == 1){\n            for(int i = 0; i < queries.size(); i++){\n                res.push_back(true);\n            }\n            return res;\n        }\n        vector<int> v(len + 1);\n        v[0] = 0;\n        for(int i = 1; i < len; i++){\n            if(nums[i] % 2 == nums[i - 1] % 2){\n                v[i] = v[i - 1] + 1;\n            } else {\n                v[i] = v[i - 1];\n            }\n        }\n        for(int i = 0; i < queries.size(); i++){\n            if(v[queries[i][1]] - v[queries[i][0]] == 0){\n                res.push_back(true);\n            } else {\n                res.push_back(false);\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 所有数对中数位不同之和\n\n拆分位运算贡献\n\n```c++\nclass Solution {\npublic:\n    long long n[100010][20];\n    long long sumDigitDifferences(vector<int>& nums) {\n        int len = nums.size();\n        long long res = 0;\n        for(int i = 0; i < len; i++){\n            int cc = nums[i], idx = 0;\n            while(cc){\n                int j = cc % 10;\n                res += i * 1ll - n[idx][j];\n                cc /= 10;   \n                n[idx][j] ++;\n                idx ++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 到达第 K 级台阶的方案数\n\n记忆化搜索\n\n灵神这题做法是用记忆存储的元素与以往题目不一样，使用 `long long p = (long long) x << 10 | num << 1 | f; `来确定元素的唯一性，这个做法tql，换我来做就需要用个二维数组来标志\n\n```c++\nclass Solution {\npublic:\n    unordered_map<long long, int> ump;\n    int dfs(int x, int num, bool f, int k){\n        if(x > k + 1 || x < 0){\n            return 0;\n        }\n        long long p = (long long) x << 10 | num << 1 | f;\n        if(ump.find(p) != ump.end()){\n            return ump[p];\n        }\n        int ss = (x == k);\n        ss += dfs(x + (1 << num), num + 1, false, k);\n        if(!f){\n            ss += dfs(x - 1, num, true, k);\n        }\n        ump[p] = ss;\n        return ss;\n    }\n    int waysToReachStair(int k) {\n        return dfs(1, 0, false, k);\n    }\n};\n```\n\n","title":" Leetcode第398场周赛\n","category":[" 算法\n"],"date":" 2024-05-20\n","author":" Jixer\n","source":" 原创\n\n"}}