{"filename":"12th-lqb-B-2","category":"aigorithm","md":{"topSummary":"\ntitle: 第十二届蓝桥杯B组省赛\ncategory: 算法\ndate: 2024-04-09\nauthor: Jixer\nsource: 原创\n\n","mainContent":"\n\n### 空间\n\n单位换算题\n\n1比特 = 8位\n\n256 * 1024 * 1024 / 4\n\n### 卡片\n\n模拟题\n\n需要注意的的是答案是输出能够拼到多少，而不是拼完的那个数，所以需要答案 - 1\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint n[10];\n\tfor(int i = 0; i <= 9; i++){\n\t\tn[i] = 2021;\n\t}\t\n\tint idx = 1;\n\twhile(true){\n\t\tint c = idx, flag = 0;\n\t\twhile(c){\n\t\t\tif(n[c % 10] == 0){\n\t\t\t\tcout << idx - 1 << endl;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn[c % 10] --;\n\t\t\tc /= 10;\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tidx ++;\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 直线\n\n模拟、数学题\n\n需要注意直线的公式：y = kx + b\n\n斜率：k = (y1 - y2) / (x1 - x2)\n\n截距：b = (y1 * x2 - y2 * x1) / (x2 - x1)\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<double, double>, int> mp;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint res = 0;\n\tfor(int i = 0; i < 20; i++){\n\t\tres ++;\n\t}\n\tfor(int i = 0; i < 21; i++){\n\t\tres ++;\n\t}\n\t\n\tfor(int i = 0; i < 20; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tfor(int x = i + 1; x < 20; x++){\n\t\t\t\tfor(int y = 0; y < 21; y++){\n\t\t\t\t\tif(i != x && j != y){\n\t\t\t\t\t\tdouble num = (j - y) * 1.0 / (i - x);\t\n\t\t\t\t\t\tdouble val = (i * y - j * x) * 1.0 / (i - x);\n\t\t\t\t\t\tif(mp.find({num, val}) == mp.end()){\n\t\t\t\t\t\t\tmp[{num, val}] = 1;\n\t\t\t\t\t\t\tres ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n### 货物摆放\n\n枚举、数学知识**因数**题\n\n找出2021041820210418所有的因数，从因数中找出满足条件的即可，极大的缩减了遍历范围\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<ll, ll>, ll> map;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t vector<ll> v;\n    \n    ll a = 2021041820210418;\n    ll res = 0;\n    \n    for(ll i = 1; i * i <= a; i++){\n        if(a % i == 0) {\n            v.push_back(i);    \n            if(i * i != a){\n                v.push_back(a / i);\n            }\n        }\n    }\n    \n    for(ll i = 0; i < v.size(); i++){\n        for(ll j = 0; j < v.size(); j++){\n            for(ll m = 0; m < v.size(); m++){    \n                if(v[i] * v[j] * v[m] == a) res++;\n            }\n        }\n        \n    }\n    cout << res;\n\treturn 0;\n}\n```\n\n### 路径\n\n图论、数学知识题\n\n迪杰斯特拉模板题，最小公倍数模板\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nmap<pair<ll, ll>, ll> map;\nint w[N], idx, h[N], ne[N], e[N], dis[N], st[N];\n\nvoid add(int x, int y, int z){\n\te[idx] = y, w[idx] = z, ne[idx] = h[x], h[x] = idx ++;\n}\n\nint fun1(int x, int y){\n\treturn y == 0 ? x : fun1(y, x % y);\n}\n\nint fun2(int x, int y){\n\treturn x / fun1(x, y) * y;\t\n}\n\nint dj(){\n\tmemset(dis, 0x3f3f3f3f, sizeof dis);\n\tpriority_queue<PII, vector<PII>, greater<PII>> pq;\n\tpq.push({1, 0});\n\twhile(!pq.empty()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tint x = top.first, y = top.second;\n\t\tif(st[x]) continue;\n\t\tst[x] = 1;\n\t\tfor(int i = h[x]; i != -1; i = ne[i]){\n\t\t\tint j = e[i];\n\t\t\tif(dis[j] > y + w[i]){\n\t\t\t\tdis[j] = y + w[i];\n\t\t\t\tpq.push({j, dis[j]});\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2021] == 0x3f3f3f3f) return -1;\n    return dis[2021];\n}\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tmemset(h, -1, sizeof h);\n\n\tfor(int i = 1; i <= 2021; i++){\n\t\tfor(int j = i + 1; j <= 2021; j++){\n\t\t\tif(j - i <= 21){\n\t\t\t\tint c = fun2(i, j);\n\t\t\t\tadd(i, j, c);\n\t\t\t\tadd(j, i, c);\t\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} \n\tcout << dj();\n\t\n\treturn 0;\n}\n```\n\n### 时间显示\n\n单位换算题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tll num;\n\tcin >> num;\n\tint dv = 1000 * 3600 * 24;\n\tnum = num % dv;\n\tint sv = num / 1000;\n\tint h = sv / 3600;\n\tint m = sv % 3600 / 60;\n\tint s = sv % 3600 % 60;\n\tprintf(\"%02d:%02d:%02d\\n\", h, m, s);\n\t\n\treturn 0;\n}\n```\n\n### 砝码称重\n\nset模拟DFS遍历，巧解此题\n\n正解为动态规划\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tvector<int> v(a);\n\tset<int> s;\n\tfor(int i = 0; i < a; i++) cin >> v[i];\n\tfor(int i = 0; i < a; i++){\n\t\tset<int> ss;\n\t\tfor(int j: s){\n\t\t\tss.insert(j + v[i]);\n\t\t\tif(j - v[i] > 0) ss.insert(j - v[i]);\n\t\t\tif(v[i] - j > 0) ss.insert(v[i] - j);\n\t\t}\n\t\tfor(int j: ss){\n\t\t\ts.insert(j);\t\n\t\t}\n\t\ts.insert(v[i]);\n\t}\n\tcout << s.size() << endl;\n\n\treturn 0;\n}\n```\n\n### 杨辉三角形\n\n技巧、二分题\n\n暴力能够 40% 的分数\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\n\nmap<PII, int> mp; \nmap<int, int> smp;\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> a;\n\tif(a == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmp[{1, 1}] = 1;\n\tint flag = 0;\n\tll res = 1;\n\tfor(int i = 2; ;i++){\n\t\tfor(int j = 1; j <= i;j ++){\n\t\t\tint cot;\n\t\t\tif(j == 1){\n\t\t\t\tcot = 1; \n\t\t\t} else {\n\t\t\t\tcot = mp[{i - 1, j}] + mp[{i - 1, j - 1}];\n\t\t\t}\n\t\t\tres ++;\n\t\t\tmp[{i, j}] = cot;\n\t\t\tif(cot == a && smp.find(cot) == smp.end()){\n\t\t\t\tflag = 1;\n\t\t\t\tcout << res << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n### 双向排序\n\nsort暴力能够 60% 题\n\n```c++\n#include<bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\nconst int N = 1e6 + 10, M = 1e9 + 10;\nint ix[4] = {1,-1,0,0}, iy[4] = {0,0,1,-1};\nint a, b, x, y;\nint n[N];\n\nint main(){\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t\n\tcin >> a >> b;\n\tfor(int i = 0; i < a; i++) n[i] = i + 1;\n\twhile(b --){\n\t\tcin >> x >> y;\n\t\tif(x == 0){\n\t\t\tsort(n, n + y, greater<int>());\n\t\t} else {\n\t\t\tsort(n + y - 1, n + a);\n\t\t}\n\n\t}\n\t\n\tfor(int i = 0; i < a; i++) cout << n[i] << \" \"; \n\treturn 0;\n}\n```\n\n","title":" 第十二届蓝桥杯B组省赛\n","category":[" 算法\n"],"date":" 2024-04-09\n","author":" Jixer\n","source":" 原创\n\n"}}